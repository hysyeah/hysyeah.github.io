<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django为已有的数据库生成model</title>
    <url>/2017/09/15/Django%E4%B8%BA%E5%B7%B2%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%9F%E6%88%90model/</url>
    <content><![CDATA[<pre><code>python manage.py inspectdb


# 将settings.py中DATABASES中指定的数据库的所表的model导入到models.py中
python manage.py inspectdb &gt; models.py



# 也可以指定数据表
python manage.py inspectdb xxx xxx &gt;&gt; models.py
</code></pre>]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title>2020书单</title>
    <url>/2020/01/13/2020%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<p>在此先列一个计划</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>书名</th>
</tr>
</thead>
<tbody>
<tr>
<td>编译原理</td>
<td><a href="https://book.douban.com/subject/11628134/" target="_blank" rel="noopener">Programing Languages:Application and Interpretation</a>(cs3520)  <br><a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">SICP</a><br><a href="https://github.com/zpoint/CPython-Internals" target="_blank" rel="noopener">python源码剖析(zpoint/cpython-internals)</a></td>
</tr>
<tr>
<td>计算机基础</td>
<td><a href="www.cs.cmu.deu/~213/schedule.html">深入理解计算机基础</a><br><a href="https://book.douban.com/subject/25984145/" target="_blank" rel="noopener">Operating System: Principles and Practice</a><br><a href="https://book.douban.com/subject/19973015/" target="_blank" rel="noopener">Operating systems three easy pieces</a><br><a href="https://book.douban.com/subject/1782316/" target="_blank" rel="noopener">Concepts,techniques and models of computer programming</a></td>
</tr>
<tr>
<td>设计模式</td>
<td><a href="https://book.douban.com/subject/26829015/" target="_blank" rel="noopener">Mastering python Design patterns</a><br><a href="https://book.douban.com/subject/25843319/" target="_blank" rel="noopener">设计模式之禅</a></td>
</tr>
<tr>
<td>编程语言</td>
<td><a href="https://book.douban.com/subject/27013197/" target="_blank" rel="noopener">The Rust Programing Language</a><br><a href="https://book.douban.com/subject/27028517/" target="_blank" rel="noopener">Fluent Python</a></td>
</tr>
<tr>
<td>代码能力</td>
<td><a href="https://book.douban.com/subject/30218046/" target="_blank" rel="noopener">Aphilosophy of Software</a></td>
</tr>
<tr>
<td>框架类</td>
<td><a href="https://www.grpc.io/" target="_blank" rel="noopener">grpc</a><br><a href="https://doc.akka.io/docs/akka-http/current/index.html?language=scala" target="_blank" rel="noopener">akka</a></td>
</tr>
<tr>
<td>容器</td>
<td>k8s, istio, knative</td>
</tr>
<tr>
<td>算法</td>
<td><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法(第4版)</a>,github上的python算法,<br><a href="https://github.com/wangzheng0822/algo" target="_blank" rel="noopener">https://github.com/wangzheng0822/algo</a><br><a href="https://github.com/algorithm-visualizer/algorithm-visualizer" target="_blank" rel="noopener">https://github.com/algorithm-visualizer/algorithm-visualizer</a><br><a href="https://github.com/TheAlgorithms/Python" target="_blank" rel="noopener">https://github.com/TheAlgorithms/Python</a></td>
</tr>
<tr>
<td>数据库</td>
<td><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">高性能MySQL</a><br><a href="https://book.douban.com/subject/34804798/" target="_blank" rel="noopener">Redis设计与源码分析</a><br><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis设计与实现</a><br><a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">Redis深度历险</a><br><a href="https://book.douban.com/subject/4838430/" target="_blank" rel="noopener">Database system:Implementation 2nd(cmu-15-721)</a></td>
</tr>
<tr>
<td>系统编程</td>
<td><a href="https://book.douban.com/subject/1788421/" target="_blank" rel="noopener">unix环境高级编程</a><br><a href="https://book.douban.com/subject/1500149/" target="_blank" rel="noopener">unix网络编程</a><br><a href="https://book.douban.com/subject/6097773/" target="_blank" rel="noopener">LINUX内核设计与实现</a></td>
</tr>
<tr>
<td>系统设计</td>
<td><a href="https://book.douban.com/subject/26197294/" target="_blank" rel="noopener">Designing Data Intensive Applications</a><br><a href="https://book.douban.com/subject/30417742/" target="_blank" rel="noopener">Reactive Design Pattern</a><br><a href="https://github.com/donnemartin/system-design-primer" target="_blank" rel="noopener">https://github.com/donnemartin/system-design-primer</a></td>
</tr>
<tr>
<td></td>
<td><a href="https://book.douban.com/subject/6829746/" target="_blank" rel="noopener">A primer on memory consistency and cache coherence</a><br><a href="https://book.douban.com/subject/25732314/" target="_blank" rel="noopener">shared-memory synchronization</a><br><a href="https://book.douban.com/subject/6080692/" target="_blank" rel="noopener">processor micro architecheture: An Implementation perspective</a><br><a href="https://book.douban.com/subject/15306337/" target="_blank" rel="noopener">static program Analysis</a></td>
</tr>
<tr>
<td>操作系统</td>
<td><a href="https://book.douban.com/subject/19973015/" target="_blank" rel="noopener">Operating system:Three easy pieces</a><br><a href="https://book.douban.com/subject/3735649/" target="_blank" rel="noopener">一个操作系统的实现</a><br><a href="https://book.douban.com/subject/25984145/" target="_blank" rel="noopener">Operating System Principles and Practice</a></td>
</tr>
<tr>
<td>协议</td>
<td><a href="https://book.douban.com/subject/26825411/" target="_blank" rel="noopener">TCP/IP</a></td>
</tr>
<tr>
<td>面试</td>
<td><a href="https://github.com/0voice/interview_internal_reference" target="_blank" rel="noopener">https://github.com/0voice/interview_internal_reference</a></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>多思考！！！</p>
]]></content>
  </entry>
  <entry>
    <title>Django内置的密码管理</title>
    <url>/2017/10/02/Django%E5%86%85%E7%BD%AE%E7%9A%84%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>Django提供了内在的登录，登出以及密码管理。 在此记录密码管理功能的使用 1.在urls.py添加如下：</p>
<pre><code>url(&#39;^&#39;, include(&#39;django.contrib.auth.urls&#39;))
</code></pre><p>相当于</p>
<pre><code>^login/$ [name=&#39;login&#39;]
^logout/$ [name=&#39;logout&#39;]
^password_change/$ [name=&#39;password_change&#39;]
^password_change/done/$ [name=&#39;password_change_done&#39;]
^password_reset/$ [name=&#39;password_reset&#39;]
^password_reset/done/$ [name=&#39;password_reset_done&#39;]
^reset/(?P&lt;uidb64&gt;[0-9A-Za-z_\-]+)/(?P&lt;token&gt;[0-9A-Za-z]{1,13}-[0-9A-Za-z]{1,20})/$ [name=&#39;password_reset_confirm&#39;]
^reset/done/$ [name=&#39;password_reset_complete&#39;]
</code></pre><p>2.<a href="http://img.hysyeah.top/2017/09/27/django%E9%80%9A%E8%BF%87qq%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6" target="_blank" rel="noopener">配置好发送邮件配置</a> 3.在前端配置好url就可实现密码修改，重置功能。</p>
<hr>
<p>Ref： 1.<a href="https://docs.djangoproject.com/en/1.11/topics/auth/default/#all-authentication-views" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title>Django开发环境搭建与项目结构</title>
    <url>/2017/09/01/Django%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>1.安装python3 2.安装virtualenv</p>
<pre><code>sudo apt-get install python3-virtualenv(ubuntu环境下)
</code></pre><p>或者</p>
<pre><code>pip3 install virtualenv
</code></pre><p>3.建立虚拟环境</p>
<pre><code>virtualenv venv
</code></pre><p>4.激活虚拟环境</p>
<pre><code>source venv/bin/activate(Linux环境）

venv\Scripts\activate(Windows）
</code></pre><p>根据自己文件路径，需适当修改 5.在虚拟环境下通过pip3安装所需软件，如为旧项目，根据项目中的requests.txt文件安装所需依赖。</p>
<pre><code>pip3 install -r requests.txt
</code></pre><p>6.建立项目，APP(如新建好，则跳过此步骤)</p>
<pre><code>django-admin startproject xxxx

django-admin startapp xxxx
</code></pre><p>7.项目结构 <img src="http://img.hysyeah.top/wp-content/uploads/2017/09/tree.png" alt="image"></p>
<pre><code>- report/static 一些静态文件，如js,css文件
- report/templates 项目模版
- report/urls.py   路由配置文件
- utils/sql.py     项目中用到的SQL查询语句
- report/views/views.py 视图函数
- report/views/xls_export.py xsl文件导出相关
- xfbank/config    一些项目配置文件,dev_settings.py(测试环境),pro_settings.py(正式环境)
- xfbank/urls.py   项目主配置urls文件&lt;/pre&gt;
</code></pre><p>8.运行Django项目</p>
<pre><code>python manage.py runserver
</code></pre>]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title>Django通过qq邮箱发送邮件</title>
    <url>/2017/09/27/Django%E9%80%9A%E8%BF%87qq%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<p>通过Django的send_mail发送邮件，send_mail(‘subject’, content, from_mail,[‘to_mail’]) 企业邮箱和普通邮箱所用的服务是不一样的，要区分开， 配置如下</p>
<pre><code>EMAIL_USE_TLS = True
EMAIL_HOST = &#39;smtp.qq.com&#39;  #若是企业邮箱要改为：&#39;smtp.exmail.qq.com&#39;
EMAIL_PORT = 587
EMAIL_HOST_USER = &#39;12345678@qq.com&#39;
EMAIL_HOST_PASSWORD = &#39;xxxxxxxxxxxxxxxx&#39;  #16位授权码(不是登录密码)，通过邮箱中的“设置”获取，可自行百度
DEFAULT_FROM_EMAIL = &#39;12345678@qq.com&#39;
</code></pre>]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title>Docker Compose管理mysql容器</title>
    <url>/2018/01/22/Docker%20Compose%E7%AE%A1%E7%90%86mysql%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>Dockerfile用于管理一个单独的应用容器，Docker Compose用于管理多个容器。</p>
<pre><code>1.sudo pip install docker-compose

2.docker pull mysql

3.mkidr mysql
  vim docker-compose.yml
</code></pre><h4 id="docker-compose-yml-包括version-services-networks三大部分"><a href="#docker-compose-yml-包括version-services-networks三大部分" class="headerlink" title="docker-compose.yml(包括version,services,networks三大部分)"></a>docker-compose.yml(包括version,services,networks三大部分)</h4><pre><code>version: &#39;2&#39;
services:
  mysql:
    image: mysql   #指定镜像为mysql
    networks:
       mysqlnet:
          ipv4_address: xxx.xxx.xxx.xxx #设置ip地址
    volumes:
    - /etc/mysql/:/etc/mysql        #将宿主机的/etc/mysql/映射到容器中，即容器上使用宿主中的/etc/mysql/
    restart: always
    environment:                    #设置环境变量
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: test
      MYSQL_USER: hys
      MYSQL_PASSWORD: hello
    expose:
      - &quot;3307&quot;
    ports:
      - &quot;3307:3306&quot;
networks:
  mysqlnet:
    driver: bridge
    ipam:
      driver: default
      config:
      - subnet: xxx.xxx.xxx.0/26


docker-compose up -d #启动后，可访问mysql服务
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>Go Json</title>
    <url>/2020/07/05/Go-Json/</url>
    <content><![CDATA[<p><code>JSON</code>(JavaScript Object Notations)是一种简单的数据交互格式，经常用于不同系统之间的信息交换。</p>
<p><code>Go</code>语言中的<code>encoding/json</code>根据<a href="https://tools.ietf.org/html/rfc7159" target="_blank" rel="noopener">RFC 7159</a>规范实现了<code>JSON</code>的编码解码。</p>
<h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p> 将<code>Go</code>语言中的结构编码为<code>Json</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Body <span class="keyword">string</span></span><br><span class="line">	Time <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := Message&#123;<span class="string">"Alice"</span>, <span class="string">"Hello"</span>, <span class="number">1294706395881547000</span>&#125;</span><br><span class="line">	b, _ := json.Marshal(m)</span><br><span class="line">	fmt.Printf(<span class="keyword">string</span>(b))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">&#123;<span class="string">"Name"</span>:<span class="string">"Alice"</span>,<span class="string">"Body"</span>:<span class="string">"Hello"</span>,<span class="string">"Time"</span>:<span class="number">1294706395881547000</span>&#125;</span><br></pre></td></tr></table></figure>
<p>只有能被表达为有效的<code>JSON</code>格式的<code>Go</code>数据类型才能被正确的编码:</p>
<ul>
<li><code>JSON</code>对象只支持字符串作为键；被编码的结构体必须符合如下格式<code>map[string]T</code>(T为json package支持的任意<code>Go</code>类型)<br>－ <code>Channel</code>,<code>Complex</code>,<code>func</code>不能被编码<br>－ 不支持循环的数据结构；会导致<code>Marshal</code>掉入无限循环<br>－ 如果数据类型是指针将会编码会指针指向的值(如果指针为<code>nil</code>刚编码为<code>null</code>)</li>
<li><code>json package</code>只会处理结构体中以大写字母开头的字段</li>
</ul>
<h5 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h5><p> 将<code>JSON</code>解码为<code>Go</code>语言中的结构体<br> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Body <span class="keyword">string</span></span><br><span class="line">	Time <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m Message</span><br><span class="line">	b := []<span class="keyword">byte</span>(<span class="string">`&#123;"Name":"Alice","Body":"Hello","Time":1294706395881547000&#125;`</span>)</span><br><span class="line">	json.Unmarshal(b, &amp;m)</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">	fmt.Println(m.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那<code>Unmarshal</code>是如何解码<code>JSON</code>中的数据，对于<code>JSON</code>的字段是如何对应结构体的字段？<br>假如<code>JSON</code>中有一个键为<code>Foo</code><br><code>Unmarshal</code>首先会寻找<code>导出字段</code>中有标签json:”Foo”的字段；如果不存在标签则会寻找<code>导出字段``Foo</code>;如果还未找到，则会寻找<code>导出字段</code>FOO，FoO或者其它忽略大小写的匹配。如果未找到匹配字段则会忽略。</p>
<h6 id="解码任意结构的JSON"><a href="#解码任意结构的JSON" class="headerlink" title="解码任意结构的JSON"></a>解码任意结构的JSON</h6><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	b := []<span class="keyword">byte</span>(<span class="string">`&#123;"Name":"Wednesday","Age":6,"Parents":["Gomez","Morticia"]&#125;`</span>)</span><br><span class="line"></span><br><span class="line">    json.Unmarshal(b, &amp;f)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时并不能通过f.Name或f["Name]进行数据字段访问，需要通过如下语句进行类型转换，可以通过f.(type)判断f可以转换为什么类型</span></span><br><span class="line">	m := f.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k,v := <span class="keyword">range</span> f &#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Streaming-Encoders-and-Decoders"><a href="#Streaming-Encoders-and-Decoders" class="headerlink" title="Streaming Encoders and Decoders"></a>Streaming Encoders and Decoders</h6><p><code>json</code>包也提供了<code>Decoder</code>和<code>Encoder</code>类型来处理流式的<code>JSON</code>数据。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span> *<span class="title">Decoder</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span> *<span class="title">Encoder</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dec := json.NewDecoder(os.Stdin)</span><br><span class="line">	enc := json.NewEncoder(os.Stdout)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> v <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> err := dec.Decode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> k := <span class="keyword">range</span> v &#123;</span><br><span class="line">			<span class="keyword">if</span> k != <span class="string">"Name"</span> &#123;</span><br><span class="line">				<span class="built_in">delete</span>(v, k)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := enc.Encode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.hysyeah.top/2020/7/4/20200705102547.png" alt></p>
<p>上面代码实现的功能是从标准输入读取数据，先进行解码，然后判断键如果不等于Name则删除，最后输出到标准输出。</p>
<h6 id="struct-field-tags"><a href="#struct-field-tags" class="headerlink" title="struct field tags"></a>struct field tags</h6><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编码为json时，字段Name名称会被改写为myName</span></span><br><span class="line"><span class="comment">// &#123;"myName":"Alice","Body":"Hello","Time":1294706395881547000&#125;</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"myName"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码为json时，字段Name名称会被改写为myName</span></span><br><span class="line"><span class="comment">// 如果Name字段为空，则输出为&#123;"Body":"Hello","Time":1294706395881547000&#125;,不包含myName字段</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json: "myName,omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码为json时，字段Name名称不会被改写</span></span><br><span class="line"><span class="comment">// 如果Name字段为空，则输出为&#123;"Body":"Hello","Time":1294706395881547000&#125;,不包含Name字段</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json: ",omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码为json时，忽略字段Name</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json: "-"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码为json时，将键Name替换为－</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"-,"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string标签只用于string, float,integer,bool类型的字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将int类型转换为字符串，输出为&#123;"Time":"1294706395881547000"&#125;</span></span><br><span class="line">Time <span class="keyword">int64</span> <span class="string">`json:",string"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将bool类型转换为字符串，输出为&#123;"Bool":"true"&#125;</span></span><br><span class="line">Bool <span class="keyword">bool</span> <span class="string">`json:",string"`</span></span><br></pre></td></tr></table></figure>
<p>结构体嵌套<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Embedded <span class="keyword">struct</span> &#123;</span><br><span class="line">	F1 <span class="keyword">int</span></span><br><span class="line">	F2 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在结构体中嵌套结构体Extra,需指定为inline</span></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="string">`json:"name"`</span></span><br><span class="line">	Embedded <span class="string">`json:",inline"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Ref:<br>1.<a href="https://blog.golang.org/json" target="_blank" rel="noopener">https://blog.golang.org/json</a><br>2.<a href="https://golang.org/pkg/encoding/json/" target="_blank" rel="noopener">https://golang.org/pkg/encoding/json/</a><br>3.<a href="https://play.golang.org/p/NnwTh9KI5r" target="_blank" rel="noopener">https://play.golang.org/p/NnwTh9KI5r</a></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>GoPackage</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-cobra</title>
    <url>/2020/07/18/Go-cobra/</url>
    <content><![CDATA[<p><code>Cobra</code>是一个构建命令行应用的强有力工具。在许多项目中都有用到<code>Cobra</code>，比如<code>Kubernetes</code>,<code>Hugo</code>等等。</p>
<p><a href="https://github.com/hysyeah/gotour/tree/master/tour" target="_blank" rel="noopener">https://github.com/hysyeah/gotour/tree/master/tour</a></p>
<hr>
<p>REF:<br>1.<a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">https://github.com/spf13/cobra</a></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>GoPackage</tag>
      </tags>
  </entry>
  <entry>
    <title>Django权限与分组</title>
    <url>/2017/09/27/Django%E6%9D%83%E9%99%90%E4%B8%8E%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<pre><code>from django.contrib.auth.models import Group, Permission
from django.contrib.contenttypes.models import ContentType


g = Group(name=&#39;group_test&#39;) #创建一个组
g.save()

g = Group.objects.get(name=&#39;group_test&#39;) #获取存在的组

content_type = ContentType.objects.get_for_model(ViewPermission) # ViewPermission为models.py中的一个类
class ViewPermission(models.Model):
    class Meta:
        permissions = (
            (&#39;ych_order&#39;, &#39;xxx&#39;),
        )

p = Permission.objects.create(codename=&#39;view_ych&#39;, name=&#39;Can see ych&#39;, content_type=content_type) #创建权限

p = Permission.objects.get(codename=&#39;view_ych&#39;) #获取已存在的权限

g.permissions.add(p) #为组g添加权限p

user.groups.add(g) #将用户user添加到组g

user.has_perm(&#39;report.view_ych&#39;) #判断权限
</code></pre>]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title>Go defer陷阱[译]</title>
    <url>/2021/01/02/Go-defer%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<h4 id="对等于nil的函数defer操作"><a href="#对等于nil的函数defer操作" class="headerlink" title="对等于nil的函数defer操作"></a>对等于<code>nil</code>的函数<code>defer</code>操作</h4><p>如果通过<code>defer</code>调用一个值等于<code>nil</code>的函数，会引发<code>panic</code>错误。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> run <span class="function"><span class="keyword">func</span><span class="params">()</span> = <span class="title">nil</span></span></span><br><span class="line">	<span class="keyword">defer</span> run()</span><br><span class="line">	fmt.Println(<span class="string">"runs"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">runs</span><br><span class="line"><span class="built_in">panic</span>: runtime error: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=<span class="number">0x1</span> addr=<span class="number">0x0</span> pc=<span class="number">0x452dc8</span>]</span><br></pre></td></tr></table></figure></p>
<p>原因：<br>在函数进行到最后之后，才执行<code>run()</code>函数,并引发<code>panic</code>错误，因为这是一个值为<code>nil</code>的函数</p>
<hr>
<h4 id="在for循环中调用defer"><a href="#在for循环中调用defer" class="headerlink" title="在for循环中调用defer"></a>在<code>for</code>循环中调用<code>defer</code></h4><p><img src="http://img.hysyeah.top/2021/1/2/1__T50bGcl0yf-ea62ALFwZw.png" alt="image"></p>
<p>上面的<code>defer row.Close()</code>在<code>for</code>循环中并不会立即执行直到函数结束(第一次循环结束并不会执行)。在调用<code>defer</code>会产生一个函数调用栈,如果循环次数过多将会产生意料之外的问题。</p>
<p>解决方法：</p>
<h5 id="1-直接调用row-Close-不使用defer"><a href="#1-直接调用row-Close-不使用defer" class="headerlink" title="1.直接调用row.Close()不使用defer"></a>1.直接调用<code>row.Close()</code>不使用<code>defer</code></h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func ()  &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		row, err := db.Query(<span class="string">"SELECT ..."</span>)</span><br><span class="line">		<span class="keyword">if</span> err != nil&#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		row.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-将操作放入一个匿名函数中，当函数结束时将会执行defer调用的函数"><a href="#2-将操作放入一个匿名函数中，当函数结束时将会执行defer调用的函数" class="headerlink" title="2.将操作放入一个匿名函数中，当函数结束时将会执行defer调用的函数"></a>2.将操作放入一个匿名函数中，当函数结束时将会执行<code>defer</code>调用的函数</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func ()  &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        func() &#123;</span><br><span class="line">            row, err := db.Query(<span class="string">"SELECT ..."</span>)</span><br><span class="line">			<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">				..</span><br><span class="line">			&#125;</span><br><span class="line">			defer row.Close()</span><br><span class="line">			..</span><br><span class="line">			// deferred funcs run here</span><br><span class="line">		&#125;()</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Defer-as-wrapper"><a href="#Defer-as-wrapper" class="headerlink" title="Defer as wrapper"></a>Defer as wrapper</h4><p>有些时个你需要对闭包使用<code>defer</code>以追求实用或者有其它的一些原因。比如：要打开数据库连接，然后运行一些查询，最后运行以确保断开连接。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">type database struct&#123;&#125;</span><br><span class="line">func (db *database) connect() (disconnect func()) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"connect"</span>)</span><br><span class="line">	<span class="keyword">return</span> func() &#123;</span><br><span class="line">		fmt.Println(<span class="string">"disconnect"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	db := &amp;database&#123;&#125;</span><br><span class="line">	defer db.connect()</span><br><span class="line">	fmt.Println(<span class="string">"query db..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">query db...</span><br><span class="line">connect</span><br></pre></td></tr></table></figure></p>
<p>为什么最后没有执行disconnect?这里出现这个bug的原因是<code>connect</code>函数返回的值并没有执行而是被保存了起来。</p>
<p>解决方法:<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	db := &amp;database&#123;&#125;</span><br><span class="line">	close := db.connect()</span><br><span class="line">	defer close()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"query db..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不好的实践：<br>虽然下面的代码可以正常的执行,但是不推荐这样使用。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">db := &amp;database&#123;&#125;</span><br><span class="line">defer db.connect()()</span><br><span class="line">..</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="Defer-in-a-block"><a href="#Defer-in-a-block" class="headerlink" title="　Defer in a block"></a>　Defer in a block</h4><p>你可能会想deferred func会在结束一个代码块的时候执行，实际上deferred func只会在包含它的函数结束的时候执行。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		defer func() &#123;</span><br><span class="line">			fmt.Println(<span class="string">"block: defer runs"</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		fmt.Println(<span class="string">"block: ends"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"main: ends"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">block: ends</span><br><span class="line">main: ends</span><br><span class="line">block: defer runs</span><br></pre></td></tr></table></figure></p>
<p>原因：<br><code>deferred func</code>只会在函数代码块结束的时候执行。</p>
<p>解决方法：使用匿名函数<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">  func() &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">      fmt.Println(<span class="string">"func: defer runs"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">"func: ends"</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">  fmt.Println(<span class="string">"main: ends"</span>)</span><br><span class="line">&#125;</span><br><span class="line">// output:</span><br><span class="line">func: ends</span><br><span class="line">func: defer runs</span><br><span class="line">main: ends</span><br></pre></td></tr></table></figure></p>
<h4 id="Deferred-method陷阱"><a href="#Deferred-method陷阱" class="headerlink" title="Deferred method陷阱"></a>Deferred method陷阱</h4><p>不使用指针：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">type Car struct &#123;</span><br><span class="line">  model string</span><br><span class="line">&#125;</span><br><span class="line">func (c Car) PrintModel() &#123;</span><br><span class="line">  fmt.Println(c.model)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">  c := Car&#123;model: <span class="string">"DeLorean DMC-12"</span>&#125;</span><br><span class="line">  defer c.PrintModel()</span><br><span class="line">  c.model = <span class="string">"Chevrolet Impala"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">DeLorean DMC<span class="number">-12</span></span><br></pre></td></tr></table></figure></p>
<p>使用指针：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func (c *Car) PrintModel() &#123;</span><br><span class="line">  fmt.Println(c.model)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Chevrolet Impala</span><br></pre></td></tr></table></figure></p>
<p>当使用<code>defer</code>时，传递给函数的参数会被立即保存下来而不用等到函数执行。</p>
<p>当一个方法的接收者是值接收者时，这个接收者会被拷贝(当调用defer函数的时候)所以当修改Car结构的数据被修改后,defer调用的函数并不会知道，因为它使用的是拷贝过来的数据。</p>
<p>如果一个方法的接收者是指针，当调用<code>defer</code>时，虽然也会产生一个新的指针，但这和原因的指针指向的是同一个对象，所以任何的对于结构体Car中的任何改变都能被探测到。</p>
<h4 id="打印Z-—-gt-A"><a href="#打印Z-—-gt-A" class="headerlink" title="打印Z —&gt; A"></a>打印Z —&gt; A</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">    defer fmt.Print(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//output: <span class="number">3210</span></span><br></pre></td></tr></table></figure>
<p>执行for循环的时候进行压栈操作，当函数结束的时候弹出然后执行压栈的函数</p>
<h4 id="参数作用域问题，参数被覆盖"><a href="#参数作用域问题，参数被覆盖" class="headerlink" title="参数作用域问题，参数被覆盖"></a>参数作用域问题，参数被覆盖</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">type reader struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (r reader) Close() error  &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">"close Error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">func release(r io.Closer) (err error)  &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		<span class="keyword">if</span> err := r.Close();err != nil&#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r := reader&#123;&#125;</span><br><span class="line">	err := release(r)</span><br><span class="line">	fmt.Print(err)</span><br><span class="line">&#125;</span><br><span class="line">//output:  nil</span><br></pre></td></tr></table></figure>
<p>也许的你期待的返回是“close Error“，但实际返回的err却是nil。</p>
<p>原因：在if代码块中使用新的err覆盖了name result中的err值,所以release()返回了原来的result-value。<br>这里还有疑惑，既然被被覆盖了难道不应该返回不为nil的值吗</p>
<p>解决方案：使用<code>=</code>而不<code>:=</code><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func release(r io.Closer) (err error)  &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		<span class="keyword">if</span> err = r.Close();err != nil&#123;</span><br><span class="line">			fmt.Println(<span class="string">"err in r.close"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="即时计算参数的值"><a href="#即时计算参数的值" class="headerlink" title="即时计算参数的值"></a>即时计算参数的值</h4><p>传递给deferred func的参数是在函数注册(调用defer)的时候进行计算的而不是当它执行的时候计算。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">type message struct &#123;</span><br><span class="line">	content string</span><br><span class="line">&#125;</span><br><span class="line">func (p *message) set(c string) &#123;</span><br><span class="line">	p.content = c</span><br><span class="line">&#125;</span><br><span class="line">func (p *message) print() string &#123;</span><br><span class="line">	<span class="keyword">return</span> p.content</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	m := &amp;message&#123;content: <span class="string">"Hello"</span>&#125;</span><br><span class="line">	defer fmt.Print(m.print())</span><br><span class="line">	m.set(<span class="string">"World"</span>)</span><br><span class="line">	// deferred func runs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//output: Hello</span><br></pre></td></tr></table></figure></p>
<p>为什么输出不是”World”<br>在调用defer时，fmt.Print是在函数结束之前执行，但是传递给它的参数m.print()会立即执行，所以传递给fmt.Print的参数是”Hello”,而且这个值会被保存直到defer中的函数执行。</p>
<h4 id="for循环中的捕获"><a href="#for循环中的捕获" class="headerlink" title="for循环中的捕获"></a>for循环中的捕获</h4><p>在循环中deferred func将会看到最新的值当函数执行的时候，有一种情况除外，就是把值当作参数传递给了deferred func。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		defer func() &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//output</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Why?<br>当defer中的函数运行时，deferred func看到的是i的最新值。因为当调用defer进行函数注册时，Go运行时捕获的是变量i的地址。当循环结束后i的值变为3,所以当运行defer中的函数时因为指针指向的是同一个值所以输出都为3。</p>
<p>解决方案1：将值当作参数传递给defer中的函数<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		defer func(i int) &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//output:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>解决方案2：使用一个新的变量i覆盖掉外一层的i<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		i := i</span><br><span class="line">		defer func() &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解决方案3：如果只有一个函数调用<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		defer fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="defer中函数的返回值"><a href="#defer中函数的返回值" class="headerlink" title="defer中函数的返回值"></a>defer中函数的返回值</h4><p>defer函数中的返回值对于调用者是不可见，但你仍可以使用<code>命名返回值</code>的方法改变结果值。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func release() error &#123;</span><br><span class="line">	defer func() error &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"error"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	r := release()</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">//outpu:&lt;nil&gt;</span><br></pre></td></tr></table></figure></p>
<p>解决方案：改变命名结果值<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func release() (err error) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		err = errors.New(<span class="string">"error"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="在deferred-func之后调用recover函数"><a href="#在deferred-func之后调用recover函数" class="headerlink" title="在deferred func之后调用recover函数"></a>在deferred func之后调用recover函数</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	recover()</span><br><span class="line">	panic(<span class="string">"error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">//output:</span><br><span class="line">panic: error</span><br></pre></td></tr></table></figure>
<p>在defer之外使用recover()不能捕获panic。<br>解决方案：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func do() &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		r := recover()</span><br><span class="line">		fmt.Println(<span class="string">"recovered:"</span>, r)</span><br><span class="line">	&#125;()</span><br><span class="line">	panic(<span class="string">"error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	do()</span><br><span class="line">&#125;</span><br><span class="line">//output</span><br><span class="line">recovered: error</span><br></pre></td></tr></table></figure></p>
<h4 id="错误的顺序调用defer-func"><a href="#错误的顺序调用defer-func" class="headerlink" title="错误的顺序调用defer func"></a>错误的顺序调用defer func</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func do() error &#123;</span><br><span class="line">  res, err := http.Get(<span class="string">"http://notexists"</span>)</span><br><span class="line">  defer res.Body.Close()</span><br><span class="line">  <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  // ..code...</span><br><span class="line">  <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line">//output</span><br><span class="line"></span><br><span class="line">panic: runtime error: invalid memory address <span class="keyword">or</span> nil pointer dereference</span><br></pre></td></tr></table></figure>
<p>原因是我们没有检查http请求是否成功，如果失败则会出现如上错误。因为出错的情况下res为nil，当执行res.Body的时候则会引发panic。</p>
<p>解决方案：加个判断<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func do() error &#123;</span><br><span class="line">  res, err := http.Get(<span class="string">"http://notexists"</span>)</span><br><span class="line">  <span class="keyword">if</span> res != nil &#123;</span><br><span class="line">    defer res.Body.Close()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  // ..code...</span><br><span class="line">  <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="不检查错误"><a href="#不检查错误" class="headerlink" title="不检查错误"></a>不检查错误</h4><p>不要以后把善后的工作委派给了defer就可以安全的释放资源。你有可能会丢失一些有用的报错信息。</p>
<p>不推荐：<br>f.Close()可能会报错，但是我们意识不到。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func do() error &#123;</span><br><span class="line">  f, err := os.Open(<span class="string">"book.txt"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  defer f.Close()</span><br><span class="line">  // ..code...</span><br><span class="line">  <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更好的做法是检查错误并处理错误<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func do() error &#123;</span><br><span class="line">  f, err := os.Open(<span class="string">"book.txt"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  defer func() &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f.Close(); err != nil &#123;</span><br><span class="line">      // log etc</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  // ..code...</span><br><span class="line">  <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你还可以使用命名结果值返回defer中的错误020年10月19日<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func do() (err error) &#123;</span><br><span class="line">  f, err := os.Open(<span class="string">"book.txt"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  defer func() &#123;</span><br><span class="line">    <span class="keyword">if</span> ferr := f.Close(); ferr != nil &#123;</span><br><span class="line">      err = ferr</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  // ..code...</span><br><span class="line">  <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Note:<br>你可以使用<a href="https://godoc.org/github.com/pkg/errors" target="_blank" rel="noopener">这个包</a>包裹多种错误。这是有必要的，因为f.Close可能会覆盖在其之前的错误。在一个错误中包裹另一个错误并打印到日志中可以更好的排查错误。<br>你也可以使用<a href="https://github.com/kisielk/errcheck" target="_blank" rel="noopener">这个包</a>来捕获你不想检查的错误</p>
<h4 id="释放相同的资源"><a href="#释放相同的资源" class="headerlink" title="释放相同的资源"></a>释放相同的资源</h4><p>你可能会对一个资源进行多次释放操作，这会发生预料之后的问题。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func do() error &#123;</span><br><span class="line">  f, err := os.Open(<span class="string">"book.txt"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  defer func() &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f.Close(); err != nil &#123;</span><br><span class="line">      // log etc</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  // ..code...</span><br><span class="line">  f, err = os.Open(<span class="string">"another-book.txt"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  defer func() &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f.Close(); err != nil &#123;</span><br><span class="line">      // log etc</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line">//output</span><br><span class="line">closing resource <span class="comment">#another-book.txt</span></span><br><span class="line">closing resource <span class="comment">#another-book.txt</span></span><br></pre></td></tr></table></figure>
<p>WHY？<br>因为当deferred func运行时，看到的是最新的值，所以看到的变量f是最新的那个(another-book.txt)。因为同一资源被释放了两次。</p>
<p>解决方案：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func do() error &#123;</span><br><span class="line">  f, err := os.Open(<span class="string">"book.txt"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  defer func(f io.Closer) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f.Close(); err != nil &#123;</span><br><span class="line">      // log etc</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;(f)</span><br><span class="line">  // ..code...</span><br><span class="line">  f, err = os.Open(<span class="string">"another-book.txt"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  defer func(f io.Closer) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f.Close(); err != nil &#123;</span><br><span class="line">      // log etc</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;(f)</span><br><span class="line">  <span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//output:</span><br><span class="line">closing resource <span class="comment">#another-book.txt</span></span><br><span class="line">closing resource <span class="comment">#book.txt</span></span><br></pre></td></tr></table></figure></p>
<h4 id="panic-recover可以获取可返回任何类型"><a href="#panic-recover可以获取可返回任何类型" class="headerlink" title="panic/recover可以获取可返回任何类型"></a>panic/recover可以获取可返回任何类型</h4><p>字符串：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func errorly() &#123;</span><br><span class="line">  defer func() &#123;</span><br><span class="line">    fmt.Println(recover())</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">if</span> badHappened &#123;</span><br><span class="line">    panic(<span class="string">"error run run"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//output:</span><br><span class="line"><span class="string">"error run run"</span></span><br></pre></td></tr></table></figure></p>
<p>Error:<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func errorly() &#123;</span><br><span class="line">  defer func() &#123;</span><br><span class="line">    fmt.Println(recover())</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">if</span> badHappened &#123;</span><br><span class="line">    panic(errors.New(<span class="string">"error run run"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//output:</span><br><span class="line"><span class="string">"error run run"</span></span><br></pre></td></tr></table></figure></p>
<p>可接收任何类型的参数<br>panic不仅可以接收字符串也可以接收error类型。这意味着你可以把任何类型的参数传递给panic然后从recover中获取。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">type myerror struct &#123;&#125;</span><br><span class="line">func (myerror) String() string &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"myerror there!"</span></span><br><span class="line">&#125;</span><br><span class="line">func errorly() &#123;</span><br><span class="line">  defer func() &#123;</span><br><span class="line">    fmt.Println(recover())</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">if</span> badHappened &#123;</span><br><span class="line">    panic(myerror&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WHY？<br>在GO中<code>interface{}</code>类型意味着任何类型.<br>panic和recover的定义<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">func panic(v interface&#123;&#125;)</span><br><span class="line">func recover() interface&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>它们的工作流程如下<br>panic(value) —&gt; recover() —&gt; value</p>
<p>recover只是返回传递给panic的值</p>
<hr>
<p>REF:</p>
<p><a href="https://blog.learngoprogramming.com/gotchas-of-defer-in-go-1-8d070894cb01" target="_blank" rel="noopener">Go defer 1</a><br><a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa" target="_blank" rel="noopener">Go defer 2</a><br><a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-iii-36a1ab3d6ef1" target="_blank" rel="noopener">Go defer 3</a></p>
]]></content>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-error</title>
    <url>/2020/07/18/Go-error/</url>
    <content><![CDATA[<p>Package<code>errors</code>为<code>Go</code>语言提供了错误处理的函数。</p>
<p><code>error</code>的定义：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>errors</code>中提供的方法<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据给定的字符串返回一个error类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在错误链中查找第一个等于target的错误，并将target设置为这个错误返回true,否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断错误链中是否包含target类型的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用参数err本身的Unwrap方法，如果err存在Unwrap方法返回该方法返回的值，否则返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unwrap</span><span class="params">(err error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>Go</code>从<code>1.13</code>开始提供了<code>Unwarp</code>方法来获取嵌套的错误。<br>1.创建一个嵌套的错误<br>方法一：通过<code>fmt.Error(&quot;%w&quot;, err)</code>来创建<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err1 := errors.New(<span class="string">"new err"</span>)</span><br><span class="line">    err2 := fmt.Errorf(<span class="string">"err2: [%w]"</span>, err1)</span><br><span class="line">    <span class="comment">// err2: [new err]</span></span><br><span class="line">    fmt.Println(err2)</span><br><span class="line">    e := errors.Unwrap(err2)</span><br><span class="line">    <span class="comment">// new err</span></span><br><span class="line">    fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二：自定义结构体，并实现<code>Error()</code>和<code>Unwrap()</code>方法<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> QueryError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Query <span class="keyword">string</span></span><br><span class="line">    Err   error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *QueryError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Query</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *QueryError)</span> <span class="title">Unwrap</span><span class="params">()</span> <span class="title">error</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err1 := QueryError&#123;<span class="string">"select"</span>, errors.New(<span class="string">"permission denied"</span>)&#125;</span><br><span class="line">    e := errors.Unwrap(&amp;err1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// output: permission denied</span></span><br><span class="line">    fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<code>errors.Is</code>判断嵌套的<code>error</code>是否包含特定的错误<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err1 := errors.New(<span class="string">"new err"</span>)</span><br><span class="line">    err2 := fmt.Errorf(<span class="string">"err2: [%w]"</span>, err1)</span><br><span class="line">    <span class="comment">// output: true</span></span><br><span class="line">    fmt.Println(errors.Is(err2, err1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.<code>errors.As</code>判断错误链中是否包含target类型的错误<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> QueryError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Query <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *QueryError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Query</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> target *QueryError</span><br><span class="line">    err2 := fmt.Errorf(<span class="string">"err2: [%w]"</span>, &amp;QueryError&#123;Query:<span class="string">"select error"</span>&#125;)</span><br><span class="line">    <span class="comment">// output: true</span></span><br><span class="line">    fmt.Println(errors.As(err2, &amp;target))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>REF:<br>1.<a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">https://blog.golang.org/go1.13-errors</a><br>2.<a href="https://golang.org/pkg/errors/" target="_blank" rel="noopener">https://golang.org/pkg/errors/</a></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>GoPackage</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-flag</title>
    <url>/2020/07/16/Go-flag/</url>
    <content><![CDATA[<p>标准库<code>flag</code>实现了命令行参数的解析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//ip类型是指针,存放的是指向flagname的指针</span></span><br><span class="line">	<span class="keyword">var</span> ip = flag.Int(<span class="string">"flagname"</span>, <span class="number">1234</span>, <span class="string">"help message"</span>)</span><br><span class="line">	<span class="keyword">var</span> flagvar <span class="keyword">string</span></span><br><span class="line">	<span class="comment">//将命令行参数值写入到flagvar中,与StringVar对应的还有IntVar,UintVar等</span></span><br><span class="line">	<span class="comment">//func StringVar(p *string, name string, value string, usage string)</span></span><br><span class="line">	flag.StringVar(&amp;flagvar, <span class="string">"flagvar"</span>, <span class="string">"helloflag"</span>, <span class="string">"help message"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将命令行解析为定义的标志</span></span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"the point address of ip is %x:\n"</span>, ip)</span><br><span class="line">	fmt.Printf(<span class="string">"the value of flagname is %d\n"</span>, *ip)</span><br><span class="line">	fmt.Printf(<span class="string">"the value of flagvar is %s\n"</span>,flagvar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令行传参形式：<br>-flag<br>-flag=x<br>-flag x          //只支持非布尔类型</p>
<p>其中<code>-</code>和<code>--</code>功能是一样的。</p>
<p>子命令的使用<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 创建一个带有指定名称和错误处理属性的空命令集</span></span><br><span class="line">	goCmd := flag.NewFlagSet(<span class="string">"create"</span>, flag.ExitOnError)</span><br><span class="line"></span><br><span class="line">	goCmd.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"go"</span>, <span class="string">"help"</span>)</span><br><span class="line">	args := flag.Args()</span><br><span class="line">	<span class="comment">// 对命令进行解析，否则获取不到name中的值</span></span><br><span class="line">	goCmd.Parse(args[<span class="number">1</span>:])</span><br><span class="line">	fmt.Println(name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>type Value<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值是存储在标志中的动态值的接口。</span></span><br><span class="line"><span class="comment">// 对于每个存在的标志，按命令行顺序调用一次Set。</span></span><br><span class="line"><span class="comment">// 可以通过这个接口的方法实现个性化操作</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">    Set(<span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如下代码会对传入的参数值末尾加上<code>_value</code><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Name)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>  &#123;</span><br><span class="line">	<span class="keyword">return</span>  fmt.Sprint(*n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Name)</span> <span class="title">Set</span><span class="params">(value <span class="keyword">string</span>)</span> <span class="title">error</span></span>  &#123;</span><br><span class="line">	*n = Name(value + <span class="string">"_value"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> name Name</span><br><span class="line">	flag.Var(&amp;name, <span class="string">"name"</span>, <span class="string">"help message"</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Printf(<span class="string">"name is %s"</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// go run flag2.go -name hys</span></span><br><span class="line"><span class="comment">// output: name is hys_value</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>REF:<br>1.<a href="https://golang.org/pkg/flag/" target="_blank" rel="noopener">https://golang.org/pkg/flag/</a></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>GoPackage</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-strings</title>
    <url>/2020/07/18/Go-strings/</url>
    <content><![CDATA[<p>Package<code>strings</code>提供了对<code>UTF-8</code>编码字符串的一些简单操作。</p>
<p>安装<code>gomacro</code>,<code>Go</code>版本的REPL,对一些函数进行验证。<br><code>go get github.com/cosmos72/gomacro</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">➜  hysyeah gomacro</span><br><span class="line"><span class="comment">// Welcome to gomacro. Type :help for help, :copy for copyright and license.</span></span><br><span class="line"><span class="comment">// This is free software with ABSOLUTELY NO WARRANTY.</span></span><br><span class="line">gomacro&gt; <span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">gomacro&gt; <span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line">gomacro&gt; strings.Compare(<span class="string">"hello"</span>,<span class="string">"hello"</span>)</span><br><span class="line"><span class="number">0</span>	<span class="comment">// int</span></span><br><span class="line">gomacro&gt; strings.Compare(<span class="string">"hello"</span>,<span class="string">"hell"</span>)</span><br><span class="line"><span class="number">1</span>	<span class="comment">// int</span></span><br><span class="line">gomacro&gt; strings.Compare(<span class="string">"hell"</span>,<span class="string">"hello"</span>)</span><br><span class="line"><span class="number">-1</span>	<span class="comment">// int</span></span><br><span class="line">gomacro&gt; strings.Contains(<span class="string">"hello"</span>,<span class="string">"h"</span>)</span><br><span class="line"><span class="literal">true</span>	<span class="comment">// bool</span></span><br><span class="line"></span><br><span class="line">gomacro&gt; strings.ContainsAny(<span class="string">"hello"</span>,<span class="string">"e"</span>)</span><br><span class="line"><span class="literal">true</span>	<span class="comment">// bool</span></span><br><span class="line">gomacro&gt; strings.ContainsAny(<span class="string">"hello编程"</span>,<span class="string">"编程"</span>)</span><br><span class="line"><span class="literal">true</span>	<span class="comment">// bool</span></span><br><span class="line">gomacro&gt; strings.Count(<span class="string">"hello"</span>, <span class="string">"h"</span>)</span><br><span class="line"><span class="number">1</span>	<span class="comment">// int</span></span><br><span class="line">gomacro&gt; strings.Count(<span class="string">"hello"</span>, <span class="string">"l"</span>)</span><br><span class="line"><span class="number">2</span>	<span class="comment">// int</span></span><br><span class="line">gomacro&gt; strings.HasPrefix(<span class="string">"hello"</span>,<span class="string">"he"</span>)</span><br><span class="line"><span class="literal">true</span>	<span class="comment">// bool</span></span><br><span class="line">gomacro&gt; strings.Index(<span class="string">"hello"</span>, <span class="string">"h"</span>)</span><br><span class="line"><span class="number">0</span>	<span class="comment">// int</span></span><br><span class="line">gomacro&gt; strings.IndexAny(<span class="string">"hello"</span>, <span class="string">"x"</span>) <span class="comment">//匹配任意一个字符，并返回第一个匹配字符的index,如果不匹配则返回-1</span></span><br><span class="line"><span class="number">-1</span>	<span class="comment">// int</span></span><br><span class="line">gomacro&gt; strings.IndexAny(<span class="string">"hello"</span>,<span class="string">"hl"</span>)</span><br><span class="line"><span class="number">0</span>	<span class="comment">// int</span></span><br><span class="line">gomacro&gt; strings.Split(<span class="string">"hello,a,b"</span>,<span class="string">","</span>)</span><br><span class="line">[hello a b]	<span class="comment">// []string</span></span><br><span class="line">gomacro&gt; s := []<span class="keyword">string</span>&#123;<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>&#125;</span><br><span class="line">gomacro&gt; fmt.Println(strings.Join(s, <span class="string">", "</span>))</span><br><span class="line">foo, bar, baz</span><br><span class="line"><span class="number">14</span>	<span class="comment">// int</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;	<span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://golang.org/pkg/strings/" target="_blank" rel="noopener">https://golang.org/pkg/strings/</a></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>GoPackage</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-reflect</title>
    <url>/2020/07/05/Go-reflect/</url>
    <content><![CDATA[<h4 id="Package-reflect实现了运行时反射，允许程序获取任意对象的运行时信息。最常见的用法就是通过调用TypeOf方法获取对象类型；调用ValueOf返回对象运行时数据。反射是程序检查自身结构的一种能力，是一种形式的元编程。"><a href="#Package-reflect实现了运行时反射，允许程序获取任意对象的运行时信息。最常见的用法就是通过调用TypeOf方法获取对象类型；调用ValueOf返回对象运行时数据。反射是程序检查自身结构的一种能力，是一种形式的元编程。" class="headerlink" title="Package reflect实现了运行时反射，允许程序获取任意对象的运行时信息。最常见的用法就是通过调用TypeOf方法获取对象类型；调用ValueOf返回对象运行时数据。反射是程序检查自身结构的一种能力，是一种形式的元编程。"></a>Package <code>reflect</code>实现了运行时反射，允许程序获取任意对象的运行时信息。最常见的用法就是通过调用<code>TypeOf</code>方法获取对象类型；调用<code>ValueOf</code>返回对象运行时数据。反射是程序检查自身结构的一种能力，是一种形式的元编程。</h4><h5 id="类型和接口-Types-and-interfaces"><a href="#类型和接口-Types-and-interfaces" class="headerlink" title="类型和接口(Types and interfaces)"></a>类型和接口(Types and interfaces)</h5><p>反射构建在类型系统之上。<code>Go</code>是静态类型语言，每个变量都有一个静态类型，在编译阶段确认。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> j MyInt</span><br><span class="line"></span><br><span class="line">	fmt.Println(reflect.TypeOf(i))</span><br><span class="line">	fmt.Println(reflect.TypeOf(j))</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main.MyInt</span><br></pre></td></tr></table></figure>
<p>变量<code>i</code>的类型为<code>int</code>,<code>j</code>的类型为<code>MyInt</code>,虽然<code>i</code>和<code>j</code>的底层类型都是<code>int</code>类型，但它们之间如果不进行类型转换则不能进行赋值。<br><code>interface{}</code>可以表示任何类型的数据。</p>
<hr>
<h4 id="Go反射三大法则"><a href="#Go反射三大法则" class="headerlink" title="Go反射三大法则"></a>Go反射三大法则</h4><h5 id="1-从interface-开始进行对象的反射"><a href="#1-从interface-开始进行对象的反射" class="headerlink" title="1.从interface{}开始进行对象的反射"></a>1.从<code>interface{}</code>开始进行对象的反射</h5><pre><code>简单来说反射就是一种从`interface`类型的变量取出里面的`Type`和`value`的一种机制。通过`reflect.TypeOf`和`reflect.ValueOf` 可以分别获取反射的类型和值。
</code></pre><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">	r := reflect.TypeOf(x)</span><br><span class="line">	fmt.Println(<span class="string">"type:"</span>, r)</span><br><span class="line">	<span class="comment">// output: type:float64</span></span><br><span class="line">	fmt.Println(reflect.TypeOf(r))</span><br><span class="line">	<span class="comment">// output: ＊reflect.rtype</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码表明变量<code>x</code>的类型为<code>float64</code>，而且传递给函数<code>TypeOf</code>的参数<code>x</code>是<code>float64</code>类型，而不是<code>interface</code>类型，所以这跟<code>interface</code>又有什么关系呢？<br>查看函数<code>TypeOf</code>源码<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span></span><br><span class="line"><span class="comment">// If i is a nil interface value, TypeOf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现<code>TypeOf</code>的参数类型为<code>interface{}</code>,所以参数<code>x</code>会存储在一个空的<code>interface</code>中，然后再从这个<code>interface</code>中恢复类型信息。<br><code>func ValueOf(i interface{}) Value</code>也是如此。</p>
<h5 id="2-从反射对象可以获得interface的值"><a href="#2-从反射对象可以获得interface的值" class="headerlink" title="2.从反射对象可以获得interface的值"></a>2.从反射对象可以获得<code>interface</code>的值</h5><p>  对于一个<code>reflect.Value</code>类型的对象(反射对象)，我们可以通过<code>Interfaace</code>方法从中获取<code>interface</code>值。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">	r := reflect.ValueOf(x)</span><br><span class="line">	fmt.Println(r.Interface())</span><br><span class="line">	<span class="comment">// output: 3.4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Interface</span><span class="params">()</span> <span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> valueInterface(v, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reflect.ValueOf</code>的作用是把<code>float64</code>类型的变量转换成<code>reflect.Value</code>类型，而<code>Interface</code>的作用与<code>reflect.ValueOf</code>正好相反。</p>
<h5 id="3-要想修改一个反射对象，反射对象必须是可设置的"><a href="#3-要想修改一个反射对象，反射对象必须是可设置的" class="headerlink" title="3.要想修改一个反射对象，反射对象必须是可设置的"></a>3.要想修改一个反射对象，反射对象必须是可设置的</h5><p>执行如下代码<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	v.SetFloat(<span class="number">7.1</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.hysyeah.top/2020/7/8/20200708204658.png" alt><br>所以报错的原因是什么呢？请看如下代码:<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></table></figure></p>
<p>因为<code>Go</code>语言的函数调用的参数都是值传递的，所以传递给<code>reflect.ValueOf</code>函数的参数<code>x</code>并不是<code>x</code>本身而是<code>x</code>的一份拷贝。如果<code>v.SetFloat(7.1)</code>可以设置成功，这并不能更新<code>x</code>的值，更新的只是<code>x</code>的拷贝；但是真正的<code>x</code>并没有更新，这样做不但没有用而且会造成很多的疑惑。</p>
<p>要想对原有变量进行修改可以采用如下方式：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">3.4</span></span><br><span class="line">		v := reflect.ValueOf(&amp;i) <span class="comment">//获取变量指针</span></span><br><span class="line">		v.Elem().SetFloat(<span class="number">10</span>)    <span class="comment">//通过Elem()获取指针指向的变量，SetFloat对变量进行更新</span></span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		<span class="comment">//output :10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>通过反射对结构体进行修改：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	t := T&#123;<span class="number">23</span>, <span class="string">"skidoo"</span>&#125;</span><br><span class="line">	s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line"></span><br><span class="line">	s.Field(<span class="number">0</span>).SetInt(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(s.Field(<span class="number">0</span>))</span><br><span class="line">	<span class="comment">// output: 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Ref: </p>
<p>1.<a href="https://golang.org/pkg/reflect/" target="_blank" rel="noopener">https://golang.org/pkg/reflect/</a><br>2.<a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="noopener">https://blog.golang.org/laws-of-reflection</a></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>GoPackage</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-syscall</title>
    <url>/2020/07/11/Go-syscall/</url>
    <content><![CDATA[<h4 id><a href="#" class="headerlink" title=" "></a> </h4><p>包<code>syscall</code>提供了操作系统系统调用的接口。不同的操作提供原语会有所区别，所以有些系统是不一样的。<code>godoc</code>会根据当前的操作系统显示对应的文档。如果你想显示对应的文档，可以设置<code>GOOS</code>和<code>GOARCH</code>两个环境变量。大部分的系统调用在其它的<code>Package</code>中提供了兼容性更好的接口，如果可能的话推荐使用其它的<code>Package</code>比如<code>os, time, net</code>。</p>
<p>这个包官方不建议使用，具体可<a href="https://docs.google.com/document/d/1QXzI9I1pOfZPujQzxhyRy6EeHYTQitKKjHfpq0zpxZs/edit#heading=h.8gsfvmj9td4q" target="_blank" rel="noopener">参考</a>,推荐使用<code>go get golang.org/x/sys</code>。</p>
<hr>
<p>REF:<br>1.<a href="https://docs.google.com/document/d/1QXzI9I1pOfZPujQzxhyRy6EeHYTQitKKjHfpq0zpxZs/edit#heading=h.8gsfvmj9td4q" target="_blank" rel="noopener">https://docs.google.com/document/d/1QXzI9I1pOfZPujQzxhyRy6EeHYTQitKKjHfpq0zpxZs/edit#heading=h.8gsfvmj9td4q</a></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>GoPackage</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang竞争条件与锁</title>
    <url>/2020/03/23/Golang%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E4%B8%8E%E9%94%81/</url>
    <content><![CDATA[<p>竞争条件指的是程序在多个线程交叉执行时,引发的不可预知的错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var data int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	go func() &#123;</span><br><span class="line">		data++</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	if data==0&#123;</span><br><span class="line">		fmt.Printf(&quot;the value is %v.\n&quot;, data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码可能会出现如下三种不同情况：</p>
<ul>
<li>不打印任何东西;第6行早于第9行执行</li>
<li>打印<code>the value is 0</code>;第9行和第10行早于第6行执行</li>
<li>打印<code>the value is 1</code>;执行第9行后，然后执行第6行，再执行第10行</li>
</ul>
<p>竞态会导致程序的结果是不可预期的，而且不方便发现和调试。<br>怎么解决这个问题呢？<br>最简单的方法就是对访问到了变量的地方进行加锁操作。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;sync&quot;</span><br><span class="line">var data int</span><br><span class="line">var mu sync.Mutex</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		mu.Lock()</span><br><span class="line">		data++</span><br><span class="line">		mu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line">	mu.Lock()</span><br><span class="line"></span><br><span class="line">	if data==0&#123;</span><br><span class="line">		fmt.Printf(&quot;the value is %v.\n&quot;, data)</span><br><span class="line">	&#125;</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.hysyeah.top/2020/3/28/basic_race.png" alt="image"><br>这样的话就不会产生竞态问题，但这样看上去不怎么优雅，而且锁用多了会很影响程序的性能。</p>
<p>也可以使用<code>golang</code>的<code>channel</code>,使<code>data++</code>操作早于<code>print</code>,所以下面的程序不会输出任何东西。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var data int</span><br><span class="line"></span><br><span class="line">var d = make(chan int)</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		data++</span><br><span class="line">		d &lt;- data</span><br><span class="line"></span><br><span class="line">	&#125;()</span><br><span class="line">	data = &lt;-d  //如果没有数据将一直等待</span><br><span class="line">	if data == 0&#123;</span><br><span class="line">		fmt.Printf(&quot;the value is %v.\n&quot;, data)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>数据竞争发生的条件：</p>
<ul>
<li>两个或两个以上的线程同时访问相同的变量</li>
<li>最少一个为写操作</li>
<li>没有使用任何同步机制</li>
</ul>
<p>一.未使用任何同步机制的例子<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// vim bank.go</span><br><span class="line">package bank</span><br><span class="line"></span><br><span class="line">var balance int</span><br><span class="line"></span><br><span class="line">func Deposit(amount int)  &#123;</span><br><span class="line">	balance = balance + amount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Balance() int  &#123;</span><br><span class="line">	return balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// vim bank_main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;github.com/bank&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // Alice</span><br><span class="line">	go func() &#123;</span><br><span class="line">		bank.Deposit(200)</span><br><span class="line">		fmt.Println(&quot;=&quot;, bank.Balance())</span><br><span class="line">	&#125;()</span><br><span class="line">    // Bob</span><br><span class="line">	go bank.Deposit(100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>go run src/bank_main.go</code>,意外的发现没有打印任何信息。这是为什么呢?因为运行<code>Go</code>程序时,至少会启动一个<code>main goroutine</code>,当<code>main goroutine</code>早于其它协程执行之前退出,其它协程还没来得及执行就结束了。<br>执行<code>go run -race src/bank_main.go</code>却打印了<code>= 200</code>。<br><img src="http://img.hysyeah.top/2020/3/23/bank-no-sync-race.png" alt="image"></p>
<p>当两个<code>goroutine</code>同时访问<code>balance</code>变量时,假如Alice读取了<code>balance</code>并要将数据写入到<code>balance</code>的时候,如果此时切换到Bob,并将数据写入到了<code>balance</code>,然后再切换到Alice,并写入<code>balance</code>,这样就会将Bob的操作进行覆盖,这就是发生了数据竞争。<br>二.使用<code>channel</code>避免多个<code>goroutine</code>访问变量,解决数据竞争问题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package bank</span><br><span class="line"></span><br><span class="line">var deposits = make(chan int) // send amount to deposit</span><br><span class="line">var balances = make(chan int) // receive balance</span><br><span class="line"></span><br><span class="line">func Deposit(amount int) &#123; deposits &lt;- amount &#125;</span><br><span class="line">func Balance() int       &#123; return &lt;-balances &#125;</span><br><span class="line"></span><br><span class="line">func teller() &#123;</span><br><span class="line">	var balance int // balance is confined to teller goroutine</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case amount := &lt;-deposits:</span><br><span class="line">			balance += amount</span><br><span class="line">		case balances &lt;- balance:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">	go teller() // start the monitor goroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行<code>go run -race src/bank_main.go</code>未发现竟争条件问题<br><img src="http://img.hysyeah.top/2020/3/23/bank1.png" alt="image"></p>
<p>三.允许多个<code>goroutine</code>访问变量,但是在同一个时刻最多只有一个<code>goroutine</code>访问。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	sema = make(chan struct&#123;&#125;, 1)</span><br><span class="line">	balance int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Deposit(amount int)  &#123;</span><br><span class="line">	sema &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">	balance += amount</span><br><span class="line">	fmt.Print(&quot;balance&quot;, balance)</span><br><span class="line">	&lt;-sema</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Balance() int  &#123;</span><br><span class="line">	sema &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">	b := balance</span><br><span class="line">	&lt;-sema</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	go Deposit(10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;sync&quot;</span><br><span class="line">var (</span><br><span class="line">mu sync.Mutex // guards balance</span><br><span class="line">balance int</span><br><span class="line">)</span><br><span class="line">func Deposit(amount int) &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line">balance = balance + amount</span><br><span class="line">mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">func Balance() int &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line">b := balance</span><br><span class="line">mu.Unlock()</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Lock</code>与<code>channel</code>有什么优缺点？</p>
<hr>
<p>Deadlocks, Livelocks, Starvation</p>
<p>Deadlocks(死锁),在维基百科的解释为:In concurrent computing, a deadlock is a state in which each member of a group is waiting for another member, including itself, to take action, such as sending a message or more commonly releasing a lock.<br><img src="http://img.hysyeah.top/2020/3/28/Process_deadlock.svg.png" alt="image"><br>图片来源：wikipedia</p>
<p>进程<code>P1</code>持有资源<code>R2</code>,进程<code>P2</code>持有资源<code>R1</code>,当进程<code>P1</code>请求资源<code>R1</code>,进程<code>P2</code>请求资源<code>R2</code>的时候这种情况下就会发生死锁,如果没有外部干预进程会一直卡死。</p>
<p>死锁发生必须的4个条件,因为这个4个条件来源的于<a href="https://en.wikipedia.org/wiki/Edward_G._Coffman_Jr." target="_blank" rel="noopener">G. Coffman, Jr.</a>的一篇，因此也被称为<code>Coffman conditions</code>。</p>
<ul>
<li>互斥：一个资源在同一时间只能被一个进程访问</li>
<li>等待条件：进程同时占用至少一个资源,而且同时请求对其它的资源</li>
<li>非抢占：资源只能被占用它的那个进程释放</li>
<li>循环等待：比如<code>P1</code>等待<code>P2</code>释放资源,<code>P2</code>等待<code>P1</code>释放,形成了环状结构</li>
</ul>
<p>使用<code>Golang</code>模拟死锁发生<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line">type value struct &#123;</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	value int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">var printSum = func(v1,v2  *value) &#123;</span><br><span class="line"></span><br><span class="line">	defer wg.Done()</span><br><span class="line"></span><br><span class="line">	v1.mu.Lock()</span><br><span class="line"></span><br><span class="line">	defer v1.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	time.Sleep(2 * time.Second)</span><br><span class="line"></span><br><span class="line">	v2.mu.Lock()</span><br><span class="line"></span><br><span class="line">	defer v2.mu.Unlock()</span><br><span class="line">	fmt.Printf(&quot;sum=%v\n&quot;,v1.value+v2.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var a, b value</span><br><span class="line">	wg.Add(2)</span><br><span class="line">	go printSum(&amp;a, &amp;b) //Goroutine p1</span><br><span class="line">	go printSum(&amp;b, &amp;a) // Goroutine p2</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.hysyeah.top/2020/3/28/dead_lock_error.png" alt="image"><br><code>Golang</code>居然检测出来发生了死锁，那<code>Golang</code>是如何进行死锁检测的呢？</p>
<p><img src="http://img.hysyeah.top/2020/3/28/dead_lock.png" alt="image"><br>图片来源：Concurrenecy in Go</p>
<p>程序运行时,<code>goroutine p1</code>获取<code>a</code>锁,此时<code>p1</code>持有<code>a</code>的锁,休眠,然后<code>goroutine p2</code>开始执行,并持有资源<code>b</code>的锁,然后<code>p1</code>请求资源<code>b</code>,<code>p2</code>请求资源<code>a</code>,发生死锁。</p>
<p>Livelocks(活锁)<br>活锁就是程序一直在运行，但是一直没有改变进程本身的状态。举个例子，比如你走在一个狭窄的通道，对面迎过来一个人，他看见了你就走到了另一边打算让你通过，而你也走到了另一边，当你们一直重复这两个动作时就发生了活锁。</p>
<p>Starvation<br>In computer science, resource starvation is a problem encountered in concurrent computing where a process is perpetually denied necessary resources to process its work.<br>在计算机科学中，资源匮乏是并发计算中遇到的一个问题，在该问题中，永久拒绝某个进程来处理其工作所需的资源</p>
<hr>
<p>Ref：<br>1.<a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Race_condition</a><br>2.<a href="https://www.gopl.io/" target="_blank" rel="noopener">The Go programing language</a><br>3.<a href="https://golang.org/ref/mem" target="_blank" rel="noopener">The Go Memory Model</a><br>4.<a href="https://book.douban.com/subject/26994591/" target="_blank" rel="noopener">Concurrency in Go</a><br>5.<a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Deadlock</a><br>6.(<a href="https://github.com/kat-co/concurrency-in-go-src(https://github.com/kat-co/concurrency-in-go-src" target="_blank" rel="noopener">https://github.com/kat-co/concurrency-in-go-src(https://github.com/kat-co/concurrency-in-go-src</a>)<br>7.<a href="https://en.wikipedia.org/wiki/Starvation_(computer_science" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Starvation_(computer_science)</a>)</p>
]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go函数</title>
    <url>/2018/08/18/Go%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>函数声明包括函数名、形式参数列表、返回值列表(可省略)以及函数体。</p>
<pre><code>func name(parameter-list) (result-list) {
    body
}
</code></pre><p>实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice，map，function， channel等类型，实参可能会由于函数的间接引用被修改。</p>
<hr>
<p>递归:Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。 虽然Go的垃圾回收机制会回收不被使用的内存，但不包括操作系统层面的资源，比如打开的文件、网络连接。 log包中的所有函数会为没有换行符的字符串增加换行符。 fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回。 匿名函数：</p>
<pre><code>func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
</code></pre><p>可变参数:</p>
<pre><code>func sum(vals...int) int {
    total := 0
    for _, val := range vals {
        total += val
    }
    return total
}
</code></pre><hr>
<p>defer语句经常用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。</p>
<pre><code>package ioutil
func ReadFile(filename string) ([]byte, error) {
    f, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    defer f.Close()
    return ReadAll(f)
}

var mu sync.Mutex
var m = make(map[string]int)
func lookup(key string) int {
    mu.Lock()
    defer mu.Unlock()
    return m[key]
}
</code></pre><p>Panic异常 Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、 空指针引用等。这些运行时错误会引起painc异常。 一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine（可以先理解成线程)中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。</p>
<hr>
<p>Recover捕获异常 如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异 常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运 行，但能正常返回。在未发生panic时调用recover，recover会返回nil。</p>
<pre><code>func Parse(input string) (s *Syntax, err error) {
    defer func() {
    if p := recover(); p != nil {
        err = fmt.Errorf(&quot;internal error: %v&quot;, p)
    }
   }()
// ...parser...
}
</code></pre><hr>
<p>Ref： 1.The Go Programming Language</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang prng</title>
    <url>/2020/06/24/Golang-prng/</url>
    <content><![CDATA[<p>伪随机数生成器－pseudo-random number generator (PRNG)。<br>实现位于<code>math/rand</code></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// math/rand如果不指定种子,则默认的种子为1;程序每次运行产生的随机数都是一样的;所以这里指定种子纳表级别的时间戳为种子,确保每次生成数都是随机的.</span></span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	r := rand.Intn(<span class="number">100</span>)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>Ref：<br>1.<a href="https://golang.org/pkg/math/rand/" target="_blank" rel="noopener">https://golang.org/pkg/math/rand/</a></p>
]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础数据类型</title>
    <url>/2018/08/14/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Go将数据类型分为四类: 基础类型、复合类型、引用类型和接口类型。 基础类型包括：数字、字符串、布尔型。 整型 整型分为有符号和无符号类型的整数。</p>
<pre><code>int8        int16       int32       int64   //分别对应8、16、32、64位大小的有符号整型数

uint8       uint16      uint32      uint64  //分别对应8、16、32、64位大小的无符号整型数
</code></pre><p>这些类型的变量不允许互相赋值或操作。如以下代码会产生错误:<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int32</span></span><br><span class="line">c := a+b</span><br></pre></td></tr></table></figure></p>
<p>Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可 以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数 据而不是一个小的整数。</p>
<pre><code>// Go中运算符优先级
* / % &lt;&lt; &gt;&gt; &amp; &amp;^
+ - | ^
== != &lt; &lt;= &gt; &gt;=
&amp;&amp;
||
</code></pre><hr>
<p>浮点数</p>
<pre><code>float32         float64
</code></pre><p>复数</p>
<pre><code>complex64                   //对应float32
complex128                  //对应float64
</code></pre><p>布尔型</p>
<pre><code>true                    false
</code></pre><p>字符串 原生字符串使用反引号代替双引号。在原生字符串面值中，不会进行转义操作。</p>
<pre><code>const t = `Go is best language`
</code></pre><p>一个字符串是包含的只读字节数组，一旦创建，是不可变的。相比之下，一个字节slice的元 素则可以自由地修改。</p>
<pre><code>// 字符串和字节slice之间可以相互转换
s := &quot;abc&quot;
b := []byte(s)
s2 := string(b)
</code></pre><p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p>
<hr>
<p>常量 常量表达式的值在编译期计算，而不是在运行期。 所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。 当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引 越界、任何导致无效浮点数的操作等 注意默认类型是规则的：无类型的整数常量默认转换为int，对应不确定的内存大小，但是浮 点数和复数常量则默认转换为float64和complex128。</p>
<pre><code>const (
    a = 1
    b
    c = 2
    d
)
fmt.Println(a, b, c, d) //1, 1, 2, 2

const (
    a uint = 1 &lt;&lt; iota
    b
    c
    d
)
fmt.Println(a, b, c, d) //1, 2, 4, 8
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i := 1</span><br><span class="line">在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。</span><br><span class="line">函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。</span><br></pre></td></tr></table></figure>
<hr>
<p>Ref： 1.The Go Programming Language</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go复合数据类型</title>
    <url>/2018/08/15/Go%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Go复合数据类型包括：数组，切片，字典，结构体。 数组：</p>
<pre><code>var a [3]int
q := [...]int{1, 2, 3}       //数组长度根据初始化元素数量决定

for i, v := range a {
    fmt.Printf(&quot;%d %d\n&quot;, i, v) //打印索引、值
}

//数组的大小也是其类型的一部分，[3]int和[4]int是不同的类型。

r :=[...]int{99:-1} //定义了一个大小为100，最后一个元素初始为-1,其余为0


c1 := sha256.Sum256([]byte(&quot;x&quot;))      //
</code></pre><p>切片</p>
<pre><code>// 切片共享底层数组数据
months := [...]string{1: &quot;January&quot;, 2: &quot;February&quot;, 3: &quot;March&quot;, 4: &quot;April&quot;, 5: &quot;June&quot;}
Q1 := months[0:3]
Q2 := months[2:3]
fmt.Println(Q1[2], &amp;Q1[2]) //February 0xc042044080
fmt.Println(Q2[0], &amp;Q2[0]) //February 0xc042044080

Q2[0] = &quot;Hello&quot;   // 修改Q2[0]后，Q1中的数据也发生改变
fmt.Println(Q1, Q2)  //[ January Hello] [Hello]

//切片的创建
var array=[5]int{1, 2, 3, 4, 5}
slice := array[:4]             //基于底层数组创建

var slice = []int{1, 2, 3, 4, 5} //直接创建

var slice = make([]int 5, 10) //使用make函数创建有5个元素的切片，cap为10
</code></pre><p>字典：</p>
<pre><code>ages := map[string]int{
    &quot;alice&quot;: 31,
    &quot;joke&quot;: 33,
}

//或者
ages := make(map[string]int)
ages[&quot;alice&quot;] = 31
ages[&quot;joke&quot;] = 33


age, ok := ages[&quot;bob&quot;]
if !ok {/* &quot;bob&quot; is not in this map&quot;*/}
//也可以写成如下形式
if age, ok := ages[&quot;bob&quot;]; !ok {/*...*/}
//不能对字典元素进行取地址的操作，因为字典元素的地址是会发生变化的，当装载因子超过一定数值后，会对字典进行rehash操作。
</code></pre><p>结构体</p>
<pre><code>type Point struct {
    X, Y int
}

pp := &amp;Point{1, 2}

pp := new(Point)
*pp = Point{1, 2}           //等价于上种方式

pp.X              //1
pp.Y              //2
</code></pre><p>结构体嵌套</p>
<pre><code>type Point struct {
    X, Y int
}

type Circle struct {
    Center Point
    Radius int
}

type Wheel struct {
    Circle Circle
    Spokes int
}

var w Wheel
w.Circle.Center.X = 8     //这样访问显得过繁琐


//结构体中的匿名字段
type Circle struct {
    Point
    Radius int
}

type Wheel struct {
    Circle
    Spokes int
}
// 这样我们就可以省略掉中间的名称直接访问w.X

//两种初始化方法
var w Wheel = Wheel{Circle{Point{8, 8}, 5}, 20}
var w Wheel = Wheel {
    Circle: Circle {
        Point: Point{X: 8, Y: 8},
        Radius: 5,
    },
    Spokes: 20,
}
</code></pre><p>JSON</p>
<pre><code>// 只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字
母开头的成员名称。
type Movie struct {
    Title string
    Year int `json:&quot;released&quot;`    //输出json格式时指定的别名
    Color bool `json:&quot;color, omitempty&quot;` //omitempty表示结构体成员为空时不生成JSON对象
    Actors []string
}
</code></pre><p>文本和HTML模版</p>
<pre><code>const templ = `{ {.TotalCount}} issues:
{ {range .Items}}----------------------------------------
Number: { {.Number}}
User: { {.User.Login}}
Title: { {.Title | printf &quot;%.64s&quot;}}
Age: { {.CreatedAt | daysAgo}} days
{ {end}}`

func daysAgo(t time.Time) int {
    return int(time.Since(t).Hours() / 24)
}

// 创建一个模版，指定过滤函数，调用Parse函数分析模板
report, err := template.New(&quot;report&quot;).
Funcs(template.FuncMap{&quot;daysAgo&quot;: daysAgo}).
Parse(templ)

//执行模版，result为传入的参数
report.Execute(os.Stdout, result)
</code></pre><hr>
<p>Ref： 1.The Go Programming Language</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go方法</title>
    <url>/2018/08/18/Go%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将函数附加这种类型上，即相当于这这种类型定义了一个独占的方法。</p>
<pre><code>/* 这个附加的参数p,叫做方法的接收器(receiver),早期的面向对象语言留下的遗产将调用一个方法称为&quot;向一个对象发送消息&quot;
在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。建议可以使用其类型的第一个字母，比如这里使用了Point的首字母p*/
type Point struct{ X, Y float64 }
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
</code></pre><p>每种类型都有其方法的命名空间，我们在用Distance这个名字的时候，不同的Distance调用指向了不同类型里的Distance方法。</p>
<hr>
<p>基于指针对象的方法 当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够进行这种默认的拷贝，这种情况我们可以使用指针。</p>
<pre><code>// 这个方法的名字是(*Point).ScaleBy
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}


p := Point{1, 2}
pptr := &amp;p

pptr.Distance(q)
(*pptr).Distance(q)
// 编译器在这里也会给我们隐式地插入*这个操作符，所以上面这两种写法等价
</code></pre><ol>
<li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。</li>
<li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。</li>
</ol>
<hr>
<p>通过嵌入结构体来扩展类型</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;image/color&quot;
)


type Point struct{X, Y float64}

type ColoredPoint struct {
    Point
    Color color.RGBA
}

func (p Point)Distance() float64{
    return p.X
}

func main() {
    red := color.RGBA{255, 0, 0, 255}
    var p = ColoredPoint{Point{1, 1}, red}
    fmt.Println(p.Distance())
}
/*
p这里可以直接调用p.Distance()方法。这里可以将Point看作一个基类，ColoredPoint是其子类或继承类。
*/
</code></pre><hr>
<p>封装 一个对象的变量或者方法如果对调用方不可见的话，一般就被定义为”封闭”。封装有时候也被叫信息隐藏，同时也是面向对象编程最关键的一个方面。 Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。</p>
<hr>
<p>Ref： 1.The Go Programming Language</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go接口</title>
    <url>/2018/08/18/Go%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。 接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。 一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。</p>
<pre><code>/* Abs()是interface类型Abser定义的方法，而MyFloat实现了该方法，所以，MyFloat实现了Abser接口
package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Abser interface {
    Abs() float64
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f &lt; 0 {
        return float64(-f)
    }
    return float64(f)
}

func main() {
    var a Abser
    f := MyFloat(-math.Sqrt2)
    a = f  // a MyFloat implements Abser
    fmt.Println(a.Abs())
</code></pre><p>interface{}被称为空接口，因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。</p>
<pre><code>var any interface{}
any = true
any = 12.34
any = &quot;hello&quot;
any = map[string]int{&quot;one&quot;: 1}
any = new(bytes.Buffer)
</code></pre><p>格式化输出</p>
<pre><code>// 实现了String方法的类型，称作实现了Stringer接口。Stringer接口为此类型提供了原始的输出格式
type Stringer interface {
        String() string
}


package main

import &quot;fmt&quot;

type IPAddr [4]byte

func main() {
    addrs := map[string]IPAddr{
        &quot;loopback&quot;:  {127, 0, 0, 1},
        &quot;googleDNS&quot;: {8, 8, 8, 8},
    }
    for n, a := range addrs {
        fmt.Printf(&quot;%v: %v\n&quot;, n, a)
    }
}
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/ip.png" alt> 为类型IPAddr实现Stringer接口</p>
<pre><code>package main

import &quot;fmt&quot;

type IPAddr [4]byte

func (ip IPAddr) String() string {    
    return fmt.Sprintf(&quot;%v.%v.%v.%v&quot;, ip[0], ip[1], ip[2], ip[3])
}

func main() {
    addrs := map[string]IPAddr{
        &quot;loopback&quot;:  {127, 0, 0, 1},
        &quot;googleDNS&quot;: {8, 8, 8, 8},
    }
    for n, a := range addrs {
        fmt.Printf(&quot;%v: %v\n&quot;, n, a)
    }
}
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/ip1.png" alt></p>
<hr>
<p>Ref：<br>1.The Go Programming Language<br>2.<a href="https://studygolang.com/articles/2652" target="_blank" rel="noopener">https://studygolang.com/articles/2652</a></p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Hyperledger Fabric编译和安装</title>
    <url>/2018/08/22/Hyperledger%20Fabric%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h4 id="环境：ubuntu-16-04-64位"><a href="#环境：ubuntu-16-04-64位" class="headerlink" title="环境：ubuntu 16.04 64位"></a>环境：ubuntu 16.04 64位</h4><p>1.依次安装<code>go 1.9.x</code>,<code>docker</code>,<code>docker-compose</code> <img src="http://img.hysyeah.top/wp-content/uploads/2018/08/fabric-req.png" alt> 2.</p>
<pre><code>mkdir -p $GOPATH/src/github.com/hyperledger
cd $GOPATH/src/github.com/hyperledger
git clone http://gerrit.hyperledger.org/r/fabric
cd fabric
git checkout release-1.0  # release-1.0才支持go 1.9.x
</code></pre><p>3.安装依赖软件</p>
<pre><code>go get github.com/golang/protobuf/protoc-gen-go
mkdir -p $GOPATH/src/github.com/hyperledger/fabric/build/docker/gotools/bin
# go get之后编译好的文件会放到$GOBIN对应的目录中，如果没有设置$GOBIN的值，生成的文件将默认存放到$GOPATH/bin下面
cp protoc-gen-go $GOPATH/src/github.com/hyperledger/fabric/build/docker/gotools/bin
</code></pre><p>4.编译</p>
<pre><code>cd $GOPATH/src/github.com/hyperledger/fabric
make release

make docker //生成docker镜像文件
</code></pre><p>5.编译成功后会在<code>$GOPATH/src/github.com/hyperledger/fabric/release/linux-amd64/bin</code>生成如下可执行文件。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/08/fabric-exe.png" alt> 6.make docker 经过漫长的等待后 <img src="http://img.hysyeah.top/wp-content/uploads/2018/08/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180823091621.png" alt> mysql镜像除外</p>
<hr>
<p>遇到的问题： 1.执行make release时报如下错误</p>
<pre><code>gotools.mk:22: *** target pattern contains no &#39;%&#39;.  Stop
</code></pre><p>原因是我的$GOPATH设置了多个路径，改成一个路径之后错误消失。</p>
<pre><code>export GOPATH=&quot;/home/hys/mycode/go:/home/hys/mycode/go/gopl:/home/hys/mycode/go/block&quot;
==&gt; export GOPATH=&quot;/home/hys/mycode/go/block&quot;
</code></pre><p>2.<code>golang.org/x</code>不能访问的问题 <a href="http://img.hysyeah.top/2018/08/22/go-get-golang-orgx-%E5%8C%85%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">解决方法</a></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>Go程序结构</title>
    <url>/2018/08/13/Go%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>Go 25个关键字</p>
<pre><code>break       default          func     interface   select
case        defer            go       map         struct
chan        else             goto     package     switch
const       fallthrough      if       range       type
continue    for              import   return      var
</code></pre><p>内置常量，类型，函数</p>
<pre><code>true        false       iota        nil


int     int8    int16   int32   int64
unit    uint8   unit16  unit32  uint64  unitptr
float32     float64     complex128      complex64
bool    byte    rune    string  error


make    len     cap     new     append      copy    close   delete
complex     real    imag
panic   recover
</code></pre><p>如果一个名称是以大写字母开头的，表示此名称对于其它的package是可见和可获取的。</p>
<hr>
<pre><code>// 常量a是package级别的声明，f是一个局部变量，package级别的实体是整个package可见的，不止在声明它的文件中。
package main

const a = 123;
func main() {
    var f = a
}
</code></pre><hr>
<p>变量</p>
<pre><code>var name  type = expression

var s string           //定义了一个名为s,类型为string的变量
var i, j, k int        // int, int, int

i := 100
i, j: = 0, 1
i, j = j, i            //交换变量
</code></pre><hr>
<p>指针</p>
<pre><code>指针的&quot;零值&quot;是nil
x := 1
p := &amp;x                        //通过&amp;取变量x的地址

函数返回一个局部变量的地址是安全，当函数返回后这个局部依然存在(在C语言中则会发生错误(段错误))
func f() *int {
    v := 1
    return &amp;v
}

func main() {
    fmt.Println(*f())    //1
}

//尽管x是局部变量，当函数返回后x还是可以被指针global访问，所以x必须分配在堆上，这种情况我们称为x逃离了f
var global *int
func f() {
    var x int
    x = 1
    global = &amp;x
}
</code></pre><p>赋值</p>
<pre><code>var s string = &quot;hello&quot;
s := &quot;hello&quot;
x, y := 0, 1

m := make(map[string]int)
v, ok = m[key]                  //返回两个值

medals := []string{&quot;hello&quot;, &quot;world&quot;}

//定义一个map并初始化
m3 := map[string]string{
    &quot;a&quot;: &quot;aa&quot;,
    &quot;b&quot;: &quot;bb&quot;,
}
</code></pre><p>类型声明</p>
<pre><code>type name underlying-type

type new_int int                        //给int定义一个别名new_int
</code></pre><p>作用域</p>
<pre><code>if f, err := os.Open(fname); err != nil { // compile error: unused: f
return err
}
f.ReadByte() // compile error: undefined f
f.Close() // compile error: undefined f

//变量f的作用域只有在if语句内，因此后面的语句将无法引入它，这将导致编译错误
</code></pre><p>包的初始化</p>
<pre><code>包的初始化首先是解决包级变量的依赖顺序，然后安照包级变量声明出现的顺序依次初始
化：
var a = b + c // a 第三个初始化, 为 3
var b = f() // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1 // c 第一个初始化, 为 1
func f() int { return c + 1 }


// init初始化函数除了不能被调用或引用外，其也行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。
func init() {  }
</code></pre><p><a href="https://github.com/hys20151008/gopl/tree/master/src/ch2" target="_blank" rel="noopener">相关代码</a></p>
<hr>
<p>Ref： 1.The Go Programming Language</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 安装mysqlclient</title>
    <url>/2017/10/28/Linux%20%E5%AE%89%E8%A3%85mysqlclient/</url>
    <content><![CDATA[<p>centos安装 mysqlclient失败，需先安装</p>
<pre><code>yum install mysql-devel


pip install mysqlclient
</code></pre><hr>
<p>ubuntu</p>
<pre><code>apt-get install libmysqlclient-dev python3-dev
</code></pre>]]></content>
      <categories>
        <category>Python Web</category>
      </categories>
  </entry>
  <entry>
    <title>Protocol Buffers and GRPC</title>
    <url>/2020/06/30/Protocol-Buffers-and-GRPC/</url>
    <content><![CDATA[<h4 id="Protocol-Buffers"><a href="#Protocol-Buffers" class="headerlink" title="Protocol Buffers"></a>Protocol Buffers</h4><p><code>Protocol buffers</code>是由Google推出来的用于描述结构化数据的一种数据格式,类似于<code>XML</code>,但更小更快更简单，语言无关，平台无关而且支持可扩展。通过描述性语言定义你所需要的数据结构,可以实现一次定义即可以生成多种语言的相关的代码。目前<code>Protocal buffers</code>基本上已支持大多数的编程语言。</p>
<p>本文将介绍在<code>Go</code>语言中怎么使用<code>Protocol buffers</code></p>
<p>1.<code>protoc</code>安装<br><a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">下载</a>所需的版本，解压设置环境变量<br>2.<code>protoc-gen-go</code>的安装<br> <code>go install google.golang.org/protobuf/cmd/protoc-gen-go</code></p>
<p>3.新建一个<code>Go Module</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  gopro mkdir grpc</span><br><span class="line">➜  gopro cd grpc</span><br><span class="line">➜  grpc mkdir src</span><br><span class="line">➜  cd src</span><br><span class="line">➜  src go mod init example.com/grpc</span><br></pre></td></tr></table></figure></p>
<p>整个目录的结构如下<br><img src="http://img.hysyeah.top/2020/7/4/20200704113839-grpc.png" alt></p>
<p>4.在<code>protofiles</code>中编辑<code>person.pb.go</code>文件。如下代码用<code>protobuf</code>声明式语言定义了一个数据结构<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  string name = <span class="number">1</span>;</span><br><span class="line">  int32 id = <span class="number">2</span>;</span><br><span class="line">  string email = <span class="number">3</span>;</span><br><span class="line">  enum PhoneType &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    string number = <span class="number">1</span>;</span><br><span class="line">    PhoneType type = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  repeated PhoneNumber phones = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.通过<code>proto</code>生成<code>Go</code>语言对应的文件<br>  在<code>grpc/src/protofiles</code>执行<code>protoc --go_out=. *.proto</code>会在当前目录下生成<br>文件<code>person.pb.go</code><br>6.编写<code>main.go</code>和<code>main_json.go</code>文件<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	pb <span class="string">"example.com/grpc/protofiles"</span> <span class="comment">//我们可以使用person.pb.go中的结构傅Person</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/golang/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 对Person进行初始化，并将指针赋值给变量p</span></span><br><span class="line">	p := &amp;pb.Person&#123;</span><br><span class="line">		Id: <span class="number">1234</span>,</span><br><span class="line">		Name: <span class="string">"Roger F"</span>,</span><br><span class="line">		Email: <span class="string">"rf@gmail.com"</span>,</span><br><span class="line">		Phones: []*pb.Person_PhoneNumber&#123;</span><br><span class="line">			&#123;Number: <span class="string">"555-4321"</span>, Type: pb.Person_HOME&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p1 := &amp;pb.Person&#123;&#125;</span><br><span class="line">	body, _ := proto.Marshal(p)</span><br><span class="line">	_ = proto.Unmarshal(body, p1)</span><br><span class="line">	fmt.Println(<span class="string">"Original struct loadef from proto file:"</span>,p,<span class="string">"\n"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"Marshaled proto data: "</span>, body, <span class="string">"\n"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"Unmarshaled struct: "</span>, p1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main_json.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	pb <span class="string">"example.com/grpc/protofiles"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := &amp;pb.Person&#123;</span><br><span class="line">		Id: <span class="number">1234</span>,</span><br><span class="line">		Name: <span class="string">"Roger F"</span>,</span><br><span class="line">		Email: <span class="string">"rf@gmail.com"</span>,</span><br><span class="line">		Phones: []*pb.Person_PhoneNumber&#123;</span><br><span class="line">			&#123;Number: <span class="string">"555-4321"</span>, Type: pb.Person_HOME&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	body, _ := json.Marshal(p)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.执行<code>go mod tidy</code>安装依赖。<br>8.分别执行<code>main.go</code>和<code>main_json.go</code><br><img src="http://img.hysyeah.top/2020/7/4/20200704161336.png" alt></p>
<h6 id="Go类型与对应的Protobuf类型"><a href="#Go类型与对应的Protobuf类型" class="headerlink" title="Go类型与对应的Protobuf类型"></a>Go类型与对应的Protobuf类型</h6><div class="table-container">
<table>
<thead>
<tr>
<th>Go</th>
<th>Protobuf type</th>
</tr>
</thead>
<tbody>
<tr>
<td>float32</td>
<td>float</td>
</tr>
<tr>
<td>float64</td>
<td>double</td>
</tr>
<tr>
<td>uint32</td>
<td>fixed32</td>
</tr>
<tr>
<td>uint64</td>
<td>fixed64</td>
</tr>
<tr>
<td>[]byte</td>
<td>bytes</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>Protobut type</th>
<th>Default value</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>“”</td>
</tr>
<tr>
<td>bytes</td>
<td>empty bytes[]</td>
</tr>
<tr>
<td>bool</td>
<td>false</td>
</tr>
<tr>
<td>int,int32,int64,float,double</td>
<td>0</td>
</tr>
<tr>
<td>enum</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="GRPC"><a href="#GRPC" class="headerlink" title="GRPC"></a>GRPC</h4><p>1.安装<code>grpc</code>Go语言相关库<br><code>go get google.golang.org/grpc</code><br><code>go get google.golang.org/grpc/cmd/protoc-gen-go-grpc</code><br>2.在<code>src</code>目录下新建<code>grpc</code>文件夹，最终的目录结构如下。<br><img src="http://img.hysyeah.top/2020/7/4/20200704220816.png" alt><br>3.定义<code>transaction.proto</code><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> grpc;</span><br><span class="line"></span><br><span class="line">message TransactionRequest &#123;</span><br><span class="line">  <span class="keyword">string</span> from = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">string</span> to = <span class="number">2</span>;</span><br><span class="line">  float amount = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message TransactionResponse &#123;</span><br><span class="line">  <span class="keyword">bool</span> confirmation = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service MoneyTransaction &#123;</span><br><span class="line">  rpc MakeTransaction(TransactionRequest) returns (TransactionResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.执行命令<code>protoc --go_out=plugins=grpc:. transaction.proto</code>,会在<code>grpc</code>目录下生成文件<code>transaction.pb.go</code>,文件中的部分内容。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TransactionRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	From   <span class="keyword">string</span>  <span class="string">`protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`</span></span><br><span class="line">	To     <span class="keyword">string</span>  <span class="string">`protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`</span></span><br><span class="line">	Amount <span class="keyword">float32</span> <span class="string">`protobuf:"fixed32,3,opt,name=amount,proto3" json:"amount,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TransactionResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	Confirmation <span class="keyword">bool</span> <span class="string">`protobuf:"varint,1,opt,name=confirmation,proto3" json:"confirmation,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> moneyTransactionClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	cc grpc.ClientConnInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMoneyTransactionClient</span><span class="params">(cc grpc.ClientConnInterface)</span> <span class="title">MoneyTransactionClient</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;moneyTransactionClient&#123;cc&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *moneyTransactionClient)</span> <span class="title">MakeTransaction</span><span class="params">(ctx context.Context, in *TransactionRequest, opts ...grpc.CallOption)</span> <span class="params">(*TransactionResponse, error)</span></span> &#123;</span><br><span class="line">	out := <span class="built_in">new</span>(TransactionResponse)</span><br><span class="line">	err := c.cc.Invoke(ctx, <span class="string">"/grpc.MoneyTransaction/MakeTransaction"</span>, in, out, opts...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterMoneyTransactionServer</span><span class="params">(s *grpc.Server, srv MoneyTransactionServer)</span></span> &#123;</span><br><span class="line">	s.RegisterService(&amp;_MoneyTransaction_serviceDesc, srv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.编写<code>client.go</code>和<code>server.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">"example.com/grpc/grpc"</span></span><br><span class="line">	<span class="string">"golang.org/x/net/context"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	port = <span class="string">":50051"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server is used to create MoneyTransactionServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeTransaction implements MoneyTransactionServer.MakeTransaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">MakeTransaction</span><span class="params">(ctx context.Context, in *pb.TransactionRequest)</span> <span class="params">(*pb.TransactionResponse, error)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">"Got request for money Transfer...."</span>)</span><br><span class="line">	log.Printf(<span class="string">"Amount: %f, From A/c:%s, To A/c:%s"</span>, in.Amount, in.From, in.To)</span><br><span class="line">	<span class="comment">// Do database logic here....</span></span><br><span class="line">	<span class="keyword">return</span> &amp;pb.TransactionResponse&#123;Confirmation: <span class="literal">true</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lis, err := net.Listen(<span class="string">"tcp"</span>, port)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">"Failed to listen: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterMoneyTransactionServer(s, &amp;server&#123;&#125;)</span><br><span class="line">	<span class="comment">// Register reflection service on gRPC server.</span></span><br><span class="line">	reflection.Register(s)</span><br><span class="line">	<span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">"Failed to serve: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">"example.com/grpc/grpc"</span></span><br><span class="line">	<span class="string">"golang.org/x/net/context"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	address = <span class="string">"localhost:50051"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Set up a connection to the server.</span></span><br><span class="line">	conn, err := grpc.Dial(address, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">"Did not connect: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">defer</span> conn.Close()</span><br><span class="line">  <span class="comment">//创建一个rpc客户端</span></span><br><span class="line">	c := pb.NewMoneyTransactionClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare data. Get this from clients like Frontend or App</span></span><br><span class="line">	from := <span class="string">"1234"</span></span><br><span class="line">	to := <span class="string">"5678"</span></span><br><span class="line">	amount := <span class="keyword">float32</span>(<span class="number">1250.75</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">	r, err := c.MakeTransaction(context.Background(), &amp;pb.TransactionRequest&#123;From: from,</span><br><span class="line">		To: to, Amount: amount&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">"Could not transact: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">"Transaction confirmed: %t"</span>, r.Confirmation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.分别执行<code>server.go</code>和<code>client.go</code><br><img src="http://img.hysyeah.top/2020/7/4/20200704221645.png" alt></p>
<hr>
<p>Ref：<br>1.<a href="https://developers.google.com/protocol-buffers/docs/gotutorial" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/gotutorial</a><br>2.<a href="https://book.douban.com/subject/30154905/" target="_blank" rel="noopener">Building RESTful Web services with Go</a><br>3.<a href="https://grpc.io/" target="_blank" rel="noopener">GRPC</a></p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Racket数据类型</title>
    <url>/2017/11/04/Racket%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>1.1 Numbers包括小数和虚数</p>
<pre><code>&gt; 1
1
&gt; 1/2
1/2
&gt; 1+2i
1+2i
&gt; 3.14
3.14
</code></pre><p>1.2 Booleans,#t表示真，#f表示假 1.3 Byte,值在0-255的整数</p>
<pre><code>&gt;(byte? 0)
#t
&gt; (byte? 256)
#f
</code></pre><p>1.4 Characters,单个字符</p>
<pre><code>&gt; (integer-&gt;char 65)
#\A
&gt; (display #\A)
A
</code></pre><p>1.5 Strings,用双引号包围</p>
<pre><code>&gt; &quot;Hello,World&quot;
&quot;Hello,World&quot;
</code></pre><p>1.6 Symbols 就原子值，打印的时候以’开始</p>
<pre><code>&gt; &#39;a
&#39;a
&gt; (symbol? &#39;a)
#t
</code></pre><p>1.7 Keyword,和symbol类似，但打印的时候以#:开始</p>
<pre><code>&gt; (string-&gt;keyword &quot;apple&quot;)
&#39;#:apple
</code></pre><p>1.8 Pairs,可以连接两个任意值，cons函数用来构造Pairs</p>
<pre><code>&gt; (pair? (cons 1 2))
#t
</code></pre><p>1.9 Lists 列表</p>
<pre><code>&gt; (list 1 2 3)
&#39;(1 2 3)
</code></pre><p>2.0 Vector,是固定长度可以存放任意值的列表，支持常量 时间获取元素和更新元素</p>
<pre><code>&gt; (vector-ref #(name (that tune)) 1)
&#39;(that tune)
</code></pre><p>2.1 Hash Tables,字典</p>
<pre><code>&gt;(define ht (make-hash))

&gt;(hash-set! ht &quot;apple&quot; &#39;(red round))

&gt;(hash-ref ht &quot;apple&quot;)

&#39;(red round)
</code></pre><p>2.2 Boxes,是一个只有一个元素的vertor,打印以#&amp;开始</p>
<pre><code>&gt; (define b (box &quot;apple&quot;))
&gt; b
&#39;#&amp;&quot;apple&quot;
&gt; (unbox b)
&quot;apple&quot;
&gt; (set-box! b &#39;(banana boat))
&gt; b
&#39;#&amp;(banana boat)
</code></pre>]]></content>
      <categories>
        <category>Racket</category>
      </categories>
  </entry>
  <entry>
    <title>Linux Namespace</title>
    <url>/2020/07/05/Linux-Namespace/</url>
    <content><![CDATA[<p><code>Linux Namespace</code>是容器的基石，可以说没有<code>Linux Namespace</code>就不存在现在的容器技术。容器最大的功能就是对资源进行隔离，容器正是通过<code>Linux Namespace</code>技术实现了各种资源的隔离。</p>
<p><code>Linux Namespace</code>总共有6种类别的<code>Namespace</code>，分别为  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Namespace</th>
<th>system call flag</th>
<th>kernal version</th>
</tr>
</thead>
<tbody>
<tr>
<td>UTS Namespace</td>
<td>CLONE_NEWUTS</td>
<td>2.6.19</td>
</tr>
<tr>
<td>Mount Namespace</td>
<td>CLONE_NEWNS</td>
<td>2.4.19</td>
</tr>
<tr>
<td>IPC Namespace</td>
<td>CLONE_NEWIPC</td>
<td>2.6.19</td>
</tr>
<tr>
<td>PID Namespace</td>
<td>CLONE_NEWPID</td>
<td>2.6.24</td>
</tr>
<tr>
<td>Network Namespace</td>
<td>CLONE_NEWNET</td>
<td>2.6.29</td>
</tr>
<tr>
<td>User  Namespace</td>
<td>CLONE_NEWUSER</td>
<td>3.8</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="1-UTS-Namespace"><a href="#1-UTS-Namespace" class="headerlink" title="1.UTS Namespace"></a>1.UTS Namespace</h4><p><code>UTS</code>是<code>UNIX Time Sharing</code>的缩写。主要用来隔离<code>hostname</code>，在每个<code>UTS Namespace</code>下，每个<code>Namespace</code>都可以拥有自己的<code>Namespace</code>。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2020-06-11</span></span><br><span class="line"><span class="comment">// UTS Namespace主要用来隔离hostname(主机名用于标识主机)和domainname两个系统标识(已淘汰)</span></span><br><span class="line"><span class="comment">// pstree 命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://www.jianshu.com/p/049f13e55840</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//指定被fork出来的新进程内的初始命令</span></span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS,</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span>&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行这段代码会进入一个<code>sh</code>运行运行环境。<br><code>echo $$</code>是输出当前的<code>PID</code>，<code>readlink</code>查看对应的进程是否是在同一个<code>Namespace</code>。<br><code>hostname -b bird</code>修改<code>hostname</code>为<code>bird</code>,重新打开一个终端，输入<code>hostname</code>发现宿主机的<code>hostname</code>并没有被改变。</p>
<p><img src="http://img.hysyeah.top/2020/6/11/20200611213343-uts-namespace.png" alt></p>
<h4 id="2-IPC-Namespace"><a href="#2-IPC-Namespace" class="headerlink" title="2.IPC Namespace"></a>2.IPC Namespace</h4><p>用于隔离<code>System V IPC</code>和<code>POSIX message queues</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC,</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左边为宿主机，右边为新建的<code>sh</code>环境。新建的<code>message queue</code>在右边的隔离<code>Namespace</code>并不能看到。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ipcs -q   <span class="comment">//查看ipc message queue</span></span><br><span class="line">ipcmk -Q  <span class="comment">//新建一个message queue</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.hysyeah.top/2020/7/11/20200711101320.png" alt></p>
<h4 id="3-PID-Namespace"><a href="#3-PID-Namespace" class="headerlink" title="3.PID Namespace"></a>3.PID Namespace</h4><p><code>PID Namespace</code>用于隔离进程<code>ID</code><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">执行上述代码`</span>sudo <span class="keyword">go</span> /opt/<span class="keyword">go</span>/bin/<span class="keyword">go</span> run pidNamespace<span class="string">`。</span></span><br><span class="line"><span class="string">`</span>echo $$<span class="string">`发现当前的PID为1，而通过`</span>pstree<span class="string">`命令发现运行执行上述代码的PID为58329,而隔离命名空间的PID却为1，说明这个58329在新的命令空间PID映射为1。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">![](http://img.hysyeah.top/2020/6/11/20200611221910-pid-namespace.png)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 4.Mount Namespace</span></span><br><span class="line"><span class="string">`</span>Mount Namespace<span class="string">`用于隔离各个进程看到的挂载点视图，是`</span>Linux<span class="string">`实现的第一个`</span>Namespace<span class="string">`类型，在不同的`</span>Namespace<span class="string">`中看到的文件系统是不一样的。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC |syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout  = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run();err != <span class="literal">nil</span>&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行上述代码，然后执行<code>ls /proc</code>发现<code>/proc</code>中的内容还是宿主机上的。<br>通过命令<code>mount -t proc proc /proc</code>将<code>/proc mount</code>到新建的命名空间,此时再执行<code>ls /proc</code>发现少了很多文件。<br>在当前<code>Namespace</code>中，<code>sh</code>进程是PID为1的进程。这就说明当前的<code>Mount Namespace</code>中的mount和外部空间是隔离的，mount操作并没有影响到外部。Docker volume正是利用了这个特性。</p>
<p><img src="http://img.hysyeah.top/2020/6/11/20200613095837-mount-namespace.png" alt></p>
<h4 id="5-User-Namespace"><a href="#5-User-Namespace" class="headerlink" title="5.User Namespace"></a>5.User Namespace</h4><p><code>User Namespace</code>主要是用于隔离用户的用户组ID。一个进程的<code>User ID和</code>Group ID<code>在</code>User Namespace<code>内外是不同的。常用的场景是在宿主机以一个非root用户运行创建一个</code>User Namespace`,然后在命名空间里面却映射成root用户。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 加上下面这行代码会报没有权限的错误</span></span><br><span class="line">	<span class="comment">//cmd.SysProcAttr.Credential = &amp;syscall.Credential&#123;Uid: uint32(1000), Gid: uint32(1000)&#125;</span></span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在宿主机和<code>User Namespace</code>中它们的UID是不同的。</p>
<p><img src="http://img.hysyeah.top/2020/6/11/20200613104253-user-namespace.png" alt></p>
<h4 id="6-Network-Namespace"><a href="#6-Network-Namespace" class="headerlink" title="6.Network Namespace"></a>6.Network Namespace</h4><p><code>Network Namespace</code>用于隔离网络设备，IP地址，端口，路由表，防火墙规则等网络栈的<code>Namespace</code>。每个容器独占一个<code>Network Namespace</code>，每个容器都能随意使用自己的端口而不会产生冲突。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS |</span><br><span class="line">			syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER |syscall.CLONE_NEWNET,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 加上下面这行代码会报没有权限的错误</span></span><br><span class="line">	<span class="comment">//cmd.SysProcAttr.Credential = &amp;syscall.Credential&#123;Uid: uint32(1000), Gid: uint32(1000)&#125;</span></span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分别在宿主机和新建<code>sh</code>环境上分别查看网络设备，发现网络设备是不一样的，说明网络已经隔离。</p>
<p><img src="http://img.hysyeah.top/2020/6/11/20200613104815-network-namespace.png" alt></p>
<hr>
<h5 id="Network-Namespace中的进程如何与宿主机进行通信"><a href="#Network-Namespace中的进程如何与宿主机进行通信" class="headerlink" title="Network Namespace中的进程如何与宿主机进行通信"></a>Network Namespace中的进程如何与宿主机进行通信</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">➜  ~ ip netns            <span class="comment">// 查看Network Namespace列表</span></span><br><span class="line"></span><br><span class="line">➜  ~ sudo ip netns add netns1  <span class="comment">//创建一个名称为netns1的Network Namespace</span></span><br><span class="line">➜  ~ ip netns</span><br><span class="line">netns1</span><br></pre></td></tr></table></figure>
<p>查询名为<code>netns1</code>的网络命名空间下的网络设备，此时网卡状态是<code>DOWN</code><br><img src="http://img.hysyeah.top/2020/7/11/20200711114159.png" alt><br>进行<code>netns1</code>执行本志回环地址，发现网络不通，因为此时设备的状态是<code>DOWN</code>,通过命令<code>ip netns exec netns1 ip link set dev lo lup</code>启动设备后可以PING通。但此时只能PING通<code>Network Namespace</code>中的本地地址，还不能与宿主机进行通信。<br><img src="http://img.hysyeah.top/2020/7/11/20200711114219.png" alt></p>
<p>我们可以新建一对虚拟的网卡<code>veth pair</code>与宿主机进行通信。<code>veth pair</code>总是成对出现且相互连接，报文从一端进去就会从另一端出来。<br>创建一对虚拟网卡，并查看网络设备；此时<code>veth0</code>和<code>veth1</code>都在宿主机的网络命名空间内。<br><img src="http://img.hysyeah.top/2020/7/11/20200711114607-add-vethpair.png" alt></p>
<p>将<code>veth1</code>加入到网络命名空间<code>netns1</code>中<code>ip link set veth1 netns netns1</code>，此时再查看网络设备。发现<code>veth1</code>已到了<code>netns</code>下。<br><img src="http://img.hysyeah.top/2020/7/11/20200711144558.png" alt><br><img src="http://img.hysyeah.top/2020/7/11/20200711152741.png" alt></p>
<p>设置网卡状态并绑定IP。<br>从宿主机PING <code>netns1</code>下的<code>veth1</code>.<br><img src="http://img.hysyeah.top/2020/7/11/20200711145407.png" alt><br>从<code>netns1</code>下PING 宿主机中的<code>veth0</code><br><img src="http://img.hysyeah.top/2020/7/11/20200711145426.png" alt></p>
<p><code>netns1</code>中的路由表与防火墙规则也是隔离的<br><img src="http://img.hysyeah.top/2020/7/11/20200711150017.png" alt></p>
<hr>
<p>Ref:<br>1.<a href="https://book.douban.com/subject/27082348/" target="_blank" rel="noopener">https://book.douban.com/subject/27082348/</a><br>2.<a href="https://book.douban.com/subject/34855927/" target="_blank" rel="noopener">https://book.douban.com/subject/34855927/</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP之在途字节数</title>
    <url>/2019/08/05/TCP%E4%B9%8B%E5%9C%A8%E9%80%94%E5%AD%97%E8%8A%82%E6%95%B0/</url>
    <content><![CDATA[<p>在途字节数(bytes in flight):已经发送出去，但尚未被确认的字节数。<br>数据发送方抓到的包才能用来分析在途字节数。</p>
<p>下图是在客户端抓的包：</p>
<p><img src="http://img.hysyeah.top/2019/08/04/byte_in_flight.jpg" alt="image"></p>
<p>假如我们想知道第0.400000秒时的在途字节数，该如何计算?</p>
<p>在该时间点之前客户端发送的是10号包,即”Seq=265248,Len=180”字节,表示序号在265248+180之前 的字节已经发送出去了。而第0.400000之前的服务器的Ack为3284,表示序号在3284之前的字节已经收到,那么在途字节数就是265248+180-3284=262144字节。</p>
<p>公式可以表示为: 在途字节数=Seq + Len - Ack(Seq和Len是来自上一个数据发送方的包,而Ack则是来自上一个数据接收方的包)</p>
<p>再看一个例子：<br><img src="http://img.hysyeah.top/2019/08/04/my_examle_flight.png" alt="image"><br>如果我们要求0.460000秒的在途字节数,套用公式,0.460000秒的上一个数据发送方的包是9号包,上一个数据接收方的包为6包。则在途字节数为1+6-1=6</p>
<p>我们也可以使用Wireshark提供的功能来查看在途字节数,这样就不用我们手动来计算了。<br>1.使用Wireshark打开所抓的包。<br><img src="http://img.hysyeah.top/2019/08/04/flight1.png" alt="image"><br>2.点击菜单栏【编辑】—&gt; 【首选项】—&gt;【Appearance】—&gt; 【Columns】<br><img src="http://img.hysyeah.top/2019/08/04/flight2.png" alt="image"><br>3.点击+号,添加自定义列。<br><img src="http://img.hysyeah.top/2019/08/04/flight3.png" alt="image"></p>
<p>4.保存,移动新列【byte in flight】到合适位置。这列显示的数据就是对应时刻的在途字数,单位为字节。 如图可知结果和我们使用上面公式计算的结果是一致的。<br><img src="http://img.hysyeah.top/2019/08/04/flight4.png" alt="image"></p>
<hr>
<p>Ref：<br>1.《Wireshark网络分析的艺术》<br>2.<a href="https://www.youtube.com/watch?v=sIxv3YO2eYw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=sIxv3YO2eYw</a></p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>Terminating状态的pod是怎么被删除的</title>
    <url>/2023/06/27/Terminating%E7%8A%B6%E6%80%81%E7%9A%84pod%E6%98%AF%E6%80%8E%E4%B9%88%E8%A2%AB%E5%88%A0%E9%99%A4%E7%9A%84/</url>
    <content><![CDATA[<p>一个<code>Terminating</code>状态(数据并没有直接从etcd删除，而是设置了DeletionTimestamp)的<code>Pod</code>是怎么删除的呢?我们知道删除一个资源对象是要调用<code>APIServer</code>接口从<code>etcd</code>中将数据删除。<br>假如要调用接口那请求发起方又是哪个组件呢？</p>
<h5 id="创建一个Terminating状态的Pod"><a href="#创建一个Terminating状态的Pod" class="headerlink" title="创建一个Terminating状态的Pod"></a>创建一个Terminating状态的Pod</h5><p><code>k apply -f b2.yaml</code>,然后<code>k delete pod b2</code>你会得到一个处于<code>Terminating</code>状态的<code>Pod</code><br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># b2.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">b2</span></span><br><span class="line">  <span class="attr">finalizers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hysyeah/my-curl:v1</span></span><br></pre></td></tr></table></figure></p>
<h5 id="删除Terminating状态的pod"><a href="#删除Terminating状态的pod" class="headerlink" title="删除Terminating状态的pod"></a>删除Terminating状态的pod</h5><p><code>k edit pod b2</code>将<code>finalizers</code>移除，然后你会发现<code>pod b2</code>被立马删除了。<br>你可以通过命令<code>watch -n 1 k get pod</code>或 <code>watch -n 1 etcdctl get /registry/pods/default/b2 -w json</code>来监听对应的资源是否删除。</p>
<p>关于<code>etcdctl</code>的使用可以<a href="https://hysyeah.top/2023/06/26/etcdctl%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">查看</a></p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>为了验证猜测，首先我把<code>k8s</code>集群中的<code>kube-controller-manager</code>给移除了。然后对<code>Terminating</code>状态的移除<code>finalizers</code>操作，发现<code>pod</code>被删除，可见这跟<code>kube-controller-manager</code>。<br>然后猜测可能是<code>kubelet</code>发送的请求，首先在<code>kubelet</code>中并没有发现删除<code>pod</code>的代码，然后经过验证发现这与<code>kubelet</code>也没有关系。</p>
<p>最后观察<code>k edit pod b2 --v=9</code>看这条操作调用了什么接口。</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当我们删除一个带有finalizer的pod时并不会马上将etcd中的数据删除</span></span><br><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">Delete</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, deleteValidation rest.ValidateObjectFunc, options *metav1.DeleteOptions)</span> <span class="params">(runtime.Object, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 这里会设置DeletionTimestamp的值</span></span><br><span class="line">	graceful, pendingGraceful, err := rest.BeforeDelete(e.DeleteStrategy, ctx, obj, options)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// this means finalizers cannot be updated via DeleteOptions if a deletion is already pending</span></span><br><span class="line">	<span class="keyword">if</span> pendingGraceful &#123;</span><br><span class="line">		out, err := e.finalizeDelete(ctx, obj, <span class="literal">false</span>, options)</span><br><span class="line">		<span class="keyword">return</span> out, <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// check if obj has pending finalizers</span></span><br><span class="line">	accessor, err := meta.Accessor(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, apierrors.NewInternalError(err)</span><br><span class="line">	&#125;</span><br><span class="line">	pendingFinalizers := <span class="built_in">len</span>(accessor.GetFinalizers()) != <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> ignoreNotFound </span><br><span class="line">	<span class="comment">// 用于判断资源是否能被立即删除</span></span><br><span class="line">	<span class="keyword">var</span> deleteImmediately <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">var</span> lastExisting, out runtime.Object</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle combinations of graceful deletion and finalization by issuing</span></span><br><span class="line">	<span class="comment">// the correct updates.</span></span><br><span class="line">	shouldUpdateFinalizers, _ := deletionFinalizersForGarbageCollection(ctx, e, accessor, options)</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> remove the check, because we support no-op updates now.</span></span><br><span class="line">	<span class="keyword">if</span> graceful || pendingFinalizers || shouldUpdateFinalizers &#123;</span><br><span class="line">		<span class="comment">// / updateForGracefulDeletionAndFinalizers 函数用于为对象进行优雅删除和最终化的更新，</span></span><br><span class="line"><span class="comment">// 它设置删除时间戳和优雅删除的宽限期秒数（graceful deletion），</span></span><br><span class="line"><span class="comment">// 并更新最终器（finalizers）列表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// updateForGracefulDeletionAndFinalizers 通过设置DeletionTimestamp和grace perios seconds和更新finalizers列表</span></span><br><span class="line">		<span class="comment">// 以实现优雅删除和终结</span></span><br><span class="line">		err, ignoreNotFound, deleteImmediately, out, lastExisting = e.updateForGracefulDeletionAndFinalizers(ctx, name, key, options, preconditions, deleteValidation, obj)</span><br><span class="line">		<span class="comment">// Update the preconditions.ResourceVersion if set since we updated the object.</span></span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; deleteImmediately &amp;&amp; preconditions.ResourceVersion != <span class="literal">nil</span> &#123;</span><br><span class="line">			accessor, err = meta.Accessor(out)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> out, <span class="literal">false</span>, apierrors.NewInternalError(err)</span><br><span class="line">			&#125;</span><br><span class="line">			resourceVersion := accessor.GetResourceVersion()</span><br><span class="line">			preconditions.ResourceVersion = &amp;resourceVersion</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// !deleteImmediately covers all cases where err != nil. We keep both to be future-proof.</span></span><br><span class="line">	<span class="comment">// 如果不能立即删除，直接返回。并不会删除etcd中的数据，pod状态变为Terminating</span></span><br><span class="line">	<span class="keyword">if</span> !deleteImmediately || err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> out, <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Going further in this function is not useful when we are</span></span><br><span class="line">	<span class="comment">// performing a dry-run request. Worse, it will actually</span></span><br><span class="line">	<span class="comment">// override "out" with the version of the object in database</span></span><br><span class="line">	<span class="comment">// that doesn't have the finalizer and deletiontimestamp set</span></span><br><span class="line">	<span class="comment">// (because the update above was dry-run too). If we already</span></span><br><span class="line">	<span class="comment">// have that version available, let's just return it now,</span></span><br><span class="line">	<span class="comment">// otherwise, we can call dry-run delete that will get us the</span></span><br><span class="line">	<span class="comment">// latest version of the object.</span></span><br><span class="line">	<span class="keyword">if</span> dryrun.IsDryRun(options.DryRun) &amp;&amp; out != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> out, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// delete immediately, or no graceful deletion supported</span></span><br><span class="line">	klog.V(<span class="number">6</span>).InfoS(<span class="string">"Going to delete object from registry"</span>, <span class="string">"object"</span>, klog.KRef(genericapirequest.NamespaceValue(ctx), name))</span><br><span class="line">	out = e.NewFunc()</span><br><span class="line">	<span class="keyword">if</span> err := e.Storage.Delete(ctx, key, out, &amp;preconditions, storage.ValidateObjectFunc(deleteValidation), dryrun.IsDryRun(options.DryRun), <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Please refer to the place where we set ignoreNotFound for the reason</span></span><br><span class="line">		<span class="comment">// why we ignore the NotFound error .</span></span><br><span class="line">		<span class="keyword">if</span> storage.IsNotFound(err) &amp;&amp; ignoreNotFound &amp;&amp; lastExisting != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// The lastExisting object may not be the last state of the object</span></span><br><span class="line">			<span class="comment">// before its deletion, but it's the best approximation.</span></span><br><span class="line">			out, err := e.finalizeDelete(ctx, lastExisting, <span class="literal">true</span>, options)</span><br><span class="line">			<span class="keyword">return</span> out, <span class="literal">true</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, storeerr.InterpretDeleteError(err, qualifiedResource, name)</span><br><span class="line">	&#125;</span><br><span class="line">	out, err = e.finalizeDelete(ctx, out, <span class="literal">true</span>, options)</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">true</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在下面的函数中打个断点，执行edit操作之后通过监听etcd数据，发现并没有被删除</span></span><br><span class="line"><span class="comment">// 可以知道删除逻辑就在这里了</span></span><br><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">Update</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, objInfo rest.UpdatedObjectInfo, createValidation rest.ValidateObjectFunc, updateValidation rest.ValidateObjectUpdateFunc, forceAllowCreate <span class="keyword">bool</span>, options *metav1.UpdateOptions)</span> <span class="params">(runtime.Object, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	key, err := e.KeyFunc(ctx, name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		creatingObj runtime.Object</span><br><span class="line">		creating    = <span class="literal">false</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	qualifiedResource := e.qualifiedResourceFromContext(ctx)</span><br><span class="line">	storagePreconditions := &amp;storage.Preconditions&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> preconditions := objInfo.Preconditions(); preconditions != <span class="literal">nil</span> &#123;</span><br><span class="line">		storagePreconditions.UID = preconditions.UID</span><br><span class="line">		storagePreconditions.ResourceVersion = preconditions.ResourceVersion</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	out := e.NewFunc()</span><br><span class="line">	<span class="comment">// deleteObj is only used in case a deletion is carried out</span></span><br><span class="line">	<span class="keyword">var</span> deleteObj runtime.Object</span><br><span class="line">	err = e.Storage.GuaranteedUpdate(ctx, key, out, <span class="literal">true</span>, storagePreconditions, <span class="function"><span class="keyword">func</span><span class="params">(existing runtime.Object, res storage.ResponseMeta)</span> <span class="params">(runtime.Object, *<span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line">		existingResourceVersion, err := e.Storage.Versioner().ObjectResourceVersion(existing)</span><br><span class="line">		</span><br><span class="line">        ...<span class="comment">//省略部分代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		    <span class="comment">// delete the object</span></span><br><span class="line">            <span class="comment">//  最终会进入到这里</span></span><br><span class="line">		    <span class="keyword">if</span> err == errEmptiedFinalizers &#123;</span><br><span class="line">                <span class="comment">// deleteWithoutFinalizers 会将数据从etcd中删除</span></span><br><span class="line">		    	<span class="keyword">return</span> e.deleteWithoutFinalizers(ctx, name, key, deleteObj, storagePreconditions,   newDeleteOptionsFromUpdateOptions(options))</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">if</span> creating &#123;</span><br><span class="line">		    	err = storeerr.InterpretCreateError(err, qualifiedResource, name)</span><br><span class="line">		    	err = rest.CheckGeneratedNameError(ctx, e.CreateStrategy, err, creatingObj)</span><br><span class="line">		    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		    	err = storeerr.InterpretUpdateError(err, qualifiedResource, name)</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, err</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> creating &#123;</span><br><span class="line">		    <span class="keyword">if</span> e.AfterCreate != <span class="literal">nil</span> &#123;</span><br><span class="line">	    		e.AfterCreate(out, newCreateOptionsFromUpdateOptions(options))</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    	<span class="keyword">if</span> e.AfterUpdate != <span class="literal">nil</span> &#123;</span><br><span class="line">	    		e.AfterUpdate(out, options)</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> e.Decorator != <span class="literal">nil</span> &#123;</span><br><span class="line">	    	e.Decorator(out)</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> out, creating, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">deleteWithoutFinalizers</span><span class="params">(ctx context.Context, name, key <span class="keyword">string</span>, obj runtime.Object, preconditions *storage.Preconditions, options *metav1.DeleteOptions)</span> <span class="params">(runtime.Object, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	out := e.NewFunc()</span><br><span class="line">	klog.V(<span class="number">6</span>).InfoS(<span class="string">"Going to delete object from registry, triggered by update"</span>, <span class="string">"object"</span>, klog.KRef(genericapirequest.NamespaceValue(ctx), name))</span><br><span class="line">	<span class="comment">// Using the rest.ValidateAllObjectFunc because the request is an UPDATE request and has already passed the admission for the UPDATE verb.</span></span><br><span class="line">	<span class="keyword">if</span> err := e.Storage.Delete(ctx, key, out, preconditions, rest.ValidateAllObjectFunc, dryrun.IsDryRun(options.DryRun), <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Deletion is racy, i.e., there could be multiple update</span></span><br><span class="line">		<span class="comment">// requests to remove all finalizers from the object, so we</span></span><br><span class="line">		<span class="comment">// ignore the NotFound error.</span></span><br><span class="line">		<span class="keyword">if</span> storage.IsNotFound(err) &#123;</span><br><span class="line">			_, err := e.finalizeDelete(ctx, obj, <span class="literal">true</span>, options)</span><br><span class="line">			<span class="comment">// clients are expecting an updated object if a PUT succeeded,</span></span><br><span class="line">			<span class="comment">// but finalizeDelete returns a metav1.Status, so return</span></span><br><span class="line">			<span class="comment">// the object in the request instead.</span></span><br><span class="line">			<span class="keyword">return</span> obj, <span class="literal">false</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, storeerr.InterpretDeleteError(err, e.qualifiedResourceFromContext(ctx), name)</span><br><span class="line">	&#125;</span><br><span class="line">	_, err := e.finalizeDelete(ctx, out, <span class="literal">true</span>, options)</span><br><span class="line">	<span class="comment">// clients are expecting an updated object if a PUT succeeded, but</span></span><br><span class="line">	<span class="comment">// finalizeDelete returns a metav1.Status, so return the object in</span></span><br><span class="line">	<span class="comment">// the request instead.</span></span><br><span class="line">	<span class="keyword">return</span> obj, <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><code>Terminating</code>状态的<code>Pod</code>即不是由<code>kubelet</code>,也不是由<code>kube-controller-manager</code>发起请求删除的。而是当更新资源时(删除finalizers)调用<code>Update</code>接口会进入<code>deleteWithoutFinalizers</code>从而删除数据。</p>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go" target="_blank" rel="noopener">staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>apt-get选项</title>
    <url>/2017/09/25/apt-get%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="通过man-apt-get查看"><a href="#通过man-apt-get查看" class="headerlink" title="通过man apt-get查看"></a>通过man apt-get查看</h3><pre><code>--选项

-d #只下载安装包

-f #尝试修正系统依赖损坏处

-m #忽略未找到的包

-q #输出到日志 - 无进展指示

-y #假定对所有的询问选是，不提示
</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>apiserver-builder-alpha</title>
    <url>/2023/04/29/apiserver-builder-alpha/</url>
    <content><![CDATA[<p><code>k8s</code>有两种扩展<code>kubernetes API</code>的方式<code>Custom Resources</code>和<code>Kubernetes API Aggregation</code><br>这两者最大的区别在于<code>CRD</code>通过在<code>kubernetes API</code>内部添加资源来扩展<code>API</code>,而<code>server aggregation</code>则是通过外部服务。</p>
<p><code>Aggregation Layer</code>: 运行在<code>kube-apiserver</code>并为新的<code>API types</code>代理请求。<br><code>APIService Resources</code>: 新的<code>API</code>通过　<code>APIService</code>进行动态　注册。<br><code>Extension API Servers</code>：响应<code>aggregation layer</code>代理的请求。</p>
<h6 id="apiserver-boot安装"><a href="#apiserver-boot安装" class="headerlink" title="apiserver-boot安装"></a>apiserver-boot安装</h6><p><a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/docs/installing.md" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/docs/installing.md</a></p>
<h6 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h6><p>必须在<code>$GOPATH/src</code>目录下,这有点坑。<br><code>apiserver-boot init repo --domain &lt;your-domain&gt;</code></p>
<p><code>apiserver-boot init repo --domain extend-k8s.hysyeah.io</code></p>
<p><img src="https://img.hysyeah.top/2023/4/apiserver-boot-init.png" alt></p>
<h6 id="创建API-resource"><a href="#创建API-resource" class="headerlink" title="创建API resource"></a>创建API resource</h6><p><code>API resource</code>为<code>CRUD</code>操作提供了REST访问点<br><code>API resources</code>通过group(package),a version,a kind(type)来定义。</p>
<p><code>apiserver-boot create group version resource --group animal --version v1beta1 --kind Cat</code></p>
<h6 id="本地运行apiserver-controller-manager"><a href="#本地运行apiserver-controller-manager" class="headerlink" title="本地运行apiserver + controller-manager"></a>本地运行apiserver + controller-manager</h6><p><code>apiserver-boot run local</code>文档上说会自动执行<code>code generators</code>和编译，然而事实上并没有。运行到这一步失败。<br><code>apiserver-boot build executables</code>编译二进制文件。</p>
<p>看下有没有注册成功<br><code>kubectl api-versions</code></p>
<hr>
<p>结论：<br><code>apiserver-builder-alpha</code>处于试验阶段，根据文档并不能成功运行项目并且很久没有更新不推荐使用。</p>
<p>REF:<br>1.<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/</a><br>2.<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/</a><br>3.<a href="https://github.com/kubernetes/sample-apiserver" target="_blank" rel="noopener">https://github.com/kubernetes/sample-apiserver</a><br>4.<a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/apiserver-builder-alpha</a><br>5.<a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/docs/concepts/api_building_overview.md" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/docs/concepts/api_building_overview.md</a><br>6.<a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/docs/tools_user_guide.md" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/apiserver-builder-alpha/blob/master/docs/tools_user_guide.md</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>asymmetric cryptography</title>
    <url>/2023/08/06/asymmetric-cryptography/</url>
    <content><![CDATA[<p>公钥密码学，也称为非对称密码学，是使用相关密钥对的密码系统领域。每个密钥对由公钥和相应的私钥组成。密钥对是通过基于数学问题的单向函数的加密算法生成的。公钥密码学的安全性取决于保持私钥的机密性；公钥可以公开分发而不会危及安全性。</p>
<h5 id="密钥对的生成"><a href="#密钥对的生成" class="headerlink" title="密钥对的生成"></a>密钥对的生成</h5><p>非对称密钥对生成通常使用一个不可预测的(大且随机的)数字并通过非对称密钥算法来生成密钥对。</p>
<p><img src="https://img.hysyeah.top/2023/8/Public-key-crypto-1.svg" alt="image"></p>
<p>可以通过<code>openssl</code>生成相应的证书，具体命令可<a href="https://hysyeah.top/2023/07/30/k8s-webhook%E7%94%9F%E6%88%90ssl%E8%AF%81%E4%B9%A6/" target="_blank" rel="noopener">参考</a></p>
<h5 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h5><p>公钥加密是使用公钥对消息进行加密，使用公钥进行加密的信息只能通过对应的密钥才能进行解密。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"crypto/rand"</span></span><br><span class="line">	<span class="string">"crypto/rsa"</span></span><br><span class="line">	<span class="string">"crypto/x509"</span></span><br><span class="line">	<span class="string">"encoding/pem"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 读取公钥</span></span><br><span class="line">	pubPEMData, err := ioutil.ReadFile(<span class="string">"server.crt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	block, _ := pem.Decode(pubPEMData)</span><br><span class="line">	<span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"failed to parse certificate PEM"</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pub, err := x509.ParseCertificate(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"failed to parse certificate: "</span> + err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rsaPub, ok := pub.PublicKey.(*rsa.PublicKey)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">"not RSA public key"</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取私钥</span></span><br><span class="line">	privPEMData, err := ioutil.ReadFile(<span class="string">"server.key"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	block, _ = pem.Decode(privPEMData)</span><br><span class="line">	<span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"failed to parse key PEM"</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv, err := x509.ParsePKCS8PrivateKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"failed to parse key: "</span> + err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加密字符串</span></span><br><span class="line">	message := []<span class="keyword">byte</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">	encryptedMessage, err := rsa.EncryptPKCS1v15(rand.Reader, rsaPub, message)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解密字符串</span></span><br><span class="line">	decryptedMessage, err := rsa.DecryptPKCS1v15(rand.Reader, priv.(*rsa.PrivateKey), encryptedMessage)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(decryptedMessage))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.hysyeah.top/2023/8/public-key-encrypt.png" alt="image"></p>
<h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>数字签名是一种使用发送者的私钥对消息进行签名的方法，并可以由任何拥有发送者公钥访问权限的人进行验证。<br>该验证证明发送者有私钥的访问权限。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"crypto"</span></span><br><span class="line">	<span class="string">"crypto/rand"</span></span><br><span class="line">	<span class="string">"crypto/rsa"</span></span><br><span class="line">	<span class="string">"crypto/sha256"</span></span><br><span class="line">	<span class="string">"crypto/x509"</span></span><br><span class="line">	<span class="string">"encoding/pem"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	message := <span class="string">"Hello, world!"</span></span><br><span class="line">	<span class="comment">// 读取私钥</span></span><br><span class="line">	privPEMData, err := ioutil.ReadFile(<span class="string">"server.key"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	block, _ := pem.Decode(privPEMData)</span><br><span class="line">	<span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"failed to parse key PEM"</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv, err := x509.ParsePKCS8PrivateKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"failed to parse key: "</span> + err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对消息进行hash</span></span><br><span class="line">	hash := sha256.Sum256([]<span class="keyword">byte</span>(message))</span><br><span class="line">    <span class="comment">// 通过密钥对hash进行签名</span></span><br><span class="line">	signature, err := rsa.SignPKCS1v15(rand.Reader, priv.(*rsa.PrivateKey), crypto.SHA256, hash[:])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"failed to sign message: "</span> + err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取公钥</span></span><br><span class="line">	pubPEMData, err := ioutil.ReadFile(<span class="string">"server.crt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	block, _ = pem.Decode(pubPEMData)</span><br><span class="line">	<span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"failed to parse certificate PEM"</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pub, err := x509.ParseCertificate(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"failed to parse certificate: "</span> + err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rsaPub, ok := pub.PublicKey.(*rsa.PublicKey)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">"not RSA public key"</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 将签名和hash传给验证者，通过公钥进行验证</span></span><br><span class="line">	err = rsa.VerifyPKCS1v15(rsaPub, crypto.SHA256, hash[:], signature)</span><br><span class="line">    <span class="comment">// 如果未出错表明得到了验证</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"failed to verify signature: "</span> + err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"signature verified"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Alice</code>使用自己的密钥对<code>sha256</code>算法hash后的<code>HelloBob!</code>进行签名，然后<code>Bob</code>使用<code>Alice</code>的公钥对签名进行验证。</p>
<p><img src="https://img.hysyeah.top/2023/8/Private_key_signing.png" alt="image"></p>
<hr>
<p>REF:</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Public-key_cryptography</a></li>
<li><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5551094/" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5551094/</a></li>
</ol>
]]></content>
      <tags>
        <tag>cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装zsh,oh-my-zsh,autojump,terminator</title>
    <url>/2017/11/12/buntu%E5%AE%89%E8%A3%85zsh,oh-my-zsh,autojump,terminator/</url>
    <content><![CDATA[<p>1.安装zsh,oh-my-zsh</p>
<pre><code>sudo apt-get install zsh git wget
wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh
chsh -s /bin/zsh
</code></pre><p>注销重新进入后生效 2.安装autojump</p>
<pre><code>git clone git://github.com/joelthelion/autojump.git
cd autojump
sudo ./install.py
. /home/hys/.autojump/etc/profile.d/autojump.sh #在~/.zshrc文件最后添加
source ~/.zshrc

重启终端后生效
</code></pre><p>或者直接通过软件仓库安装</p>
<pre><code>sudo apt-get install autojump

. /usr/share/autojump/autojump.sh #在~/.zshrc文件最后添加

source ~/.zshrc

重启终端后生效
</code></pre><p>3.安装terminator</p>
<pre><code>sudo apt-get install terminator
</code></pre><p>安装oh-my-zsh可能会出现这样的错误 1.you may not change the shell for ‘username’</p>
<pre><code>sudo usermod -s /bin/zsh username
</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu上搭建git仓库</title>
    <url>/2018/03/21/buntu%E4%B8%8A%E6%90%AD%E5%BB%BAgit%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<pre><code>1.安装git ,git-core,openssh-server
2.创建用户git,
3.客户端生成公钥，ssh-keygen -t rsa -C &quot;xxx@126.com&quot;
5.将客户端公钥添加到服务端的~/.ssh/authorized_keys文件下
6.git –bare init /home/git/myRep.git  #在服务端建一个空的仓库
7.在客户端输入命令拉取代码
git clone git@gitServerIP:/home/git/myRep.git


8.在myRep.git下的hooks 新建post-receive,
添加git --work-tree=/home/wwwroot/hehe checkout -f
设置工作目录(代码存放的目录)，每次提交代码后将会触发post-receive下的脚本,
目标目录必须先创建,注意文件夹git用户写入权限
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu常见dpkg错误</title>
    <url>/2019/04/09/buntu%E5%B8%B8%E8%A7%81dpkg%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p><img src="http://img.hysyeah.top/wp-content/uploads/2019/04/lock-frotend.png" alt></p>
<hr>
<p>Ref：<br>１.<a href="https://itsfoss.com/could-not-get-lock-error/" target="_blank" rel="noopener">https://itsfoss.com/could-not-get-lock-error/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>c语言移位操作</title>
    <url>/2017/12/10/c%E8%AF%AD%E8%A8%80%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>对于一个位表示为[ [latex]x<em>{w-1},x</em>{w-2},…,x_1,x_0[/latex] ]的操作数x,C表达式x&lt;&lt; k会生成一个值，其位表示为[ [latex]x<em>{w-k-1},x</em>{w-k-2},…,x_1,x_0,0,…,0[/latex] ]<br>也就是说，x向左移动k位，丢弃最高的k位，并在右端补k个0。</p>
<hr>
<p>逻辑右移与算术右移<br>逻辑右移在左端补k个0，得到的结果是[ [latex]0,…,0,x<em>{w-1},x</em>{w-2},…,x<em>k[/latex] ]<br>算术右移是在左端补k个最高有效位的值，得到的结果是[ [latex]x</em>{w-1},…,x<em>{w-1},x</em>{w-1},x_{w-2}…,x_k[/latex] ]</p>
<hr>
<p>操作</p>
<p>值1</p>
<p>值2</p>
<p>参数x</p>
<p>0110 0011</p>
<p>1001 0101</p>
<p>x &lt;&lt; 4</p>
<p>0011 0000</p>
<p>0101 0000</p>
<p>x &gt;&gt; 4(逻辑右移)</p>
<p>0000 0110</p>
<p>0000 1001</p>
<p>x &gt;&gt; 4(算术右移)</p>
<p>0000 0110</p>
<p>1111 1001</p>
<hr>
<p>几乎所有的编译器都对有符号数(负数)使用算术右移，可<a href="https://github.com/hys20151008/cs/blob/master/chapter2/shift.c" target="_blank" rel="noopener">Ref</a></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>c语言typedef</title>
    <url>/2017/12/09/c%E8%AF%AD%E8%A8%80typedef/</url>
    <content><![CDATA[<pre><code>/*定义identifier为宏，指令为identifier后的一系列指令（以前认为只能是一句）*/
#define identifier replacement-list(optional)

#define PyObject_HEAD                   \
    Py_ssize_t ob_refcnt;               \
    struct _typeobject *ob_type;

typedef struct _object {
    PyObject_HEAD
} PyObject;
//相当于：
typedef struct _object {
    Py_ssize_t ob_refcnt;
    struct _typeobject *ob_type;
} PyObject;
</code></pre><hr>
<pre><code>#include &lt;stdio.h&gt;

#define T int b;int c;
typedef struct gg {
    T
} gg;
int main(int argc, char *argv[]){
    gg g = {1, 2};
    printf(&quot;%d\n&quot;, g.b);
    printf(&quot;%d\n&quot;, g.c);
    return 0;
}
输出：
1
2
</code></pre><hr>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>c调用python3 C API</title>
    <url>/2017/11/30/c%E8%B0%83%E7%94%A8python3%20C%20API/</url>
    <content><![CDATA[<pre><code>/*创建一个长度为3的列表，并对其进行赋值，并打印*/
/*hello.c*/
#include &lt;stdio.h&gt;
#include &quot;python3.5m/Python.h&quot;
int main(int argc, char *argv[]) {
    int i=0;
    long value;
    Py_Initialize();
    PyObject *t, *item;
    t = PyList_New(3);
    PyList_SetItem(t, 0, PyLong_FromLong(1L));
    PyList_SetItem(t, 1, PyLong_FromLong(2L));
    PyList_SetItem(t, 2, PyLong_FromLong(3L));
    for(i=0; i&lt;3;i++) {
        item = PyList_GetItem(t, i);
        value = PyLong_AsLong(item);
        printf(&quot;%ld\n&quot;, value);
    }
    Py_Finalize();
    return 0;
}


void Py_Initialize()//初始化python解析器，必须在调用Python/C API之前调用

PyObject* PyList_New(Py_ssize_t len)//创建一个长度为len的列表，Return:List Reference OR NULL(创建失败)

/*设置list索引为index的值为item,Return: 0 OR -1*/
int PyList_SetItem(PyObject *list, Py_ssize_t index, PyObject *item) 

/*获取list索引为index的值,Return:  Borrowed reference OR NULL and set an IndexError exception.*/
PyObject* PyList_GetItem(PyObject *list, Py_ssize_t index)

/*返回C类型的变量*/
long PyLong_AsLong(PyObject *obj)

/*释放资源*/
void Py_Finalize()
</code></pre><hr>
<pre><code>/*编译运行,ubuntu 16.04,gcc5.4.0,python3.5*/
/*-L 指定库的路径，-l 指定需连接的库名
如果文件为libpython3.5.so,刚库名为python3.5*/
gcc hello.c -L/usr/lib/python3.5/config-3.5m-x86_64-linux-gnu -lpython3.5
out:
1
2
3
</code></pre><hr>
<p>若/usr/include/python3.5m下无Python.h文件，请Ref<a href="http://img.hysyeah.top/2017/11/30/ubuntu%E6%9C%AA%E5%8F%91%E7%8E%B0python-h%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">Python.h</a></p>
<hr>
<p>Ref： 1.<a href="https://docs.python.org/3/c-api/" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>C语言</category>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>cni-plugins之ipam-host-local</title>
    <url>/2023/04/16/cni-plugins%E4%B9%8Bipam-host-local/</url>
    <content><![CDATA[<h5 id="host-local是一种IP地址管理-IPAM-插件。"><a href="#host-local是一种IP地址管理-IPAM-插件。" class="headerlink" title="host-local是一种IP地址管理(IPAM)插件。"></a><code>host-local</code>是一种IP地址管理(IPAM)插件。</h5><p>它从一组地址范围中分配IP地址,也可以从主机上的resolv.conf文件中获取DNS配置。它在主机文件系统上存储本地状态，因此可以确保单个主机上IP地址的唯一性。<br>该分配器可以分配多个地址范围，并支持多个(不相交的)子网集。分配策略是在每个范围集中松散的轮询。<br>在 CNI 调用链中，每个插件都会返回一个 JSON 格式的结果，其中会包含网络配置信息，如 IP 地址、子网掩码、网关等。当一个插件执行完毕，将其返回的结果传递给下一个插件，下一个插件将使用上一个插件返回的网络配置信息来配置网络。当最后一个插件执行完毕后，kubelet 会检查所有插件返回的结果，只有当所有插件都成功设置了 IP 地址，才会认为整个 CNI 调用链执行成功。如果其中一个插件失败，后续的插件将不会被执行，同时整个 CNI 调用链也会被标记为失败。</p>
<h5 id="配置示例-多个地址范围"><a href="#配置示例-多个地址范围" class="headerlink" title="配置示例(多个地址范围)"></a>配置示例(多个地址范围)</h5><p><code>ranges</code>表示一个列表，元素是<code>rangeSet</code>,下面的<code>ranges</code>包含两个<code>rangeSet</code>。<code>ranges</code>的长度表示返回多少<code>ip</code>。<code>rangeSet</code>表示<code>ip</code>地址的可选范围。<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"ipam"</span>: &#123;</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"host-local"</span>,</span><br><span class="line">		<span class="attr">"ranges"</span>: [</span><br><span class="line">			[</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">"subnet"</span>: <span class="string">"10.10.0.0/16"</span>,</span><br><span class="line">					<span class="attr">"rangeStart"</span>: <span class="string">"10.10.1.20"</span>,</span><br><span class="line">					<span class="attr">"rangeEnd"</span>: <span class="string">"10.10.3.50"</span>,</span><br><span class="line">					<span class="attr">"gateway"</span>: <span class="string">"10.10.0.254"</span></span><br><span class="line">				&#125;,</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">"subnet"</span>: <span class="string">"172.16.5.0/24"</span></span><br><span class="line">				&#125;</span><br><span class="line">			],</span><br><span class="line">			[</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">"subnet"</span>: <span class="string">"3ffe:ffff:0:01ff::/64"</span>,</span><br><span class="line">					<span class="attr">"rangeStart"</span>: <span class="string">"3ffe:ffff:0:01ff::0010"</span>,</span><br><span class="line">					<span class="attr">"rangeEnd"</span>: <span class="string">"3ffe:ffff:0:01ff::0020"</span></span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"routes"</span>: [</span><br><span class="line">			&#123; <span class="attr">"dst"</span>: <span class="string">"0.0.0.0/0"</span> &#125;,</span><br><span class="line">			&#123; <span class="attr">"dst"</span>: <span class="string">"192.168.0.0/16"</span>, <span class="attr">"gw"</span>: <span class="string">"10.10.5.1"</span> &#125;,</span><br><span class="line">			&#123; <span class="attr">"dst"</span>: <span class="string">"3ffe:ffff:0:01ff::1/64"</span> &#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"dataDir"</span>: <span class="string">"/run/my-orchestrator/container-ipam-state"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="ip地址分配"><a href="#ip地址分配" class="headerlink" title="ip地址分配"></a>ip地址分配</h5><p>对于每一个请求的自定义 IP，host-local 分配器会在它所管理的地址范围中进行请求。因此可以指定多个自定义 IP 和多个地址范围。如果一个IP在使用中或者不在范围内将会分配失败。</p>
<h5 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h5><p><code>host-local</code>将已分配的 IP 地址作为文件存储在 /var/lib/cni/networks/$NETWORK_NAME 目录下。</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><h6 id="host-local入口"><a href="#host-local入口" class="headerlink" title="host-local入口"></a>host-local入口</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PluginMain 是plugin的main函数，自动进行了错误处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	skel.PluginMain(cmdAdd, cmdCheck, cmdDel, version.All, bv.BuildString(<span class="string">"host-local"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vendor/github.com/containernetworking/cni/pkg/skel/skel.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PluginMain</span><span class="params">(cmdAdd, cmdCheck, cmdDel <span class="keyword">func</span>(_ *CmdArgs)</span> <span class="title">error</span>, <span class="title">versionInfo</span> <span class="title">version</span>.<span class="title">PluginInfo</span>, <span class="title">about</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e := PluginMainWithError(cmdAdd, cmdCheck, cmdDel, versionInfo, about); e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := e.Print(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Print(<span class="string">"Error writing error JSON to stdout: "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="三个方法cmdCheck-cmdAdd-cmdDel。"><a href="#三个方法cmdCheck-cmdAdd-cmdDel。" class="headerlink" title="三个方法cmdCheck,cmdAdd, cmdDel。"></a>三个方法cmdCheck,cmdAdd, cmdDel。</h5><h6 id="cmdCheck"><a href="#cmdCheck" class="headerlink" title="cmdCheck"></a>cmdCheck</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据提供的ContainerID和IfName，判断ip是否存在。如不存在则返回一个错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdCheck</span><span class="params">(args *skel.CmdArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过传过来的参数(也就是第二步中的json)构建一个IPAMConfig</span></span><br><span class="line">	ipamConf, _, err := allocator.LoadIPAMConfig(args.StdinData, args.Args)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Look to see if there is at least one IP address allocated to the container</span></span><br><span class="line">	<span class="comment">// in the data dir, irrespective of what that address actually is</span></span><br><span class="line">    <span class="comment">// 创建一个store对象，包含一个FileLock和目录.用于文件的操作</span></span><br><span class="line">	store, err := disk.New(ipamConf.Name, ipamConf.DataDir)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> store.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过容器ID和网络接口的名称(如eth0)</span></span><br><span class="line">	containerIPFound := store.FindByID(args.ContainerID, args.IfName)</span><br><span class="line">	<span class="keyword">if</span> !containerIPFound &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"host-local: Failed to find address added by container %v"</span>, args.ContainerID)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="cmdAdd"><a href="#cmdAdd" class="headerlink" title="cmdAdd"></a>cmdAdd</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从可选分配一个ip</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdAdd</span><span class="params">(args *skel.CmdArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过传过来的参数(也就是第二步中的json)构建一个IPAMConfig</span></span><br><span class="line">	ipamConf, confVersion, err := allocator.LoadIPAMConfig(args.StdinData, args.Args)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result := &amp;current.Result&#123;CNIVersion: current.ImplementedSpecVersion&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ipamConf.ResolvConf != <span class="string">""</span> &#123;</span><br><span class="line">		dns, err := parseResolvConf(ipamConf.ResolvConf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		result.DNS = *dns</span><br><span class="line">	&#125;</span><br><span class="line">　　 <span class="comment">// 创建一个store对象，包含一个FileLock和目录.用于文件的操作</span></span><br><span class="line">	store, err := disk.New(ipamConf.Name, ipamConf.DataDir)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> store.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Keep the allocators we used, so we can release all IPs if an error</span></span><br><span class="line">	<span class="comment">// occurs after we start allocating</span></span><br><span class="line">    <span class="comment">// 保存分配的ip,如果在分配过程中出现错误可以进行释放</span></span><br><span class="line">	allocs := []*allocator.IPAllocator&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Store all requested IPs in a map, so we can easily remove ones we use</span></span><br><span class="line">	<span class="comment">// and error if some remain</span></span><br><span class="line">	requestedIPs := <span class="keyword">map</span>[<span class="keyword">string</span>]net.IP&#123;&#125; <span class="comment">// net.IP cannot be a key</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ipamConf.IPArgs为请求的ip列表</span></span><br><span class="line">	<span class="keyword">for</span> _, ip := <span class="keyword">range</span> ipamConf.IPArgs &#123;</span><br><span class="line">		requestedIPs[ip.String()] = ip</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 遍历Ranges</span></span><br><span class="line">	<span class="keyword">for</span> idx, rangeset := <span class="keyword">range</span> ipamConf.Ranges &#123;</span><br><span class="line">        <span class="comment">// 返回IPAllocator指针</span></span><br><span class="line">        <span class="comment">// IPAllocator实现了Get方法获取一个IP</span></span><br><span class="line">        <span class="comment">// Release方法释放为容器分配的IP</span></span><br><span class="line">		allocator := allocator.NewIPAllocator(&amp;rangeset, store, idx)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check to see if there are any custom IPs requested in this range.</span></span><br><span class="line">		<span class="keyword">var</span> requestedIP net.IP</span><br><span class="line">		<span class="keyword">for</span> k, ip := <span class="keyword">range</span> requestedIPs &#123;</span><br><span class="line">			<span class="keyword">if</span> rangeset.Contains(ip) &#123;</span><br><span class="line">				requestedIP = ip</span><br><span class="line">                <span class="comment">// 在一个rangeset找到了ip,则删除requestedIPs中的记录</span></span><br><span class="line">				<span class="built_in">delete</span>(requestedIPs, k)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 根据容器ID,网络接口的名称和IP返回IPConfig</span></span><br><span class="line">		ipConf, err := allocator.Get(args.ContainerID, args.IfName, requestedIP)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Deallocate all already allocated IPs</span></span><br><span class="line">            <span class="comment">// 如果获取IP出错，释放对应的IP</span></span><br><span class="line">			<span class="keyword">for</span> _, alloc := <span class="keyword">range</span> allocs &#123;</span><br><span class="line">				_ = alloc.Release(args.ContainerID, args.IfName)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to allocate for range %d: %v"</span>, idx, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		allocs = <span class="built_in">append</span>(allocs, allocator)</span><br><span class="line"></span><br><span class="line">		result.IPs = <span class="built_in">append</span>(result.IPs, ipConf)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If an IP was requested that wasn't fulfilled, fail</span></span><br><span class="line">    <span class="comment">// 如果requestedIPs长度不为0,表示有些IP不符合要求</span></span><br><span class="line">    <span class="comment">// 进行回退操作，释放已分配IP</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(requestedIPs) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, alloc := <span class="keyword">range</span> allocs &#123;</span><br><span class="line">			_ = alloc.Release(args.ContainerID, args.IfName)</span><br><span class="line">		&#125;</span><br><span class="line">		errstr := <span class="string">"failed to allocate all requested IPs:"</span></span><br><span class="line">		<span class="keyword">for</span> _, ip := <span class="keyword">range</span> requestedIPs &#123;</span><br><span class="line">			errstr = errstr + <span class="string">" "</span> + ip.String()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(errstr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result.Routes = ipamConf.Routes</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> types.PrintResult(result, confVersion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="cmdDel"><a href="#cmdDel" class="headerlink" title="cmdDel"></a>cmdDel</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放ip</span></span><br><span class="line"><span class="comment">// 通过对cmdAdd的分析，这里应该比较清晰了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdDel</span><span class="params">(args *skel.CmdArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ipamConf, _, err := allocator.LoadIPAMConfig(args.StdinData, args.Args)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	store, err := disk.New(ipamConf.Name, ipamConf.DataDir)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> store.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Loop through all ranges, releasing all IPs, even if an error occurs</span></span><br><span class="line">	<span class="keyword">var</span> errors []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> idx, rangeset := <span class="keyword">range</span> ipamConf.Ranges &#123;</span><br><span class="line">		ipAllocator := allocator.NewIPAllocator(&amp;rangeset, store, idx)</span><br><span class="line"></span><br><span class="line">		err := ipAllocator.Release(args.ContainerID, args.IfName)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errors = <span class="built_in">append</span>(errors, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> errors != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(strings.Join(errors, <span class="string">";"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对应的一些结构体"><a href="#对应的一些结构体" class="headerlink" title="对应的一些结构体"></a>对应的一些结构体</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// plugins/ipam/host-local/backend/allocator/allocator.go</span></span><br><span class="line"><span class="keyword">type</span> IPAllocator <span class="keyword">struct</span> &#123;</span><br><span class="line">	rangeset *RangeSet</span><br><span class="line">	store    backend.Store</span><br><span class="line">	rangeID  <span class="keyword">string</span> <span class="comment">// Used for tracking last reserved ip</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins/ipam/host-local/backend/disk/backend.go</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">struct</span> &#123;</span><br><span class="line">	*FileLock</span><br><span class="line">	dataDir <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins/ipam/host-local/backend/allocator/config.go</span></span><br><span class="line"><span class="comment">// The top-level network config - IPAM plugins are passed the full configuration</span></span><br><span class="line"><span class="comment">// of the calling plugin, not just the IPAM section.</span></span><br><span class="line"><span class="keyword">type</span> Net <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name          <span class="keyword">string</span>      <span class="string">`json:"name"`</span></span><br><span class="line">	CNIVersion    <span class="keyword">string</span>      <span class="string">`json:"cniVersion"`</span></span><br><span class="line">	IPAM          *IPAMConfig <span class="string">`json:"ipam"`</span></span><br><span class="line">	RuntimeConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="comment">// The capability arg</span></span><br><span class="line">		IPRanges []RangeSet <span class="string">`json:"ipRanges,omitempty"`</span></span><br><span class="line">		IPs      []*ip.IP   <span class="string">`json:"ips,omitempty"`</span></span><br><span class="line">	&#125; <span class="string">`json:"runtimeConfig,omitempty"`</span></span><br><span class="line">	Args *<span class="keyword">struct</span> &#123;</span><br><span class="line">		A *IPAMArgs <span class="string">`json:"cni"`</span></span><br><span class="line">	&#125; <span class="string">`json:"args"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IPAMConfig represents the IP related network configuration.</span></span><br><span class="line"><span class="comment">// This nests Range because we initially only supported a single</span></span><br><span class="line"><span class="comment">// range directly, and wish to preserve backwards compatibility</span></span><br><span class="line"><span class="keyword">type</span> IPAMConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Range</span><br><span class="line">	Name       <span class="keyword">string</span></span><br><span class="line">	Type       <span class="keyword">string</span>         <span class="string">`json:"type"`</span></span><br><span class="line">	Routes     []*types.Route <span class="string">`json:"routes"`</span></span><br><span class="line">	DataDir    <span class="keyword">string</span>         <span class="string">`json:"dataDir"`</span></span><br><span class="line">	ResolvConf <span class="keyword">string</span>         <span class="string">`json:"resolvConf"`</span></span><br><span class="line">	Ranges     []RangeSet     <span class="string">`json:"ranges"`</span></span><br><span class="line">	IPArgs     []net.IP       <span class="string">`json:"-"`</span> <span class="comment">// Requested IPs from CNI_ARGS, args and capabilities</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPAMEnvArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	types.CommonArgs</span><br><span class="line">	IP ip.IP <span class="string">`json:"ip,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPAMArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	IPs []*ip.IP <span class="string">`json:"ips"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RangeSet []Range</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Range <span class="keyword">struct</span> &#123;</span><br><span class="line">	RangeStart net.IP      <span class="string">`json:"rangeStart,omitempty"`</span> <span class="comment">// The first ip, inclusive</span></span><br><span class="line">	RangeEnd   net.IP      <span class="string">`json:"rangeEnd,omitempty"`</span>   <span class="comment">// The last ip, inclusive</span></span><br><span class="line">	Subnet     types.IPNet <span class="string">`json:"subnet"`</span></span><br><span class="line">	Gateway    net.IP      <span class="string">`json:"gateway,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://www.cni.dev/plugins/current/ipam/host-local/" target="_blank" rel="noopener">https://www.cni.dev/plugins/current/ipam/host-local/</a><br>2.<a href="https://github.com/containernetworking/plugins/blob/release-1.1/plugins/ipam/host-local/main.go" target="_blank" rel="noopener">plugins/ipam/host-local/main.go</a><br>3.<a href="https://github.com/containernetworking/plugins/blob/release-1.1/plugins/ipam/host-local/backend/allocator/allocator.go" target="_blank" rel="noopener">plugins/ipam/host-local/backend/allocator/allocator.go</a><br>4.<a href="https://github.com/containernetworking/plugins/blob/release-1.1/plugins/ipam/host-local/backend/disk/backend.go" target="_blank" rel="noopener">plugins/ipam/host-local/backend/disk/backend.go</a><br>5.<a href="https://github.com/containernetworking/plugins/blob/release-1.1/plugins/ipam/host-local/backend/allocator/config.go" target="_blank" rel="noopener"> plugins/ipam/host-local/backend/allocator/config.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>cni</tag>
      </tags>
  </entry>
  <entry>
    <title>django models migrate</title>
    <url>/2017/12/17/django-models-migrate/</url>
    <content><![CDATA[<pre><code>修改models.py后，python manage.py makemigrations未发现改变  
原因是settings.py中INSTALLED_APPS未添加app名称
</code></pre>]]></content>
      <categories>
        <category>Django</category>
        <category>Python Web</category>
      </categories>
  </entry>
  <entry>
    <title>apue第一章:UNIX系统概览-笔记-函数</title>
    <url>/2017/12/03/apue%E7%AC%AC%E4%B8%80%E7%AB%A0%20UNIX%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A7%88-%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<pre><code>opendir, fdopendidr ---打开目录

#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;

DIR *opendir(const char *name);
DIR *fdopendir(int fd);
struct dirent *readdir(DIR *dirp);

struct __dirstream   
   {   
    void *__fd;    
    char *__data;    
    int __entry_data;    
    char *__ptr;    
    int __entry_ptr;    
    size_t __allocation;    
    size_t __size;    
    __libc_lock_define (, __lock)    
   };   

typedef struct __dirstream DIR;  

struct dirent {
     ino_t          d_ino;       /* inode number */
     off_t          d_off;       /* not an offset; see NOTES */
     unsigned short d_reclen;    /* length of this record */
     unsigned char  d_type;      /* type of file; not supported by all filesystem types */
     char           d_name[256]; /* filename */
};
</code></pre><hr>
<p><a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener">read</a> <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener">write</a></p>
<pre><code>#include &lt;unistd.h&gt;
/*从文件描述符fd中读取count字节到buf中*/
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
</code></pre><hr>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

/*返回进程ID*/
pid_t getpid(void);
/*返回进程的父亲进程ID*/
pid_t getppid(void);
</code></pre><hr>
<p><a href="http://man7.org/linux/man-pages/man2/fork.2.html" target="_blank" rel="noopener">fork</a> <a href="http://man7.org/linux/man-pages/man3/execlp.3.html" target="_blank" rel="noopener">execlp</a></p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t fork(void);
</code></pre><hr>
<pre><code>#include &lt;string.h&gt;
/*返回指向错误信息字符串的指针*/
char *strerror(int errnum);

#include &lt;stdio.h&gt;
/*根据errno的值返回错误信息*/
void perror(const char *msg);
</code></pre><hr>
<p><a href="http://man7.org/linux/man-pages/man3/getuid.3p.html" target="_blank" rel="noopener">getuid</a> <a href="http://man7.org/linux/man-pages/man3/getgid.3p.html" target="_blank" rel="noopener">getgid</a></p>
<pre><code>#include &lt;unistd.h&gt;
uid_t getuid(void);
gid_t getgid(void);
</code></pre><hr>
<p><a href="http://man7.org/linux/man-pages/man3/waitpid.3p.html" target="_blank" rel="noopener">waitpid</a></p>
<pre><code>#include &lt;sys/wait.h&gt;
pid_t waitpid(pid_t pid, int *stat_loc, int options);
</code></pre>]]></content>
      <categories>
        <category>apue</category>
      </categories>
      <tags>
        <tag>apue</tag>
      </tags>
  </entry>
  <entry>
    <title>django添加自定义过滤器</title>
    <url>/2017/09/08/django%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p>1.在app目录下与models.py同级目录下新建一个templatetags文件夹， <img src="http://img.hysyeah.top/wp-content/uploads/2017/09/笔.png" alt="image"> 2.utils.py</p>
<pre><code>from django import template

register = template.Library()

@register.filter
def val_type(val):
    return type(val).__name__
</code></pre><p>3.此函数是返回变量的类型名，在模版文件中通过</p>
<pre><code>{% load utils %}
</code></pre><p>导入</p>
<pre><code>{ { val|val_type }}
</code></pre><p>返回变量的类型</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title>docker centos镜像安装mysql</title>
    <url>/2019/07/13/docker-centos%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<p>1.拉取CentOs基础镜像<br><code>docker pull centos</code><br>2.启动容器，要加<code>--privileged</code>,不然使用systemctl会报错<br><code>docker run -idt --privileged centos init</code><br>3.进入容器<br><code>docker exec -it 83c2d9bc6aef /bin/bash</code></p>
<p>4.安装<code>MySQL</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"></span><br><span class="line">yum -y install mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"></span><br><span class="line">yum -y install mysql-community-server.x86_64</span><br></pre></td></tr></table></figure>
<p>启动MySQL</p>
<pre><code>systemctl start mysqld.service
systemctl enable mysqld.service

cat /var/log/mysqld.log | grep password
</code></pre><p>5.安装keepalived<br><code>yum -y install keepalived</code></p>
<p>6.登录<code>MySQL</code>,修改密码，授权远程访问。</p>
<p>7.导出容器快照到本地文件<br><code>docker export 83c2d9bc6aef -o keepalived.tar</code><br>8.将容器快照导入为镜像,下次就可以直接通过此镜像启动有MySQL和keepalived的容器<br><code>cat keepalived.tar | docker import - centos/keepalived</code></p>
]]></content>
  </entry>
  <entry>
    <title>docker-compose up -d启动失败不能创建网络</title>
    <url>/2018/02/01/docker-compose%20up%20-d%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<pre><code>当修改docker-compose.yml文件后台，使用命令docker-coompose up -d 启动服务
出现如下错误
Creating network &quot;master_sparknet&quot; with driver &quot;bridge&quot;
ERROR: cannot create network ddc16ca081602776df238912eeb042380f5cb15b88c108799b66d074742c704a (br-ddc16ca08160): conflicts with network fa6a55dd5ed30ce92342c4d3218558139293fd1800f5893c83b9f6a75aeaf277 (br-fa6a55dd5ed3): networks have overlapping IPv4

提示不能创建网络，两个网络发生冲突
</code></pre><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><pre><code>1.docker network ls  #展示docker容器网络
2.找到冲突的网络 docker network rm fa6a55dd5ed3
3.docker-compose up -d #重新启动服务
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>docker切换成阿里的源</title>
    <url>/2019/05/19/docker%E5%88%87%E6%8D%A2%E6%88%90%E9%98%BF%E9%87%8C%E7%9A%84%E6%BA%90/</url>
    <content><![CDATA[<p>环境：ubuntu18.04 <img src="http://img.hysyeah.top/wp-content/uploads/2019/05/docker_version.png" alt> 1.访问<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">镜像加速</a>,会生成一个镜像加速地址。 2.按如下命令操作即可</p>
<pre><code>sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
{
  &quot;registry-mirrors&quot;: [&quot;https://xxxxxxx.mirror.aliyuncs.com&quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器apt-get失败</title>
    <url>/2019/07/13/docker%E5%AE%B9%E5%99%A8apt-get%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p>1.进入容器后,执行<code>apt-get update</code>失败<br><img src="http://img.hysyeah.top/2019/07/13/docker-apt-get-update.png" alt="image"></p>
<p>原因是容器中的DNS不对。</p>
<p>2.查找宿主机的DNS<br><img src="http://img.hysyeah.top/2019/07/13/win10-dns.png" alt="image"></p>
<p>3.修改容器中的DNS</p>
<p><code>echo &quot;nameserver 192.168.2.1&quot; | tee /etc/resolv.conf</code></p>
<p>4.执行<code>apt-get update</code></p>
]]></content>
  </entry>
  <entry>
    <title>docker使容器和宿主机使用同一网段</title>
    <url>/2018/03/16/docker%E4%BD%BF%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E7%BD%91%E6%AE%B5/</url>
    <content><![CDATA[<h5 id="1-通过ifconfig查询物理网卡信息，名称为eno1"><a href="#1-通过ifconfig查询物理网卡信息，名称为eno1" class="headerlink" title="1.通过ifconfig查询物理网卡信息，名称为eno1"></a>1.通过ifconfig查询物理网卡信息，名称为eno1</h5><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/03/maclvan_ifconfig.png" alt="image"></p>
<h5 id="2-route-n-查询网关为10-68-2-1"><a href="#2-route-n-查询网关为10-68-2-1" class="headerlink" title="2.route -n,查询网关为10.68.2.1"></a>2.route -n,查询网关为10.68.2.1</h5><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/03/maclvan_route.png" alt="image"></p>
<h5 id="3-使用docker命令创建网络"><a href="#3-使用docker命令创建网络" class="headerlink" title="3.使用docker命令创建网络"></a>3.使用docker命令创建网络</h5><pre><code>docker network create -d macvlan \
--subnet 10.68.2.0/24 --gateway 10.68.2.1 \
-o parent=eno1 -o macvlan_mode=bridge macnet
# parent指定物理网卡名称,
# 创建的网络名称为macnet
</code></pre><h5 id="4-创建docker-compose-yml文件"><a href="#4-创建docker-compose-yml文件" class="headerlink" title="4.创建docker-compose.yml文件"></a>4.创建docker-compose.yml文件</h5><pre><code>version: &quot;2&quot;
services:
  ubuntu-master:
    image: ubuntu:16.04
    networks:
       default:
          ipv4_address: 10.68.2.133
    container_name: ubuntu-master
    privileged: true
    tty: true
networks:
  default:
    external:
      name: macnet
</code></pre><h5 id="5-启动容器，查看IP"><a href="#5-启动容器，查看IP" class="headerlink" title="5.启动容器，查看IP"></a>5.启动容器，查看IP</h5><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/03/maclvan_ip.png" alt="image"></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>docker容器使用keepalived模拟mysql主备切换</title>
    <url>/2019/07/14/docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8keepalived%E6%A8%A1%E6%8B%9Fmysql%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<p>1.使用制作的<a href="http://hysyeah.top/2019/07/13/docker-centos%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85mysql/" target="_blank" rel="noopener">centos/keepalived镜像</a>,运行两次，生成两个容器<br><code>docker run -idt --privileged centos/keepalived  init</code><br>容器ip分别为 172.17.0.3, 172.17.0.4(通过命令<code>docker inspect [container_id] | grep IP</code>查看)</p>
<p>2.分别进入容器<br>IP: 172.17.0.3<br>vim /etc/keepalived/keepalived.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">    router_id mysql_master</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_mysql &#123;</span><br><span class="line">    script &quot;netstat -lntp | grep 3306&quot;</span><br><span class="line">    interval 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance mysql &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0             #在容器中执行ifconfig查看</span><br><span class="line">    virtual_router_id 210</span><br><span class="line">    priority 150</span><br><span class="line">    nopreempt</span><br><span class="line">    advert_int 1</span><br><span class="line"></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        172.17.0.5/16</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_mysql</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>IP: 172.17.0.4<br>vim /etc/keepalived/keepalived.conf<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">    router_id mysql_slave</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_mysql &#123;</span><br><span class="line">    script &quot;netstat -lntp | grep 3306&quot;</span><br><span class="line">    interval 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance mysql &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 210</span><br><span class="line">    priority 150</span><br><span class="line">    nopreempt</span><br><span class="line">    advert_int 1</span><br><span class="line"></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        172.17.0.5/16</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_mysql</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.启动keepalived<br><code>systemctl start keepalived</code><br><code>systemctl enable keepalived</code><br><img src="http://img.hysyeah.top/2019/07/13/keepalived-vip.png" alt="image"></p>
<p>验证：</p>
<ul>
<li>停止172.17.0.4中的<code>MySQL</code>服务(systemctl stop mysqld),发现VIP飘到了172.17.0.3上<br><img src="http://img.hysyeah.top/2019/07/13/keepalived-vip2.png" alt="image"></li>
</ul>
<hr>
<p>所遇问题：<br>1.<code>systemctl status keepalived</code>查看keepalived状态,发现提示Can’t initialize ipvs: Protocol not available<br>解决方法：加载ip_vs模块(在宿主机执行如下命令)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modprobe ip_vs</span><br><span class="line">modprobe ip_vs_wrr</span><br></pre></td></tr></table></figure></p>
<p>查看内核是否加载ip_vs<br><code>lsmod | grep ip_vs</code></p>
]]></content>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2017/09/25/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>-docker安装[通过脚本安装]</p>
<pre><code>curl -sSL https://get.daocloud.io/docker | sh
</code></pre><p>-常用命令</p>
<pre><code>sudo apt-get update

sudo systemctl enable docker

sudo systemctl start docker #启动docker

sudo docker push | pull  # 推|拉镜像

sudo docker images #列出本地镜像

sudo docker run -t -i ubuntu:16.04 /bin/bash #-t:让Docker分配一个伪终端，-i:让容器的的标准输入保持打开，-d:后台运行，启动后会返回一个唯一的id

sudo docker tag   #修改镜像的标签

sudo docker save  #保存镜像到本地文件

sudo docker load #从导出的本地文件再加载本地镜像库[sudo docker load --input ubuntu.rar OR sudo docker load &lt; ubuntu.rar]

sudo docker rmi #移除镜像

sudo docker rm  #移除容器

在删除镜像之前要先用docker rm删掉依赖于这个镜像的所有容器。


docker run所涉及的操作

- 检查本地是否存在指定的镜像，不存在就从公有仓库下载
- 利用镜像创建并启动一个容器
- 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层
- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
- 从地址池配置一个ip地址给容器
- 执行用户指定的应用程序
- 执行完毕后容器被终止

sudo  docker ps #查看容器信息，-a:所有容器

docker logs [container ID or NAMES]获取容器的输出信息

docker stop|start|restart [container ID or NAMES] 终止容器|启动容器|重启容器
sudo docker export #导出本地某个容器，导出容器快照到本地文件 
sudo docker import #从容器快照文件中再导入为镜像，如cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0

用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以
使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容
器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状
态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入
时可以重新指定标签等元数据信息。

sudo docker rm 用来删除一个处于终止状态的容器
用 docker ps -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量
太多要一个个删除可能会很麻烦，用 docker rm $(docker ps -a -q) 可以全
部清理掉。
*注意：这个命令其实会试图删除所有的包括还在运行中的容器，不过就像上面提过
的 docker rm 默认并不会删除运行中的容器。

#-m：指定提交说明信息，-a:指定更新的用户信息， 用于创建镜像的容器的ID,最后指定目标镜像的仓库名和tag信息
sudo docker commit -m &quot;add python3&quot; -a &quot;hys&quot; 425fffab3201 hys/test:v1.0
</code></pre><p>-进入通过参数-d启动的容器 docker attach | nsenter</p>
<pre><code>- sudo docker attach [container ID or NAMES]
但是使用 attach 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的
时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作



- nsenter安装
. sudo wget https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz
. tar -xzvf util-linux-2.24.tar.gz
. cd util-linux-2.24
. ./configure --without-ncurses
. make
. sudo cp nsenter /usr/local/bin

sudo docker inspect --format &quot;{ {.State.Pid }}&quot; [container ID]
sudo nsenter --target 40621 --mount --uts --ipc --net --pid
执行出错：nsenter: failed to execute /bin/zsh: No such file or directory

sudo env SHELL=&quot;/bin/bash&quot; nsenter --target 40907 --mount --uts --ipc --net --pid
ok
</code></pre><p>-另一种方法，<a href="https://raw.githubusercontent.com/yeasy/docker_practice/master/_local/.bashrc_docker" target="_blank" rel="noopener">.bashrc_docker</a>将里面的内容放到~/.bashrc文件中，</p>
<pre><code>.bashrc_docker

# Some useful commands to use docker.
# Author: yeasy@github
# Created:2014-09-25

alias docker-pid=&quot;sudo docker inspect --format &#39;{ {.State.Pid}}&#39;&quot;
alias docker-ip=&quot;sudo docker inspect --format &#39;{ { .NetworkSettings.IPAddress }}&#39;&quot;

#the implementation refs from https://github.com/jpetazzo/nsenter/blob/master/docker-enter
function docker-enter() {
#if [ -e $(dirname &quot;$0&quot;)/nsenter ]; then
#Change for centos bash running
if [ -e $(dirname &#39;$0&#39;)/nsenter ]; then
# with boot2docker, nsenter is not in the PATH but it is in the same folder
NSENTER=$(dirname &quot;$0&quot;)/nsenter
else
# if nsenter has already been installed with path notified, here will be clarified
NSENTER=$(which nsenter)
#NSENTER=nsenter
fi
[ -z &quot;$NSENTER&quot; ]  echo &quot;WARN Cannot find nsenter&quot;  return

if [ -z &quot;$1&quot; ]; then
echo &quot;Usage: `basename &quot;$0&quot;` CONTAINER [COMMAND [ARG]...]&quot;
echo &quot;&quot;
echo &quot;Enters the Docker CONTAINER and executes the specified COMMAND.&quot;
echo &quot;If COMMAND is not specified, runs an interactive shell in CONTAINER.&quot;
else
PID=$(sudo docker inspect --format &quot;{ {.State.Pid}}&quot; &quot;$1&quot;)
if [ -z &quot;$PID&quot; ]; then
echo &quot;WARN Cannot find the given container&quot;
return
fi
shift

OPTS=&quot;--target $PID --mount --uts --ipc --net --pid&quot;

if [ -z &quot;$1&quot; ]; then
# No command given.
# Use su to clear all host environment variables except for TERM,
# initialize the environment variables HOME, SHELL, USER, LOGNAME, PATH,
# and start a login shell.
#sudo $NSENTER &quot;$OPTS&quot; su - root
sudo $NSENTER --target $PID --mount --uts --ipc --net --pid su - root
else
# Use env to clear all host environment variables.
sudo $NSENTER --target $PID --mount --uts --ipc --net --pid env -i $@
fi
fi
}



通过docker-pid可以获取某个容器的PID；而docker_enter可以进入容器 或直接在容器内执行命令

echo $(docker-pid &lt;container&gt;)

docker-enter &lt;container&gt;
</code></pre><p>-Dockerfile</p>
<pre><code>FROM 指令告诉Docker使用哪个镜像作为基础 # 如果镜像不存在本地则从远程仓库进行拉取，存在本地则不会拉取
MAINTAINER 维护者的信息
RUN apt-get install
ADD 复制本地文件到镜像
EXPOSE 用来向外部开放端口

docker build -t=&quot;hys/test:v2.0&quot; . #-t 添加tag,指定新的镜像用户信息。&#39;.&#39;表示Dockerfile所在的路径(当前目录),当然也可以指定具体路径。

sudo apt-get install -y xxx #直接安装
</code></pre><p>如：构建django开发环境的镜像</p>
<pre><code>FROM ubuntu:16.04

MAINTAINER hys &lt;img.hysyeah.top&gt;

RUN apt-get upadate

RUN apt-get install -y python3-pip

RUN pip3 install django
</code></pre><hr>
<p>Ref：Dockers-从入门到实践</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>docker常用命令2</title>
    <url>/2018/02/07/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A42/</url>
    <content><![CDATA[<pre><code># 容器和主机之间的文件复制
1.从主机复制到容器 sudo docker cp host_path containerid:container_path
2.从容器复制到主机 sudo docker cp containerid:container_path host_path



# 免sudo
sudo groupadd docker 
sudo usermod -aG docker $USER
sudo service docker restart
sudo chmod a+rw /var/run/docker.sock
newgrp docker


➜  ~ docker images
REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
hyspark                   latest              652a7a9d9fbe        12 days ago         1.66GB
d.img.hysyeah.top:5000/busybox   latest              f9b6f7f7b9d3        3 weeks ago         1.14MB
mysql                     latest              f008d8ff927d        3 weeks ago         409MB

docker save -o mysql.tar mysql  #将镜像导出为mysql.tar文件
docker load -i mysql.tar        #导入镜像
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>docker配置代理</title>
    <url>/2021/06/09/docker%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>在k8s编译中需要到很多<code>k8s.gcr.io</code>中的镜像,查了很多资料都没有很好的解决办法。原因是国内同步的镜像都是很久之前的，没有我需要的镜像，所以只能通过代理来解决</p>
<p>1.首先你需要一个科学上网的工具，这一步不多说，自行查找资料。<br>2.尝试执行如下命令，发现并没有用，原因在于docker并没有使用系统的代理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8123</span></span><br><span class="line">export https_proxy=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8123</span></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>3.为docker设置镜像拉取代理<br><code>vim /lib/systemd/system/docker.service</code>系统版本不一样此路径也可能不同<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec=<span class="number">0</span></span><br><span class="line">RestartSec=<span class="number">2</span></span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加如下两行</span></span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://127.0.0.1:8123"</span></span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=http://127.0.0.1:8123"</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>4.然后你就能顺利的拉取<code>k8s.gcr.io</code>上的镜像了。</p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>elf可重定向目标文件格式</title>
    <url>/2018/01/01/elf%E5%8F%AF%E9%87%8D%E5%AE%9A%E5%90%91%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>ELF头</p>
<p>.text</p>
<p>.rodata</p>
<p>.data</p>
<p>.bss</p>
<p>.symtab</p>
<p>.rel.text</p>
<p>.rel.data</p>
<p>.debug</p>
<p>.line</p>
<p>.strtab</p>
<p>节头部表</p>
<p><strong>典型的ELF可重定位目标文件</strong></p>
<pre><code>.text:已编译程序的机器代码
.rodata:只读数据，一般是程序里面的只读变量（如const修饰的变量）和字符串常量。
.data:已初始化的全局和静态C变量。局部C变量运行被保存在栈中，既不出现在.data节中，也不出现在.bss中

.COMMON 未初始化的全局变量
.bss:未初始化的静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。

.symtab:一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。
.rel.text:一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。
.rel.data:被模块引用或定义的所有全局变量的重定位作息。一般来说，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。
.debug:一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有以-g选项调用编译器驱动程序时，才会得到这张表。
.line:原始C源程序中的行号和.text节中的机器指令这间的映射。只有以-g选项调用编译器驱动程序时，才会得到这张表。
.strtab:一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串就是以null结尾的字符串的序列。
.comment:存放的是编译器版本信息。
.dynamic:动态链接作息
.hash:符号哈希表
.note:额外的编译器信息

.plt
.got:动态链接的跳转表和全局入口表

.init
.fini:程序初始化与终结代码段
</code></pre>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>docker容器启动时设置容器内服务自启动</title>
    <url>/2018/02/24/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E8%AE%BE%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%86%85%E6%9C%8D%E5%8A%A1%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>1.编写shell脚本，auto_start.sh</p>
<pre><code>#！/bin/sh
/etc/init.d/ssh start  #启动服务
/bin/bash              #一定要加上这句，否则容器会自动退出
</code></pre><p>2.修改docker-compose.yml</p>
<pre><code>volumes:
  - ./auto_start.sh:/root/auto_start.sh
command:[&quot;/root/auto_start.sh&quot;]
</code></pre><p>3.启动容器，便会自动启动auto_start.sh中的服务。</p>
<hr>
<p>可能出现的问题： 1.exec: \“/root/auto_start.sh\“: permission denied”: unknown’，提示没有权限 解决方法: 修改宿主机上的auto_start.sh文件权限，chmod a+x auto_start.sh,重新启动服务。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>/etc/shadow及相关c函数</title>
    <url>/2017/11/13/etc%20shadow%E5%8F%8A%E7%9B%B8%E5%85%B3c%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>/etc/shadow包含系统用户的密码信息，普通用户不能查看此文件 每行分为9个片段，通过冒号’:’分隔 hys:$6$q1Jaurz4$8hPn.i0F6k7xPeLNcKDGdKZODMx7uTnHjAXjgvND2dRrz7jk16O.DbI15qe.G9SqSbFO.O0PMsW.yHv1X2/z60:17421:0:99999:7::: 用户名： 加密后的密码(单向散列)： 最后修改密码的时间(为距1970.1.1的天数)： 密码最小存活时间(指用户还有多少天可以修改密码，空或0表示没有密码最小存活时间): 最大密码存活时间(超过这个时间，用户需修改密码，如果这个值小于密码最小存活时间，则用户不能修改密码)： 密码过期前多少天提醒： 密码超过最大存活时间后还能进行登录的时间： 用户过期时间： 保留域</p>
<pre><code>struct spwd {
    char *sp_namp; /* Login name */
    char *sp_pwdp; /* Encrypted password */
    long sp_lstchg; /* Date of last change(measured in days since 1970-01-01 00:00:00 +0000 (UTC)) */
    long sp_min; /* Min # of days between changes */
    long sp_max; /* Max # of days between changes */
    long sp_warn; /* # of days before password expires to warn user to change it */
    long sp_inact; /* # of days after password expires
    until account is disabled */
    long sp_expire; /* Date when account expires(measured in days since 1970-01-01 00:00:00 +0000 (UTC)) */
    unsigned long sp_flag; /* Reserved */
};


struct spwd *getspnam(const char *name);//通过用户名获取指向struct spwd结构体的指针
struct spwd *getspent(void);//获取/etc/shadow文件中的信息，返回struct spwd结构体指针
void setspent(void);//初始化输入流
void endspent(void);//释放资源
</code></pre><p>例：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;shadow.h&gt;
#include &lt;unistd.h&gt;
int main(){
struct spwd *p,*ptr;
p = getspnam(usbmux);
if(p == NULL){
    printf(&quot;error&quot;);
}
printf(&quot;%s\n&quot;, p-&gt;sp_namp);
printf(&quot;%s\n&quot;, p-&gt;sp_pwdp);
printf(&quot;%ld\n&quot;, p-&gt;sp_lstchg);
printf(&quot;%ld\n&quot;, p-&gt;sp_min);
printf(&quot;%ld\n&quot;, p-&gt;sp_max);
printf(&quot;%ld\n&quot;, p-&gt;sp_warn);
printf(&quot;%ld\n&quot;, p-&gt;sp_inact);
printf(&quot;%ld\n&quot;, p-&gt;sp_expire);
printf(&quot;%lu\n&quot;, p-&gt;sp_flag);
setspent();
while((ptr = getspent())!=NULL){
    printf(&quot;%s\n&quot;, ptr-&gt;sp_namp);
}
endspent();
return 0;
}
</code></pre><hr>
<p>Ref：<br>1.<a href="http://manpages.ubuntu.com/manpages/precise/man5/shadow.5.html" target="_blank" rel="noopener">http://manpages.ubuntu.com/manpages/precise/man5/shadow.5.html</a><br>2.<a href="https://linux.die.net/man/3/getspnam" target="_blank" rel="noopener">https://linux.die.net/man/3/getspnam</a></p>
]]></content>
      <categories>
        <category>C语言</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>etcdctl的使用</title>
    <url>/2023/06/26/etcdctl%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h5 id="etcdctl安装"><a href="#etcdctl安装" class="headerlink" title="etcdctl安装"></a>etcdctl安装</h5><ol>
<li>访问etcd的GitHub仓库，链接为：<a href="https://github.com/etcd-io/etcd/releases" target="_blank" rel="noopener">https://github.com/etcd-io/etcd/releases</a></li>
<li>在该页面中，找到与您的操作系统和体系结构相匹配的最新版本的etcd二进制文件。例如，对于Linux系统，您可以下载以<code>etcd-vX.Y.Z-linux-amd64.tar.gz</code>为后缀的文件</li>
<li>下载所选版本的二进制文件，并将其解压缩到您的系统中</li>
<li>进入解压缩后的文件夹，并找到名为<code>etcdctl</code>的二进制文件</li>
<li>将<code>etcdctl</code>二进制文件移动到您的系统的可执行路径中，例如<code>/usr/local/bin/</code></li>
<li>确保<code>etcdctl</code>的可执行权限已设置，您可以使用<code>chmod +x etcdctl</code>命令进行设置</li>
</ol>
<h5 id="配置etcdctl环境变量"><a href="#配置etcdctl环境变量" class="headerlink" title="配置etcdctl环境变量"></a>配置etcdctl环境变量</h5><p>将下面的信念添加到<code>~/.bashrc</code>,然后<code>source ~/.zshrc</code><br>将所有的文件改为当前用户有访问权限，如果访问要加<code>sudo</code>可能会有问题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ETCDCTL_API=3</span><br><span class="line">export ETCDCTL_ENDPOINTS=https://[etcd-endpoint]:2379</span><br><span class="line">export ETCDCTL_CACERT=/etc/kubernetes/pki/etcd/ca.crt</span><br><span class="line">export ETCDCTL_CERT=/etc/kubernetes/pki/etcd/server.crt</span><br><span class="line">export ETCDCTL_KEY=/etc/kubernetes/pki/etcd/server.key</span><br></pre></td></tr></table></figure></p>
<h5 id="常用的一些命令"><a href="#常用的一些命令" class="headerlink" title="常用的一些命令"></a>常用的一些命令</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 检测endpoint健康状态</span><br><span class="line">etcdctl endpoint health</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 返回所有以/registry开头的key</span><br><span class="line">etcdctl get /registry --prefix --keys-only=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 通过key获取对应的值并以json格式展示</span><br><span class="line">etcdctl get /registry/pods/default/b2 -w json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 监听指定键的变化</span><br><span class="line">etcdctl watch &lt;key&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>extern &quot;C&quot;</title>
    <url>/2017/11/11/extern-c/</url>
    <content><![CDATA[<p>C++为了与C兼容，在符号的管理上，C++提供了一 个用来声明或定义C符号的”extern “C””关键字。C++编译器会将在extern “C”的大括号内部的代码当作C语言处理，C++的名称修饰机制将不起作用。 <img src="http://img.hysyeah.top/wp-content/uploads/2017/11/1.png" alt> 很多时候我们会碰到有些头文件声明了一些C语言的 函数和全局变量，但是这个头文件可能会被C语言代码或c++代码包含。比 如很常见的，我们的C语言库函数中的string.h中声明了memset这个函数，它的原型如下：</p>
<pre><code>void *memset (void *, int ,size);
</code></pre><p>如果不加任何处理，当我们的C语言程序包含string.h的时候，并且用到了memset这个函数 ，编译器会将memset符号引用正确处理；但是在C++语言中，编译器会认为这个memset函数是一个C++函数，将memset的符号修饰成_Z6memsetPvii,这样链接器就无法与C语言库中的memset符号进行链接。所以对于C++来说，必须使用extern “C”来声明memset这个函数。但是C语言又不支持extern “C”语法，如果为了兼容C语言和C++语言定义两套头文件，未免于麻烦。幸好我们有一种很好的方法可以解决上述问题，就是使用C++的宏”__cplusplus”,C++编译会在编译c++的程序默认定义这个宏，我们可以使用条件宏来判断当前编译单元是不是C++代码。具体代码如下：</p>
<pre><code>#ifdef __cplusplus

extern &quot;C&quot; {

#endif

void *memset (void *, int,  size_t);

#ifdef __cplusplus

}

#endif
</code></pre><p>如果当前编译单元是C++代码，那么memset会在extern “C”里面被声明；如果是C代码，就直接声明。 Ref： 1.程序员的自我修养 2.<a href="https://www.cnblogs.com/stonecrazyking/archive/2006/09/23/512552.html" target="_blank" rel="noopener">https://www.cnblogs.com/stonecrazyking/archive/2006/09/23/512552.html</a></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>flatten</title>
    <url>/2017/09/05/flatten/</url>
    <content><![CDATA[<pre><code>In [1]: from compiler.ast import flatten

In [2]: flatten([1, [2], [3, [[4,]]]])
Out[2]: [1, 2, 3, 4]
</code></pre><p>源代码：</p>
<pre><code>def flatten(seq):
    l = []
    for elt in seq:
        t = type(elt)
        if t is tuple or t is list:
            for elt2 in flatten(elt):
                l.append(elt2)
        else:
            l.append(elt)
    return l
</code></pre><p>上面方法在python3已经被移除 生成器方法实现：</p>
<pre><code>In [36]: def f(seq):
             for elt in seq:
                 if isinstance(elt, Iterable):
                     for elt2 in f(elt):
                         yield elt2
                 else:
                     yield elt

In [37]:

In [37]: a = f([1,2,[3,4]])

In [38]: l = [x for x in a]

In [39]: l
Out[39]: [1, 2, 3, 4]

In [40]: a
Out[40]: &lt;generator object f at 0x7fead3fca0f8&gt;
</code></pre><p>扩展求任意嵌套字典<code>{&#39;a&#39;: 1,&#39;b&#39;:{&#39;c&#39;:1,&#39;d&#39;:{&#39;e&#39;:2,&#39;d&#39;:3}}}</code>所有值的和，如<code>1+1+2+3</code>的和为7</p>
<pre><code>def f(d):
    for elt in d.values():
        if isinstance(elt, collections.Iterable):
            for elt2 in f(elt):
                yield elt2
        else:
            yield elt


a = f(d)
l = sum(x for x in a)
print(l)              # 7
</code></pre>]]></content>
      <categories>
        <category>python标准库</category>
      </categories>
  </entry>
  <entry>
    <title>gcc常用选项</title>
    <url>/2017/12/24/gcc%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<pre><code>/*对源文件hello.c进行预处理,并生成一个ASCII码的中间文件hello.i*/
gcc -E hello.c -o hello.i /*等同于cpp hello.c hello.i*/

/*将hello.c或hello.i翻译成汇编语言文件hello.s*/
gcc -S hello.c -o hello.s /*gcc -S hello.i -o hello.s*/

/*将hello.s翻译成可重定向文件hello.o*/
gcc hello.s -o hello.o

/*编译和汇编(不进行链接)生成hello.o*/
gcc -c hello.c

/*生成可执行文件hello*/
gcc hello.c -o hello

/*-fpic(Position-Independent Code)器生成位置无关的代码,共享库的编译必须总是使用这个选项;-shared指示编译器创建一个共享的目标文件*/
gcc -shared -fpic -o lib.so a.c b.c
</code></pre>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>github 工作流</title>
    <url>/2020/05/23/github-%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<p>如果你要参与一个开源项目你就必须知道<code>github工作流</code>，<code>github工作流</code>其实就是多人在参与同一个项目的一种协作方式。</p>
<p>假如你想要参与<code>kubernetes</code>项目，你就得了解<code>github</code>工作流。</p>
<p>1.首先你需要将<code>kubernetes</code>项目的代码Fork到你的<code>github</code>仓库中</p>
<p>2.然后将你仓库中的代码克隆到你本地的工作目录。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/$user/kubernetes.git</span><br></pre></td></tr></table></figure></p>
<p>3.更新本地代码,不建设使用<code>git pull</code>因为<code>git pull</code>是做一个合并操作，会使commit变的杂乱。或者改变git配置，<code>git config branch.autoSetupRebase always</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line">git checkout master</span><br><span class="line">git rebase upstream/master</span><br></pre></td></tr></table></figure>
<p>4.创建新的分支，并在此分支上进行开发<br><code>git checkout -b mybrach</code></p>
<p>5.保存更改后的代码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git add &lt;files&gt;</span><br><span class="line">git commit -m</span><br></pre></td></tr></table></figure></p>
<p>6.将更新后的代码，推到你Fork的仓库中<br><code>git push -f ${your_remote_name} myfeature</code></p>
<p>7.创建一个合并请求<br><a href="https://github.com/kubernetes/community/blob/master/contributors/guide/pull-requests.md" target="_blank" rel="noopener">怎样创建合并请求</a></p>
<p>8.当创建合并请求之后，会给这个合并请求分配<code>reviewers</code>并进行一系列的检查 ，当这些都通过之后代码会进行合并。若存在一些问题，则需要进行一些修改。<br>使用如下命令进行 操作<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line">git push -f $remotename mybrach</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.hysyeah.top/2020/5/17/git_workflow.png" alt="image"></p>
<p><a href="https://github.com/kubernetes/community/blob/master/contributors/guide/git_workflow.png" target="_blank" rel="noopener">图片来源</a></p>
<hr>
<p>Ref：<br>1.<a href="https://github.com/kubernetes/community/blob/master/contributors/guide/github-workflow.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/guide/github-workflow.md</a><br>2.<a href="https://faust.readthedocs.io/en/latest/contributing.html" target="_blank" rel="noopener">https://faust.readthedocs.io/en/latest/contributing.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>go-import</title>
    <url>/2019/12/22/go-import/</url>
    <content><![CDATA[<p>go使用import 命令来导入包文件</p>
<p>像下面这样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">fmt.Println(&quot;hello go&quot;)</span><br></pre></td></tr></table></figure></p>
<h6 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;./model&quot;            //当前文件同一目录的model目录,但不建议这种方式</span><br></pre></td></tr></table></figure>
<h6 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;shorturl/model&quot;    //加载gopath/src/shorturl/model</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="点操作"><a href="#点操作" class="headerlink" title="点操作"></a>点操作</h6><p>使用点操作可以省略前缀的包名,<code>fmt.Println可以缩写成Println</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	. &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Println(&quot;hello go&quot;)</span><br></pre></td></tr></table></figure></p>
<hr>
<h6 id="别名操作"><a href="#别名操作" class="headerlink" title="别名操作"></a>别名操作</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	f &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">f.Println(&quot;hello, go&quot;)</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="操作"><a href="#操作" class="headerlink" title="_操作"></a>_操作</h6><p>_操作其实是引入该包,不直接使用包里面的函数,而是调用了该包里的<code>init</code>函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	_ &quot;fmt&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Ref：<br>1.go web编程</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go get golang.org/x 包失败解决方法</title>
    <url>/2018/08/22/go-get-golang-orgx/</url>
    <content><![CDATA[<p>由于网络问题不能访问<code>golang.org</code>,通过go get安装golang官方包会失败，如</p>
<pre><code>go get lint
package golang.org/x/lint: unrecognized import path &quot;golang.org/x/lint&quot; (https fetch: Get https://golang.org/x/lint?go-get=1: dial tcp 216.239.37.1:443: i/o timeout)
</code></pre><p>不翻墙的情况下怎么解决这个问题？其实 golang 在 github 上建立了一个镜像库，如 <a href="https://github.com/golang/lint" target="_blank" rel="noopener">https://github.com/golang/lint</a> 即是 <a href="https://golang.org/x/lint" target="_blank" rel="noopener">https://golang.org/x/lint</a> 的镜像库 解决方法</p>
<pre><code>mkdir -p $GOPATH/src/golang.org/x
cd $GOPATH/src/golang.org/x
git clone https://github.com/golang/lint.git

go install golang.org/x/lint
</code></pre><hr>
<p>Ref：<br>1.<a href="https://blog.csdn.net/alexwoo0501/article/details/73409917" target="_blank" rel="noopener">https://blog.csdn.net/alexwoo0501/article/details/73409917</a></p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-接收者</title>
    <url>/2019/12/22/go-%E6%8E%A5%E6%94%B6%E8%80%85/</url>
    <content><![CDATA[<p>定义一个计算长方形面积的函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Rectangle struct &#123;</span><br><span class="line">	width, height float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func area(r Rectangle) float64 &#123;</span><br><span class="line">	return r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r1 := Rectangle&#123;12, 2&#125;</span><br><span class="line">	r2 := Rectangle&#123;9, 4&#125;</span><br><span class="line">	fmt.Println(&quot;Area of r1 is: &quot;, area(r1))</span><br><span class="line">	fmt.Println(&quot;Area of r2 is: &quot;, area(r2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这种方式定义是一个可以求长方形面积的函数<code>area</code>。这个方法并不是属于<code>Rectangle</code>这个对象。如果要把<code>area</code>当作<code>Rectangle</code>的<code>method</code>,也就是把<code>area</code>当作<code>Rectangle</code>的一个 属性,可以使用接收者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 虽然method名称一样,但是如果接收者不一样,那么method就不一样</span><br><span class="line">// method里面可以访问接收者的字段</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Rectangle struct &#123;</span><br><span class="line">	width, height float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Circle struct &#123;</span><br><span class="line">	radius float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Rectangle) area() float64  &#123;</span><br><span class="line">	return r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c Circle) area() float64  &#123;</span><br><span class="line">	return c.radius *c.radius *math.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r1 := Rectangle&#123;12, 2&#125;</span><br><span class="line">	r2 := Rectangle&#123;9, 4&#125;</span><br><span class="line">	c1 :=Circle&#123;10&#125;</span><br><span class="line">	c2 :=Circle&#123;25&#125;</span><br><span class="line">	fmt.Println(&quot;Area of r1 is: &quot;, r1.area())</span><br><span class="line">	fmt.Println(&quot;Area of r2 is: &quot;, r2.area())</span><br><span class="line">	fmt.Println(&quot;Area of c1 is: &quot;, c1.area())</span><br><span class="line">	fmt.Println(&quot;Area of c2 is: &quot;, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>接收者的值传递OR引用传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Rectangle struct &#123;</span><br><span class="line">	width, height float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Rectangle) area() float64  &#123;</span><br><span class="line">	r.width = 10</span><br><span class="line">	return r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r1 := Rectangle&#123;12, 2&#125;</span><br><span class="line">	fmt.Println(&quot;r1.width is: &quot;,r1.width )</span><br><span class="line">	r1.area()</span><br><span class="line">	fmt.Println(&quot;r1.width is: &quot;,r1.width )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.hysyeah.top/2019/12/22/go-reciver1.png" alt="image"></p>
<p>把<code>area</code>method改为如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (r *Rectangle) area() float64  &#123;</span><br><span class="line">	r.width = 10</span><br><span class="line">	return r.width*r.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><img src="http://img.hysyeah.top/2019/12/22/go-reciver2.png" alt="image"></p>
<p>如果接收者前面没有加<code>*</code>号则表示方法使用的是引用传递,指针作为<code>Receiver</code>会对实例对象的内容发生操作,如果没加星号则是以值传递,只是对实例的副本进行操作。</p>
<hr>
<p>Ref：<br>1.go web编程</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go-module的使用</title>
    <url>/2020/06/27/go-module/</url>
    <content><![CDATA[<p>Go 1.11和1.12已经基本上支持<code>Go Modules</code>,<code>Go</code>的新依赖管理系统，更好的管理依赖的版本信息。</p>
<p>本文使用版本<code>Go1.13</code>.<br>在<code>Go Modules</code>之前，每个项目都必须设置一个<code>GOPATH</code>,并将第三方包安装在各自的目录下，多个项目之间不能共用第三方包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">GO111MODULE</span><br><span class="line">GO111MODULE 有三个值：off, on和auto（默认值）。</span><br><span class="line"></span><br><span class="line">GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找</span><br><span class="line">GO111MODULE=on，go命令行会使用module功能</span><br><span class="line">GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能</span><br><span class="line"></span><br><span class="line">如下两种情况会启用module功能：</span><br><span class="line">－ 当前目录在GOPATH/src之外且该目录包含go.mod文件</span><br><span class="line">－ 当前文件在包含go.mod文件的目录下面。</span><br><span class="line"></span><br><span class="line">当module功能启用时，依赖包的存放位置变更为$GOPATH/pkg，允许同一个package多个版本并存，且多个项目可以共享缓存的 module。</span><br></pre></td></tr></table></figure>
<h4 id="新建一个module"><a href="#新建一个module" class="headerlink" title="新建一个module"></a>新建一个<code>module</code></h4><p>在<code>$GOPATH/src</code>目录之外新建一个目录<code>hello</code>,并新建一个文件<code>server.go</code><br>整个目录结构如下：<br><img src="http://img.hysyeah.top/2020/7/4/20200704110458-hello-go-mod.png" alt><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  gopro mkdir hello</span><br><span class="line">➜  gopro cd hello</span><br><span class="line">➜  hello vim hello.go</span><br><span class="line">➜  hello cat hello.go</span><br><span class="line">package hello</span><br><span class="line"></span><br><span class="line">func Hello() string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, world."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➜  hello cat hello_test.go </span><br><span class="line">package hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">func TestHello(t *testing.T) &#123;</span><br><span class="line">    want := <span class="string">"Hello, world."</span></span><br><span class="line">    <span class="keyword">if</span> got := Hello(); got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">"Hello() = %q, want %q"</span>, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到目前为止这个目录包含<code>package</code>,但不是一个<code>module</code>，因为不包含<code>go.mod</code>文件。<br>执行<code>go test</code>,将会提示如下错误(使用的go版本为1.13)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go test</span><br><span class="line">go: cannot find main module; see <span class="string">'go help modules'</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>go mod init</code>把目录转换成为一个<code>module</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go mod init example.com/hello</span><br><span class="line">go: creating new go.mod: module example.com/hello</span><br><span class="line">➜  hello go test</span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	<span class="number">0.002</span>s</span><br><span class="line">➜  hello cat go.mod </span><br><span class="line">module example.com/hello  //定义了 module path,是导入路径的根目录</span><br><span class="line"></span><br><span class="line">go <span class="number">1.13</span></span><br></pre></td></tr></table></figure></p>
<p><code>go.mod</code>文件一般只出现于<code>module</code>的根目录。如果你在<code>module</code>下面新建了一个子目录<code>world</code>,<code>world</code>会自动被认为是<code>example.com/hello</code>的一部分，导入路径为<code>example.com/hello/world</code>。(<code>go.mod</code>所在的目录被认为是一个<code>module</code>的根目录,导入路径为<code>example.com/hello</code>加入对应的<code>package</code>名称)</p>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello cat hello.go</span><br><span class="line">package hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"rsc.io/quote"</span></span><br><span class="line"></span><br><span class="line">func Hello() string &#123;</span><br><span class="line">    <span class="keyword">return</span> quote.Hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>go test</code>命令,该命令会自动下载所需要的包。并将所需的依赖写入到<code>go.mod</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go test</span><br><span class="line">go: finding rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br><span class="line">go: downloading rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br><span class="line">go: extracting rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br><span class="line">go: downloading rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">go: extracting rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">go: downloading golang.org/x/text v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170915032832</span><span class="number">-14</span>c0d48ead0c</span><br><span class="line">go: extracting golang.org/x/text v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170915032832</span><span class="number">-14</span>c0d48ead0c</span><br><span class="line">go: finding rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">go: finding golang.org/x/text v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170915032832</span><span class="number">-14</span>c0d48ead0c</span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	<span class="number">0.003</span>s</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello cat go.mod </span><br><span class="line">module example.com/hello</span><br><span class="line"></span><br><span class="line">go <span class="number">1.13</span></span><br><span class="line"></span><br><span class="line">require rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>
<p>go命令还维护了一个文件<code>go.sum</code>,里面定义了<code>go.mod</code>包中所需的依赖项。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello cat go.sum </span><br><span class="line">golang.org/x/text v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170915032832</span><span class="number">-14</span>c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=</span><br><span class="line">golang.org/x/text v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20170915032832</span><span class="number">-14</span>c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=</span><br><span class="line">rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span> h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=</span><br><span class="line">rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span>/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe+TKr0=</span><br><span class="line">rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span> h1:<span class="number">7</span>uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=</span><br><span class="line">rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span>/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=</span><br></pre></td></tr></table></figure></p>
<h4 id="更新依赖"><a href="#更新依赖" class="headerlink" title="更新依赖"></a>更新依赖</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go get golang.org/x/text</span><br><span class="line">go: finding golang.org/x/text v0<span class="number">.3</span><span class="number">.3</span></span><br><span class="line">go: downloading golang.org/x/text v0<span class="number">.3</span><span class="number">.3</span></span><br><span class="line">go: extracting golang.org/x/text v0<span class="number">.3</span><span class="number">.3</span></span><br><span class="line">➜  hello go test</span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	<span class="number">0.003</span>s</span><br></pre></td></tr></table></figure>
<p>此时查看依赖项,<code>golang.org/x/text</code>已经被升级到v0.3.3<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go list -m all</span><br><span class="line">go: finding golang.org/x/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180917221912</span><span class="number">-90</span>fa682c2a6e</span><br><span class="line">example.com/hello</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.3</span></span><br><span class="line">golang.org/x/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180917221912</span><span class="number">-90</span>fa682c2a6e</span><br><span class="line">rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br><span class="line">rsc.io/sampler v1<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">➜  hello cat  go.mod</span><br><span class="line">module example.com/hello</span><br><span class="line"></span><br><span class="line">go <span class="number">1.13</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	golang.org/x/text v0<span class="number">.3</span><span class="number">.3</span> // indirect</span><br><span class="line">	rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>尝试升级<code>rsc.io/sampler</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go get rsc.io/sampler</span><br><span class="line">go: finding rsc.io/sampler v1<span class="number">.99</span><span class="number">.99</span></span><br><span class="line">go: downloading rsc.io/sampler v1<span class="number">.99</span><span class="number">.99</span></span><br><span class="line">go: extracting rsc.io/sampler v1<span class="number">.99</span><span class="number">.99</span></span><br><span class="line">➜  hello go test</span><br><span class="line">--- FAIL: TestHello (<span class="number">0.00</span>s)</span><br><span class="line">    hello_test.go:<span class="number">8</span>: Hello() = <span class="string">"99 bottles of beer on the wall, 99 bottles of beer, ..."</span>, want <span class="string">"Hello, world."</span></span><br><span class="line">FAIL</span><br><span class="line">exit status <span class="number">1</span></span><br><span class="line">FAIL	example.com/hello	<span class="number">0.002</span>s</span><br></pre></td></tr></table></figure></p>
<p><code>rsc.io/sampler</code>包是更新成功了，但<code>go test</code>命令执行失败。<br>查看<code>rsc.io/sampler</code>版本信息<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go list -m -versions rsc.io/sampler</span><br><span class="line">rsc.io/sampler v1<span class="number">.0</span><span class="number">.0</span> v1<span class="number">.2</span><span class="number">.0</span> v1<span class="number">.2</span><span class="number">.1</span> v1<span class="number">.3</span><span class="number">.0</span> v1<span class="number">.3</span><span class="number">.1</span> v1<span class="number">.99</span><span class="number">.99</span></span><br></pre></td></tr></table></figure></p>
<p>导致出错的原因可能是，<code>rsc.io/sampler@v1.99.99</code>与原来版本的包不兼容所致。我们重新安装<br><code>rsc.io/sampler@v1.3.1</code>然后再进行测试。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go get rsc.io/sampler@v1<span class="number">.3</span><span class="number">.1</span></span><br><span class="line">go: finding rsc.io/sampler v1<span class="number">.3</span><span class="number">.1</span></span><br><span class="line">go: downloading rsc.io/sampler v1<span class="number">.3</span><span class="number">.1</span></span><br><span class="line">go: extracting rsc.io/sampler v1<span class="number">.3</span><span class="number">.1</span></span><br><span class="line">➜  hello go test</span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	<span class="number">0.003</span>s</span><br></pre></td></tr></table></figure></p>
<h4 id="添加对新主版本的依赖"><a href="#添加对新主版本的依赖" class="headerlink" title="添加对新主版本的依赖"></a>添加对新主版本的依赖</h4><p>修改<code>hello.go</code>的内容如下:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello cat hello.go</span><br><span class="line">package hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"rsc.io/quote"</span></span><br><span class="line">    quoteV3 <span class="string">"rsc.io/quote/v3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Hello() string &#123;</span><br><span class="line">    <span class="keyword">return</span> quote.Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Proverb() string &#123;</span><br><span class="line">    <span class="keyword">return</span> quoteV3.Concurrency()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改<code>hello_test.go</code>的内容如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">package hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">func TestHello(t *testing.T) &#123;</span><br><span class="line">    want := <span class="string">"Hello, world."</span></span><br><span class="line">    <span class="keyword">if</span> got := Hello(); got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">"Hello() = %q, want %q"</span>, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestProverb(t *testing.T) &#123;</span><br><span class="line">    want := <span class="string">"Concurrency is not parallelism."</span></span><br><span class="line">    <span class="keyword">if</span> got := Proverb(); got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">"Proverb() = %q, want %q"</span>, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行<code>go test</code>命令<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go test          </span><br><span class="line">go: finding rsc.io/quote/v3 v3<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">go: downloading rsc.io/quote/v3 v3<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">go: extracting rsc.io/quote/v3 v3<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	<span class="number">0.003</span>s</span><br></pre></td></tr></table></figure></p>
<p>查看<code>rsc.io/quote</code>,发现存在不同版本的两个包。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go list -m rsc.io/q...</span><br><span class="line">rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br><span class="line">rsc.io/quote/v3 v3<span class="number">.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></p>
<h4 id="升级新主版本的依赖"><a href="#升级新主版本的依赖" class="headerlink" title="升级新主版本的依赖"></a>升级新主版本的依赖</h4><p>因为一些原因我们需要将<code>quote</code>升级到<code>V3</code>版本。<br>修改<code>hello.go</code>的内容如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello cat hello.go</span><br><span class="line">package hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    quoteV3 <span class="string">"rsc.io/quote/v3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Hello() string &#123;</span><br><span class="line">    <span class="keyword">return</span> quoteV3.HelloV3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Proverb() string &#123;</span><br><span class="line">    <span class="keyword">return</span> quoteV3.Concurrency()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行<code>go test</code>命令<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go test</span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/hello	<span class="number">0.003</span>s</span><br></pre></td></tr></table></figure></p>
<h4 id="移除没有使用的依赖"><a href="#移除没有使用的依赖" class="headerlink" title="移除没有使用的依赖"></a>移除没有使用的依赖</h4><p>在上一步中，我们的代码已经没有使用<code>rsc.io/quote/v1</code>版本，但<code>rsc.io/quote v1.5.2</code>还是存在于依赖中。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go list -m all</span><br><span class="line">example.com/hello</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.3</span></span><br><span class="line">golang.org/x/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180917221912</span><span class="number">-90</span>fa682c2a6e</span><br><span class="line">rsc.io/quote v1<span class="number">.5</span><span class="number">.2</span></span><br><span class="line">rsc.io/quote/v3 v3<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">rsc.io/sampler v1<span class="number">.3</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p>
<p>因为构建单个软件包（例如使用go build或go test）可以轻松判断出什么时候缺少什么东西和需要添加什么东西，但是不能确定什么时候可以安全地删除东西。 仅在检查模块中的所有软件包以及这些软件包的所有可能的构建标记组合之后，才能删除依赖项。 普通的build命令不会加载此信息，因此它不能安全地删除依赖项。</p>
<p>使用<code>go mod tidy</code>命令清除未使用的依赖。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  hello go mod tidy</span><br><span class="line">➜  hello go list -m all</span><br><span class="line">example.com/hello</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.3</span></span><br><span class="line">golang.org/x/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180917221912</span><span class="number">-90</span>fa682c2a6e</span><br><span class="line">rsc.io/quote/v3 v3<span class="number">.1</span><span class="number">.0</span></span><br><span class="line">rsc.io/sampler v1<span class="number">.3</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p><code>go mod</code>相关命令:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>COMMAND</th>
<th>DESC</th>
</tr>
</thead>
<tbody>
<tr>
<td>download</td>
<td>download modules to local cache</td>
</tr>
<tr>
<td>edit</td>
<td>edit go.mod from tools or scripts</td>
</tr>
<tr>
<td>graph</td>
<td>print module requirement graph</td>
</tr>
<tr>
<td>init</td>
<td>initialize new module in current directory</td>
</tr>
<tr>
<td>tidy</td>
<td>add missing and remove unused modules</td>
</tr>
<tr>
<td>vendor</td>
<td>make vendored copy of dependencies</td>
</tr>
<tr>
<td>verify</td>
<td>verify dependencies have expected content</td>
</tr>
<tr>
<td>why</td>
<td>explain why packages or modules are needed</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>Ref：<br>1.<a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">https://blog.golang.org/using-go-modules</a><br>2.<a href="https://juejin.im/post/5c8e503a6fb9a070d878184a" target="_blank" rel="noopener">https://juejin.im/post/5c8e503a6fb9a070d878184a</a></p>
]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang http.Get详解</title>
    <url>/2023/03/13/golang-http-Get%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>从一道题目开始, 如果你对这些输出不是很理解。接下我们将一步一步debug源码彻底搞懂这些问题。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		 resp,_:=http.Get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">		_, _ = ioutil.ReadAll(resp.Body)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fmt.Printf(<span class="string">"Num of Goroutines %d\n"</span>, runtime.NumGoroutine()) <span class="comment">// 3，readLoop + writeLoop + main</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		 resp,_:=http.Get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">		resp.Body.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fmt.Printf(<span class="string">"Num of Goroutines %d\n"</span>, runtime.NumGoroutine()) <span class="comment">// 3，readLoop + writeLoop + main</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		http.Get(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"Num of Goroutines %d\n"</span>, runtime.NumGoroutine()) <span class="comment">// 7, 3 readLoop + 3 writeLoop + main = 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本次主要涉及到如下三个文件<br><code>net/http/client.go</code><br><code>net/http/request.go</code><br><code>net/http/transport.go</code></p>
<p><code>http.Client</code>：该类型表示可以发起 HTTP 请求的 HTTP 客户端。它提供了 Get、Post 和 Do 等方法，用于使用不同的 HTTP 方法发起 HTTP 请求。它还可以配置自定义的 http.Transport 对象，以控制底层网络连接。</p>
<p><code>http.Request</code>：该类型表示可以被 HTTP 客户端发送的 HTTP 请求。它提供了 Method、URL 和 Header 等字段，用于设置请求的 HTTP 方法、URL 和 HTTP 头部。它还提供了设置请求体的方法。</p>
<p><code>http.Transport</code>：该类型表示 HTTP 客户端用于发起 HTTP 请求的传输层,它负责TCP连接的创建和维护。它提供了配置底层网络连接的选项，例如最大空闲连接数、最大空闲连接时长和连接超时。http.Client 类型使用 http.Transport 的实例来发起 HTTP 请求。</p>
<p><code>http.Get</code>的调用链如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- http.Get</span><br><span class="line">  - DefaultClient.Get</span><br><span class="line">    - c.Do(req)</span><br><span class="line">      - c.do(req)</span><br><span class="line">        -  c.send(req,...)</span><br><span class="line">          -  send(...)</span><br><span class="line">            -  rt.RoundTrip(req)</span><br><span class="line">              -  t.roundTrip(req)</span><br><span class="line">                -  t.getConn(req, ...)</span><br><span class="line">                  -  t.queueForDial(w)</span><br><span class="line">                    -  t.dialConnFor</span><br><span class="line">                      - t.dialConn(w.ctx, w.cm)</span><br><span class="line">                        -  go pconn.readLoop()</span><br><span class="line">                        -  go pconn.writeLoop()</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">dialConn</span><span class="params">(ctx context.Context, cm connectMethod)</span> <span class="params">(pconn *persistConn, err error)</span></span> &#123;</span><br><span class="line">	pconn = &amp;persistConn&#123;</span><br><span class="line">		t:             t,</span><br><span class="line">		cacheKey:      cm.key(),</span><br><span class="line">		reqch:         <span class="built_in">make</span>(<span class="keyword">chan</span> requestAndChan, <span class="number">1</span>),</span><br><span class="line">		writech:       <span class="built_in">make</span>(<span class="keyword">chan</span> writeRequest, <span class="number">1</span>),</span><br><span class="line">		closech:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		writeErrCh:    <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>),</span><br><span class="line">		writeLoopDone: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">	<span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">	<span class="keyword">return</span> pconn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到对于每一个链接都会启动一个<code>goroutine</code>从链接中读取数据和一个<code>goroutine</code>往链接中写数据。<br>问题来了这两个<code>goroutine</code>什么时候退出呢？<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func (pc *persistConn) readLoop() &#123;</span><br><span class="line">	closeErr := errReadLoopExiting // default value, <span class="keyword">if</span> <span class="keyword">not</span> changed below</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		pc.close(closeErr)</span><br><span class="line">		pc.t.removeIdleConn(pc)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	alive := true</span><br><span class="line">	<span class="keyword">for</span> alive &#123;</span><br><span class="line">		waitForBodyRead := make(chan bool, <span class="number">2</span>)</span><br><span class="line">		body := &amp;bodyEOFSignal&#123;</span><br><span class="line">			body: resp.Body,</span><br><span class="line">			earlyCloseFn: func() error &#123;</span><br><span class="line">				waitForBodyRead &lt;- false</span><br><span class="line">				&lt;-eofc // will be closed by deferred call at the end of the function</span><br><span class="line">				<span class="keyword">return</span> nil</span><br><span class="line"></span><br><span class="line">			&#125;,</span><br><span class="line">			fn: func(err error) error &#123;</span><br><span class="line">				isEOF := err == io.EOF</span><br><span class="line">				waitForBodyRead &lt;- isEOF</span><br><span class="line">				<span class="keyword">if</span> isEOF &#123;</span><br><span class="line">					&lt;-eofc // see comment above eofc declaration</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">					<span class="keyword">if</span> cerr := pc.canceled(); cerr != nil &#123;</span><br><span class="line">						<span class="keyword">return</span> cerr</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        // 当alive=false时，readLoop()会结束运行</span><br><span class="line">		select &#123;</span><br><span class="line">            // 当waitForBodyRead值为false的时候程序退出</span><br><span class="line">            // 当执行earlyCloseFn时，才会给waitForBodyRead赋值为false</span><br><span class="line">		case bodyEOF := &lt;-waitForBodyRead:</span><br><span class="line">			pc.t.setReqCanceler(rc.req, nil)</span><br><span class="line">			alive = alive &amp;&amp;</span><br><span class="line">				bodyEOF &amp;&amp;</span><br><span class="line">				!pc.sawEOF &amp;&amp;</span><br><span class="line">				pc.wroteRequest() &amp;&amp;</span><br><span class="line">				tryPutIdleConn(trace)</span><br><span class="line">			<span class="keyword">if</span> bodyEOF &#123;</span><br><span class="line">				eofc &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		case &lt;-rc.req.Cancel:</span><br><span class="line">			alive = false</span><br><span class="line">			pc.t.CancelRequest(rc.req)</span><br><span class="line">		case &lt;-rc.req.Context().Done():</span><br><span class="line">			alive = false</span><br><span class="line">			pc.t.cancelRequest(rc.req, rc.req.Context().Err())</span><br><span class="line">		case &lt;-pc.closech:</span><br><span class="line">			alive = false</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看下什么会执行earlyCloseFn函数和fn函数<br>fn函数在调用<code>ioutil.ReadAll(resp.Body)</code>时会被执行，而earlyCloseFn会在调用<code>resp.Body.Close()</code>时执行<code>earlyCoseFn()</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (es *bodyEOFSignal) Read(p []byte) (n int, err error) &#123;</span><br><span class="line">	es.mu.Lock()</span><br><span class="line">	closed, rerr := es.closed, es.rerr</span><br><span class="line">	es.mu.Unlock()</span><br><span class="line">	if closed &#123;</span><br><span class="line">		return 0, errReadOnClosedResBody</span><br><span class="line">	&#125;</span><br><span class="line">	if rerr != nil &#123;</span><br><span class="line">		return 0, rerr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n, err = es.body.Read(p)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		es.mu.Lock()</span><br><span class="line">		defer es.mu.Unlock()</span><br><span class="line">		if es.rerr == nil &#123;</span><br><span class="line">			es.rerr = err</span><br><span class="line">		&#125;</span><br><span class="line">		err = es.condfn(err)</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行fn函数，会往waitForBodyRead发送true值</span><br><span class="line">// 此时readLoop()并不会退出，但会把这个连接重新放回到连接池中(只有当数据被正常的读取完)</span><br><span class="line">func (es *bodyEOFSignal) condfn(err error) error &#123;</span><br><span class="line">	if es.fn == nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	err = es.fn(err)</span><br><span class="line">	es.fn = nil</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 当earlyCloseFn != nil 和错误不等于io.EOF时会执行earlyCloseFn函数</span><br><span class="line">func (es *bodyEOFSignal) Close() error &#123;</span><br><span class="line">	es.mu.Lock()</span><br><span class="line">	defer es.mu.Unlock()</span><br><span class="line">	if es.closed &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line">	es.closed = true</span><br><span class="line">	if es.earlyCloseFn != nil &amp;&amp; es.rerr != io.EOF &#123;</span><br><span class="line">		return es.earlyCloseFn()</span><br><span class="line">	&#125;</span><br><span class="line">	err := es.body.Close()</span><br><span class="line">	return es.condfn(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 当readLoop()退出时，会close channel,writeLoop()接收到后便会退出</span><br><span class="line">func (pc *persistConn) writeLoop() &#123;</span><br><span class="line">	defer close(pc.writeLoopDone)</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case wr := &lt;-pc.writech:</span><br><span class="line">			startBytesWritten := pc.nwrite</span><br><span class="line">			err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))</span><br><span class="line">			if bre, ok := err.(requestBodyReadError); ok &#123;</span><br><span class="line">				err = bre.error</span><br><span class="line">				// Errors reading from the user&apos;s</span><br><span class="line">				// Request.Body are high priority.</span><br><span class="line">				// Set it here before sending on the</span><br><span class="line">				// channels below or calling</span><br><span class="line">				// pc.close() which tears town</span><br><span class="line">				// connections and causes other</span><br><span class="line">				// errors.</span><br><span class="line">				wr.req.setError(err)</span><br><span class="line">			&#125;</span><br><span class="line">			if err == nil &#123;</span><br><span class="line">				err = pc.bw.Flush()</span><br><span class="line">			&#125;</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				wr.req.Request.closeBody()</span><br><span class="line">				if pc.nwrite == startBytesWritten &#123;</span><br><span class="line">					err = nothingWrittenError&#123;err&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			pc.writeErrCh &lt;- err // to the body reader, which might recycle us</span><br><span class="line">			wr.ch &lt;- err         // to the roundTrip function</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				pc.close(err)</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">		case &lt;-pc.closech:</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>如果调用<code>ioutil.ReadAll</code>读取了<code>resp.Body</code>,即使不调用<code>resp.Body.Close()</code>也不会出现泄漏,为什么建议每次都要调用<code>resp.Body.Close()</code>主要是因为处理异常的情况，当出现异常情况时，会往<code>waitForBodyRead</code>发送一个<code>false</code>使<code>readLoop</code>退出。</li>
<li>如果没有读取连接中的数据也没有调用<code>resp.Body.Close()</code>，会导致<code>readLoop</code>,<code>writeLoop</code>不会退出从而产生泄漏。每次<code>http.Get</code>都会产生两个<code>goroutine</code></li>
<li>如果复用了连接将不会产生新的<code>readLoop</code>和<code>writeLoop</code> <code>goroutine</code>。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>golang-struct-option-value</title>
    <url>/2021/07/30/golang-struct-option-val/</url>
    <content><![CDATA[<p>在<code>Golang</code>中初始化<code>struct</code>之后如何优雅的设置一些字段的值.现在来学习下<code>k8s</code>源码中是如何做的</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="keyword">int</span></span><br><span class="line">	b <span class="keyword">int</span></span><br><span class="line">	res resource</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> resource <span class="keyword">struct</span> &#123;</span><br><span class="line">	kind <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option接口</span></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">	Apply(*Config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aOption <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为需要修改的字段实现一个Apply方法,具体修改struct中的字段内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o aOption)</span> <span class="title">Apply</span><span class="params">(config *Config)</span></span>   &#123;</span><br><span class="line">	config.a = <span class="keyword">int</span>(o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回aOption类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithA</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">Option</span></span>  &#123;</span><br><span class="line">	<span class="keyword">return</span> aOption(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> resourceOption <span class="keyword">struct</span> &#123;</span><br><span class="line">	res resource</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o resourceOption)</span> <span class="title">Apply</span><span class="params">(config *Config)</span></span>  &#123;</span><br><span class="line">	config.res = o.res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithRes</span><span class="params">(res resource)</span> <span class="title">Option</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> resourceOption&#123;res: res&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// newA opts为可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newA</span><span class="params">(opts ...Option)</span> *<span class="title">Config</span></span>  &#123;</span><br><span class="line">	config := &amp;Config&#123;</span><br><span class="line">		a: <span class="number">0</span>,</span><br><span class="line">		b: <span class="number">0</span>,</span><br><span class="line">		res: resource&#123;</span><br><span class="line">			kind: <span class="string">"Cat"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行额外的赋值操作,通过opts中的内容修改config中的值</span></span><br><span class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts&#123;</span><br><span class="line">		opt.Apply(config)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	opts := []Option&#123;WithA(<span class="number">1</span>), WithRes(resource&#123;kind: <span class="string">"Dog"</span>&#125;)&#125;</span><br><span class="line">	r := newA(opts...)</span><br><span class="line">	fmt.Println(r) <span class="comment">// &amp;&#123;1 0 &#123;Dog&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种类似的方法,相当于省略了Apply函数，将Apply函数的内容写在了<code>WithClientSet</code>函数中。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> frameworkOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">	clientSet 	<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fOption <span class="function"><span class="keyword">func</span><span class="params">(*frameworkOptions)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithClientSet</span><span class="params">(clientSet <span class="keyword">string</span>)</span> <span class="title">fOption</span></span>  &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *frameworkOptions)</span></span> &#123;</span><br><span class="line">		o.clientSet = clientSet</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFrameWork</span><span class="params">(opts ...fOption)</span> *<span class="title">frameworkOptions</span></span>  &#123;</span><br><span class="line">	fr := &amp;frameworkOptions&#123;</span><br><span class="line">		clientSet: <span class="string">"Cat"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行额外的赋值操作,通过opts中的内容修改frameworkOptions中的值</span></span><br><span class="line">	<span class="keyword">for</span> _,opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">		opt(fr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    opts := []fOption&#123;WithClientSet(<span class="string">"Dog"</span>)&#125;</span><br><span class="line">    r := newFrameWork(options...)</span><br><span class="line">    fmt.Println(r) <span class="comment">// &amp;&#123;Dog&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/vendor/go.opentelemetry.io/otel/sdk/metric/controller/basic/config.go" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/blob/master/vendor/go.opentelemetry.io/otel/sdk/metric/controller/basic/config.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go概览</title>
    <url>/2018/08/12/go%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<p>Go是编译型语言。 如果缺少import或者导入之后没有使用，程序都不会进行编译。 Go每行结尾并不需要加分号(加分号也不会报错，但不符合规范) Go提供了gofmt命令来处理编码规范问题。</p>
<pre><code>$ gofmt --help
usage: gofmt [flags] [path ...]
  -cpuprofile string
        write cpu profile to this file
  -d    display diffs instead of rewriting files
  -e    report all errors (not just the first 10 on different lines)
  -l    list files whose formatting differs from gofmt&#39;s
  -r string
        rewrite rule (e.g., &#39;a[b:len(a)] -&gt; a[b:]&#39;)
  -s    simplify code
  -w    write result to (source) file instead of stdout


os.Args //命令行输入，os.Args[0]表示命令本身

for initialization; condition; post {
    //zero or more statements
}

// 相当于while
for condition {

}
// 相当于无限循环
for {

}

range //返回当前索引的索引和值

ch := make(chan string) //初始化字符串类型的通道
&lt;-ch                    //从通道中取值
ch &lt;-                   //往通道中写入值


strings.Join(&lt;list&gt;, sep)         // 功能和python中join一样
input := bufio.NewScanner(os.Stdin)        //读取标准输入的数据，并分解为行或单词
input.Scan() //读取下一行，并去掉换行符
input.Text() //获取输入内容


%d          十进制整数
%x, %o, %b  十六进制，八进制，二进制整数。
%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00
%t          布尔：true或false
%c          字符（rune） (Unicode码点)
%s          字符串
%q          带双引号的字符串&quot;abc&quot;或带单引号的字符&#39;c&#39;
%v          变量的自然形式（natural format）
%T          变量的类型
%%          字面上的百分号标志（无操作数）


fmt.Sprintf       //返回格式化后的字符串
fmt.Println       //打印到标准输出，返回字节数和err

// 格式化字符串并写入到w中，返回写入的字节数和err
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)       

// 返回一个可读文件对象
func Open(name string) (*File, error)   //os.Open
func Exit(code int)                     //os.Open,结束程序，0表示成功
func ReadFile(filename string) ([]byte, error) //ioutil.ReadFile,读取整个文件并返回内容
func ReadAll(r io.Reader) ([]byte, error) //ioutil.ReadAll,从r中读取直到EOF或产生错误

func Join(a []string, sep string) string //strings.Join
func Split(s, sep string) []string       //strings.Split
func (c *Client) Get(url string) (resp *Response, err error)//http.Get
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) //http.HandleFunc,根据pattern注册处理函数

func Fatal(v ...interface{})  //log.Fatal,等同于Print()+os.Exit(1)

func Now() Time        //time.Now,返回本地当前时间
func Since(t Time) Duration //time.Since


//sync.Mutex
func (m *Mutex) Lock()  
func (m *Mutex) Unlock()


//io
func Copy(dst Writer, src Reader) (written int64, err error) //copy src to dst, ioutil.Discard相当于/dev/null
</code></pre><p><a href="https://github.com/hys20151008/gopl/tree/master/src/ch1" target="_blank" rel="noopener">相关代码</a></p>
<hr>
<p>Ref： 1.The Go Programming Language</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-world</title>
    <url>/2017/08/25/hello-world/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>hadoop,spark踩过的坑</title>
    <url>/2018/02/07/hadoop,spark%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h5 id="1-WARN-yarn-Client-Neither-spark-yarn-jars-nor-spark-yarn-archive-is-set-falling-back-to-uploading-libraries-under-SPARK-HOME"><a href="#1-WARN-yarn-Client-Neither-spark-yarn-jars-nor-spark-yarn-archive-is-set-falling-back-to-uploading-libraries-under-SPARK-HOME" class="headerlink" title="1.WARN yarn.Client: Neither spark.yarn.jars nor spark.yarn.archive is set, falling back to uploading libraries under SPARK_HOME"></a>1.WARN yarn.Client: Neither spark.yarn.jars nor spark.yarn.archive is set, falling back to uploading libraries under SPARK_HOME</h5><pre><code>hdfs dfs -mkdir /hadoop/spark_jars
hdfs dfs -put /opt/spark-2.2.0-bin-hadoop2.7/jars/spark-* /hadoop/spark_jars #将spark-*.jar文件复制到/hadoop/spark_jars
在spark-defaults.conf中添加
spark.yarn.jars                   hdfs://192.168.2.10:9000/hadoop/spark_jars/*
</code></pre><h5 id="2-NodeManager-from-464aa87ad374-doesn’t-satisfy-minimum-allocations-Sending-SHUTDOWN-signal-to-the-NodeManager"><a href="#2-NodeManager-from-464aa87ad374-doesn’t-satisfy-minimum-allocations-Sending-SHUTDOWN-signal-to-the-NodeManager" class="headerlink" title="2. NodeManager from 464aa87ad374 doesn’t satisfy minimum allocations, Sending SHUTDOWN signal to the NodeManager."></a>2. NodeManager from 464aa87ad374 doesn’t satisfy minimum allocations, Sending SHUTDOWN signal to the NodeManager.</h5><pre><code># 在yarn-site.xml添加如下
&lt;property&gt;
 &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;
 &lt;value&gt;3072&lt;/value&gt;
&lt;/property&gt;

 &lt;property&gt;
 &lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt;
 &lt;value&gt;1&lt;/value&gt;
&lt;/property&gt;
</code></pre><h5 id="3-To-adjust-logging-level-use-sc-setLogLevel-newLevel-For-SparkR-use-setLogLevel-newLevel"><a href="#3-To-adjust-logging-level-use-sc-setLogLevel-newLevel-For-SparkR-use-setLogLevel-newLevel" class="headerlink" title="3.To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel)."></a>3.To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</h5><p>18/02/07 08:10:21 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable 18/02/07 08:10:57 WARN YarnSchedulerBackend$YarnSchedulerEndpoint: Container marked as failed: container_1517990956375_0001_01_000003 on host: slave2. Exit status: 1. Diagnostics: Exception from container-launch. Container id: container_1517990956375_0001_01_000003 Exit code: 1 Stack trace: ExitCodeException exitCode=1: at org.apache.hadoop.util.Shell.runCommand(Shell.java:585) at org.apache.hadoop.util.Shell.run(Shell.java:482) at org.apache.hadoop.util.Shell$ShellCommandExecutor.execute(Shell.java:776) at org.apache.hadoop.yarn.server.nodemanager.DefaultContainerExecutor.launchContainer(DefaultContainerExecutor.java:212) at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:302) at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call(ContainerLaunch.java:82) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Container exited with a non-zero exit code 1</p>
<pre><code># 修改spark-defaults.conf添加如下，值根据实际情况修改
spark.executor.memory            2g
spark.driver.memory               2g
</code></pre><hr>
<h5 id="4-Caused-by-java-io-InvalidClassException-org-apache-spark-sql-execution-FileSourceScanExec-local-class-incompatible-stream-classdesc-serialVersionUID-4243567174184146251-local-class-serialVersionUID-7006716103980652543"><a href="#4-Caused-by-java-io-InvalidClassException-org-apache-spark-sql-execution-FileSourceScanExec-local-class-incompatible-stream-classdesc-serialVersionUID-4243567174184146251-local-class-serialVersionUID-7006716103980652543" class="headerlink" title="4.Caused by: java.io.InvalidClassException: org.apache.spark.sql.execution.FileSourceScanExec; local class incompatible: stream classdesc serialVersionUID = 4243567174184146251, local class serialVersionUID = -7006716103980652543"></a>4.Caused by: java.io.InvalidClassException: org.apache.spark.sql.execution.FileSourceScanExec; local class incompatible: stream classdesc serialVersionUID = 4243567174184146251, local class serialVersionUID = -7006716103980652543</h5><pre><code>使用pyspark对进行groupby后DataFrame进行show()操作时出现的错误
df2 = df.groupby(df.date).agg({&#39;event_type&#39;: &#39;count&#39;})
df2 = df.show()
解决方法：将客户端的pyspark版本改成与服务端一致
</code></pre><hr>
<h5 id="5-Cannot-run-program-“python”-error-2-No-such-file-or-directory"><a href="#5-Cannot-run-program-“python”-error-2-No-such-file-or-directory" class="headerlink" title="5.Cannot run program “python”: error=2, No such file or directory"></a>5.Cannot run program “python”: error=2, No such file or directory</h5><pre><code>执行spark任务时，出现如上提示
解决方法：因为用的是python3,可能spark却去找python，找不到所以报错。因时间问题，只能暴力解决，在各个节点执行下面命令
ln -s /usr/bin/python3 /usr/bin/python
</code></pre><h5 id="6-standard-init-linux-go-195-exec-user-process-caused-“exec-format-error”"><a href="#6-standard-init-linux-go-195-exec-user-process-caused-“exec-format-error”" class="headerlink" title="6.standard_init_linux.go:195: exec user process caused “exec format error”"></a>6.standard_init_linux.go:195: exec user process caused “exec format error”</h5><pre><code>启动容器时报如上错误，原因不小心将docker-compose.yml中command中执行的脚本文件中第一行写成了#/bin/sh,改为#!/bin/sh后解决。
</code></pre><p>Ref：1.<a href="https://issues.apache.org/jira/browse/SPARK-12759" title="https://issues.apache.org/jira/browse/SPARK-12759" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/SPARK-12759</a> 2.<a href="http://blog.csdn.net/u013641234/article/details/51123648" title="http://blog.csdn.net/u013641234/article/details/51123648" target="_blank" rel="noopener">http://blog.csdn.net/u013641234/article/details/51123648</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2019/07/14/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>node version v12.14.0</p>
<p>hexo新建命令<br><code>hexo new [layout] &quot;title&quot;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>layout</th>
<th>path</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>post</td>
<td>source/_post</td>
<td>新建文章</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts/</td>
<td>新建草稿</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
<td>新建一个页面文件</td>
</tr>
</tbody>
</table>
</div>
<p>hexo发布草稿中的文章<br><code>hexo publish &lt;title&gt;</code></p>
<p><code>hexo clean  #清除缓存文件</code><br><code>hexo g      #生成静态文件</code><br><code>hexo d      #部署网站</code></p>
<hr>
<p>Ref:<br>1.<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo添加评论系统giscus</title>
    <url>/2023/04/15/hexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9Fgiscus/</url>
    <content><![CDATA[<p>如何给hexo搭建的博客添加评论系统,经过对比之后决定使用<code>giscus</code>。<code>giscus</code>有如下优点，参考<a href="https://giscus.app/zh-CN" target="_blank" rel="noopener">官网</a>。</p>
<p>本人使用的<code>hexo</code>的一些信息,使用的主题为<code>next</code>,版本为<code>7.1.2</code>。<br>查看文件<code>themes/next/package.json</code>获取版本信息。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ hexo version</span><br><span class="line">hexo: 3.9.0</span><br><span class="line">hexo-cli: 4.2.0</span><br><span class="line">os: Linux 5.15.0-67-generic linux x64</span><br><span class="line">http_parser: 2.9.3</span><br><span class="line">node: 10.19.0</span><br><span class="line">v8: 6.8.275.32-node.55</span><br><span class="line">uv: 1.34.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.15.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.40.0</span><br><span class="line">napi: 5</span><br><span class="line">openssl: 1.1.1d</span><br><span class="line">icu: 66.1</span><br><span class="line">unicode: 13.0</span><br><span class="line">cldr: 36.1</span><br><span class="line">tz: 2022g</span><br></pre></td></tr></table></figure></p>
<hr>
<p>本来是参照<a href="https://github.com/next-theme/hexo-next-giscus" target="_blank" rel="noopener">https://github.com/next-theme/hexo-next-giscus</a>进行操作的，但是根据上面的方法修改<code>_config.yml</code>部署后并没有生效，所以才有了下面的(5,6,7)步骤。如果修改<code>_config.yml</code>的方式生效则不必执行下面的<code>5,6,7</code>。</p>
<p>1.新建一个<code>github</code>仓库,此仓库必须是公开的。<br>2.安装<a href="https://github.com/apps/giscus" target="_blank" rel="noopener">giscus</a> app,否则访客将无法评论和回应。<br>3.在新建的仓库中<a href="https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/enabling-or-disabling-github-discussions-for-a-repository" target="_blank" rel="noopener">启用</a>Discussions功能<br>4.安装<code>hexo-next-giscus</code><br><code>npm install hexo-next-giscus --save</code><br>5.在<code>themes/next/layout/_macro/</code>目录下,新建文件<code>discus.swig</code>。内容如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://giscus.app/client.js&quot;</span><br><span class="line">        data-repo=&quot;[在此输入仓库]&quot;</span><br><span class="line">        data-repo-id=&quot;[在此输入仓库 ID]&quot;</span><br><span class="line">        data-category=&quot;[在此输入分类名]&quot;</span><br><span class="line">        data-category-id=&quot;[在此输入分类 ID]&quot;</span><br><span class="line">        data-mapping=&quot;pathname&quot;</span><br><span class="line">        data-strict=&quot;0&quot;</span><br><span class="line">        data-reactions-enabled=&quot;1&quot;</span><br><span class="line">        data-emit-metadata=&quot;0&quot;</span><br><span class="line">        data-input-position=&quot;bottom&quot;</span><br><span class="line">        data-theme=&quot;preferred_color_scheme&quot;</span><br><span class="line">        data-lang=&quot;zh-CN&quot;</span><br><span class="line">        crossorigin=&quot;anonymous&quot;</span><br><span class="line">        async&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果获取上面的<code>data-repo</code>,data-repo-id<code>,</code>data-category<code>,</code>data-category-id`呢?</p>
<p>打开<a href="https://giscus.app/zh-CN" target="_blank" rel="noopener">giscus.app</a>,==&gt; <em>配置</em>　==&gt; <em>仓库</em>,输入第一步新建的仓库名称,选择对应的分类，就会自动生成<code>&lt;scrip&gt;...&lt;/script&gt;</code>中的内容，直接复制就可以。<br>6.编辑<code>themes/next/layout/post.swig</code>,带<code>+</code>号的行为新增的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% extends &apos;_layout.swig&apos; %&#125;</span><br><span class="line">&#123;% import &apos;_macro/post.swig&apos; as post_template %&#125;</span><br><span class="line">&#123;% import &apos;_macro/sidebar.swig&apos; as sidebar_template %&#125;</span><br><span class="line">+ &#123;% import &apos;_macro/discus.swig&apos; as discus_template %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;&#123;&#123; page.title &#125;&#125; | &#123;&#123; title &#125;&#125;&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block page_class %&#125;page-post-detail&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt;</span><br><span class="line">    &#123;&#123; post_template.render(page) &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">+   &lt;div&gt;</span><br><span class="line">+   &#123;&#123; discus_template.render(true)&#125;&#125;</span><br><span class="line">+  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block sidebar %&#125;</span><br><span class="line">  &#123;&#123; sidebar_template.render(true) &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block script_extra %&#125;</span><br><span class="line">  &#123;% include &apos;_scripts/pages/post-details.swig&apos; %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>7.重新部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/next-theme/hexo-next-giscus" target="_blank" rel="noopener">https://github.com/next-theme/hexo-next-giscus</a><br>2.<a href="https://giscus.app/zh-CN" target="_blank" rel="noopener">https://giscus.app/zh-CN</a></p>
]]></content>
  </entry>
  <entry>
    <title>istio bookinfo</title>
    <url>/2020/06/13/istio-bookinfo/</url>
    <content><![CDATA[<p>1.安装<a href="https://istio.io/latest/zh/docs/setup/getting-started/" target="_blank" rel="noopener">istio</a>,如未安装k8s集群，可Ref<a href="https://github.com/gotok8s/gotok8s" target="_blank" rel="noopener">gotok8s</a>安装单机版集群<br><img src="http://img.hysyeah.top/2020/6/13/20200613170407-istio-system.png" alt="image"></p>
<p>2.设置<code>default</code>命名空间自动注入<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kubectl label namespace default istio-injection=enabled</span><br></pre></td></tr></table></figure></p>
<p>3.部署应用<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kubectl apply -f bookinfo.yaml</span><br></pre></td></tr></table></figure></p>
<p>4.查看<code>service</code>和<code>pods</code>是否启动<br><img src="http://img.hysyeah.top/2020/6/13/20200613173811-svc-pod.png" alt="image"></p>
<p>5.设置<code>Istio Gateway</code><br><figure class="highlight plain"><figcaption><span>apply -f bookinfo-gateway```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6.确认`Ingress`端口和`IP`</span><br><span class="line">![image](http://img.hysyeah.top/2020/6/13/20200613174652-gateway.png)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">export INGRESS_HOST=10.101.124.143</span><br><span class="line">export INGERSS_PORT=31176</span><br><span class="line">export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT</span><br></pre></td></tr></table></figure></p>
<p>7.在浏览器访问服务,<br><img src="http://img.hysyeah.top/2020/6/13/20200613170734-bookinfo-sample.png" alt="image"></p>
<p>8.访问<code>kiali</code>,在浏览器中输入对应的<code>IP</code>和<code>端口</code>。<br><img src="http://img.hysyeah.top/2020/6/13/20200613175529.png" alt="image"><br><img src="http://img.hysyeah.top/2020/6/13/20200613170855-bookinfo-kiali.png" alt="image"></p>
<hr>
<p>Ref：<br>1.<a href="https://istio.io/latest/zh/docs/examples/bookinfo/" target="_blank" rel="noopener">https://istio.io/latest/zh/docs/examples/bookinfo/</a></p>
]]></content>
  </entry>
  <entry>
    <title>jupyterhub启动容器失败</title>
    <url>/2021/12/26/jupyterhub%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p>在使用jupyterhub时候往启动的容器里挂载了一个文件很多的目录，导致容器启动报错如下。<br>配置如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">singleuser:</span><br><span class="line">  defaultUrl: &quot;/lab&quot;</span><br><span class="line">  extraEnv:</span><br><span class="line">    JUPYTERHUB_SINGLEUSER_APP: &quot;jupyter_server.serverapp.ServerApp&quot;</span><br><span class="line">  storage:</span><br><span class="line">    capacity: 20Gi</span><br><span class="line">    dynamic:</span><br><span class="line">      storageClass: managed-nfs-storage-nfs-10</span><br><span class="line">    extraVolumes:</span><br><span class="line">      - name: dataset</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: dataset-pvc</span><br><span class="line">      - name: share</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: share-pvc</span><br><span class="line">    extraVolumeMounts:</span><br><span class="line">      - name: dataset</span><br><span class="line">        mountPath: /Datasets</span><br><span class="line">      - name: share</span><br><span class="line">        mountPath: /home/jovyan/share</span><br></pre></td></tr></table></figure></p>
<p><code>Warning  FailedMount  77s    kubelet Unable to attach or mount volumes: unmounted volumes=[dataset], unattached volumes=[dataset volume-admin jupyterhub-share]: timed out waiting for the condition</code><br>因为刚开始挂载了一个文件较小的目录是能正常启动的，当又挂载了一个文件很多的目录后，容器启动失败并提示如下错误。<br>因为小目录是可以挂载成功的，所以可以排除，网络等原因，猜测可能是k8s的问题。</p>
<p>于是，自己写了个yaml文件并把pvc dataset 进行挂载，发现此时容器正常启动并无异常。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mount-test</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: mount-test</span><br><span class="line">    image: gpu-jupyter:cu111-ubuntu20.04</span><br><span class="line">    command: </span><br><span class="line">    - sleep</span><br><span class="line">    - &quot;36000&quot;</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /DataSets</span><br><span class="line">      name: dataset</span><br><span class="line">  initContainers:</span><br><span class="line">  - command:</span><br><span class="line">    - iptables</span><br><span class="line">    - -A</span><br><span class="line">    - OUTPUT</span><br><span class="line">    - -d</span><br><span class="line">    - 169.254.169.254</span><br><span class="line">    - -j</span><br><span class="line">    - DROP</span><br><span class="line">    image: jupyterhub/k8s-network-tools:1.1.4</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: bbb</span><br><span class="line">    securityContext:</span><br><span class="line">      capabilities:</span><br><span class="line">        add:</span><br><span class="line">        - NET_ADMIN</span><br><span class="line">      privileged: true</span><br><span class="line">      runAsUser: 0</span><br><span class="line">  securityContext:</span><br><span class="line">    fsGroup: 100</span><br><span class="line">  volumes:</span><br><span class="line">  - name: dataset</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: dataset-pvc</span><br></pre></td></tr></table></figure></p>
<p>于是和jupyterhub启动的容器yaml进行对比，然后不断添加配置，直到添加<code>securityContext:fsGroup:100</code>后导致容器启动失败。<br>查看k8s文档，发现当指定了fsGroup后，当挂载文件时，k8s会对文件的所有权和权限进行检查和修改，导致容器启动缓慢，并会打印出mount 失败的日志。</p>
<p>解决方法：<br>1.不挂载大目录<br>2.删除fsGroup配置</p>
<p>修改jupyterhub的config配置，改为如下,然后<code>helm upgrade</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">singleuser:</span><br><span class="line">  fsGid: null</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<hr>
<p>1.<a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#configure-volume-permission-and-ownership-change-policy-for-pods" target="_blank" rel="noopener">k8s-security-context</a></p>
]]></content>
  </entry>
  <entry>
    <title>k8s Indexer索引器实现</title>
    <url>/2021/07/11/k8s-Indexer%E7%B4%A2%E5%BC%95%E5%99%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>1.Indexer是什么？<br>Indexer是client-go用来存储资源对象并自带索引功能的本地存储(内存)，Reflector从DeltaFIFO中将消费出来的资源对象存储到Indexer。Indexer中的数据与Etcd集群中的数据保持完全一致。client-go可以很方便的从本地存储(内存)读取相应的资源对象数据，而不用每次都远程从Etcd集群中读取数据，减轻kube-apiserver和Etcd的压力。</p>
<p>2.Indexer涉及到的数据结构<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/client-go/tools/cache/index.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储缓存数据</span></span><br><span class="line"><span class="keyword">type</span> Index <span class="keyword">map</span>[<span class="keyword">string</span>]sets.String</span><br><span class="line"><span class="comment">// 索引器,key为索引器名称;value为索引器的实现函数</span></span><br><span class="line"><span class="keyword">type</span> Indexers <span class="keyword">map</span>[<span class="keyword">string</span>]IndexFunc</span><br><span class="line"><span class="comment">// 索引器实现函数,接受一个资源对象返回一个字符串列表</span></span><br><span class="line"><span class="keyword">type</span> IndexFunc <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key这索引器名称,value为Index</span></span><br><span class="line"><span class="keyword">type</span> Indices <span class="keyword">map</span>[<span class="keyword">string</span>]Index</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging/src/k8s.io/client-go/tools/cache/thread_safe_store.go</span></span><br><span class="line"><span class="comment">// cache.NewIndexer返回一个Indexer对象，为cache&#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 可看作一个并发安全的Map,并实现了ByIndex方法(下文会用到),</span></span><br><span class="line">    cacheStorage ThreadSafeStore</span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadSafeStore的实现</span></span><br><span class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock sync.RWMutex</span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    indexers Indexers</span><br><span class="line">    indices Indices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.通过一个例子了解Indexer的使用和实现</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码来自于&lt;&lt;kubernetes源码剖析&gt;&gt;</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"k8s.io/api/core/v1"</span></span><br><span class="line">	metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/tools/cache"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UsersIndexFunc</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	pod := obj.(*v1.Pod)</span><br><span class="line">	userString := pod.Annotations[<span class="string">"users"</span>]</span><br><span class="line">	<span class="keyword">return</span> strings.Split(userString, <span class="string">","</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化一个Indexer对象,第一个参数为计算对象key值的函数,第二个参数用于定义索引器,其中key为索引器名称(byUser),值为索引器函数</span></span><br><span class="line">	index := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers&#123;</span><br><span class="line">		<span class="string">"byUser"</span>: UsersIndexFunc,</span><br><span class="line">	&#125;)</span><br><span class="line">	pod1 := &amp;v1.Pod&#123;ObjectMeta: metav1.ObjectMeta&#123;Name: <span class="string">"one"</span>,</span><br><span class="line">		Annotations: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"users"</span>: <span class="string">"ernie,bert"</span>&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加pod对象到index</span></span><br><span class="line">	index.Add(pod1)</span><br><span class="line">    <span class="comment">// 执行索引器得到索引结果</span></span><br><span class="line">	erniePods, err := index.ByIndex(<span class="string">"byUser"</span>, <span class="string">"ernie"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, erniePod := <span class="keyword">range</span> erniePods &#123;</span><br><span class="line">		fmt.Println(erniePod.(*v1.Pod).Name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.程序执行步骤<br> 初始化后的index对象,items和indices都为空<br><img src="http://img.hysyeah.top/2021/7/20210711081147-index1.png" alt="image"><br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.Add(pod1)</span></span><br><span class="line"><span class="comment">// 将资源对象添加到缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算对象的key</span></span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.cacheStorage.Add(key, obj)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正将资源对象添加到缓存中的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *threadSafeMap)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	c.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line">    oldObject := c.items[key]</span><br><span class="line">    <span class="comment">// 添加数据到缓存中</span></span><br><span class="line">    c.items[key] = obj</span><br><span class="line">    <span class="comment">// 更新indices</span></span><br><span class="line">	c.updateIndices(oldObject, obj, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *threadSafeMap)</span> <span class="title">updateIndices</span><span class="params">(oldObj <span class="keyword">interface</span>&#123;&#125;, newObj <span class="keyword">interface</span>&#123;&#125;, key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// if we got an old object, we need to remove it before we add it again</span></span><br><span class="line">	<span class="keyword">if</span> oldObj != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.deleteFromIndices(oldObj, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历索引器</span></span><br><span class="line">	<span class="keyword">for</span> name, indexFunc := <span class="keyword">range</span> c.indexers &#123;</span><br><span class="line">        <span class="comment">// indexValues = ['ernie','bert']</span></span><br><span class="line">		indexValues, err := indexFunc(newObj)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Errorf(<span class="string">"unable to calculate an index entry for key %q on index %q: %v"</span>, key, name, err))</span><br><span class="line">		&#125;</span><br><span class="line">        index := c.indices[name]</span><br><span class="line">        <span class="comment">// 判断Index是否存在,不存在则新建</span></span><br><span class="line">		<span class="keyword">if</span> index == <span class="literal">nil</span> &#123;</span><br><span class="line">			index = Index&#123;&#125;</span><br><span class="line">			c.indices[name] = index</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历indexValues(['ernie','bert']),构建一个反向映射，从indexValue指向key</span></span><br><span class="line">        <span class="comment">// 类似于构建成&#123;"ernie":"one","bert":"one"&#125;字典结构,用于快速通过索引找到对应的资源对象</span></span><br><span class="line">		<span class="keyword">for</span> _, indexValue := <span class="keyword">range</span> indexValues &#123;</span><br><span class="line">			set := index[indexValue]</span><br><span class="line">			<span class="keyword">if</span> set == <span class="literal">nil</span> &#123;</span><br><span class="line">				set = sets.String&#123;&#125;</span><br><span class="line">				index[indexValue] = set</span><br><span class="line">			&#125;</span><br><span class="line">			set.Insert(key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行完Add操作后的对象<br><img src="http://img.hysyeah.top/2021/7/20210711083021-index2.png" alt="image"></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.ByIndex 通过索引查询资源对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">ByIndex</span><span class="params">(indexName, indexKey <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.cacheStorage.ByIndex(indexName, indexKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *threadSafeMap)</span> <span class="title">ByIndex</span><span class="params">(indexName, indexedValue <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	c.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引器名称(此例为:byUser)，获取索引器函数</span></span><br><span class="line">	indexFunc := c.indexers[indexName]</span><br><span class="line">	<span class="keyword">if</span> indexFunc == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Index with name %s does not exist"</span>, indexName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引器名称,获取对应的缓存数据</span></span><br><span class="line">	index := c.indices[indexName]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取index对应的值，此例indexedValue=ernie,set=&#123;"one"&#125;</span></span><br><span class="line">	set := index[indexedValue]</span><br><span class="line">    list := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, set.Len())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历set,从缓存中取出对象并返回</span></span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> set &#123;</span><br><span class="line">		list = <span class="built_in">append</span>(list, c.items[key])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> list, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.小结<br>Indexer通过索引器函数来实现索引的可定制化，用户可以定制自己的索引器实现函数，实现自定义条件查询。Index构建了一个类似于map的结构(只不过值为k8s实现的set类型)，键为索引，值为资源对象通过<code>keyFunc</code>计算出来的key，可提供快速查询的功能。要想更好理解的话，最好自己调试一下。</p>
<hr>
<p>1.Kubernetes源码剖析</p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s controller-expectation</title>
    <url>/2023/06/15/k8s-controller-expectation/</url>
    <content><![CDATA[<h5 id="Controller-Expectation"><a href="#Controller-Expectation" class="headerlink" title="Controller Expectation"></a>Controller Expectation</h5><p>在<code>Kubernetes中</code>，<code>Controller Expectation</code>（控制器期望机制）是一种用于协调多个控制器对共享资源的操作的机制。它通过维护每个控制器对资源的期望状态，以确保只有一个控制器能够成功执行操作。</p>
<p>该机制的实现是通过<code>Expectations</code>对象来管理的。<code>Expectations</code>对象是一个保存了资源键（Resource Key）和期望计数（Expectation Count）之间映射关系的数据结构。每个控制器都可以通过<code>Expectations</code>对象来声明它对某个资源键的期望计数。</p>
<p>当控制器需要执行对资源的操作时，它会先检查<code>Expectations</code>对象中对应资源键的期望计数是否满足要求。如果满足，则该控制器可以执行操作，并将期望计数减一。如果不满足，则跳过对应的操作</p>
<p>通过使用<code>Controller Expectation</code>机制，可以有效地协调多个控制器并发对共享资源进行操作，避免了冲突和竞争条件的发生。这种机制能够确保每个控制器在执行操作之前都满足了其期望的前置条件，从而保证了系统的一致性和正确性。</p>
<h5 id="Controller-Expectation实现"><a href="#Controller-Expectation实现" class="headerlink" title="Controller Expectation实现"></a>Controller Expectation实现</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/controller_utils.go</span></span><br><span class="line"><span class="comment">//	ControllerExpectations: &#123;</span></span><br><span class="line"><span class="comment">//		controller1: expects  2 adds in 2 minutes</span></span><br><span class="line"><span class="comment">//		controller2: expects  2 dels in 2 minutes</span></span><br><span class="line"><span class="comment">//		controller3: expects -1 adds in 2 minutes =&gt; 表示已经达到期望状态</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现：</span></span><br><span class="line"><span class="comment">// ControlleeExpectation: 通过原子计数来追踪controllee的creation/deletion</span></span><br><span class="line"><span class="comment">// ControllerExpectationsStore: TTLStore + 每个controller设置ControlleeExpectation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个controller不会再执行sync直到它的expections状态为fulfilled或expire</span></span><br><span class="line"><span class="comment">// 没有设置expections的Controller将被唤醒以处理每个匹配的控制对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了需要实现的方法</span></span><br><span class="line"><span class="keyword">type</span> ControllerExpectationsInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetExpectations(controllerKey <span class="keyword">string</span>) (*ControlleeExpectations, <span class="keyword">bool</span>, error)</span><br><span class="line">	SatisfiedExpectations(controllerKey <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line">	DeleteExpectations(controllerKey <span class="keyword">string</span>)</span><br><span class="line">	SetExpectations(controllerKey <span class="keyword">string</span>, add, del <span class="keyword">int</span>) error</span><br><span class="line">	ExpectCreations(controllerKey <span class="keyword">string</span>, adds <span class="keyword">int</span>) error</span><br><span class="line">	ExpectDeletions(controllerKey <span class="keyword">string</span>, dels <span class="keyword">int</span>) error</span><br><span class="line">	CreationObserved(controllerKey <span class="keyword">string</span>)</span><br><span class="line">	DeletionObserved(controllerKey <span class="keyword">string</span>)</span><br><span class="line">	RaiseExpectations(controllerKey <span class="keyword">string</span>, add, del <span class="keyword">int</span>)</span><br><span class="line">	LowerExpectations(controllerKey <span class="keyword">string</span>, add, del <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ControllerExpectations is a cache mapping controllers to what they expect to see before being woken up for a sync.</span></span><br><span class="line"><span class="keyword">type</span> ControllerExpectations <span class="keyword">struct</span> &#123;</span><br><span class="line">	cache.Store</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControllerExpectations)</span> <span class="title">GetExpectations</span><span class="params">(controllerKey <span class="keyword">string</span>)</span> <span class="params">(*ControlleeExpectations, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	exp, exists, err := r.GetByKey(controllerKey)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">		<span class="keyword">return</span> exp.(*ControlleeExpectations), <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeleteExpectations deletes the expectations of the given controller from the TTLStore.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControllerExpectations)</span> <span class="title">DeleteExpectations</span><span class="params">(controllerKey <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> exp, exists, err := r.GetByKey(controllerKey); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">		<span class="keyword">if</span> err := r.Delete(exp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">"Error deleting expectations for controller %v: %v"</span>, controllerKey, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControllerExpectations)</span> <span class="title">SatisfiedExpectations</span><span class="params">(controllerKey <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> exp, exists, err := r.GetExpectations(controllerKey); exists &#123;</span><br><span class="line">		<span class="keyword">if</span> exp.Fulfilled() &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"Controller expectations fulfilled %#v"</span>, exp)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> exp.isExpired() &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"Controller expectations expired %#v"</span>, exp)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"Controller still waiting on expectations %#v"</span>, exp)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).Infof(<span class="string">"Error encountered while checking expectations %#v, forcing sync"</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// When a new controller is created, it doesn't have expectations.</span></span><br><span class="line">		<span class="comment">// When it doesn't see expected watch events for &gt; TTL, the expectations expire.</span></span><br><span class="line">		<span class="comment">//	- In this case it wakes up, creates/deletes controllees, and sets expectations again.</span></span><br><span class="line">		<span class="comment">// When it has satisfied expectations and no controllees need to be created/destroyed &gt; TTL, the expectations expire.</span></span><br><span class="line">		<span class="comment">//	- In this case it continues without setting expectations till it needs to create/delete controllees.</span></span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"Controller %v either never recorded expectations, or the ttl expired."</span>, controllerKey)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Trigger a sync if we either encountered and error (which shouldn't happen since we're</span></span><br><span class="line">	<span class="comment">// getting from local store) or this controller hasn't established expectations.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(exp *ControlleeExpectations)</span> <span class="title">isExpired</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> clock.RealClock&#123;&#125;.Since(exp.timestamp) &gt; ExpectationsTimeout</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetExpectations registers new expectations for the given controller. Forgets existing expectations.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControllerExpectations)</span> <span class="title">SetExpectations</span><span class="params">(controllerKey <span class="keyword">string</span>, add, del <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	exp := &amp;ControlleeExpectations&#123;add: <span class="keyword">int64</span>(add), del: <span class="keyword">int64</span>(del), key: controllerKey, timestamp: clock.RealClock&#123;&#125;.Now()&#125;</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"Setting expectations %#v"</span>, exp)</span><br><span class="line">	<span class="keyword">return</span> r.Add(exp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControllerExpectations)</span> <span class="title">ExpectCreations</span><span class="params">(controllerKey <span class="keyword">string</span>, adds <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.SetExpectations(controllerKey, adds, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControllerExpectations)</span> <span class="title">ExpectDeletions</span><span class="params">(controllerKey <span class="keyword">string</span>, dels <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.SetExpectations(controllerKey, <span class="number">0</span>, dels)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decrements the expectation counts of the given controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControllerExpectations)</span> <span class="title">LowerExpectations</span><span class="params">(controllerKey <span class="keyword">string</span>, add, del <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> exp, exists, err := r.GetExpectations(controllerKey); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">		exp.Add(<span class="keyword">int64</span>(-add), <span class="keyword">int64</span>(-del))</span><br><span class="line">		<span class="comment">// The expectations might've been modified since the update on the previous line.</span></span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"Lowered expectations %#v"</span>, exp)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Increments the expectation counts of the given controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControllerExpectations)</span> <span class="title">RaiseExpectations</span><span class="params">(controllerKey <span class="keyword">string</span>, add, del <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> exp, exists, err := r.GetExpectations(controllerKey); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">		exp.Add(<span class="keyword">int64</span>(add), <span class="keyword">int64</span>(del))</span><br><span class="line">		<span class="comment">// The expectations might've been modified since the update on the previous line.</span></span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"Raised expectations %#v"</span>, exp)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreationObserved atomically decrements the `add` expectation count of the given controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControllerExpectations)</span> <span class="title">CreationObserved</span><span class="params">(controllerKey <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	r.LowerExpectations(controllerKey, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeletionObserved atomically decrements the `del` expectation count of the given controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ControllerExpectations)</span> <span class="title">DeletionObserved</span><span class="params">(controllerKey <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	r.LowerExpectations(controllerKey, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ControlleeExpectations track controllee creates/deletes.</span></span><br><span class="line"><span class="keyword">type</span> ControlleeExpectations <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// See: https://golang.org/pkg/sync/atomic/ for more information</span></span><br><span class="line">	add       <span class="keyword">int64</span></span><br><span class="line">	del       <span class="keyword">int64</span></span><br><span class="line">	key       <span class="keyword">string</span></span><br><span class="line">	timestamp time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add increments the add and del counters.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ControlleeExpectations)</span> <span class="title">Add</span><span class="params">(add, del <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	atomic.AddInt64(&amp;e.add, add)</span><br><span class="line">	atomic.AddInt64(&amp;e.del, del)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fulfilled returns true if this expectation has been fulfilled.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ControlleeExpectations)</span> <span class="title">Fulfilled</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> think about why this line being atomic doesn't matter</span></span><br><span class="line">	<span class="keyword">return</span> atomic.LoadInt64(&amp;e.add) &lt;= <span class="number">0</span> &amp;&amp; atomic.LoadInt64(&amp;e.del) &lt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetExpectations returns the add and del expectations of the controllee.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ControlleeExpectations)</span> <span class="title">GetExpectations</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atomic.LoadInt64(&amp;e.add), atomic.LoadInt64(&amp;e.del)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="expection在replicaSetController中的使用"><a href="#expection在replicaSetController中的使用" class="headerlink" title="expection在replicaSetController中的使用"></a>expection在replicaSetController中的使用</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/replicaset/replica_set.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBaseController</span><span class="params">(rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, kubeClient clientset.Interface, burstReplicas <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	gvk schema.GroupVersionKind, metricOwnerName, queueName <span class="keyword">string</span>, podControl controller.PodControlInterface, eventBroadcaster record.EventBroadcaster)</span> *<span class="title">ReplicaSetController</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	rsc := &amp;ReplicaSetController&#123;</span><br><span class="line">		GroupVersionKind: gvk,</span><br><span class="line">		kubeClient:       kubeClient,</span><br><span class="line">		podControl:       podControl,</span><br><span class="line">		eventBroadcaster: eventBroadcaster,</span><br><span class="line">		burstReplicas:    burstReplicas,</span><br><span class="line">        <span class="comment">// 设置expectations</span></span><br><span class="line">		expectations:     controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectations()),</span><br><span class="line">		queue:            workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), queueName),</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/controller/controller_utils.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUIDTrackingControllerExpectations</span><span class="params">(ce ControllerExpectationsInterface)</span> *<span class="title">UIDTrackingControllerExpectations</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;UIDTrackingControllerExpectations&#123;ControllerExpectationsInterface: ce, uidStore: cache.NewStore(UIDSetKeyFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现了ControllerExpectationsInterface接口</span></span><br><span class="line"><span class="keyword">type</span> UIDTrackingControllerExpectations <span class="keyword">struct</span> &#123;</span><br><span class="line">	ControllerExpectationsInterface</span><br><span class="line">	uidStoreLock sync.Mutex</span><br><span class="line">	<span class="comment">// Store used for the UIDs associated with any expectation tracked via the</span></span><br><span class="line">	<span class="comment">// ControllerExpectationsInterface.</span></span><br><span class="line">	uidStore cache.Store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/replicaset/replica_set.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">syncReplicaSet</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	rs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">		klog.FromContext(ctx).V(<span class="number">4</span>).Info(<span class="string">"deleted"</span>, <span class="string">"kind"</span>, rsc.Kind, <span class="string">"key"</span>, key)</span><br><span class="line">        <span class="comment">// 删除对应的key</span></span><br><span class="line">		rsc.expectations.DeleteExpectations(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	rsNeedsSync := rsc.expectations.SatisfiedExpectations(key)</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">var</span> manageReplicasErr error</span><br><span class="line">    <span class="comment">// 如果rsNeedsSync不为true,说明有Controller正在执行对应调谐操作</span></span><br><span class="line">    <span class="comment">// 这时当时Controller则不会执行manageReplicas,也就是真正的调谐操作</span></span><br><span class="line">	<span class="keyword">if</span> rsNeedsSync &amp;&amp; rs.DeletionTimestamp == <span class="literal">nil</span> &#123;</span><br><span class="line">		manageReplicasErr = rsc.manageReplicas(ctx, filteredPods, rs)</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">manageReplicas</span><span class="params">(ctx context.Context, filteredPods []*v1.Pod, rs *apps.ReplicaSet)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> diff &lt; <span class="number">0</span> &#123;</span><br><span class="line">		diff *= <span class="number">-1</span></span><br><span class="line">		<span class="keyword">if</span> diff &gt; rsc.burstReplicas &#123;</span><br><span class="line">			diff = rsc.burstReplicas</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Track UIDs of creates just like deletes. The problem currently</span></span><br><span class="line">		<span class="comment">// is we'd need to wait on the result of a create to record the pod's</span></span><br><span class="line">		<span class="comment">// UID, which would require locking *across* the create, which will turn</span></span><br><span class="line">		<span class="comment">// into a performance bottleneck. We should generate a UID for the pod</span></span><br><span class="line">		<span class="comment">// beforehand and store it via ExpectCreations.</span></span><br><span class="line">        <span class="comment">// 添加期望数diff</span></span><br><span class="line">		rsc.expectations.ExpectCreations(rsKey, diff)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> skippedPods := diff - successfulCreations; skippedPods &gt; <span class="number">0</span> &#123;</span><br><span class="line">			klog.FromContext(ctx).V(<span class="number">2</span>).Info(<span class="string">"Slow-start failure. Skipping creation of pods, decrementing expectations"</span>, <span class="string">"podsSkipped"</span>, skippedPods, <span class="string">"kind"</span>, rsc.Kind, <span class="string">"replicaSet"</span>, klog.KObj(rs))</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; skippedPods; i++ &#123;</span><br><span class="line">				<span class="comment">// Decrement the expected number of creates because the informer won't observe this pod</span></span><br><span class="line">                <span class="comment">// 忽略的pod说明不是期望的，这里要减去</span></span><br><span class="line">				rsc.expectations.CreationObserved(rsKey)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> diff &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 说明需要缩容</span></span><br><span class="line">		<span class="keyword">if</span> diff &gt; rsc.burstReplicas &#123;</span><br><span class="line">			diff = rsc.burstReplicas</span><br><span class="line">		&#125;</span><br><span class="line">		klog.FromContext(ctx).V(<span class="number">2</span>).Info(<span class="string">"Too many replicas"</span>, <span class="string">"replicaSet"</span>, klog.KObj(rs), <span class="string">"need"</span>, *(rs.Spec.Replicas), <span class="string">"deleting"</span>, diff)</span><br><span class="line"></span><br><span class="line">		relatedPods, err := rsc.getIndirectlyRelatedPods(klog.FromContext(ctx), rs)</span><br><span class="line">		utilruntime.HandleError(err)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Choose which Pods to delete, preferring those in earlier phases of startup.</span></span><br><span class="line">		podsToDelete := getPodsToDelete(filteredPods, relatedPods, diff)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Snapshot the UIDs (ns/name) of the pods we're expecting to see</span></span><br><span class="line">		<span class="comment">// deleted, so we know to record their expectations exactly once either</span></span><br><span class="line">		<span class="comment">// when we see it as an update of the deletion timestamp, or as a delete.</span></span><br><span class="line">		<span class="comment">// Note that if the labels on a pod/rs change in a way that the pod gets</span></span><br><span class="line">		<span class="comment">// orphaned, the rs will only wake up after the expectations have</span></span><br><span class="line">		<span class="comment">// expired even if other pods are deleted.</span></span><br><span class="line">		rsc.expectations.ExpectDeletions(rsKey, getPodKeys(podsToDelete))</span><br><span class="line"></span><br><span class="line">		errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, diff)</span><br><span class="line">		<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">		wg.Add(diff)</span><br><span class="line">		<span class="keyword">for</span> _, pod := <span class="keyword">range</span> podsToDelete &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(targetPod *v1.Pod)</span></span> &#123;</span><br><span class="line">				<span class="keyword">defer</span> wg.Done()</span><br><span class="line">				<span class="keyword">if</span> err := rsc.podControl.DeletePod(ctx, rs.Namespace, targetPod.Name, rs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="comment">// Decrement the expected number of deletes because the informer won't observe this deletion</span></span><br><span class="line">					podKey := controller.PodKey(targetPod)</span><br><span class="line">                    <span class="comment">// 删除了一个pod, expectations上也要减去</span></span><br><span class="line">					rsc.expectations.DeletionObserved(rsKey, podKey)</span><br><span class="line">					<span class="keyword">if</span> !apierrors.IsNotFound(err) &#123;</span><br><span class="line">						klog.FromContext(ctx).V(<span class="number">2</span>).Info(<span class="string">"Failed to delete pod, decremented expectations"</span>, <span class="string">"pod"</span>, podKey, <span class="string">"kind"</span>, rsc.Kind, <span class="string">"replicaSet"</span>, klog.KObj(rs))</span><br><span class="line">						errCh &lt;- err</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(pod)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> err := &lt;-errCh:</span><br><span class="line">			<span class="comment">// all errors have been reported before and they're likely to be the same, so we'll only return the first one we hit.</span></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">deleteRS</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	rs, ok := obj.(*apps.ReplicaSet)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delete expectations for the ReplicaSet so if we create a new one with the same name it starts clean</span></span><br><span class="line">	rsc.expectations.DeleteExpectations(key)</span><br><span class="line"></span><br><span class="line">	rsc.queue.Add(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// When a pod is created, enqueue the replica set that manages it and update its expectations.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">addPod</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	pod := obj.(*v1.Pod)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pod.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// on a restart of the controller manager, it's possible a new pod shows up in a state that</span></span><br><span class="line">		<span class="comment">// is already pending deletion. Prevent the pod from being a creation observation.</span></span><br><span class="line">		rsc.deletePod(pod)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If it has a ControllerRef, that's all that matters.</span></span><br><span class="line">	<span class="keyword">if</span> controllerRef := metav1.GetControllerOf(pod); controllerRef != <span class="literal">nil</span> &#123;</span><br><span class="line">		rs := rsc.resolveControllerRef(pod.Namespace, controllerRef)</span><br><span class="line">		<span class="keyword">if</span> rs == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		rsKey, err := controller.KeyFunc(rs)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"Pod %s created: %#v."</span>, pod.Name, pod)</span><br><span class="line">        <span class="comment">// pod创建成功，需要减去pod的期望数</span></span><br><span class="line">		rsc.expectations.CreationObserved(rsKey)</span><br><span class="line">		rsc.queue.Add(rsKey)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// When a pod is deleted, enqueue the replica set that manages the pod and update its expectations.</span></span><br><span class="line"><span class="comment">// obj could be an *v1.Pod, or a DeletionFinalStateUnknown marker item.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">deletePod</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	pod, ok := obj.(*v1.Pod)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	controllerRef := metav1.GetControllerOf(pod)</span><br><span class="line">	<span class="keyword">if</span> controllerRef == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// No controller should care about orphans being deleted.</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	rs := rsc.resolveControllerRef(pod.Namespace, controllerRef)</span><br><span class="line">	<span class="keyword">if</span> rs == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	rsKey, err := controller.KeyFunc(rs)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"couldn't get key for object %#v: %v"</span>, rs, err))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"Pod %s/%s deleted through %v, timestamp %+v: %#v."</span>, pod.Namespace, pod.Name, utilruntime.GetCaller(), pod.DeletionTimestamp, pod)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同样当删除了一个pod,期望删除的pod数也更新</span></span><br><span class="line">	rsc.expectations.DeletionObserved(rsKey, controller.PodKey(pod))</span><br><span class="line">	rsc.queue.Add(rsKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/controller_utils.go" target="_blank" rel="noopener">pkg/controller/controller_utils.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/replicaset/replica_set.go" target="_blank" rel="noopener">pkg/controller/replicaset/replica_set.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/controller_utils.go" target="_blank" rel="noopener">pkg/controller/controller_utils.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s Pod Qos</title>
    <url>/2023/06/18/k8s-Pod-Qos/</url>
    <content><![CDATA[<h5 id="QOS"><a href="#QOS" class="headerlink" title="QOS"></a>QOS</h5><p><code>Qos</code>(Quality of Service),<code>k8s</code>会根据<code>Pod</code>容器中指定的资源约束为每个<code>Pod</code>设置<code>QoS</code>类。<code>k8s</code>依赖这种分类来决定当<code>Node</code>上没有足够可用资源时要驱逐哪些 <code>Pod</code>。</p>
<p><code>QoS</code> 类<br><code>k8s</code> 对你运行的 <code>Pod</code> 进行分类，并将每个 <code>Pod</code> 分配到特定的 <code>QoS</code>类中。 <code>k8s</code> 使用这种分类来影响不同 <code>Pod</code> 被处理的方式。<code>k8s</code> 基于 <code>Pod</code> 中容器的资源请求进行分类， 同时确定这些请求如何与资源限制相关。 这称为服务质量 (QoS) 类。 <code>k8s</code> 基于每个 Pod 中容器的资源请求和限制为 <code>Pod</code> 设置 <code>QoS</code> 。<code>k8s</code> 使用 <code>QoS</code> 类来决定从遇到节点压力的 <code>Node</code> 中驱逐哪些 <code>Pod</code>。可选的 <code>QoS</code> 类有 <code>Guaranteed</code>、<code>Burstable</code> 和 <code>BestEffort</code>。 当一个 <code>Node</code> 耗尽资源时，<code>k8s</code> 将首先驱逐在该 <code>Node</code> 上运行的 <code>BestEffort Pod</code>， 然后是 <code>Burstable Pod</code>，最后是 <code>Guaranteed Pod</code>。当这种驱逐是由于资源压力时， 只有超出资源请求的 <code>Pod</code> 才是被驱逐的候选对象。</p>
<h6 id="Guaranteed"><a href="#Guaranteed" class="headerlink" title="Guaranteed"></a>Guaranteed</h6><p><code>Guaranteed Pod</code> 具有最严格的资源限制，并且最不可能面临驱逐。 在这些 <code>Pod</code> 超过其自身的限制或者没有可以从 <code>Node</code> 抢占的低优先级 <code>Pod</code> 之前， 这些 <code>Pod</code> 保证不会被杀死。这些 <code>Pod</code> 不可以获得超出其指定 <code>limit</code> 的资源。这些 <code>Pod</code> 也可以使用 <code>static CPU</code> 管理策略来使用独占的 <code>CPU</code>。</p>
<p><code>Pod</code> 被赋予 <code>Guaranteed QoS</code> 类的几个依据：</p>
<ul>
<li><code>Pod</code> 中的每个容器必须有内存 <code>limit</code> 和内存 <code>request</code>。</li>
<li>对于 <code>Pod</code> 中的每个容器，内存 <code>limit</code> 必须等于内存 <code>request</code>。</li>
<li><code>Pod</code> 中的每个容器必须有 <code>CPU limit</code> 和 <code>CPU request</code>。</li>
<li>对于 <code>Pod</code> 中的每个容器，<code>CPU limit</code> 必须等于 <code>CPU request</code>。</li>
</ul>
<h6 id="Burstable"><a href="#Burstable" class="headerlink" title="Burstable"></a>Burstable</h6><p><code>Burstable Pod</code> 有一些基于 <code>request</code> 的资源下限保证，但不需要特定的 <code>limit</code>。 如果未指定 <code>limit</code>，则默认为其 <code>limit</code> 等于 <code>Node</code> 容量，这允许 <code>Pod</code> 在资源可用时灵活地增加其资源。 在由于 <code>Node</code> 资源压力导致 <code>Pod</code> 被驱逐的情况下，只有在所有 <code>BestEffort Pod</code> 被驱逐后 这些 <code>Pod</code> 才会被驱逐。因为 <code>Burstable Pod</code> 可以包括没有资源 <code>limit</code> 或资源 <code>request</code> 的容器， 所以 <code>Burstable Pod</code> 可以尝试使用任意数量的节点资源。</p>
<p><code>Pod</code>被赋予 <code>Burstable QoS</code> 类的几个依据：</p>
<ul>
<li><code>Pod</code> 不满足针对 QoS 类 <code>Guaranteed</code> 的判据。</li>
<li><code>Pod</code> 中至少一个容器有内存或 <code>CPU</code> 的 <code>request</code> 或 <code>limit</code>。</li>
</ul>
<h6 id="BestEffort"><a href="#BestEffort" class="headerlink" title="BestEffort"></a>BestEffort</h6><p><code>BestEffort QoS</code> 类中的 <code>Pod</code> 可以使用未专门分配给其他 <code>QoS</code> 类中的 <code>Pod</code> 的节点资源。 例如若你有一个节点有 16 核 CPU 可供 kubelet 使用，并且你将 4 核 CPU 分配给一个 <code>Guaranteed Pod</code>， 那么 <code>BestEffort QoS</code> 类中的 <code>Pod</code> 可以尝试任意使用剩余的 12 核 CPU。</p>
<p>如果节点遇到资源压力，kubelet 将优先驱逐 <code>BestEffort Pod</code>。</p>
<p>如果 Pod 不满足 <code>Guaranteed</code> 或 <code>Burstable</code> 的判据，则它的 <code>QoS</code> 类为 <code>BestEffort</code>。 换言之，只有当 <code>Pod</code> 中的所有容器没有内存 <code>limit</code> 或内存 <code>request</code>，也没有 <code>CPU limit</code> 或 <code>CPU request</code> 时，<code>Pod</code> 才是 <code>BestEffort</code>。<code>Pod</code> 中的容器可以请求（除 CPU 或内存之外的） 其他资源并且仍然被归类为 <code>BestEffort</code>。</p>
<p>以上来自<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-qos/" target="_blank" rel="noopener">k8s文档</a></p>
<hr>
<h5 id="Qos与cgroup的关系"><a href="#Qos与cgroup的关系" class="headerlink" title="Qos与cgroup的关系"></a>Qos与cgroup的关系</h5><h6 id="创建不同Qos的pod"><a href="#创建不同Qos的pod" class="headerlink" title="创建不同Qos的pod"></a>创建不同Qos的pod</h6><p>使用下面的<code>yaml</code>文件创建对应的`pod<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">guaranteed</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hysyeah/my-curl:v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line"><span class="string">--</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">burstable</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hysyeah/my-curl:v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">"64Mi"</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">"250m"</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">besteffort</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hysyeah/my-curl:v1</span></span><br></pre></td></tr></table></figure></p>
<p>当我们<code>apply</code>这个<code>yaml</code>文件后，<code>Pod</code>会被调度到对应的<code>Node</code>,<code>kubelet</code>会将<code>PodSpec</code>中的内容传递给<code>CRI</code>,<code>CRI</code>再将这此内容翻译成<br>更底层的<a href="https://github.com/opencontainers/runtime-spec/blob/main/config.md#configuration-schema-example" target="_blank" rel="noopener">OCI JSON Spec</a>描述容器创建的信息。</p>
<p><code>crictl inspect &lt;containerID&gt;</code>查看对应的资源信息<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0e5962a09e2d3的部分内容</span></span><br><span class="line"><span class="comment">// 包括了资源的限制信息及cgroupsPath</span></span><br><span class="line">"linux": &#123;</span><br><span class="line">        "resources": &#123;</span><br><span class="line">          "devices": [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"allow"</span>: <span class="literal">false</span>,</span><br><span class="line">              <span class="attr">"access"</span>: <span class="string">"rwm"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          "memory": &#123;</span><br><span class="line">            "limit": 67108864 // 64M</span><br><span class="line">          &#125;,</span><br><span class="line">          "cpu": &#123;</span><br><span class="line">            "shares": 256,</span><br><span class="line">            "quota": 25000,</span><br><span class="line">            "period": 100000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "cgroupsPath": "/kubepods/pod21ef5ccc-a09d-4754-aa1e-a65820d572cc/0e5962a09e2d3840e4f6ae1a3750136ad578c3df026a8dd64b175f8e33570823",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建完成后你可以查看对应<code>pod</code>的<code>Qos</code>。<br><code>k describe pod &lt;pod-name&gt;</code><br><img src="https://img.hysyeah.top/2023/6/guaranteed-20230618114018.png" alt="image"></p>
<h6 id="查看系统中的cgroups"><a href="#查看系统中的cgroups" class="headerlink" title="查看系统中的cgroups"></a>查看系统中的cgroups</h6><ol>
<li><p>节点系统信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">✗ uname -a</span><br><span class="line">Linux hysyeah 5.15.0-72-generic #79~20.04.1-Ubuntu SMP Thu Apr 20 22:12:07 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> cgroups版本</span><br><span class="line"><span class="meta">#</span> 对于 cgroup v2，输出为 cgroup2fs</span><br><span class="line"><span class="meta">#</span> 对于 cgroup v1，输出为 tmpfs</span><br><span class="line">➜ stat -fc %T /sys/fs/cgroup/</span><br><span class="line">tmpfs</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器相关信息<code>crictl ps</code>,对应的<code>PodID</code>和<code>ContainerID</code>下面我们会使用到<br><img src="https://img.hysyeah.top/2023/6/crictl-ps-20230618123811.png" alt="image"></p>
</li>
<li><p><code>cgroups</code>的目录为<code>/sys/fs/cgroup</code>,我们只关注<code>cpu</code>和<code>memory</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  cgroup ls</span><br><span class="line">blkio  cpu  cpuacct  cpu,cpuacct  cpuset  devices  freezer  hugetlb  memory  misc  net_cls  net_cls,net_prio  net_prio  perf_event  pids  rdma  systemd  unified</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://img.hysyeah.top/2023/6/cpu-20230618130040.png" alt="image"><br><img src="https://img.hysyeah.top/2023/6/memory-20230618130004.png" alt="image"></p>
<p>可以看到<code>cpu</code>和<code>memory</code>目录下都有一个名为<code>kubepods</code>的目录，<code>k8s</code>相关的<code>cgroups</code>就是放在这个目录下的。<br>以<code>memory/kubepods</code>为例：<br>其中<code>Qos</code>为<code>burstable</code>和<code>besteffort</code>的<code>Pod</code>的<code>cgroup</code>信息分别放在目录<code>burstable</code>,<code>besteffort</code>下。<code>Qos</code>为<code>guaranteed</code>的<code>pod</code>的<code>cgroup</code>信息放在<pod<uuid>&gt;下的目录下。<br><img src="https://img.hysyeah.top/2023/6/memory-kubepods-20230618130917.png" alt="image"></pod<uuid></p>
<p>查看<code>burstable</code>目录下的<code>cgroups</code>,有两个目录分别是<code>container</code>和<code>pod</code>对应的<code>cgroups</code><br><img src="https://img.hysyeah.top/2023/6/20230618132815.png" alt="image"></p>
<h6 id="posSpec中的resources与cgroup的映射关系"><a href="#posSpec中的resources与cgroup的映射关系" class="headerlink" title="posSpec中的resources与cgroup的映射关系"></a>posSpec中的resources与cgroup的映射关系</h6><div class="table-container">
<table>
<thead>
<tr>
<th>podSpec</th>
<th>cgroup</th>
</tr>
</thead>
<tbody>
<tr>
<td>limits.cpu</td>
<td>cpu.cfs_period_us, cpu.cfs_quota_us, cpu.shares</td>
</tr>
<tr>
<td>limits.memory</td>
<td>memory.limit_in_bytes</td>
</tr>
</tbody>
</table>
</div>
<p><code>cpu.cfs_period_us</code>: 表示cfs调度时间周期，默认值为100000us(100ms)<br><code>cpu.cfs_quota_us</code>: 表示在一个调度周期内允许执行的时间。-1表示不限制<br><code>cpu.shares</code>：表示cpu group对控制组之间的cpu分配比例<br><code>memory.limit_in_bytes</code>: 使用的最大内存量<br><code>cpu.cfs_quota_us/cpu.cfs_period_us</code>表示这个控制组允许使用的<code>cpu</code>最大值。<br>如上我们设置limit.cpu=250m,则cpu.cfs_quota_us=25000,cpu.cfs_period_us=100000。<code>cpu.cfs_quota_us/cpu.cfs_period_us=0.25</code>,也就是<code>podSpec</code>中的<code>250m</code>。</p>
<hr>
<p>REF:<br>1.<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-qos/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-qos/</a><br>2.<a href="https://docs.kernel.org/admin-guide/cgroup-v1/memory.html" target="_blank" rel="noopener">https://docs.kernel.org/admin-guide/cgroup-v1/memory.html</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>helm chart install/uninstall源码分析</title>
    <url>/2024/05/19/helm-chart-install%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="helm项目主要目录"><a href="#helm项目主要目录" class="headerlink" title="helm项目主要目录"></a>helm项目主要目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg/action: 包含执行Helm操作的主要客户端。和CLI处理过程中使用的是同一个包。如果你仅仅需要执行来自另一个Go程序的最基本的Helm命令，这个包会很适合你</span><br><span class="line"></span><br><span class="line">pkg/&#123;chart,chartutil&#125;: 加载和控制chart时使用的方法和帮助内容</span><br><span class="line"></span><br><span class="line">pkg/cli 和它的子包： 包含标准Helm环境变量所有的处理程序以及子包涵盖了输出和正在处理的value文件</span><br><span class="line"></span><br><span class="line">pkg/release: 定义了 Release 对象和状态值</span><br><span class="line"></span><br><span class="line">pkg/storage: 后端存储，支持memory, configmap, secret</span><br><span class="line"></span><br><span class="line">pkg/kube: 封装了对k8s资源的操作</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><code>helm version: v3.10.1</code><br>通过<code>SDK</code>安装一个指定的chart包<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"helm.sh/helm/v3/pkg/action"</span></span><br><span class="line">	<span class="string">"helm.sh/helm/v3/pkg/chart/loader"</span></span><br><span class="line">	<span class="string">"helm.sh/helm/v3/pkg/cli"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/rest"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// must be run in k8s cluster</span></span><br><span class="line">	kubeConfig, _ := rest.InClusterConfig()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// init action config</span></span><br><span class="line">	actionConfig := <span class="built_in">new</span>(action.Configuration)</span><br><span class="line">	settings := cli.New()</span><br><span class="line">	helmDriver := os.Getenv(<span class="string">"HELM_DRIVER"</span>)</span><br><span class="line">	settings.KubeAPIServer = kubeConfig.Host</span><br><span class="line">	settings.KubeToken = kubeConfig.BearerToken</span><br><span class="line">	settings.KubeInsecureSkipTLSVerify = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	err := actionConfig.Init(settings.RESTClientGetter(), <span class="string">"namespace"</span>, helmDriver, log.Printf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create install client and set</span></span><br><span class="line">	client := action.NewInstall(actionConfig)</span><br><span class="line">	client.CreateNamespace = <span class="literal">true</span></span><br><span class="line">	client.Namespace = <span class="string">"namespace"</span></span><br><span class="line">	client.Timeout = <span class="number">300</span> * time.Second</span><br><span class="line">	client.RepoURL = <span class="string">"change to your repoURL"</span></span><br><span class="line">	client.ReleaseName = <span class="string">"release name"</span></span><br><span class="line">	cp, err := client.ChartPathOptions.LocateChart(<span class="string">"chart name"</span>, settings)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	chartRequested, err := loader.Load(cp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// values is the value set in Values.yaml or --set command</span></span><br><span class="line">	values := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	_, err = client.RunWithContext(context.TODO(), chartRequested, values)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="源码分析install"><a href="#源码分析install" class="headerlink" title="源码分析install"></a>源码分析install</h3><h4 id="RunWithContext"><a href="#RunWithContext" class="headerlink" title="RunWithContext"></a>RunWithContext</h4><p>执行安装操作</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/action/install.go</span></span><br><span class="line"><span class="comment">// Run executes the installation with Context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *Install)</span> <span class="title">RunWithContext</span><span class="params">(ctx context.Context, chrt *chart.Chart, vals <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*release.Release, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check reachability of cluster unless in client-only mode (e.g. `helm template` without `--validate`)</span></span><br><span class="line">	<span class="comment">// 如果不是ClientOnly,检测集群是否能连通</span></span><br><span class="line">	<span class="keyword">if</span> !i.ClientOnly &#123;</span><br><span class="line">		<span class="keyword">if</span> err := i.cfg.KubeClient.IsReachable(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 检查ReleaseName是否合法</span></span><br><span class="line">	<span class="comment">// 1. name是否为空;长度是否大于53个chart;是否符合正则表达式`^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$`</span></span><br><span class="line">	<span class="comment">// 2. name是否正在使用当中</span></span><br><span class="line">	<span class="comment">// 3. 判断release的状态(针对已经删除的release),如果状态为uninstalled或failed且i.Replace=true,这种情况下是合法的</span></span><br><span class="line">	<span class="keyword">if</span> err := i.availableName(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里是获取子chart中Value.yaml中的值，递归的获取子chart的values</span></span><br><span class="line">	<span class="comment">// 最后会与父chart的values进行合并</span></span><br><span class="line">	<span class="keyword">if</span> err := chartutil.ProcessDependencies(chrt, vals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pre-install anything in the crd/ directory. We do this before Helm</span></span><br><span class="line">	<span class="comment">// contacts the upstream server and builds the capabilities object.</span></span><br><span class="line">	<span class="keyword">if</span> crds := chrt.CRDObjects(); !i.ClientOnly &amp;&amp; !i.SkipCRDs &amp;&amp; <span class="built_in">len</span>(crds) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// On dry run, bail here</span></span><br><span class="line">		<span class="keyword">if</span> i.DryRun &#123;</span><br><span class="line">			i.cfg.Log(<span class="string">"WARNING: This chart or one of its subcharts contains CRDs. Rendering may fail or contain inaccuracies."</span>)</span><br><span class="line">                <span class="comment">//优先安装CRD,通过kubeClient.Build构建Resource,然后发送请求给k8s apiserver</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err := i.installCRDs(crds); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ClientOnly 不连接k8s apiserver</span></span><br><span class="line">	<span class="keyword">if</span> i.ClientOnly &#123;</span><br><span class="line">		<span class="comment">// Add mock objects in here so it doesn't use Kube API server</span></span><br><span class="line">		<span class="comment">// NOTE(bacongobbler): used for `helm template`</span></span><br><span class="line">		i.cfg.Capabilities = chartutil.DefaultCapabilities.Copy()</span><br><span class="line">		<span class="keyword">if</span> i.KubeVersion != <span class="literal">nil</span> &#123;</span><br><span class="line">			i.cfg.Capabilities.KubeVersion = *i.KubeVersion</span><br><span class="line">		&#125;</span><br><span class="line">		i.cfg.Capabilities.APIVersions = <span class="built_in">append</span>(i.cfg.Capabilities.APIVersions, i.APIVersions...)</span><br><span class="line">		i.cfg.KubeClient = &amp;kubefake.PrintingKubeClient&#123;Out: ioutil.Discard&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 使用内存存储数据</span></span><br><span class="line">		mem := driver.NewMemory()</span><br><span class="line">		mem.SetNamespace(i.Namespace)</span><br><span class="line">		i.cfg.Releases = storage.Init(mem)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !i.ClientOnly &amp;&amp; <span class="built_in">len</span>(i.APIVersions) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		i.cfg.Log(<span class="string">"API Version list given outside of client only mode, this list will be ignored"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure if Atomic is set, that wait is set as well. This makes it so</span></span><br><span class="line">	<span class="comment">// the user doesn't have to specify both</span></span><br><span class="line">	i.Wait = i.Wait || i.Atomic</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	caps, err := i.cfg.getCapabilities()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// special case for helm template --is-upgrade</span></span><br><span class="line">	isUpgrade := i.IsUpgrade &amp;&amp; i.DryRun</span><br><span class="line">	options := chartutil.ReleaseOptions&#123;</span><br><span class="line">		Name:      i.ReleaseName,</span><br><span class="line">		Namespace: i.Namespace,</span><br><span class="line">		Revision:  <span class="number">1</span>,</span><br><span class="line">		IsInstall: !isUpgrade,</span><br><span class="line">		IsUpgrade: isUpgrade,</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// 设置值到Values中</span></span><br><span class="line">	valuesToRender, err := chartutil.ToRenderValues(chrt, vals, options, caps)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建release对象,此时的状态为unknown</span></span><br><span class="line">	rel := i.createRelease(chrt, vals)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> manifestDoc *bytes.Buffer</span><br><span class="line">        <span class="comment">// 对资源进行渲染, 这里会根据不同的资源类型进行排序</span></span><br><span class="line">        <span class="comment">// InstallOrder</span></span><br><span class="line">	rel.Hooks, manifestDoc, rel.Info.Notes, err = i.cfg.renderResources(chrt, valuesToRender, i.ReleaseName, i.OutputDir, i.SubNotes, i.UseReleaseName, i.IncludeCRDs, i.PostRenderer, i.DryRun)</span><br><span class="line">	<span class="comment">// Even for errors, attach this if available</span></span><br><span class="line">	<span class="keyword">if</span> manifestDoc != <span class="literal">nil</span> &#123;</span><br><span class="line">		rel.Manifest = manifestDoc.String()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Check error from render</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		rel.SetStatus(release.StatusFailed, fmt.Sprintf(<span class="string">"failed to render resource: %s"</span>, err.Error()))</span><br><span class="line">		<span class="comment">// Return a release with partial data so that the client can show debugging information.</span></span><br><span class="line">		<span class="keyword">return</span> rel, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark this release as in-progress</span></span><br><span class="line">    <span class="comment">// 设置release状态为pending-install</span></span><br><span class="line">	rel.SetStatus(release.StatusPendingInstall, <span class="string">"Initial install underway"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> toBeAdopted kube.ResourceList</span><br><span class="line">    <span class="comment">// 构建资源对象</span></span><br><span class="line">	resources, err := i.cfg.KubeClient.Build(bytes.NewBufferString(rel.Manifest), !i.DisableOpenAPIValidation)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"unable to build kubernetes objects from release manifest"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// It is safe to use "force" here because these are resources currently rendered by the chart.</span></span><br><span class="line">	err = resources.Visit(setMetadataVisitor(rel.Name, rel.Namespace, <span class="literal">true</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Install requires an extra validation step of checking that resources</span></span><br><span class="line">	<span class="comment">// don't already exist before we actually create resources. If we continue</span></span><br><span class="line">	<span class="comment">// forward and create the release object with resources that already exist,</span></span><br><span class="line">	<span class="comment">// we'll end up in a state where we will delete those resources upon</span></span><br><span class="line">	<span class="comment">// deleting the release because the manifest will be pointing at that</span></span><br><span class="line">	<span class="comment">// resource</span></span><br><span class="line">	<span class="keyword">if</span> !i.ClientOnly &amp;&amp; !isUpgrade &amp;&amp; <span class="built_in">len</span>(resources) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// toBeadopted是指已经存在的资源且是由helm管理的(通过label和annotation来判断)</span></span><br><span class="line">		toBeAdopted, err = existingResourceConflict(resources, rel.Name, rel.Namespace)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"rendered manifests contain a resource that already exists. Unable to continue with install"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bail out here if it is a dry run</span></span><br><span class="line">	<span class="keyword">if</span> i.DryRun &#123;</span><br><span class="line">		rel.Info.Description = <span class="string">"Dry run complete"</span></span><br><span class="line">		<span class="keyword">return</span> rel, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Namespace</span></span><br><span class="line">	<span class="keyword">if</span> i.CreateNamespace &#123;</span><br><span class="line">		ns := &amp;v1.Namespace&#123;</span><br><span class="line">			TypeMeta: metav1.TypeMeta&#123;</span><br><span class="line">				APIVersion: <span class="string">"v1"</span>,</span><br><span class="line">				Kind:       <span class="string">"Namespace"</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">				Name: i.Namespace,</span><br><span class="line">				Labels: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">					<span class="string">"name"</span>: i.Namespace,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		buf, err := yaml.Marshal(ns)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		resourceList, err := i.cfg.KubeClient.Build(bytes.NewBuffer(buf), <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _, err := i.cfg.KubeClient.Create(resourceList); err != <span class="literal">nil</span> &amp;&amp; !apierrors.IsAlreadyExists(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If Replace is true, we need to supercede the last release.</span></span><br><span class="line">	<span class="keyword">if</span> i.Replace &#123;</span><br><span class="line">		<span class="keyword">if</span> err := i.replaceRelease(rel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Store the release in history before continuing (new in Helm 3). We always know</span></span><br><span class="line">	<span class="comment">// that this is a create operation.</span></span><br><span class="line">	<span class="keyword">if</span> err := i.cfg.Releases.Create(rel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// We could try to recover gracefully here, but since nothing has been installed</span></span><br><span class="line">		<span class="comment">// yet, this is probably safer than trying to continue when we know storage is</span></span><br><span class="line">		<span class="comment">// not working.</span></span><br><span class="line">		<span class="keyword">return</span> rel, err</span><br><span class="line">	&#125;</span><br><span class="line">	rChan := <span class="built_in">make</span>(<span class="keyword">chan</span> resultMessage)</span><br><span class="line">	doneChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(doneChan)</span><br><span class="line">    <span class="comment">// 开始进行安装操作</span></span><br><span class="line">	<span class="keyword">go</span> i.performInstall(rChan, rel, toBeAdopted, resources)</span><br><span class="line">	<span class="keyword">go</span> i.handleContext(ctx, rChan, doneChan, rel)</span><br><span class="line">	result := &lt;-rChan</span><br><span class="line">	<span class="comment">//start preformInstall go routine</span></span><br><span class="line">	<span class="keyword">return</span> result.r, result.e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h4><p>将chart转换成chart.Chart对象</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/chart/loader/load.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载一个chart</span></span><br><span class="line"><span class="comment">// 如果存在.helmignore文件，directory loader将会跳过匹配的文件</span></span><br><span class="line"><span class="comment">// 如果是压缩包的话则不会读取.helmignore</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Load</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*chart.Chart, error)</span></span> &#123;</span><br><span class="line">	l, err := Loader(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l.Load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChartLoader loads a chart.</span></span><br><span class="line"><span class="comment">// ChartLoader 是一个接口</span></span><br><span class="line"><span class="comment">// 目前有两个ChartLoader: DirLoader, FileLoader</span></span><br><span class="line"><span class="keyword">type</span> ChartLoader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Load() (*chart.Chart, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Loader returns a new ChartLoader appropriate for the given chart name</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Loader</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(ChartLoader, error)</span></span> &#123;</span><br><span class="line">	fi, err := os.Stat(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果name对应的是一个目录,创建一个DirLoader</span></span><br><span class="line">	<span class="keyword">if</span> fi.IsDir() &#123;</span><br><span class="line">		<span class="keyword">return</span> DirLoader(name), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果不是目录则创建一个FileLoader</span></span><br><span class="line">	<span class="keyword">return</span> FileLoader(name), <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DirLoader,FileLoader读取目录或压缩包，并将文件信息放到BufferedFile</span></span><br><span class="line"><span class="comment">// 最终DirLoader, FileLoader都会调用LoadFiles转换成chart.Chart</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadFiles</span><span class="params">(files []*BufferedFile)</span> <span class="params">(*chart.Chart, error)</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">new</span>(chart.Chart)</span><br><span class="line">	subcharts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]*BufferedFile)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// do not rely on assumed ordering of files in the chart and crash</span></span><br><span class="line">	<span class="comment">// if Chart.yaml was not coming early enough to initialize metadata</span></span><br><span class="line">	<span class="comment">// 遍历所有文件初始化一个chart.Chart对象</span></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">		<span class="comment">// c.Raw记录原始的文件信息</span></span><br><span class="line">		c.Raw = <span class="built_in">append</span>(c.Raw, &amp;chart.File&#123;Name: f.Name, Data: f.Data&#125;)</span><br><span class="line">		<span class="keyword">if</span> f.Name == <span class="string">"Chart.yaml"</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> c.Metadata == <span class="literal">nil</span> &#123;</span><br><span class="line">				c.Metadata = <span class="built_in">new</span>(chart.Metadata)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := yaml.Unmarshal(f.Data, c.Metadata); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> c, errors.Wrap(err, <span class="string">"cannot load Chart.yaml"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// NOTE(bacongobbler): while the chart specification says that APIVersion must be set,</span></span><br><span class="line">			<span class="comment">// Helm 2 accepted charts that did not provide an APIVersion in their chart metadata.</span></span><br><span class="line">			<span class="comment">// Because of that, if APIVersion is unset, we should assume we're loading a v1 chart.</span></span><br><span class="line">			<span class="keyword">if</span> c.Metadata.APIVersion == <span class="string">""</span> &#123;</span><br><span class="line">				c.Metadata.APIVersion = chart.APIVersionV1</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> f.Name == <span class="string">"Chart.yaml"</span>:</span><br><span class="line">			<span class="comment">// already processed</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> f.Name == <span class="string">"Chart.lock"</span>:</span><br><span class="line">			c.Lock = <span class="built_in">new</span>(chart.Lock)</span><br><span class="line">			<span class="keyword">if</span> err := yaml.Unmarshal(f.Data, &amp;c.Lock); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> c, errors.Wrap(err, <span class="string">"cannot load Chart.lock"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> f.Name == <span class="string">"values.yaml"</span>:</span><br><span class="line">			c.Values = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">			<span class="keyword">if</span> err := yaml.Unmarshal(f.Data, &amp;c.Values); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> c, errors.Wrap(err, <span class="string">"cannot load values.yaml"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> f.Name == <span class="string">"values.schema.json"</span>:</span><br><span class="line">			c.Schema = f.Data</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Deprecated: requirements.yaml is deprecated use Chart.yaml.</span></span><br><span class="line">		<span class="comment">// We will handle it for you because we are nice people</span></span><br><span class="line">		<span class="keyword">case</span> f.Name == <span class="string">"requirements.yaml"</span>:</span><br><span class="line">			<span class="keyword">if</span> c.Metadata == <span class="literal">nil</span> &#123;</span><br><span class="line">				c.Metadata = <span class="built_in">new</span>(chart.Metadata)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.Metadata.APIVersion != chart.APIVersionV1 &#123;</span><br><span class="line">				log.Printf(<span class="string">"Warning: Dependencies are handled in Chart.yaml since apiVersion \"v2\". We recommend migrating dependencies to Chart.yaml."</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := yaml.Unmarshal(f.Data, c.Metadata); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> c, errors.Wrap(err, <span class="string">"cannot load requirements.yaml"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.Metadata.APIVersion == chart.APIVersionV1 &#123;</span><br><span class="line">				c.Files = <span class="built_in">append</span>(c.Files, &amp;chart.File&#123;Name: f.Name, Data: f.Data&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// Deprecated: requirements.lock is deprecated use Chart.lock.</span></span><br><span class="line">		<span class="keyword">case</span> f.Name == <span class="string">"requirements.lock"</span>:</span><br><span class="line">			c.Lock = <span class="built_in">new</span>(chart.Lock)</span><br><span class="line">			<span class="keyword">if</span> err := yaml.Unmarshal(f.Data, &amp;c.Lock); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> c, errors.Wrap(err, <span class="string">"cannot load requirements.lock"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.Metadata == <span class="literal">nil</span> &#123;</span><br><span class="line">				c.Metadata = <span class="built_in">new</span>(chart.Metadata)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.Metadata.APIVersion == chart.APIVersionV1 &#123;</span><br><span class="line">				c.Files = <span class="built_in">append</span>(c.Files, &amp;chart.File&#123;Name: f.Name, Data: f.Data&#125;)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(f.Name, <span class="string">"templates/"</span>):</span><br><span class="line">			c.Templates = <span class="built_in">append</span>(c.Templates, &amp;chart.File&#123;Name: f.Name, Data: f.Data&#125;)</span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(f.Name, <span class="string">"charts/"</span>):</span><br><span class="line">			<span class="keyword">if</span> filepath.Ext(f.Name) == <span class="string">".prov"</span> &#123;</span><br><span class="line">				c.Files = <span class="built_in">append</span>(c.Files, &amp;chart.File&#123;Name: f.Name, Data: f.Data&#125;)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fname := strings.TrimPrefix(f.Name, <span class="string">"charts/"</span>)</span><br><span class="line">			cname := strings.SplitN(fname, <span class="string">"/"</span>, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">			subcharts[cname] = <span class="built_in">append</span>(subcharts[cname], &amp;BufferedFile&#123;Name: fname, Data: f.Data&#125;)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			c.Files = <span class="built_in">append</span>(c.Files, &amp;chart.File&#123;Name: f.Name, Data: f.Data&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.Metadata == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c, errors.New(<span class="string">"Chart.yaml file is missing"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := c.Validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n, files := <span class="keyword">range</span> subcharts &#123;</span><br><span class="line">		<span class="keyword">var</span> sc *chart.Chart</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> strings.IndexAny(n, <span class="string">"_."</span>) == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> filepath.Ext(n) == <span class="string">".tgz"</span>:</span><br><span class="line">			file := files[<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">if</span> file.Name != n &#123;</span><br><span class="line">				<span class="keyword">return</span> c, errors.Errorf(<span class="string">"error unpacking tar in %s: expected %s, got %s"</span>, c.Name(), n, file.Name)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Untar the chart and add to c.Dependencies</span></span><br><span class="line">			sc, err = LoadArchive(bytes.NewBuffer(file.Data))</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// We have to trim the prefix off of every file, and ignore any file</span></span><br><span class="line">			<span class="comment">// that is in charts/, but isn't actually a chart.</span></span><br><span class="line">			buff := <span class="built_in">make</span>([]*BufferedFile, <span class="number">0</span>, <span class="built_in">len</span>(files))</span><br><span class="line">			<span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">				parts := strings.SplitN(f.Name, <span class="string">"/"</span>, <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(parts) &lt; <span class="number">2</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				f.Name = parts[<span class="number">1</span>]</span><br><span class="line">				buff = <span class="built_in">append</span>(buff, f)</span><br><span class="line">			&#125;</span><br><span class="line">			sc, err = LoadFiles(buff)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> c, errors.Wrapf(err, <span class="string">"error unpacking %s in %s"</span>, n, c.Name())</span><br><span class="line">		&#125;</span><br><span class="line">		c.AddDependency(sc)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/chart/loader/directory.go</span></span><br><span class="line"><span class="comment">// DirLoader 实现</span></span><br><span class="line"> <span class="keyword">var</span> utf8bom = []<span class="keyword">byte</span>&#123;<span class="number">0xEF</span>, <span class="number">0xBB</span>, <span class="number">0xBF</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DirLoader loads a chart from a directory</span></span><br><span class="line"><span class="keyword">type</span> DirLoader <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Load loads the chart</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l DirLoader)</span> <span class="title">Load</span><span class="params">()</span> <span class="params">(*chart.Chart, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> LoadDir(<span class="keyword">string</span>(l))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadDir loads from a directory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This loads charts only from directories.</span></span><br><span class="line"><span class="comment">// 遍历整个目录，将文件加载到内存对象中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadDir</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="params">(*chart.Chart, error)</span></span> &#123;</span><br><span class="line">	topdir, err := filepath.Abs(dir)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Just used for errors.</span></span><br><span class="line">	c := &amp;chart.Chart&#123;&#125;</span><br><span class="line"></span><br><span class="line">	rules := ignore.Empty()</span><br><span class="line">	ifile := filepath.Join(topdir, ignore.HelmIgnore)</span><br><span class="line">	<span class="keyword">if</span> _, err := os.Stat(ifile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		r, err := ignore.ParseFile(ifile)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> c, err</span><br><span class="line">		&#125;</span><br><span class="line">		rules = r</span><br><span class="line">	&#125;</span><br><span class="line">	rules.AddDefaults()</span><br><span class="line"></span><br><span class="line">	files := []*BufferedFile&#123;&#125;</span><br><span class="line">	topdir += <span class="keyword">string</span>(filepath.Separator)</span><br><span class="line"></span><br><span class="line">	walk := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, fi os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		n := strings.TrimPrefix(name, topdir)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="string">""</span> &#123;</span><br><span class="line">			<span class="comment">// No need to process top level. Avoid bug with helmignore .* matching</span></span><br><span class="line">			<span class="comment">// empty names. See issue 1779.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Normalize to / since it will also work on Windows</span></span><br><span class="line">		n = filepath.ToSlash(n)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> fi.IsDir() &#123;</span><br><span class="line">			<span class="comment">// Directory-based ignore rules should involve skipping the entire</span></span><br><span class="line">			<span class="comment">// contents of that directory.</span></span><br><span class="line">			<span class="keyword">if</span> rules.Ignore(n, fi) &#123;</span><br><span class="line">				<span class="keyword">return</span> filepath.SkipDir</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If a .helmignore file matches, skip this file.</span></span><br><span class="line">		<span class="keyword">if</span> rules.Ignore(n, fi) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Irregular files include devices, sockets, and other uses of files that</span></span><br><span class="line">		<span class="comment">// are not regular files. In Go they have a file mode type bit set.</span></span><br><span class="line">		<span class="comment">// See https://golang.org/pkg/os/#FileMode for examples.</span></span><br><span class="line">		<span class="keyword">if</span> !fi.Mode().IsRegular() &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot load irregular file %s as it has file mode type bits set"</span>, name)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		data, err := ioutil.ReadFile(name)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrapf(err, <span class="string">"error reading %s"</span>, n)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		data = bytes.TrimPrefix(data, utf8bom)</span><br><span class="line"></span><br><span class="line">		files = <span class="built_in">append</span>(files, &amp;BufferedFile&#123;Name: n, Data: data&#125;)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err = sympath.Walk(topdir, walk); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> LoadFiles(files)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ToRenderValues"><a href="#ToRenderValues" class="headerlink" title="ToRenderValues"></a>ToRenderValues</h4><p>将合并后values值设置到Values中</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/chartutil/values.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToRenderValues composes the struct from the data coming from the Releases, Charts and Values files</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This takes both ReleaseOptions and Capabilities to merge into the render values.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToRenderValues</span><span class="params">(chrt *chart.Chart, chrtVals <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, options ReleaseOptions, caps *Capabilities)</span> <span class="params">(Values, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> caps == <span class="literal">nil</span> &#123;</span><br><span class="line">		caps = DefaultCapabilities</span><br><span class="line">	&#125;</span><br><span class="line">	top := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">"Chart"</span>:        chrt.Metadata,</span><br><span class="line">		<span class="string">"Capabilities"</span>: caps,</span><br><span class="line">		<span class="string">"Release"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">			<span class="string">"Name"</span>:      options.Name,</span><br><span class="line">			<span class="string">"Namespace"</span>: options.Namespace,</span><br><span class="line">			<span class="string">"IsUpgrade"</span>: options.IsUpgrade,</span><br><span class="line">			<span class="string">"IsInstall"</span>: options.IsInstall,</span><br><span class="line">			<span class="string">"Revision"</span>:  options.Revision,</span><br><span class="line">			<span class="string">"Service"</span>:   <span class="string">"Helm"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 合并所有的values,包括子chart</span></span><br><span class="line">	vals, err := CoalesceValues(chrt, chrtVals)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> top, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := ValidateAgainstSchema(chrt, vals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		errFmt := <span class="string">"values don't meet the specifications of the schema(s) in the following chart(s):\n%s"</span></span><br><span class="line">		<span class="keyword">return</span> top, fmt.Errorf(errFmt, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	top[<span class="string">"Values"</span>] = vals</span><br><span class="line">	<span class="keyword">return</span> top, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="renderResources"><a href="#renderResources" class="headerlink" title="renderResources"></a>renderResources</h4><p>对资源进行渲染，因为chart支持了模版，用户可以自己配置一些值，所以在安装时需要对这些<br>参数渲染成实际的值</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cfg *Configuration)</span> <span class="title">renderResources</span><span class="params">(ch *chart.Chart, values chartutil.Values, releaseName, outputDir <span class="keyword">string</span>, subNotes, useReleaseName, includeCrds <span class="keyword">bool</span>, pr postrender.PostRenderer, dryRun <span class="keyword">bool</span>)</span> <span class="params">([]*release.Hook, *bytes.Buffer, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	hs := []*release.Hook&#123;&#125;</span><br><span class="line">	b := bytes.NewBuffer(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	caps, err := cfg.getCapabilities()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> hs, b, <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ch.Metadata.KubeVersion != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !chartutil.IsCompatibleRange(ch.Metadata.KubeVersion, caps.KubeVersion.String()) &#123;</span><br><span class="line">			<span class="keyword">return</span> hs, b, <span class="string">""</span>, errors.Errorf(<span class="string">"chart requires kubeVersion: %s which is incompatible with Kubernetes %s"</span>, ch.Metadata.KubeVersion, caps.KubeVersion.String())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> files <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> err2 error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A `helm template` or `helm install --dry-run` should not talk to the remote cluster.</span></span><br><span class="line">	<span class="comment">// It will break in interesting and exotic ways because other data (e.g. discovery)</span></span><br><span class="line">	<span class="comment">// is mocked. It is not up to the template author to decide when the user wants to</span></span><br><span class="line">	<span class="comment">// connect to the cluster. So when the user says to dry run, respect the user's</span></span><br><span class="line">	<span class="comment">// wishes and do not connect to the cluster.</span></span><br><span class="line">	<span class="keyword">if</span> !dryRun &amp;&amp; cfg.RESTClientGetter != <span class="literal">nil</span> &#123;</span><br><span class="line">		restConfig, err := cfg.RESTClientGetter.ToRESTConfig()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> hs, b, <span class="string">""</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		files, err2 = engine.RenderWithClient(ch, values, restConfig)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		files, err2 = engine.Render(ch, values)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> hs, b, <span class="string">""</span>, err2</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// NOTES.txt gets rendered like all the other files, but because it's not a hook nor a resource,</span></span><br><span class="line">	<span class="comment">// pull it out of here into a separate file so that we can actually use the output of the rendered</span></span><br><span class="line">	<span class="comment">// text file. We have to spin through this map because the file contains path information, so we</span></span><br><span class="line">	<span class="comment">// look for terminating NOTES.txt. We also remove it from the files so that we don't have to skip</span></span><br><span class="line">	<span class="comment">// it in the sortHooks.</span></span><br><span class="line">	<span class="keyword">var</span> notesBuffer bytes.Buffer</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> files &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.HasSuffix(k, notesFileSuffix) &#123;</span><br><span class="line">			<span class="keyword">if</span> subNotes || (k == path.Join(ch.Name(), <span class="string">"templates"</span>, notesFileSuffix)) &#123;</span><br><span class="line">				<span class="comment">// If buffer contains data, add newline before adding more</span></span><br><span class="line">				<span class="keyword">if</span> notesBuffer.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">					notesBuffer.WriteString(<span class="string">"\n"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				notesBuffer.WriteString(v)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">delete</span>(files, k)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	notes := notesBuffer.String()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sort hooks, manifests, and partials. Only hooks and manifests are returned,</span></span><br><span class="line">	<span class="comment">// as partials are not used after renderer.Render. Empty manifests are also</span></span><br><span class="line">	<span class="comment">// removed here.</span></span><br><span class="line">	hs, manifests, err := releaseutil.SortManifests(files, caps.APIVersions, releaseutil.InstallOrder)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// By catching parse errors here, we can prevent bogus releases from going</span></span><br><span class="line">		<span class="comment">// to Kubernetes.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// We return the files as a big blob of data to help the user debug parser</span></span><br><span class="line">		<span class="comment">// errors.</span></span><br><span class="line">		<span class="keyword">for</span> name, content := <span class="keyword">range</span> files &#123;</span><br><span class="line">			<span class="keyword">if</span> strings.TrimSpace(content) == <span class="string">""</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Fprintf(b, <span class="string">"---\n# Source: %s\n%s\n"</span>, name, content)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> hs, b, <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Aggregate all valid manifests into one big doc.</span></span><br><span class="line">	fileWritten := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> includeCrds &#123;</span><br><span class="line">		<span class="keyword">for</span> _, crd := <span class="keyword">range</span> ch.CRDObjects() &#123;</span><br><span class="line">			<span class="keyword">if</span> outputDir == <span class="string">""</span> &#123;</span><br><span class="line">				fmt.Fprintf(b, <span class="string">"---\n# Source: %s\n%s\n"</span>, crd.Name, <span class="keyword">string</span>(crd.File.Data[:]))</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				err = writeToFile(outputDir, crd.Filename, <span class="keyword">string</span>(crd.File.Data[:]), fileWritten[crd.Name])</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> hs, b, <span class="string">""</span>, err</span><br><span class="line">				&#125;</span><br><span class="line">				fileWritten[crd.Name] = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> manifests &#123;</span><br><span class="line">		<span class="keyword">if</span> outputDir == <span class="string">""</span> &#123;</span><br><span class="line">			fmt.Fprintf(b, <span class="string">"---\n# Source: %s\n%s\n"</span>, m.Name, m.Content)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			newDir := outputDir</span><br><span class="line">			<span class="keyword">if</span> useReleaseName &#123;</span><br><span class="line">				newDir = filepath.Join(outputDir, releaseName)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// <span class="doctag">NOTE:</span> We do not have to worry about the post-renderer because</span></span><br><span class="line">			<span class="comment">// output dir is only used by `helm template`. In the next major</span></span><br><span class="line">			<span class="comment">// release, we should move this logic to template only as it is not</span></span><br><span class="line">			<span class="comment">// used by install or upgrade</span></span><br><span class="line">			err = writeToFile(newDir, m.Name, m.Content, fileWritten[m.Name])</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> hs, b, <span class="string">""</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			fileWritten[m.Name] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pr != <span class="literal">nil</span> &#123;</span><br><span class="line">		b, err = pr.Run(b)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> hs, b, notes, errors.Wrap(err, <span class="string">"error while running post render on files"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hs, b, notes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KindSortOrder"><a href="#KindSortOrder" class="headerlink" title="KindSortOrder"></a>KindSortOrder</h4><p>k8s资源的创建顺序</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/releaseutil/kind_sorter.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InstallOrder is the order in which manifests should be installed (by Kind).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Those occurring earlier in the list get installed before those occurring later in the list.</span></span><br><span class="line"><span class="comment">// helm安装的资源根据下面的顺序进行排序</span></span><br><span class="line"><span class="keyword">var</span> InstallOrder KindSortOrder = []<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">"Namespace"</span>,</span><br><span class="line">	<span class="string">"NetworkPolicy"</span>,</span><br><span class="line">	<span class="string">"ResourceQuota"</span>,</span><br><span class="line">	<span class="string">"LimitRange"</span>,</span><br><span class="line">	<span class="string">"PodSecurityPolicy"</span>,</span><br><span class="line">	<span class="string">"PodDisruptionBudget"</span>,</span><br><span class="line">	<span class="string">"ServiceAccount"</span>,</span><br><span class="line">	<span class="string">"Secret"</span>,</span><br><span class="line">	<span class="string">"SecretList"</span>,</span><br><span class="line">	<span class="string">"ConfigMap"</span>,</span><br><span class="line">	<span class="string">"StorageClass"</span>,</span><br><span class="line">	<span class="string">"PersistentVolume"</span>,</span><br><span class="line">	<span class="string">"PersistentVolumeClaim"</span>,</span><br><span class="line">	<span class="string">"CustomResourceDefinition"</span>,</span><br><span class="line">	<span class="string">"ClusterRole"</span>,</span><br><span class="line">	<span class="string">"ClusterRoleList"</span>,</span><br><span class="line">	<span class="string">"ClusterRoleBinding"</span>,</span><br><span class="line">	<span class="string">"ClusterRoleBindingList"</span>,</span><br><span class="line">	<span class="string">"Role"</span>,</span><br><span class="line">	<span class="string">"RoleList"</span>,</span><br><span class="line">	<span class="string">"RoleBinding"</span>,</span><br><span class="line">	<span class="string">"RoleBindingList"</span>,</span><br><span class="line">	<span class="string">"Service"</span>,</span><br><span class="line">	<span class="string">"DaemonSet"</span>,</span><br><span class="line">	<span class="string">"Pod"</span>,</span><br><span class="line">	<span class="string">"ReplicationController"</span>,</span><br><span class="line">	<span class="string">"ReplicaSet"</span>,</span><br><span class="line">	<span class="string">"Deployment"</span>,</span><br><span class="line">	<span class="string">"HorizontalPodAutoscaler"</span>,</span><br><span class="line">	<span class="string">"StatefulSet"</span>,</span><br><span class="line">	<span class="string">"Job"</span>,</span><br><span class="line">	<span class="string">"CronJob"</span>,</span><br><span class="line">	<span class="string">"IngressClass"</span>,</span><br><span class="line">	<span class="string">"Ingress"</span>,</span><br><span class="line">	<span class="string">"APIService"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="performInstall"><a href="#performInstall" class="headerlink" title="performInstall"></a>performInstall</h4><p>真正执行资源创建的函数，将渲染后的chart转换成k8s资源yaml,并发送请求给kubernetes</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *Install)</span> <span class="title">performInstall</span><span class="params">(c <span class="keyword">chan</span>&lt;- resultMessage, rel *release.Release, toBeAdopted kube.ResourceList, resources kube.ResourceList)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pre-install hooks</span></span><br><span class="line">    <span class="comment">// 执行pre-install hooks</span></span><br><span class="line">	<span class="keyword">if</span> !i.DisableHooks &#123;</span><br><span class="line">		<span class="keyword">if</span> err := i.cfg.execHook(rel, release.HookPreInstall, i.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			i.reportToRun(c, rel, fmt.Errorf(<span class="string">"failed pre-install: %s"</span>, err))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// At this point, we can do the install. Note that before we were detecting whether to</span></span><br><span class="line">	<span class="comment">// do an update, but it's not clear whether we WANT to do an update if the re-use is set</span></span><br><span class="line">	<span class="comment">// to true, since that is basically an upgrade operation.</span></span><br><span class="line">        <span class="comment">// 没有需要升级的对象,直接创建所有的resources</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(toBeAdopted) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(resources) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _, err := i.cfg.KubeClient.Create(resources); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			i.reportToRun(c, rel, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(resources) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 更新已存在的资源，创建不存在的资源</span></span><br><span class="line">		<span class="keyword">if</span> _, err := i.cfg.KubeClient.Update(toBeAdopted, resources, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			i.reportToRun(c, rel, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置了Wait则会进行等待</span></span><br><span class="line">	<span class="keyword">if</span> i.Wait &#123;</span><br><span class="line">		<span class="keyword">if</span> i.WaitForJobs &#123;</span><br><span class="line">			<span class="keyword">if</span> err := i.cfg.KubeClient.WaitWithJobs(resources, i.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				i.reportToRun(c, rel, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := i.cfg.KubeClient.Wait(resources, i.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				i.reportToRun(c, rel, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !i.DisableHooks &#123;</span><br><span class="line">		<span class="keyword">if</span> err := i.cfg.execHook(rel, release.HookPostInstall, i.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			i.reportToRun(c, rel, fmt.Errorf(<span class="string">"failed post-install: %s"</span>, err))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(i.Description) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		rel.SetStatus(release.StatusDeployed, i.Description)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rel.SetStatus(release.StatusDeployed, <span class="string">"Install complete"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is a tricky case. The release has been created, but the result</span></span><br><span class="line">	<span class="comment">// cannot be recorded. The truest thing to tell the user is that the</span></span><br><span class="line">	<span class="comment">// release was created. However, the user will not be able to do anything</span></span><br><span class="line">	<span class="comment">// further with this release.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// One possible strategy would be to do a timed retry to see if we can get</span></span><br><span class="line">	<span class="comment">// this stored in the future.</span></span><br><span class="line">	<span class="keyword">if</span> err := i.recordRelease(rel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		i.cfg.Log(<span class="string">"failed to record the release: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i.reportToRun(c, rel, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码分析uninstall"><a href="#源码分析uninstall" class="headerlink" title="源码分析uninstall"></a>源码分析uninstall</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Run uninstalls the given release.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *Uninstall)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*release.UninstallReleaseResponse, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 判断集群连通性</span></span><br><span class="line">	<span class="keyword">if</span> err := u.cfg.KubeClient.IsReachable(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// uninstall的dryRun只是判断下release是否存在</span></span><br><span class="line">	<span class="keyword">if</span> u.DryRun &#123;</span><br><span class="line">		<span class="comment">// In the dry run case, just see if the release exists</span></span><br><span class="line">		r, err := u.cfg.releaseContent(name, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;release.UninstallReleaseResponse&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;release.UninstallReleaseResponse&#123;Release: r&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := chartutil.ValidateReleaseName(name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"uninstall: Release name is invalid: %s"</span>, name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rels, err := u.cfg.Releases.History(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"uninstall: Release not loaded: %s"</span>, name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(rels) &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errMissingRelease</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	releaseutil.SortByRevision(rels)</span><br><span class="line">	rel := rels[<span class="built_in">len</span>(rels)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Are there any cases where we want to force a delete even if it's</span></span><br><span class="line">	<span class="comment">// already marked deleted?</span></span><br><span class="line">	<span class="keyword">if</span> rel.Info.Status == release.StatusUninstalled &#123;</span><br><span class="line">		<span class="keyword">if</span> !u.KeepHistory &#123;</span><br><span class="line">			<span class="comment">// 清除所有的历史记录</span></span><br><span class="line">			<span class="keyword">if</span> err := u.purgeReleases(rels...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"uninstall: Failed to purge the release"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> &amp;release.UninstallReleaseResponse&#123;Release: rel&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"the release named %q is already deleted"</span>, name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	u.cfg.Log(<span class="string">"uninstall: Deleting %s"</span>, name)</span><br><span class="line">	rel.Info.Status = release.StatusUninstalling</span><br><span class="line">	rel.Info.Deleted = helmtime.Now()</span><br><span class="line">	rel.Info.Description = <span class="string">"Deletion in progress (or silently failed)"</span></span><br><span class="line">	res := &amp;release.UninstallReleaseResponse&#123;Release: rel&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !u.DisableHooks &#123;</span><br><span class="line">		<span class="keyword">if</span> err := u.cfg.execHook(rel, release.HookPreDelete, u.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> res, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		u.cfg.Log(<span class="string">"delete hooks disabled for %s"</span>, name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// From here on out, the release is currently considered to be in StatusUninstalling</span></span><br><span class="line">	<span class="comment">// state.</span></span><br><span class="line">	<span class="keyword">if</span> err := u.cfg.Releases.Update(rel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		u.cfg.Log(<span class="string">"uninstall: Failed to store updated release: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	deletedResources, kept, errs := u.deleteRelease(rel)</span><br><span class="line">	<span class="keyword">if</span> errs != <span class="literal">nil</span> &#123;</span><br><span class="line">		u.cfg.Log(<span class="string">"uninstall: Failed to delete release: %s"</span>, errs)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"failed to delete release: %s"</span>, name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kept != <span class="string">""</span> &#123;</span><br><span class="line">		kept = <span class="string">"These resources were kept due to the resource policy:\n"</span> + kept</span><br><span class="line">	&#125;</span><br><span class="line">	res.Info = kept</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> u.Wait &#123;</span><br><span class="line">		<span class="keyword">if</span> kubeClient, ok := u.cfg.KubeClient.(kube.InterfaceExt); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> err := kubeClient.WaitForDelete(deletedResources, u.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !u.DisableHooks &#123;</span><br><span class="line">		<span class="keyword">if</span> err := u.cfg.execHook(rel, release.HookPostDelete, u.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rel.Info.Status = release.StatusUninstalled</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(u.Description) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		rel.Info.Description = u.Description</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rel.Info.Description = <span class="string">"Uninstallation complete"</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !u.KeepHistory &#123;</span><br><span class="line">		u.cfg.Log(<span class="string">"purge requested for %s"</span>, name)</span><br><span class="line">		err := u.purgeReleases(rels...)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs = <span class="built_in">append</span>(errs, errors.Wrap(err, <span class="string">"uninstall: Failed to purge the release"</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Return the errors that occurred while deleting the release, if any</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> res, errors.Errorf(<span class="string">"uninstallation completed with %d error(s): %s"</span>, <span class="built_in">len</span>(errs), joinErrors(errs))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := u.cfg.Releases.Update(rel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		u.cfg.Log(<span class="string">"uninstall: Failed to store updated release: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res, errors.Errorf(<span class="string">"uninstallation completed with %d error(s): %s"</span>, <span class="built_in">len</span>(errs), joinErrors(errs))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ol>
<li><a href="https://helm.sh/zh/docs/topics/advanced/" target="_blank" rel="noopener">https://helm.sh/zh/docs/topics/advanced/</a></li>
<li><a href="https://github.com/helm/helm/blob/main/pkg/action/install.go" target="_blank" rel="noopener">https://github.com/helm/helm/blob/main/pkg/action/install.go</a></li>
<li><a href="https://github.com/helm/helm/blob/main/pkg/chartutil/values.go" target="_blank" rel="noopener">https://github.com/helm/helm/blob/main/pkg/chartutil/values.go</a></li>
<li><a href="https://github.com/helm/helm/blob/main/pkg/releaseutil/kind_sorter.go" target="_blank" rel="noopener">https://github.com/helm/helm/blob/main/pkg/releaseutil/kind_sorter.go</a></li>
</ol>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s-crd</title>
    <url>/2021/05/15/k8s-crd/</url>
    <content><![CDATA[<p>CRD是k8s提供对现有资源进行扩展的一种方式，当现有k8s资源都无法满足你的需求时就可以考虑使用CRD对现有资源进行扩展。</p>
<p>环境信息：golang 1.16.2,kubernetes v1.19.0</p>
<p>如何自定义一个k8s CRD(Custom Resource Definition)</p>
<p>1.新建一个项目，项目名称为<code>k8s-crd</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  gopro mkdir k8s-crd</span><br><span class="line">➜  gopro cd k8s-crd </span><br><span class="line">➜  k8s-crd mkdir -p pkg/apis/crd/v1</span><br><span class="line">➜  k8s-crd go mod init hysyeah.top/k8s-crd</span><br></pre></td></tr></table></figure></p>
<p>2.定义资源注册所需的字段信息，<code>pkg/apis/crd/register.go</code><br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span>  crd</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	GroupName = <span class="string">"crd.alpha.io"</span></span><br><span class="line">	Version = <span class="string">"v1"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>3.定义全局标签，<code>pkg/apis/crd/v1/doc.go</code>.k8s中许多代码都是通过代码生成器生成的，代码生成器通过Tags(标签)来判断一个包如何进行代码生成。k8s中存在如下两种Tag:</p>
<ul>
<li>全局Tags: 定义在每个包的doc.文件中，对整个包中的类型自动生成代码</li>
<li>局部Tags: 定义在Go语言的类型声明上方，只对指定的类型自动生成代码</li>
</ul>
<p>可参考<a href="https://pkg.go.dev/k8s.io/gengo/examples/deepcopy-gen" target="_blank" rel="noopener">deepcopy-gen</a></p>
<p>全局Tags告诉deepcopy-gen代码生成器为该包中的每个类型自动生成DeepCopy函数。其中//+groupNmae定义了资源组名称，一般使用域名形式命名<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +k8s:deepcopy-gen=package</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +groupName=crd.hysyeah.top</span></span><br><span class="line"><span class="keyword">package</span> v1</span><br></pre></td></tr></table></figure></p>
<p>4.定义资源类型，<code>pkg/apis/crd/v1/types.go</code><br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"><span class="comment">// +genclient:noStatus</span></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Machine describes a Machine resource</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">	metav1.ObjectMeta <span class="string">`json:"metadata,omitempty"`</span></span><br><span class="line">	Spec DogSepc <span class="string">`json:"spec"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DogSpec定义资源拥有的属性</span></span><br><span class="line"><span class="keyword">type</span> DogSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//在这里可以自定义Dog所拥有的属性,我们这种定义了Kg和Age两个属性</span></span><br><span class="line">	Kg <span class="keyword">int</span> <span class="string">`json:"kg"`</span></span><br><span class="line">	Age <span class="keyword">int</span> <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DogList定义列表资源</span></span><br><span class="line"><span class="keyword">type</span> DogList <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">	metav1.ListMeta <span class="string">`json:"metadata"`</span></span><br><span class="line">	Items []Dog <span class="string">`json:"items"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Dog</code>上方的Tags为局部Tags。它定义了两个代码生成器genclient和deepcopy-gen。其中genclient代码生 成器为这个资源类型自动生成对应的客户端代码,deepcopy-gen代码生成器为这个资源类型自动生成DeepCopy函数，并为该类型生成返回值为<code>runtime.Object</code>类型的DeepCopyObject函数。</p>
<p>5.定义资源注册方法,<code>pkg/apis/crd/v1/register.go</code><br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/runtime"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/runtime/schema"</span></span><br><span class="line">	<span class="string">"hysyeah.top/k8s-crd/pkg/apis/crd"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义注册资源的资源组和版本</span></span><br><span class="line"><span class="keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;</span><br><span class="line">	Group: crd.GroupName,</span><br><span class="line">	Version: crd.Version,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line">	AddToScheme = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Resource</span><span class="params">(resource <span class="keyword">string</span>)</span> <span class="title">schema</span>.<span class="title">GroupResource</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Kind</span><span class="params">(kind <span class="keyword">string</span>)</span> <span class="title">schema</span>.<span class="title">GroupKind</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> SchemeGroupVersion.WithKind(kind).GroupKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addKnownTypes 定义注册方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addKnownTypes</span><span class="params">(scheme *runtime.Schema)</span> <span class="title">error</span></span>  &#123;</span><br><span class="line">	scheme.AddKnownType(</span><br><span class="line">		SchemeGroupVersion,</span><br><span class="line">		&amp;Dog&#123;&#125;,</span><br><span class="line">		&amp;DogList&#123;&#125;,</span><br><span class="line">		)</span><br><span class="line">	metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.配置code-generator,在项目根目录下新建目录<code>hack</code>并新建文件<code>tools.go</code>。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +build tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Copyright 2019 The Kubernetes Authors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment">   you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">   You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">   distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">   See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">   limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This package imports things required by build scripts, to force `go mod` to see them as dependencies</span></span><br><span class="line"><span class="keyword">package</span> tools</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"k8s.io/code-generator"</span></span><br></pre></td></tr></table></figure></p>
<p>新建文件<code>hack/boilerplate.go.txt</code>,生成代码需要添加这个license<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright The Kubernetes Authors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment">you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>新建<code>hack/update-codegen.sh</code><br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line"># Copyright <span class="number">2017</span> The Kubernetes Authors.</span><br><span class="line">#</span><br><span class="line"># Licensed under the Apache License, Version <span class="number">2.0</span> (the <span class="string">"License"</span>);</span><br><span class="line"># you may not use this file except in compliance with the License.</span><br><span class="line"># You may obtain a <span class="built_in">copy</span> of the License at</span><br><span class="line">#</span><br><span class="line">#     http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line">#</span><br><span class="line"># Unless required by applicable law or agreed to in writing, software</span><br><span class="line"># distributed under the License is distributed on an <span class="string">"AS IS"</span> BASIS,</span><br><span class="line"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"># See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line"># limitations under the License.</span><br><span class="line"></span><br><span class="line">set -o errexit</span><br><span class="line">set -o nounset</span><br><span class="line">set -o pipefail</span><br><span class="line"></span><br><span class="line"># generate the code with:</span><br><span class="line"># --output-base    because this script should also be able to run inside the vendor dir of</span><br><span class="line">#                  k8s.io/kubernetes. The output-base is needed <span class="keyword">for</span> the generators to output into the vendor dir</span><br><span class="line">#                  instead of the $GOPATH directly. For normal projects this can be dropped.</span><br><span class="line">ROOT_PACKAGE=<span class="string">"hysyeah.top/k8s-crd"</span></span><br><span class="line">CUSTOM_RESOURCE_NAME=<span class="string">"crd"</span></span><br><span class="line">CUSTOM_RESOURCE_VERSION=<span class="string">"v1"</span></span><br><span class="line"></span><br><span class="line">chmod +x ../vendor/k8s.io/code-generator/generate-groups.sh</span><br><span class="line">../vendor/k8s.io/code-generator/generate-groups.sh all <span class="string">"$ROOT_PACKAGE/pkg/client"</span> <span class="string">"$ROOT_PACKAGE/pkg/apis"</span> <span class="string">"$CUSTOM_RESOURCE_NAME:$CUSTOM_RESOURCE_VERSION"</span> \</span><br><span class="line">  --<span class="keyword">go</span>-header-file $(pwd)/boilerplate.<span class="keyword">go</span>.txt</span><br></pre></td></tr></table></figure></p>
<p>7.生成代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//在项目根目录下</span><br><span class="line">➜  k8s-crd go mod vendor</span><br><span class="line">➜  k8s-crd chmod +x hack/update-codegen.sh</span><br><span class="line">➜  k8s-crd cd hack </span><br><span class="line">➜  hack./update-codegen.sh</span><br><span class="line">Generating deepcopy funcs</span><br><span class="line">Generating clientset for crd:v1 at hysyeah.top/k8s-crd/pkg/client/clientset</span><br><span class="line">Generating listers for crd:v1 at hysyeah.top/k8s-crd/pkg/client/listers</span><br><span class="line">Generating informers for crd:v1 at hysyeah.top/k8s-crd/pkg/client/informers</span><br></pre></td></tr></table></figure>
<p>执行完代码生成命令后，根据日志可能看出代码已经生成出来了，但是你却发现生成的文件并不在项目目录中，这是什么原因呢？<br>其实代码生成的路径是<code>$GOPATH/src/hysyeah.top/k8s-crd</code>，将生成代码拷贝至项目中。此时项目结构如下,其中红框中的代码是自动生成的：<br><img src="http://img.hysyeah.top/2021/5/20210515185844.png" alt="image"></p>
<p>8.有了自定义资源，我们还需要定义如何使用它，不然这个资源也无用之地。而对于资源的如何使用k8s是通过controller来进行资源控制的。</p>
<ul>
<li>新建目录<code>pkg/signals</code>,接收系统信号，直接使用<a href="https://github.com/kubernetes/sample-controller/tree/master/pkg/signals" target="_blank" rel="noopener">社区代码</a></li>
<li>controller.go,业务逻辑代码，可以针对资源不同的事件注册对应的函数</li>
<li>main.go, 入口函数</li>
</ul>
<p>9.编译，生成一个二进制文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go mod vendor</span><br><span class="line">go build -o dogcontroller</span><br></pre></td></tr></table></figure></p>
<p>10.创建CRD<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  k8s-crd kubectl apply -f Dog.yaml</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/dogs.crd.hysyeah.top created</span><br><span class="line">➜  k8s-crd kubectl get crd</span><br><span class="line">NAME                   CREATED AT</span><br><span class="line">dogs.crd.hysyeah.top   2021-05-15T12:25:01Z</span><br></pre></td></tr></table></figure></p>
<p>11.创建Dog实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  k8s-crd kubectl apply -f example-dog.yaml</span><br><span class="line">dog.crd.hysyeah.top/alpha-dog created</span><br></pre></td></tr></table></figure></p>
<p>12.运行dogcontroller<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./dogcontroller -kubeconfig=$HOME/.kube/config</span><br></pre></td></tr></table></figure></p>
<p>13.分别执行相应的操作，controller会解发相应的动作。以删除dog实例为例。<br><img src="http://img.hysyeah.top/2021/5/20210515203544.png" alt="image"></p>
<hr>
<p>小结：<br>以上便是手动构建CRD的过程，可以使我们更好的了解CRD和Controller的工作原理。其实工作中如果要自定义一个CRD和Controller大可不必那么麻烦，可以借助一些框架使整个过程更方便，如<a href="https://book.kubebuilder.io/" target="_blank" rel="noopener">kubebuilder</a>,<a href="https://sdk.operatorframework.io/" target="_blank" rel="noopener">operator-sdk</a>。</p>
<hr>
<p>参考：<br>1.<a href="https://github.com/kangxiaoning/learn-kubernetes-crd/blob/main/README.md" target="_blank" rel="noopener">https://github.com/kangxiaoning/learn-kubernetes-crd/blob/main/README.md</a><br>2.<a href="https://github.com/kubernetes/code-generator" target="_blank" rel="noopener">https://github.com/kubernetes/code-generator</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s hasSynced</title>
    <url>/2023/06/20/k8s-hasSynced/</url>
    <content><![CDATA[<h5 id="k8s-cache"><a href="#k8s-cache" class="headerlink" title="k8s cache"></a>k8s cache</h5><p>在<code>k8s</code>中为减轻<code>apiserver</code>的压力,会使用缓存来存储<code>k8s</code>中的资源，这样每次访问就可以直接从缓存了获取数据(<code>k8s</code>通过<code>watch</code>，<code>resync</code>机制来保证本地缓存和数据的同步)。</p>
<p>当我们在使用<code>informer</code>机制时，必须等待资源同步到本地缓存中。<br>所以如何等待和判断数据已经同步到了本地缓存呢？</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">factory := informers.NewSharedInformerFactory(clientset, time.Minute)</span><br><span class="line">podInformer := factory.Core().V1().Pods().Informer()</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">go</span> podInformer.Run(<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;))</span><br><span class="line">   <span class="comment">// client-go 中通过WaitForCacheSync来等待缓存同步</span></span><br><span class="line">   <span class="keyword">if</span> !cache.WaitForCacheSync(<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;), podInformer.HasSynced) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/client-go/tools/cache/shared_informer.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitForCacheSync</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, cacheSyncs ...InformerSynced)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	err := wait.PollImmediateUntil(syncedPollPeriod,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> _, syncFunc := <span class="keyword">range</span> cacheSyncs &#123;</span><br><span class="line">                <span class="comment">// 这里的syncFunc就是podInformer.HasSynced</span></span><br><span class="line">				<span class="keyword">if</span> !syncFunc() &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">		stopCh)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).Infof(<span class="string">"stop requested"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"caches populated"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HasSynced</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	s.startedLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.controller == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.controller.HasSynced()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging/src/k8s.io/client-go/tools/cache/controller.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">HasSynced</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.config.Queue.HasSynced()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging/src/k8s.io/client-go/tools/cache/delta_fifo.go</span></span><br><span class="line"><span class="comment">// 最后是调用DeltaFIFO中HasSynced方法进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">HasSynced</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">    <span class="comment">// 为什么这两个条件就能判断是否进行过一次fulllist呢？</span></span><br><span class="line">    <span class="comment">// 接着往下看</span></span><br><span class="line">	<span class="keyword">return</span> f.populated &amp;&amp; f.initialPopulationCount == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging/src/k8s.io/apimachinery/pkg/util/wait/poll.go</span></span><br><span class="line"><span class="comment">// PollImmediateUntil执行conditionFunc 直到函数返回true,或者error或者关闭了stopCh</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PollImmediateUntil</span><span class="params">(interval time.Duration, condition ConditionFunc, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	done, err := condition()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> done &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">		<span class="keyword">return</span> ErrWaitTimeout</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> PollUntil(interval, condition, stopCh)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// populated is true if the first batch of items inserted by Replace() has been populated</span></span><br><span class="line">	<span class="comment">// or Delete/Add/Update/AddIfNotPresent was called first.</span></span><br><span class="line">    <span class="comment">// 调用了Repllace()函数，或者Delete/Add/Update/AddIfNotPresent， populated = true</span></span><br><span class="line">	populated <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// initialPopulationCount is the number of items inserted by the first call of Replace()</span></span><br><span class="line">    <span class="comment">// 调用Replace()插入数据的长度</span></span><br><span class="line">	initialPopulationCount <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;</span><br><span class="line">		KnownObjects:          s.indexer,</span><br><span class="line">		EmitDeltaTypeReplaced: <span class="literal">true</span>,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	cfg := &amp;Config&#123;</span><br><span class="line">		Queue:            fifo,</span><br><span class="line">		ListerWatcher:    s.listerWatcher,</span><br><span class="line">		ObjectType:       s.objectType,</span><br><span class="line">		FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">		RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">		ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">		Process:           s.HandleDeltas,</span><br><span class="line">		WatchErrorHandler: s.watchErrorHandler,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">		s.controller = New(cfg)</span><br><span class="line">		s.controller.(*controller).clock = s.clock</span><br><span class="line">		s.started = <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Separate stop channel because Processor should be stopped strictly after controller</span></span><br><span class="line">	processorStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">	<span class="keyword">defer</span> wg.Wait()              <span class="comment">// Wait for Processor to stop</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(processorStopCh) <span class="comment">// Tell Processor to stop</span></span><br><span class="line">	wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br><span class="line">	wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">		s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">	&#125;()</span><br><span class="line">	s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stopCh</span><br><span class="line">		c.config.Queue.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">	r := NewReflector(</span><br><span class="line">		c.config.ListerWatcher,</span><br><span class="line">		c.config.ObjectType,</span><br><span class="line">		c.config.Queue,</span><br><span class="line">		c.config.FullResyncPeriod,</span><br><span class="line">	)</span><br><span class="line">	r.ShouldResync = c.config.ShouldResync</span><br><span class="line">	r.WatchListPageSize = c.config.WatchListPageSize</span><br><span class="line">	r.clock = c.clock</span><br><span class="line">	<span class="keyword">if</span> c.config.WatchErrorHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.watchErrorHandler = c.config.WatchErrorHandler</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.reflectorMutex.Lock()</span><br><span class="line">	c.reflector = r</span><br><span class="line">	c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line"></span><br><span class="line">	wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line"></span><br><span class="line">	wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">2</span>).Infof(<span class="string">"Starting reflector %s (%s) from %s"</span>, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class="line">	wait.BackoffUntil(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			r.watchErrorHandler(r, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, r.backoffManager, <span class="literal">true</span>, stopCh)</span><br><span class="line">	klog.V(<span class="number">2</span>).Infof(<span class="string">"Stopping reflector %s (%s) from %s"</span>, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// syncWith会调用Delta中的Replace方法</span></span><br><span class="line">    <span class="keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unable to sync list result: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">syncWith</span><span class="params">(items []runtime.Object, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	found := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(items))</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">		found = <span class="built_in">append</span>(found, item)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r.store.Replace(found, resourceVersion)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Replace</span><span class="params">(list []<span class="keyword">interface</span>&#123;&#125;, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	keys := <span class="built_in">make</span>(sets.String, <span class="built_in">len</span>(list))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// keep backwards compat for old clients</span></span><br><span class="line">	action := Sync</span><br><span class="line">	<span class="keyword">if</span> f.emitDeltaTypeReplaced &#123;</span><br><span class="line">		action = Replaced</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add Sync/Replaced action for each new item.</span></span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> list &#123;</span><br><span class="line">		key, err := f.KeyOf(item)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> KeyError&#123;item, err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		keys.Insert(key)</span><br><span class="line">		<span class="keyword">if</span> err := f.queueActionLocked(action, item); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't enqueue object: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> f.knownObjects == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Do deletion detection against our own list.</span></span><br><span class="line">		queuedDeletions := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> k, oldItem := <span class="keyword">range</span> f.items &#123;</span><br><span class="line">			<span class="keyword">if</span> keys.Has(k) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Delete pre-existing items not in the new list.</span></span><br><span class="line">			<span class="comment">// This could happen if watch deletion event was missed while</span></span><br><span class="line">			<span class="comment">// disconnected from apiserver.</span></span><br><span class="line">			<span class="keyword">var</span> deletedObj <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">			<span class="keyword">if</span> n := oldItem.Newest(); n != <span class="literal">nil</span> &#123;</span><br><span class="line">				deletedObj = n.Object</span><br><span class="line">			&#125;</span><br><span class="line">			queuedDeletions++</span><br><span class="line">			<span class="keyword">if</span> err := f.queueActionLocked(Deleted, DeletedFinalStateUnknown&#123;k, deletedObj&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !f.populated &#123;</span><br><span class="line">            <span class="comment">// 如果在这之前没有调用Add/Update/Delete/AddIfNotPresent,则设置populated = true</span></span><br><span class="line">			f.populated = <span class="literal">true</span></span><br><span class="line">			<span class="comment">// While there shouldn't be any queued deletions in the initial</span></span><br><span class="line">			<span class="comment">// population of the queue, it's better to be on the safe side.</span></span><br><span class="line">            <span class="comment">// 设置initialPopulationCount, 在进行Pop操作的时候会对initialPopulationCount-1</span></span><br><span class="line">			f.initialPopulationCount = keys.Len() + queuedDeletions</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect deletions not already in the queue.</span></span><br><span class="line">	knownKeys := f.knownObjects.ListKeys()</span><br><span class="line">	queuedDeletions := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> knownKeys &#123;</span><br><span class="line">		<span class="keyword">if</span> keys.Has(k) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		deletedObj, exists, err := f.knownObjects.GetByKey(k)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			deletedObj = <span class="literal">nil</span></span><br><span class="line">			klog.Errorf(<span class="string">"Unexpected error %v during lookup of key %v, placing DeleteFinalStateUnknown marker without object"</span>, err, k)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !exists &#123;</span><br><span class="line">			deletedObj = <span class="literal">nil</span></span><br><span class="line">			klog.Infof(<span class="string">"Key %v does not exist in known objects store, placing DeleteFinalStateUnknown marker without object"</span>, k)</span><br><span class="line">		&#125;</span><br><span class="line">		queuedDeletions++</span><br><span class="line">		<span class="keyword">if</span> err := f.queueActionLocked(Deleted, DeletedFinalStateUnknown&#123;k, deletedObj&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !f.populated &#123;</span><br><span class="line">		f.populated = <span class="literal">true</span></span><br><span class="line">		f.initialPopulationCount = keys.Len() + queuedDeletions</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span></span><br><span class="line">			<span class="comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span></span><br><span class="line">			<span class="comment">// Which causes this loop to continue and return from the Pop().</span></span><br><span class="line">			<span class="keyword">if</span> f.closed &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, ErrFIFOClosed</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			f.cond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		id := f.queue[<span class="number">0</span>]</span><br><span class="line">		f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">			f.initialPopulationCount--</span><br><span class="line">		&#125;</span><br><span class="line">		item, ok := f.items[id]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// This should never happen</span></span><br><span class="line">			klog.Errorf(<span class="string">"Inconceivable! %q was in f.queue but not f.items; ignoring."</span>, id)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">delete</span>(f.items, id)</span><br><span class="line">		err := process(item)</span><br><span class="line">		<span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">			f.addIfNotPresent(id, item)</span><br><span class="line">			err = e.Err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">		<span class="comment">// ownership to the caller.</span></span><br><span class="line">		<span class="keyword">return</span> item, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>综上<code>f.populated &amp;&amp; f.initialPopulationCount == 0</code> 表示至少进行过一次全量<code>List</code></p>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/staging/src/k8s.io/client-go/tools/cache/shared_informer.go" target="_blank" rel="noopener">staging/src/k8s.io/client-go/tools/cache/shared_informer.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/staging/src/k8s.io/client-go/tools/cache/controller.go" target="_blank" rel="noopener">staging/src/k8s.io/client-go/tools/cache/controller.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/staging/src/k8s.io/client-go/tools/cache/delta_fifo.go" target="_blank" rel="noopener">staging/src/k8s.io/client-go/tools/cache/delta_fifo.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/staging/src/k8s.io/apimachinery/pkg/util/wait/poll.go" target="_blank" rel="noopener">staging/src/k8s.io/apimachinery/pkg/util/wait/poll.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>golang container list实现</title>
    <url>/2023/09/24/golang-container-list%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><code>golang</code>源码中的<code>container</code>列表实现。</p>
<h4 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Element 表示列表中的一个节点</span></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Next and previous pointers in the doubly-linked list of elements.</span></span><br><span class="line">	<span class="comment">// To simplify the implementation, internally a list l is implemented</span></span><br><span class="line">	<span class="comment">// as a ring, such that &amp;l.root is both the next element of the last</span></span><br><span class="line">	<span class="comment">// list element (l.Back()) and the previous element of the first list</span></span><br><span class="line">	<span class="comment">// element (l.Front()).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下一个节点和前一个节点的指针</span></span><br><span class="line">	next, prev *Element</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The list to which this element belongs.</span></span><br><span class="line">    <span class="comment">// List指针表示该节点所属的列表</span></span><br><span class="line">	list *List</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The value stored with this element.</span></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">	Value any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next 返回下一个节点口的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Element)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果e.list != nil 且下一个节点不是root则返回e.next</span></span><br><span class="line">	<span class="keyword">if</span> p := e.next; e.list != <span class="literal">nil</span> &amp;&amp; p != &amp;e.list.root &#123;</span><br><span class="line">		<span class="keyword">return</span> p</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prev 返回上一个节点的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Element)</span> <span class="title">Prev</span><span class="params">()</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果e.list != nil 且下一个节点不是root则返回e.prev</span></span><br><span class="line">	<span class="keyword">if</span> p := e.prev; e.list != <span class="literal">nil</span> &amp;&amp; p != &amp;e.list.root &#123;</span><br><span class="line">		<span class="keyword">return</span> p</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 表示一个双向链表</span></span><br><span class="line"><span class="comment">// 链表的最后一个节点的next指针和链表的第一个节点的prev指针都指向root</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	root Element <span class="comment">// sentinel list element, only &amp;root, root.prev, and root.next are used</span></span><br><span class="line">	<span class="built_in">len</span>  <span class="keyword">int</span>     <span class="comment">// current list length excluding (this) sentinel element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init 初始化或清除一个列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Init</span><span class="params">()</span> *<span class="title">List</span></span> &#123;</span><br><span class="line">	l.root.next = &amp;l.root</span><br><span class="line">	l.root.prev = &amp;l.root</span><br><span class="line">	l.<span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 初始化一个列表并返回其指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">List</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span>(List).Init() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回列表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> l.<span class="built_in">len</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Front 返回列表的第一个节点指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Front</span><span class="params">()</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> l.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l.root.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Back 返回列表的最后一个指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Back</span><span class="params">()</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> l.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l.root.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lazyInit lazily initializes a zero List value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">lazyInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> l.root.next == <span class="literal">nil</span> &#123;</span><br><span class="line">		l.Init()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert 在节点at之后插入节点e, 并返回节点e指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">insert</span><span class="params">(e, at *Element)</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">	e.prev = at</span><br><span class="line">	e.next = at.next</span><br><span class="line">	e.prev.next = e</span><br><span class="line">	e.next.prev = e</span><br><span class="line">	e.list = l</span><br><span class="line">	l.<span class="built_in">len</span>++</span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// insertValue 对insert的封装</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">insertValue</span><span class="params">(v any, at *Element)</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> l.insert(&amp;Element&#123;Value: v&#125;, at)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove 将节点从列表中移除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">remove</span><span class="params">(e *Element)</span></span> &#123;</span><br><span class="line">	e.prev.next = e.next</span><br><span class="line">	e.next.prev = e.prev</span><br><span class="line">	e.next = <span class="literal">nil</span> <span class="comment">// avoid memory leaks</span></span><br><span class="line">	e.prev = <span class="literal">nil</span> <span class="comment">// avoid memory leaks</span></span><br><span class="line">	e.list = <span class="literal">nil</span></span><br><span class="line">	l.<span class="built_in">len</span>--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// move 将节点e移动到节点at之后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">move</span><span class="params">(e, at *Element)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e == at &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	e.prev.next = e.next</span><br><span class="line">	e.next.prev = e.prev</span><br><span class="line"></span><br><span class="line">	e.prev = at</span><br><span class="line">	e.next = at.next</span><br><span class="line">	e.prev.next = e</span><br><span class="line">	e.next.prev = e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 将节点从列表中移除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Remove</span><span class="params">(e *Element)</span> <span class="title">any</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e.list == l &#123;</span><br><span class="line">		<span class="comment">// if e.list == l, l must have been initialized when e was inserted</span></span><br><span class="line">		<span class="comment">// in l or l == nil (e is a zero Element) and l.remove will crash</span></span><br><span class="line">		l.remove(e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> e.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushFront 将节点插入到列表头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">PushFront</span><span class="params">(v any)</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">	l.lazyInit()</span><br><span class="line">	<span class="keyword">return</span> l.insertValue(v, &amp;l.root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushBack 将节点插入到列表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">PushBack</span><span class="params">(v any)</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">	l.lazyInit()</span><br><span class="line">	<span class="keyword">return</span> l.insertValue(v, l.root.prev)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InsertBefore 将v插入到节点mark之前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">InsertBefore</span><span class="params">(v any, mark *Element)</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> mark.list != l &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// see comment in List.Remove about initialization of l</span></span><br><span class="line">	<span class="keyword">return</span> l.insertValue(v, mark.prev)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InsertAfter 将v插入到节点mark之后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">InsertAfter</span><span class="params">(v any, mark *Element)</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> mark.list != l &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// see comment in List.Remove about initialization of l</span></span><br><span class="line">	<span class="keyword">return</span> l.insertValue(v, mark)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MoveToFront 将节点e移动到列表头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveToFront</span><span class="params">(e *Element)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e.list != l || l.root.next == e &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// see comment in List.Remove about initialization of l</span></span><br><span class="line">	l.move(e, &amp;l.root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MoveToBack 将节点e移动到列表末尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveToBack</span><span class="params">(e *Element)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e.list != l || l.root.prev == e &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// see comment in List.Remove about initialization of l</span></span><br><span class="line">	l.move(e, l.root.prev)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MoveBefore 将节点e移动到mark之前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveBefore</span><span class="params">(e, mark *Element)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e.list != l || e == mark || mark.list != l &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	l.move(e, mark.prev)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// MoveAfter 将节点e移动到mark之后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">MoveAfter</span><span class="params">(e, mark *Element)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e.list != l || e == mark || mark.list != l &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	l.move(e, mark)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushBackList 将一个列表中的所有元素加入l中，在l之后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">PushBackList</span><span class="params">(other *List)</span></span> &#123;</span><br><span class="line">	l.lazyInit()</span><br><span class="line">	<span class="keyword">for</span> i, e := other.Len(), other.Front(); i &gt; <span class="number">0</span>; i, e = i<span class="number">-1</span>, e.Next() &#123;</span><br><span class="line">		l.insertValue(e.Value, l.root.prev)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushFrontList 将一个列表中的所有元素加入l中，在l之前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">PushFrontList</span><span class="params">(other *List)</span></span> &#123;</span><br><span class="line">	l.lazyInit()</span><br><span class="line">	<span class="keyword">for</span> i, e := other.Len(), other.Back(); i &gt; <span class="number">0</span>; i, e = i<span class="number">-1</span>, e.Prev() &#123;</span><br><span class="line">		l.insertValue(e.Value, &amp;l.root)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/list"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l := list.New()</span><br><span class="line">	e4 := l.PushBack(<span class="number">4</span>)</span><br><span class="line">	e1 := l.PushFront(<span class="number">1</span>)</span><br><span class="line">	l.InsertBefore(<span class="number">3</span>, e4)</span><br><span class="line">	l.InsertAfter(<span class="number">2</span>, e1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate through list and print its contents.</span></span><br><span class="line">	<span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		fmt.Println(e.Value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:</p>
<ol>
<li><a href="https://github.com/golang/go/blob/master/src/container/list/list.go" target="_blank" rel="noopener">container/list/list.go</a></li>
</ol>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s informer</title>
    <url>/2021/07/25/k8s-informer/</url>
    <content><![CDATA[<p>今天通过一张图和一段代码来完全掌握k8s中的informer机制。</p>
<p><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/images/client-go-controller-interaction.jpeg" target="_blank" rel="noopener">图片来源</a><br><img src="http://img.hysyeah.top/2021/7/k8s-informer.jpg" alt="image"></p>
<h5 id="Reflector-用于监听指定k8s资源的变化，并将事件推送到DeltaFIFO中-监听的对象需要实现ListAndWatch方法-监听的对象可以是k8s中的内置资源也可以自定义资源"><a href="#Reflector-用于监听指定k8s资源的变化，并将事件推送到DeltaFIFO中-监听的对象需要实现ListAndWatch方法-监听的对象可以是k8s中的内置资源也可以自定义资源" class="headerlink" title="Reflector: 用于监听指定k8s资源的变化，并将事件推送到DeltaFIFO中.监听的对象需要实现ListAndWatch方法.监听的对象可以是k8s中的内置资源也可以自定义资源"></a>Reflector: 用于监听指定k8s资源的变化，并将事件推送到<code>DeltaFIFO</code>中.监听的对象需要实现<code>ListAndWatch</code>方法.监听的对象可以是k8s中的内置资源也可以自定义资源</h5><h5 id="DeltaFIFO-一个存储资源对象的先进先出队列"><a href="#DeltaFIFO-一个存储资源对象的先进先出队列" class="headerlink" title="DeltaFIFO: 一个存储资源对象的先进先出队列"></a>DeltaFIFO: 一个存储资源对象的先进先出队列</h5><h5 id="Indexer-自带索引功能的本地存储-可参考k8s-indexer"><a href="#Indexer-自带索引功能的本地存储-可参考k8s-indexer" class="headerlink" title="Indexer: 自带索引功能的本地存储.可参考k8s-indexer"></a>Indexer: 自带索引功能的本地存储.可参考<a href="http://hysyeah.top/2021/07/11/k8s-Indexer%E7%B4%A2%E5%BC%95%E5%99%A8%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">k8s-indexer</a></h5><p>k8s代码版本为<code>V1.21</code></p>
<h4 id="Reflector结构定义"><a href="#Reflector结构定义" class="headerlink" title="Reflector结构定义"></a>Reflector结构定义</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/client-go/tools/cache/reflector.go</span></span><br><span class="line"><span class="comment">// Reflector 监听指定资源变化并将变化事件推送到指定存储</span></span><br><span class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 只列出部分字段</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 指定存储</span></span><br><span class="line">    <span class="comment">// 需实现Add,Update,Delete,List,ListKeys,Get,GetByKey,Replace,Resync方法</span></span><br><span class="line">    store Store</span><br><span class="line">    listerWatcher ListerWatcher</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging/src/k8s.io/client-go/tools/cache/listwatch.go</span></span><br><span class="line"><span class="keyword">type</span> Lister <span class="keyword">interface</span> &#123;</span><br><span class="line">	List(options metav1.ListOptions) (runtime.Object, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Watcher <span class="keyword">interface</span> &#123;</span><br><span class="line">	Watch(options metav1.ListOptions) (watch.Interface, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListerWatcher <span class="keyword">interface</span> &#123;</span><br><span class="line">	Lister</span><br><span class="line">	Watcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListFunc knows how to list resources</span></span><br><span class="line"><span class="keyword">type</span> ListFunc <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WatchFunc knows how to watch resources</span></span><br><span class="line"><span class="keyword">type</span> WatchFunc <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ListWatch knows how to list and watch a set of apiserver resources.  It satisfies the ListerWatcher interface.</span></span><br><span class="line"><span class="comment">// It is a convenience function for users of NewReflector, etc.</span></span><br><span class="line"><span class="comment">// ListFunc and WatchFunc must not be nil</span></span><br><span class="line"><span class="keyword">type</span> ListWatch <span class="keyword">struct</span> &#123;</span><br><span class="line">	ListFunc  ListFunc</span><br><span class="line">	WatchFunc WatchFunc</span><br><span class="line">	<span class="comment">// DisableChunking requests no chunking for this list watcher.</span></span><br><span class="line">	DisableChunking <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewListWatchFromClient creates a new ListWatch from the specified client, resource, namespace and field selector.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewListWatchFromClient</span><span class="params">(c Getter, resource <span class="keyword">string</span>, namespace <span class="keyword">string</span>, fieldSelector fields.Selector)</span> *<span class="title">ListWatch</span></span> &#123;</span><br><span class="line">	optionsModifier := <span class="function"><span class="keyword">func</span><span class="params">(options *metav1.ListOptions)</span></span> &#123;</span><br><span class="line">		options.FieldSelector = fieldSelector.String()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NewFilteredListWatchFromClient(c, resource, namespace, optionsModifier)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewFilteredListWatchFromClient creates a new ListWatch from the specified client, resource, namespace, and option modifier.</span></span><br><span class="line"><span class="comment">// Option modifier is a function takes a ListOptions and modifies the consumed ListOptions. Provide customized modifier function</span></span><br><span class="line"><span class="comment">// to apply modification to ListOptions with a field selector, a label selector, or any other desired options.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFilteredListWatchFromClient</span><span class="params">(c Getter, resource <span class="keyword">string</span>, namespace <span class="keyword">string</span>, optionsModifier <span class="keyword">func</span>(options *metav1.ListOptions)</span>) *<span class="title">ListWatch</span></span> &#123;</span><br><span class="line">	listFunc := <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">		optionsModifier(&amp;options)</span><br><span class="line">		<span class="keyword">return</span> c.Get().</span><br><span class="line">			Namespace(namespace).</span><br><span class="line">			Resource(resource).</span><br><span class="line">			VersionedParams(&amp;options, metav1.ParameterCodec).</span><br><span class="line">			Do(context.TODO()).</span><br><span class="line">			Get()</span><br><span class="line">	&#125;</span><br><span class="line">	watchFunc := <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">		options.Watch = <span class="literal">true</span></span><br><span class="line">		optionsModifier(&amp;options)</span><br><span class="line">		<span class="keyword">return</span> c.Get().</span><br><span class="line">			Namespace(namespace).</span><br><span class="line">			Resource(resource).</span><br><span class="line">			VersionedParams(&amp;options, metav1.ParameterCodec).</span><br><span class="line">			Watch(context.TODO())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;ListWatch&#123;ListFunc: listFunc, WatchFunc: watchFunc&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List a set of apiserver resources</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lw *ListWatch)</span> <span class="title">List</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ListWatch is used in Reflector, which already supports pagination.</span></span><br><span class="line">	<span class="comment">// Don't paginate here to avoid duplication.</span></span><br><span class="line">	<span class="keyword">return</span> lw.ListFunc(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watch a set of apiserver resources</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lw *ListWatch)</span> <span class="title">Watch</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> lw.WatchFunc(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DeltaFIFO结构定义"><a href="#DeltaFIFO结构定义" class="headerlink" title="DeltaFIFO结构定义"></a>DeltaFIFO结构定义</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/client-go/tools/cache/delta_fifo.go</span></span><br><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock sync.RWMutex</span><br><span class="line">	cond sync.Cond</span><br><span class="line"></span><br><span class="line">	items <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas</span><br><span class="line">    queue []<span class="keyword">string</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type   DeltaType    <span class="comment">// 事件类型：string</span></span><br><span class="line">	Object <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 资源对象: k8s对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Deltas []Delta</span><br></pre></td></tr></table></figure>
<h4 id="通过一段代码来搞清楚informer是怎么工作的"><a href="#通过一段代码来搞清楚informer是怎么工作的" class="headerlink" title="通过一段代码来搞清楚informer是怎么工作的"></a>通过一段代码来搞清楚informer是怎么工作的</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 构建config</span></span><br><span class="line">	config, err := clientcmd.BuildConfigFromFlags(<span class="string">""</span>,<span class="string">"/root/.kube/config"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(stopCh)</span><br><span class="line">    <span class="comment">// informer的工厂函数,返回的是sharedInformerFactory对象</span></span><br><span class="line">    factory := informers.NewSharedInformerFactory(clientset, time.Minute)</span><br><span class="line">    <span class="comment">// 创建Pod资源对象的Informer</span></span><br><span class="line">    informer := factory.Core().V1().Pods().Informer()</span><br><span class="line">    <span class="comment">// 注册事件回调函数</span></span><br><span class="line">	informer.AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			p := obj.(*corev1.Pod)</span><br><span class="line">			fmt.Println(<span class="string">"add a pod:"</span>, p.Name)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"update a pod"</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"delete a pod"</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	informer.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.获取informer工厂函数</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/informers/factory.go</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">type</span> sharedInformerFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">	client           kubernetes.Interface</span><br><span class="line">	namespace        <span class="keyword">string</span></span><br><span class="line">	tweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class="line">	lock             sync.Mutex</span><br><span class="line">	defaultResync    time.Duration</span><br><span class="line">	customResync     <span class="keyword">map</span>[reflect.Type]time.Duration</span><br><span class="line"></span><br><span class="line">	informers <span class="keyword">map</span>[reflect.Type]cache.SharedIndexInformer</span><br><span class="line">	<span class="comment">// startedInformers is used for tracking which informers have been started.</span></span><br><span class="line">	<span class="comment">// This allows Start() to be called multiple times safely.</span></span><br><span class="line">	startedInformers <span class="keyword">map</span>[reflect.Type]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用NewSharedInformerFactoryWithOptions创建一个sharedInformerFactory并最先实例化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSharedInformerFactoryWithOptions</span><span class="params">(client kubernetes.Interface, defaultResync time.Duration, options ...SharedInformerOption)</span> <span class="title">SharedInformerFactory</span></span> &#123;</span><br><span class="line">	factory := &amp;sharedInformerFactory&#123;</span><br><span class="line">		client:           client,</span><br><span class="line">		namespace:        v1.NamespaceAll,</span><br><span class="line">		defaultResync:    defaultResync,</span><br><span class="line">		informers:        <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]cache.SharedIndexInformer),</span><br><span class="line">		startedInformers: <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]<span class="keyword">bool</span>),</span><br><span class="line">		customResync:     <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]time.Duration),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Apply all options</span></span><br><span class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> options &#123;</span><br><span class="line">		factory = opt(factory)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> factory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SharedIndexInformer provides add and get Indexers ability based on SharedInformer.</span><br><span class="line">// 在SharedInformer的基础上提供了Indexers能力</span><br><span class="line">type SharedIndexInformer interface &#123;</span><br><span class="line">	SharedInformer</span><br><span class="line">	// AddIndexers add indexers to the informer before it starts.</span><br><span class="line">	AddIndexers(indexers Indexers) error</span><br><span class="line">	GetIndexer() Indexer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.<code>informer</code>的创建流程<br><img src="http://img.hysyeah.top/2021/7/20210725201508-podinformercreate.png" alt="image"><br><figure class="highlight plain"><figcaption><span>:</span></figcaption><table><tr><td class="code"><pre><span class="line">```golang</span><br><span class="line">// client-go/informers/factory.go</span><br><span class="line">func (f *sharedInformerFactory) Core() core.Interface &#123;</span><br><span class="line">	return core.New(f, f.namespace, f.tweakListOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/informers/core/interface.go</span></span><br><span class="line"><span class="keyword">type</span> group <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory          internalinterfaces.SharedInformerFactory</span><br><span class="line">	namespace        <span class="keyword">string</span></span><br><span class="line">	tweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New(core.New) returns a new Interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(f internalinterfaces.SharedInformerFactory, namespace <span class="keyword">string</span>, tweakListOptions internalinterfaces.TweakListOptionsFunc)</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;group&#123;factory: f, namespace: namespace, tweakListOptions: tweakListOptions&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *group)</span> <span class="title">V1</span><span class="params">()</span> <span class="title">v1</span>.<span class="title">Interface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v1.New(g.factory, g.namespace, g.tweakListOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/informers/core/v1/interface.go</span></span><br><span class="line"><span class="keyword">type</span> version <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory          internalinterfaces.SharedInformerFactory</span><br><span class="line">	namespace        <span class="keyword">string</span></span><br><span class="line">	tweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New(V1.New) returns a new Interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(f internalinterfaces.SharedInformerFactory, namespace <span class="keyword">string</span>, tweakListOptions internalinterfaces.TweakListOptionsFunc)</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;version&#123;factory: f, namespace: namespace, tweakListOptions: tweakListOptions&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pods返回PodInformer实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *version)</span> <span class="title">Pods</span><span class="params">()</span> <span class="title">PodInformer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;podInformer&#123;factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/informers/core/v1/pod.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *podInformer)</span> <span class="title">Informer</span><span class="params">()</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f.factory.InformerFor(&amp;corev1.Pod&#123;&#125;, f.defaultInformer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/informers/factory.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">InformerFor</span><span class="params">(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	informerType := reflect.TypeOf(obj)</span><br><span class="line">	informer, exists := f.informers[informerType]</span><br><span class="line">	<span class="keyword">if</span> exists &#123;</span><br><span class="line">		<span class="keyword">return</span> informer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resyncPeriod, exists := f.customResync[informerType]</span><br><span class="line">	<span class="keyword">if</span> !exists &#123;</span><br><span class="line">		resyncPeriod = f.defaultResync</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	informer = newFunc(f.client, resyncPeriod)</span><br><span class="line">	f.informers[informerType] = informer</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.informer是如何启动的<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/shared_informer.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="comment">// 创建一个FIFO队列</span></span><br><span class="line">	fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;</span><br><span class="line">		KnownObjects:          s.indexer,</span><br><span class="line">		EmitDeltaTypeReplaced: <span class="literal">true</span>,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	cfg := &amp;Config&#123;</span><br><span class="line">        Queue:            fifo,</span><br><span class="line">        <span class="comment">// 设置ListerWatcher函数</span></span><br><span class="line">        ListerWatcher:    s.listerWatcher,</span><br><span class="line">        <span class="comment">// 对象类型v1.Pod</span></span><br><span class="line">		ObjectType:       s.objectType,</span><br><span class="line">		FullResyncPeriod: s.resyncCheckPeriod,</span><br><span class="line">		RetryOnError:     <span class="literal">false</span>,</span><br><span class="line">		ShouldResync:     s.processor.shouldResync,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里应该是设置事件回调函数</span></span><br><span class="line">		Process:           s.HandleDeltas,</span><br><span class="line">		WatchErrorHandler: s.watchErrorHandler,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据上面的配置文件,创建一个Controller对象</span></span><br><span class="line">		s.controller = New(cfg)</span><br><span class="line">		s.controller.(*controller).clock = s.clock</span><br><span class="line">		s.started = <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Separate stop channel because Processor should be stopped strictly after controller</span></span><br><span class="line">	processorStopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">	<span class="keyword">defer</span> wg.Wait()              <span class="comment">// Wait for Processor to stop</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(processorStopCh) <span class="comment">// Tell Processor to stop</span></span><br><span class="line">    <span class="comment">// 启动两个goroutine</span></span><br><span class="line">    wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br><span class="line">	wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.startedLock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> s.startedLock.Unlock()</span><br><span class="line">		s.stopped = <span class="literal">true</span> <span class="comment">// Don't want any new listeners</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 运行控制器</span></span><br><span class="line">	s.controller.Run(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进入到s.controller.Run(stopCh),在这里会创建Reflector对象</span></span><br><span class="line"><span class="comment">// client-go/tools/cache/controller.go</span></span><br><span class="line"><span class="comment">// s.controller.Run(stopCh)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stopCh</span><br><span class="line">		c.config.Queue.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 创建Reflector</span></span><br><span class="line"></span><br><span class="line">	r := NewReflector(</span><br><span class="line">		c.config.ListerWatcher,</span><br><span class="line">		c.config.ObjectType,</span><br><span class="line">		c.config.Queue,</span><br><span class="line">		c.config.FullResyncPeriod,</span><br><span class="line">	)</span><br><span class="line">	r.ShouldResync = c.config.ShouldResync</span><br><span class="line">	r.WatchListPageSize = c.config.WatchListPageSize</span><br><span class="line">	r.clock = c.clock</span><br><span class="line">	<span class="keyword">if</span> c.config.WatchErrorHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.watchErrorHandler = c.config.WatchErrorHandler</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.reflectorMutex.Lock()</span><br><span class="line">	c.reflector = r</span><br><span class="line">	c.reflectorMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg wait.Group</span><br><span class="line">    <span class="comment">// 以goroutine的形式启动Reflector</span></span><br><span class="line">	wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line">    <span class="comment">// 以goroutine的形式启动c.processLoop,</span></span><br><span class="line">	wait.Until(c.processLoop, time.Second, stopCh)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从工作队列中获取元素,并进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *controller)</span> <span class="title">processLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == ErrFIFOClosed &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.config.RetryOnError &#123;</span><br><span class="line">				<span class="comment">// This is the safe way to re-enqueue.</span></span><br><span class="line">				c.config.Queue.AddIfNotPresent(obj)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/delta_fifo.go</span></span><br><span class="line"><span class="comment">// 从队列中Pop元素，并执行用户自定义的事件回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span></span><br><span class="line">			<span class="comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span></span><br><span class="line">			<span class="comment">// Which causes this loop to continue and return from the Pop().</span></span><br><span class="line">			<span class="keyword">if</span> f.closed &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, ErrFIFOClosed</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			f.cond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		id := f.queue[<span class="number">0</span>]</span><br><span class="line">		f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">			f.initialPopulationCount--</span><br><span class="line">		&#125;</span><br><span class="line">		item, ok := f.items[id]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// This should never happen</span></span><br><span class="line">			klog.Errorf(<span class="string">"Inconceivable! %q was in f.queue but not f.items; ignoring."</span>, id)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="built_in">delete</span>(f.items, id)</span><br><span class="line">        <span class="comment">// 用户自定义的事件 处理函数</span></span><br><span class="line">		err := process(item)</span><br><span class="line">		<span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">			f.addIfNotPresent(id, item)</span><br><span class="line">			err = e.Err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">		<span class="comment">// ownership to the caller.</span></span><br><span class="line">		<span class="keyword">return</span> item, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们进入process(item)函数<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/shared_informer.go</span></span><br><span class="line"><span class="comment">// 真正处理DeltaFIFO数据的函数</span></span><br><span class="line"><span class="comment">// 这里会将获取到的数据存入indexer中(如果数据存在的话进行更新操作，否则直接插入)，完成后还会进行distribute操作</span></span><br><span class="line"><span class="comment">// 将事件分发给监听者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s.blockDeltas.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// from oldest to newest</span></span><br><span class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">		<span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> Sync, Replaced, Added, Updated:</span><br><span class="line">			s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">			<span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				isSync := <span class="literal">false</span></span><br><span class="line">				<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> d.Type == Sync:</span><br><span class="line">					<span class="comment">// Sync events are only propagated to listeners that requested resync</span></span><br><span class="line">					isSync = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">case</span> d.Type == Replaced:</span><br><span class="line">					<span class="keyword">if</span> accessor, err := meta.Accessor(d.Object); err == <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> oldAccessor, err := meta.Accessor(old); err == <span class="literal">nil</span> &#123;</span><br><span class="line">							<span class="comment">// Replaced events that didn't change resourceVersion are treated as resync events</span></span><br><span class="line">							<span class="comment">// and only propagated to listeners that requested resync</span></span><br><span class="line">							isSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> Deleted:</span><br><span class="line">			<span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将事件分发给监听者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *sharedProcessor)</span> <span class="title">distribute</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, sync <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	p.listenersLock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> p.listenersLock.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sync &#123;</span><br><span class="line">		<span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.syncingListeners &#123;</span><br><span class="line">			listener.add(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, listener := <span class="keyword">range</span> p.listeners &#123;</span><br><span class="line">			listener.add(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那存量的pod列表信息是何时放入到DeltaFIFO中的呢,也就是说何时调用ListFunc？<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/reflector.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 此处会调用client-go/informers/core/v1/pod.go中NewFilteredPodInformer中的ListFunc,获取pod资源对象列表</span></span><br><span class="line">    pager := pager.New(pager.SimplePageFunc(<span class="function"><span class="keyword">func</span><span class="params">(opts metav1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r.listerWatcher.List(opts)</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="comment">// 此处将pod资源对象列表插入到DeltaFIFO中</span></span><br><span class="line">    <span class="keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unable to sync list result: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将list接口中的数据存放到cache.DeltaFIFO中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">syncWith</span><span class="params">(items []runtime.Object, resourceVersion <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	found := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(items))</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">		found = <span class="built_in">append</span>(found, item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对store中已存在的元素进行替换操作</span></span><br><span class="line">	<span class="keyword">return</span> r.store.Replace(found, resourceVersion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真正执行入队的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">queueActionLocked</span><span class="params">(actionType DeltaType, obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	id, err := f.KeyOf(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    oldDeltas := f.items[id]</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    newDeltas := <span class="built_in">append</span>(oldDeltas, Delta&#123;actionType, obj&#125;)</span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">	newDeltas = dedupDeltas(newDeltas)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(newDeltas) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _, exists := f.items[id]; !exists &#123;</span><br><span class="line">			f.queue = <span class="built_in">append</span>(f.queue, id)</span><br><span class="line">		&#125;</span><br><span class="line">		f.items[id] = newDeltas</span><br><span class="line">		f.cond.Broadcast()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// This never happens, because dedupDeltas never returns an empty list</span></span><br><span class="line">		<span class="comment">// when given a non-empty list (as it is here).</span></span><br><span class="line">		<span class="comment">// If somehow it happens anyway, deal with it but complain.</span></span><br><span class="line">		<span class="keyword">if</span> oldDeltas == <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Errorf(<span class="string">"Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; ignoring"</span>, id, oldDeltas, obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.Errorf(<span class="string">"Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; breaking invariant by storing empty Deltas"</span>, id, oldDeltas, obj)</span><br><span class="line">		f.items[id] = newDeltas</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; broke DeltaFIFO invariant by storing empty Deltas"</span>, id, oldDeltas, obj)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>使用IDE对文中的示例代码进行调试，因为这段代码会启动多个不会退出的协程，所以为调试增加了难度。执行<code>informer.Run(stopCh)</code>会运行多个<code>goroutine</code>,可以在对应的协程代码里面打断点进行调试，更好的理解<code>informer</code>机制。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)</span><br><span class="line">wg.StartWithChannel(processorStopCh, s.processor.run)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行Reflector实例</span></span><br><span class="line">wg.StartWithChannel(stopCh, r.Run)</span><br><span class="line">wait.Until(c.processLoop, time.Second, stopCh)</span><br></pre></td></tr></table></figure></p>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="noopener">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a><br>2.<a href="https://cloudnative.to/blog/client-go-informer-source-code/" target="_blank" rel="noopener">https://cloudnative.to/blog/client-go-informer-source-code</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>golang net/http路由实现</title>
    <url>/2023/11/04/golang-net-http%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>当我们使用<code>net/http</code>开发一个接口时，需要编写一个handler函数，然后将handler函数注册到对应的url中。<br>当服务启动后， 访问对应的url就会将对应的请求转发到对应的hander函数中。<br>下面是一个使用<code>net/http</code>的示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func helloWorldHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	fmt.Fprintf(w, &quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	http.HandleFunc(&quot;/&quot;, helloWorldHandler)</span><br><span class="line">	http.ListenAndServe(&quot;:8888&quot;, nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜   curl http://127.0.0.1:8888</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
<p>今天我们就来分析下这当中的路由过程，也就是<code>net/http</code>是如何通过<code>URI</code>找到对应的handler函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// net/http/server.go</span><br><span class="line">// HandleFunc 将handler函数注册到指定的pattern中</span><br><span class="line">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;</span><br><span class="line">	if handler == nil &#123;</span><br><span class="line">		panic(&quot;http: nil handler&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">    // HandlerFunc 实现了ServeHTTP方法</span><br><span class="line">	mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The HandlerFunc type is an adapter to allow the use of</span><br><span class="line">// ordinary functions as HTTP handlers. If f is a function</span><br><span class="line">// with the appropriate signature, HandlerFunc(f) is a</span><br><span class="line">// Handler that calls f.</span><br><span class="line">type HandlerFunc func(ResponseWriter, *Request)</span><br><span class="line"></span><br><span class="line">// ServeHTTP calls f(w, r).</span><br><span class="line">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">	f(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Handle 完成handler函数的注册</span><br><span class="line">func (mux *ServeMux) Handle(pattern string, handler Handler) &#123;</span><br><span class="line">    // 上锁</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	defer mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    // pattern不能为空</span><br><span class="line">	if pattern == &quot;&quot; &#123;</span><br><span class="line">		panic(&quot;http: invalid pattern&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">    // handler函数不能为nil</span><br><span class="line">	if handler == nil &#123;</span><br><span class="line">		panic(&quot;http: nil handler&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">    // 如果patter已经注册，也会panic</span><br><span class="line">	if _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">		panic(&quot;http: multiple registrations for &quot; + pattern)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if mux.m == nil &#123;</span><br><span class="line">		mux.m = make(map[string]muxEntry)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">    // 注册到m中</span><br><span class="line">	mux.m[pattern] = e</span><br><span class="line">    // 如果pattern以/结尾还需要加入到mux.es中</span><br><span class="line">	if pattern[len(pattern)-1] == &apos;/&apos; &#123;</span><br><span class="line">		mux.es = appendSorted(mux.es, e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if pattern[0] != &apos;/&apos; &#123;</span><br><span class="line">		mux.hosts = true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以上便是handler的整个注册过程</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// net/http/server.go</span></span><br><span class="line"><span class="comment">// 上面涉及到的DefaultServeMux是一个结构体指针，指向ServeMux</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Patterns name 有两种形式，一种是 rooted paths, 如 "/favicon.ico"</span></span><br><span class="line"><span class="comment">// 另一个是 rooted subtrees, 如"/images/"(注意这里是以"/"结尾)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用最长匹配优先原则，也就是说如果同时注册了"/images/", "/images/thumbnails/"</span></span><br><span class="line"><span class="comment">// 如果一个请求的URL前缀是"/images/thumbnails/"将会匹配到"/images/thumbnails/"对应的handler,</span></span><br><span class="line"><span class="comment">// "/images/"将会匹配除"/images/thumbnails/"之外的所有以"/images/"作为前缀的请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽说以 "/"结尾的pattern叫作 rooted subtree, 但"/"会匹配所有没有被匹配到的请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果注册了一个 rooted subtrees且一个请求的URL是没有以"/"结尾的 subtree, ServeMux将会将这个请求</span></span><br><span class="line"><span class="comment">// 重定向到subtree root,也就是说会加上"/". 这个行为可以通过注册另一个没有以"/"结尾的pattern来避免。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设你只注册了"/images/", ServeMux会将"/images"重定向到"/images/"，除非你再单独注册"/images"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有的pattern可能还带有主机名，限制只匹配某一主机, 此优先级高于通用的pattern</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeMux 是定义了一个http请求多路复用器</span></span><br><span class="line"><span class="comment">// 对于每个请求会根据请求的URL找到对应的handler函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">	es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">	hosts <span class="keyword">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	h       Handler</span><br><span class="line">	pattern <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个http请求的路由过程<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ListenAndServe 监听指定地址，然后调用handler处理请求</span><br><span class="line">// 这里的Handler是一个接口，实现了ServeHTTP方法</span><br><span class="line">func ListenAndServe(addr string, handler Handler) error &#123;</span><br><span class="line">	server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">	return server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Handler interface &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ServeMux实现了ServeHTTP方法</span><br><span class="line">// 一个请求进行来ListenAndServe会调用ServeHTTP处理请求</span><br><span class="line">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">	if r.RequestURI == &quot;*&quot; &#123;</span><br><span class="line">		if r.ProtoAtLeast(1, 1) &#123;</span><br><span class="line">			w.Header().Set(&quot;Connection&quot;, &quot;close&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">    // 这里会返回一个handler函数，该函数实现了ServeHTTP方法</span><br><span class="line">	h, _ := mux.Handler(r)</span><br><span class="line">    // 调用handler函数</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) &#123;</span><br><span class="line"></span><br><span class="line">	// CONNECT requests are not canonicalized.</span><br><span class="line">	if r.Method == &quot;CONNECT&quot; &#123;</span><br><span class="line">		// If r.URL.Path is /tree and its handler is not registered,</span><br><span class="line">		// the /tree -&gt; /tree/ redirect applies to CONNECT requests</span><br><span class="line">		// but the path canonicalization does not.</span><br><span class="line">		if u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok &#123;</span><br><span class="line">			return RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return mux.handler(r.Host, r.URL.Path)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// All other requests have any port stripped and path cleaned</span><br><span class="line">	// before passing to mux.handler.</span><br><span class="line">	host := stripHostPort(r.Host)</span><br><span class="line">	path := cleanPath(r.URL.Path)</span><br><span class="line"></span><br><span class="line">	// If the given path is /tree and its handler is not registered,</span><br><span class="line">	// redirect for /tree/.</span><br><span class="line">	if u, ok := mux.redirectToPathSlash(host, path, r.URL); ok &#123;</span><br><span class="line">		return RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if path != r.URL.Path &#123;</span><br><span class="line">		_, pattern = mux.handler(host, path)</span><br><span class="line">		u := &amp;url.URL&#123;Path: path, RawQuery: r.URL.RawQuery&#125;</span><br><span class="line">		return RedirectHandler(u.String(), StatusMovedPermanently), pattern</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) &#123;</span><br><span class="line">	mux.mu.RLock()</span><br><span class="line">	defer mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">	// Host-specific pattern takes precedence over generic ones</span><br><span class="line">	if mux.hosts &#123;</span><br><span class="line">		h, pattern = mux.match(host + path)</span><br><span class="line">	&#125;</span><br><span class="line">	if h == nil &#123;</span><br><span class="line">		h, pattern = mux.match(path)</span><br><span class="line">	&#125;</span><br><span class="line">	if h == nil &#123;</span><br><span class="line">		h, pattern = NotFoundHandler(), &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// match 最终对URL进行匹配操作</span><br><span class="line">func (mux *ServeMux) match(path string) (h Handler, pattern string) &#123;</span><br><span class="line">	// Check for exact match first.</span><br><span class="line"></span><br><span class="line">	v, ok := mux.m[path]</span><br><span class="line">	if ok &#123;</span><br><span class="line">		return v.h, v.pattern</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Check for longest valid match.  mux.es contains all patterns</span><br><span class="line">	// that end in / sorted from longest to shortest.</span><br><span class="line">	for _, e := range mux.es &#123;</span><br><span class="line">		if strings.HasPrefix(path, e.pattern) &#123;</span><br><span class="line">			return e.h, e.pattern</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return nil, &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>小结：<br><code>net/http</code>的路由方式实现比较简单，只能适用于一些简单的场景，对于一些复杂的需求还是需要每三方库。<br><code>ServeMux</code>使用map和列表来存储数据，如果存在很多类似的pattern的情况下会占用比较多的空间(相对于字典树实现方式)，<br>通过列表进行匹配也需要更多的计算资源。</p>
<hr>
<p>REF:</p>
<ol>
<li><a href="https://gauravsarma1992.medium.com/comparison-of-net-http-and-httprouter-df8edd1004e7" target="_blank" rel="noopener">https://gauravsarma1992.medium.com/comparison-of-net-http-and-httprouter-df8edd1004e7</a></li>
<li><a href="https://pkg.go.dev/net/http" target="_blank" rel="noopener">https://pkg.go.dev/net/http</a></li>
</ol>
]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s/kubeflow排障</title>
    <url>/2022/04/05/k8s-kubeflow%E6%8E%92%E9%9A%9C/</url>
    <content><![CDATA[<p>记录一下部署kubeflow过程中遇到的问题。</p>
<h5 id="部署ingress-nginx失败记录"><a href="#部署ingress-nginx失败记录" class="headerlink" title="部署ingress-nginx失败记录"></a>部署ingress-nginx失败记录</h5><p><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.0/deploy/static/provider/cloud/deploy.yaml</code><br>执行命令后提示如下错误：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time=&quot;2021-12-30T01:47:24Z&quot; level=fatal msg=&quot;error creating kubernetes client config: open /var/run/secrets/kubernetes.io/serviceaccount/token: no such file or directory&quot;</span><br></pre></td></tr></table></figure></p>
<p>解决方法:<br>修改kube-apiserver.yaml,去掉—disable-admission-plugins=ServiceAccount,等待kube-apiserver重启，然后重新部署</p>
<h5 id="Pod启动失败-“cni0”-already-has-an-IP-address"><a href="#Pod启动失败-“cni0”-already-has-an-IP-address" class="headerlink" title="Pod启动失败, “cni0” already has an IP address"></a>Pod启动失败, “cni0” already has an IP address</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning  FailedCreatePodSandBox  35s (x137911 over 4d21h)  kubelet  (combined from similar events): Failed to create pod sandbox: rpc error: code = Unknown desc = failed to set up sandbox container &quot;de753a2dbc417b7a05f99044d63aa285dac37beddc2bcbe806c4d3ff1772d027&quot; network for pod &quot;coredns-78fcd69978-h4lqn&quot;: networkPlugin cni failed to set up pod &quot;coredns-78fcd69978-h4lqn_kube-system&quot; network: failed to set bridge addr: &quot;cni0&quot; already has an IP address different from 10.63.0.1/24</span><br></pre></td></tr></table></figure>
<p>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig cni0 down    </span><br><span class="line">ip link delete cni0</span><br></pre></td></tr></table></figure></p>
<h5 id="安装MySQL报错如下-chown-changing-ownership-of-‘-var-lib-postgresql-data’-Operation-not-permitted"><a href="#安装MySQL报错如下-chown-changing-ownership-of-‘-var-lib-postgresql-data’-Operation-not-permitted" class="headerlink" title="安装MySQL报错如下,chown: changing ownership of ‘/var/lib/postgresql/data’: Operation not permitted"></a>安装MySQL报错如下,<code>chown: changing ownership of ‘/var/lib/postgresql/data’: Operation not permitted</code></h5><p>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># PV使用的是nfs</span><br><span class="line">vim /etc/exports</span><br><span class="line"># 增加 no_root_squash，修改为如下</span><br><span class="line">/nfs 10.1.55.0/24(rw,sync,no_subtree_check,no_root_squash)</span><br><span class="line"></span><br><span class="line"># 重启nfs server</span><br><span class="line">/etc/init.d/nfs-kernel-server restart</span><br><span class="line"></span><br><span class="line"># 修改deploy,增加readOnly: false</span><br><span class="line">volumeMounts:</span><br><span class="line">- name: mysql-storage</span><br><span class="line">  mountPath: /var/lib/mysql</span><br><span class="line">  readOnly: false</span><br></pre></td></tr></table></figure></p>
<h5 id="kubeflow-cache-server-启动失败-secret-“webhook-server-tls”-not-found"><a href="#kubeflow-cache-server-启动失败-secret-“webhook-server-tls”-not-found" class="headerlink" title="kubeflow/cache-server 启动失败, secret “webhook-server-tls” not found"></a>kubeflow/cache-server 启动失败, secret “webhook-server-tls” not found</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MountVolume.SetUp failed for volume &quot;webhook-tls-certs&quot; : secret &quot;webhook-server-tls&quot; not found</span><br></pre></td></tr></table></figure>
<p>解决方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把其它pod的状态弄到 Running 状态后，重启Pod 问题解决</span><br></pre></td></tr></table></figure></p>
<h5 id="登录kubeflow-webui界面，创建Notebook-Server-报错如下"><a href="#登录kubeflow-webui界面，创建Notebook-Server-报错如下" class="headerlink" title="登录kubeflow webui界面，创建Notebook Server, 报错如下"></a>登录kubeflow webui界面，创建Notebook Server, 报错如下</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No default Storage Class is set. Can&apos;t create new Disks for the new Notebook. Please use an Existing Disk.</span><br></pre></td></tr></table></figure>
<p>解决方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 因为集群中己经配置过storageclass,因此直接将这个storageclass设置为默认的storageclass就行</span><br><span class="line">kubectl patch storageclass managed-nfs-storage -p &apos;&#123;&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<h5 id="创建notebook报错-创建volume报错"><a href="#创建notebook报错-创建volume报错" class="headerlink" title="创建notebook报错, 创建volume报错"></a>创建notebook报错, 创建volume报错</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeflow 403 could not find csrf cookie xsrf-token in the request</span><br></pre></td></tr></table></figure>
<p>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k edit deploy jupyter-web-app-deployment -n kubeflow</span><br><span class="line"></span><br><span class="line"># 添加如下环境变量</span><br><span class="line">- name: APP_SECURE_COOKIES                                                                                                                </span><br><span class="line">  value: &quot;false&quot;         </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"> k edit deploy volumes-web-app-deployment -n kubeflow </span><br><span class="line"> </span><br><span class="line"># 添加如下环境变量</span><br><span class="line">- name: APP_SECURE_COOKIES                                                                                                                </span><br><span class="line">  value: &quot;false&quot;</span><br></pre></td></tr></table></figure></p>
<h5 id="kubeflow第一次登录未出现创建Namespace的页面"><a href="#kubeflow第一次登录未出现创建Namespace的页面" class="headerlink" title="kubeflow第一次登录未出现创建Namespace的页面"></a>kubeflow第一次登录未出现创建Namespace的页面</h5><p>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k edit deploy centraldashboard</span><br><span class="line"></span><br><span class="line"># 修改为如下</span><br><span class="line">- name: REGISTRATION_FLOW                                                                                                                 </span><br><span class="line">  value: &quot;true&quot;</span><br></pre></td></tr></table></figure></p>
<p>如在部署前可修改文件apps/centraldashboard/upstream/base/params.env<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CD_CLUSTER_DOMAIN=cluster.local</span><br><span class="line">CD_USERID_HEADER=kubeflow-userid</span><br><span class="line">CD_USERID_PREFIX=</span><br><span class="line">CD_REGISTRATION_FLOW=true</span><br></pre></td></tr></table></figure></p>
<h5 id="coredns启动报错"><a href="#coredns启动报错" class="headerlink" title="coredns启动报错"></a>coredns启动报错</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ai-10-1-55-12-dev-sz:~# k logs coredns-6c76c8bb89-g98cq -n kube-system</span><br><span class="line">.:53</span><br><span class="line">[INFO] plugin/reload: Running configuration MD5 = db32ca3650231d74073ff4cf814959a7</span><br><span class="line">CoreDNS-1.7.0</span><br><span class="line">linux/amd64, go1.14.4, f59c03d</span><br><span class="line">[FATAL] plugin/loop: Loop (127.0.0.1:40293 -&gt; :53) detected for zone &quot;.&quot;, see https://coredns.io/plugins/loop#troubleshooting. Query: &quot;HINFO 4247289002016518455.6908858903734866660.&quot;</span><br></pre></td></tr></table></figure>
<p>解决方法: 删除/etc/resolv.conf中的本地地址nameserver 127.0.0.53</p>
<h5 id="安装kubeflow-之后-从istio-ingressgateway进入的所有流量都会重定向到-auth-dex，带来了很多问题。"><a href="#安装kubeflow-之后-从istio-ingressgateway进入的所有流量都会重定向到-auth-dex，带来了很多问题。" class="headerlink" title="安装kubeflow 之后,从istio-ingressgateway进入的所有流量都会重定向到/auth/dex，带来了很多问题。"></a>安装kubeflow 之后,从istio-ingressgateway进入的所有流量都会重定向到/auth/dex，带来了很多问题。</h5><p>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k get envoyfilter -n istio-system</span><br><span class="line">k delete envoyfilter authn-filter -n istio-system</span><br><span class="line"></span><br><span class="line">k edit cm istio -n istio-system </span><br><span class="line"># 新增如下内容,保存然后重启istiod</span><br><span class="line">data:                                                                                                                                                                                 </span><br><span class="line">  mesh: |-                                                                                         </span><br><span class="line">    extensionProviders:                                                                                                                                                               </span><br><span class="line">    - name: &quot;dex-auth-provider&quot;                                                                                                                                                       </span><br><span class="line">      envoyExtAuthzHttp:                                                                                                                                                              </span><br><span class="line">        service: &quot;authservice.istio-system.svc.cluster.local&quot;                                                                                                                         </span><br><span class="line">        port: &quot;8080&quot; # The default port used by oauth2-proxy.                                                                                                                         </span><br><span class="line">        includeHeadersInCheck: [&quot;authorization&quot;, &quot;cookie&quot;, &quot;x-auth-token&quot;] # headers sent to the oauth2-proxy in the check request.                                                   </span><br><span class="line">        headersToUpstreamOnAllow: [&quot;kubeflow-userid&quot;] # headers sent to backend application when request is allowed.</span><br><span class="line"></span><br><span class="line"># 新建AuthorizationPolicy，kf-ap.yaml, k apply -f kf-ap.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: security.istio.io/v1beta1                                                                                                                                                 </span><br><span class="line">kind: AuthorizationPolicy                                                                                                                                                             </span><br><span class="line">metadata:                                                                                                                                                                             </span><br><span class="line">  name: dex-auth                                                                                                                                                                      </span><br><span class="line">  namespace: istio-system                                                                                                                                                             </span><br><span class="line">spec:                                                                                                                                                                                 </span><br><span class="line">  selector:                                                                                                                                                                           </span><br><span class="line">    matchLabels:                                                                                                                                                                      </span><br><span class="line">      istio: ingressgateway                                                                                                                                                           </span><br><span class="line">  action: CUSTOM                                                                                                                                                                      </span><br><span class="line">  provider:                                                                                                                                                                           </span><br><span class="line">    # The provider name must match the extension provider defined in the mesh config.                                                                                                 </span><br><span class="line">    name: dex-auth-provider                                                                                                                                                           </span><br><span class="line">  rules:                                                                                                                                                                              </span><br><span class="line">  # The rules specify when to trigger the external authorizer.                                                                                                                        </span><br><span class="line">  - to:                                                                                                                                                                               </span><br><span class="line">    - operation:                                                                                                                                                                      </span><br><span class="line">        hosts: [&quot;kubeflow.xxx.com&quot;]</span><br></pre></td></tr></table></figure></p>
<h5 id="通过ingress-nginx访问harbor-dashboard正常，后改为通过istio-ingressgateway访问dashboard登录报403"><a href="#通过ingress-nginx访问harbor-dashboard正常，后改为通过istio-ingressgateway访问dashboard登录报403" class="headerlink" title="通过ingress-nginx访问harbor dashboard正常，后改为通过istio-ingressgateway访问dashboard登录报403"></a>通过ingress-nginx访问harbor dashboard正常，后改为通过istio-ingressgateway访问dashboard登录报403</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2022-01-21T06:43:14Z [DEBUG] [/lib/http/error.go:59]: &#123;&quot;errors&quot;:[&#123;&quot;code&quot;:&quot;FORBIDDEN&quot;,&quot;message&quot;:&quot;CSRF token invalid&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p> 一开始以为是istio-ingressgateway的限制，所以查看了所有的AuthorizationPolicy,发现默认对istio-ingressgateway的流量是放行的。后查看harbor-core发现流量己经进入到集群内，直觉可能跟https有关重新安装harbor解决问题。<br>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm uninstall harbor -n harbor</span><br><span class="line">#https -&gt; http</span><br><span class="line">helm upgrade --cleanup-on-fail --install harbor . --namespace=harbor --set externalURL=http://tharbor.fiture.com</span><br></pre></td></tr></table></figure></p>
<h5 id="Istio-容器一直处于创建中。MountVolume-SetUp-failed-for-volume-“istio-token”-failed-to-fetch-token-the-API-server-does-not-have-TokenRequest-endpoints-enabled"><a href="#Istio-容器一直处于创建中。MountVolume-SetUp-failed-for-volume-“istio-token”-failed-to-fetch-token-the-API-server-does-not-have-TokenRequest-endpoints-enabled" class="headerlink" title="Istio 容器一直处于创建中。MountVolume.SetUp failed for volume “istio-token”:failed to fetch token: the API server does not have TokenRequest endpoints enabled"></a>Istio 容器一直处于创建中。MountVolume.SetUp failed for volume “istio-token”:failed to fetch token: the API server does not have TokenRequest endpoints enabled</h5><p>解决方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/manifests/kube-apiserver.yaml</span><br><span class="line"># 添加如下内容</span><br><span class="line">- --service-account-key-file=/etc/kubernetes/pki/sa.pub</span><br><span class="line">- --service-account-signing-key-file=/etc/kubernetes/pki/sa.key</span><br><span class="line">- --service-account-issuer=api</span><br><span class="line">- --service-account-api-audiences=api,vault,factors</span><br></pre></td></tr></table></figure></p>
<h5 id="docker-login-Error-response-from-daemon-Get-“https-tharbor-fiture-com-v2-“-dial-tcp-10-1-55-16-443-connect-connection-refused"><a href="#docker-login-Error-response-from-daemon-Get-“https-tharbor-fiture-com-v2-“-dial-tcp-10-1-55-16-443-connect-connection-refused" class="headerlink" title="docker login,Error response from daemon: Get “https://tharbor.fiture.com/v2/“: dial tcp 10.1.55.16:443: connect: connection refused"></a>docker login,Error response from daemon: Get “<a href="https://tharbor.fiture.com/v2/" target="_blank" rel="noopener">https://tharbor.fiture.com/v2/</a>“: dial tcp 10.1.55.16:443: connect: connection refused</h5><p>解决方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加:insecure-registries</span><br><span class="line">vim /etc/docker/daemon.json </span><br><span class="line"></span><br><span class="line">insecure-registries: [&quot;http://harbor.com&quot;]</span><br></pre></td></tr></table></figure></p>
<h5 id="访问kubeflow-dashboard显示空白"><a href="#访问kubeflow-dashboard显示空白" class="headerlink" title="访问kubeflow dashboard显示空白"></a>访问kubeflow dashboard显示空白</h5><p>解决方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k edit vs dex -n auth</span><br><span class="line"># host修改为对应的域名</span><br></pre></td></tr></table></figure></p>
<h5 id="登录kubeflow-点击左侧菜单，显示Sorry-jupyter-is-not-a-valid-page"><a href="#登录kubeflow-点击左侧菜单，显示Sorry-jupyter-is-not-a-valid-page" class="headerlink" title="登录kubeflow, 点击左侧菜单，显示Sorry, /jupyter/ is not a valid page"></a>登录kubeflow, 点击左侧菜单，显示Sorry, /jupyter/ is not a valid page</h5><p>解决方法:原因是vs dex和vs centeraldashboard配置了host: kubeflow.xx.com, 都删除掉host就行</p>
<h5 id="创建notebook提示Insufficient-nvidia-com-gpu。"><a href="#创建notebook提示Insufficient-nvidia-com-gpu。" class="headerlink" title="创建notebook提示Insufficient nvidia.com/gpu。"></a>创建notebook提示Insufficient nvidia.com/gpu。</h5><p>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装nvidia-device-plugin</span><br><span class="line"></span><br><span class="line">k apply -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/master/nvidia-device-plugin.yml</span><br></pre></td></tr></table></figure></p>
<h5 id="当挂载目录文件过多导致pod启动失败-kubeflow-notebook启动失败"><a href="#当挂载目录文件过多导致pod启动失败-kubeflow-notebook启动失败" class="headerlink" title="当挂载目录文件过多导致pod启动失败, kubeflow notebook启动失败"></a>当挂载目录文件过多导致pod启动失败, kubeflow notebook启动失败</h5><p>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1.istio层面的原因</span><br><span class="line">k edit deploy istiod -n istio-system</span><br><span class="line"># 添加如下环境变量</span><br><span class="line">- name: ENABLE_LEGACY_FSGROUP_INJECTION</span><br><span class="line">  value: &quot;false&quot;</span><br><span class="line">  </span><br><span class="line"># 2.kubeflow的原因</span><br><span class="line">k edit deploy notebook-controller-deployment</span><br><span class="line"># 添加如下环境变量</span><br><span class="line">- name: ADD_FSGROUP</span><br><span class="line">  value: &quot;false&quot;</span><br></pre></td></tr></table></figure></p>
<h5 id="Cephfs-mount-error"><a href="#Cephfs-mount-error" class="headerlink" title="Cephfs mount error"></a>Cephfs mount error</h5><p>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在每个节点上安装cefs-common</span><br><span class="line">apt install ceph-common</span><br><span class="line"> </span><br><span class="line"># 对ceph key 进行base64加密</span><br><span class="line">https://github.com/kubernetes-retired/kube-deploy/issues/264#issuecomment-292815926</span><br></pre></td></tr></table></figure></p>
<h5 id="点击tensorboard发生404"><a href="#点击tensorboard发生404" class="headerlink" title="点击tensorboard发生404"></a>点击tensorboard发生404</h5><p>解决方法：删除tensorboard server.重新新建一个server,名称不能与notebook名称相同。</p>
<h5 id="Metric-server-not-ready-k8s-metrics-server-x509-cannot-validate-certificate-for-because-it-doesn’t-contain-any-IP-SANs”"><a href="#Metric-server-not-ready-k8s-metrics-server-x509-cannot-validate-certificate-for-because-it-doesn’t-contain-any-IP-SANs”" class="headerlink" title="Metric-server not ready:k8s metrics server x509: cannot validate certificate for  because it doesn’t contain any IP SANs”"></a>Metric-server not ready:k8s metrics server x509: cannot validate certificate for  because it doesn’t contain any IP SANs”</h5><p>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment 启动参数增加--kubelet-insecure-tls</span><br><span class="line">containers:                                                                             - args:                                                                                                                                                                      - --cert-dir=/tmp                                                                                                                                                      - --secure-port=4443                                                                                                                                                     - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname                                                                                                       - --kubelet-use-node-status-port                                                                                                                                        - --metric-resolution=15s                                                                                                                                              - ---kubelet-insecure-tls</span><br></pre></td></tr></table></figure></p>
<h5 id="Docker-错误之Error-response-from-daemon-could-not-select-device-driver-““-with-capabilities-gpu"><a href="#Docker-错误之Error-response-from-daemon-could-not-select-device-driver-““-with-capabilities-gpu" class="headerlink" title="[Docker] 错误之Error response from daemon: could not select device driver ““ with capabilities: [[gpu]]"></a>[Docker] 错误之Error response from daemon: could not select device driver ““ with capabilities: [[gpu]]</h5><p>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install nvidia-container-runtime</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></p>
<h5 id="ping-gitlab-xxx-com偶尔出现Name-or-service-not-known。"><a href="#ping-gitlab-xxx-com偶尔出现Name-or-service-not-known。" class="headerlink" title="ping gitlab.xxx.com偶尔出现Name or service not known。"></a>ping gitlab.xxx.com偶尔出现Name or service not known。</h5><p>解决方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加policy sequential </span><br><span class="line">k edit cm coredns -n kube-system</span><br><span class="line">        forward . /etc/resolv.conf &#123;                                                                                                                                                                               </span><br><span class="line">          max_concurrent 1000                                                                                                                                                                                     </span><br><span class="line">          policy sequential                                                                                                                                                                                       </span><br><span class="line">       &#125;  </span><br><span class="line">       </span><br><span class="line"># 然后删除corndns的pod</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubeflow</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s set类型实现</title>
    <url>/2021/07/14/k8s-set%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Golang是没有像python一样本身实现set类型，如果在开发过程中需要使用set类型的话则需要自己实现。<br>今天我们来学习一下k8s源码中的int类型的set实现。<br>代码位于<br><code>https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/apimachinery/pkg/util/sets</code>目录下。</p>
<p>1.set可以看作值为空的map，为了节省内存，这里使用<code>struct{}</code>来充当map中的值。因为空的<code>struct{}</code>大小可以看作为零，因为空的<code>struct{}</code>是指向同一个地址。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义值为空结构体</span></span><br><span class="line"><span class="keyword">type</span> Empty <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Int类型set,值为Empty</span></span><br><span class="line"><span class="keyword">type</span> Int <span class="keyword">map</span>[<span class="keyword">int</span>]Empty</span><br></pre></td></tr></table></figure></p>
<p>2.sets中提供一个将字典转换为set类型的方法<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将键为int的map转换成set,set的元素为map的key</span></span><br><span class="line"><span class="comment">// 如果theMap的键不为int则会产生panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntKeySet</span><span class="params">(theMap <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Int</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(theMap)</span><br><span class="line">	ret := Int&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, keyValue := <span class="keyword">range</span> v.MapKeys() &#123;</span><br><span class="line">		ret.Insert(keyValue.Interface().(<span class="keyword">int</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.初始化元素为int类型的set<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInt</span><span class="params">(items ...<span class="keyword">int</span>)</span> <span class="title">Int</span></span> &#123;</span><br><span class="line">	ss := Int&#123;&#125;</span><br><span class="line">	ss.Insert(items...)</span><br><span class="line">	<span class="keyword">return</span> ss</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.下面是set的一些常见的方法实现<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将int类型的元素添加到set中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int)</span> <span class="title">Insert</span><span class="params">(items ...<span class="keyword">int</span>)</span> <span class="title">Int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">		s[item] = Empty&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除set中的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int)</span> <span class="title">Delete</span><span class="params">(items ...<span class="keyword">int</span>)</span> <span class="title">Int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">		<span class="built_in">delete</span>(s, item)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个元素是否存在set,存在返回true,否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int)</span> <span class="title">Has</span><span class="params">(item <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	_, contained := s[item]</span><br><span class="line">	<span class="keyword">return</span> contained</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否所有元素都存在于set集合中，如果是返回true,否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int)</span> <span class="title">HasAll</span><span class="params">(items ...<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">		<span class="keyword">if</span> !s.Has(item) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断任意一个元素是否存在于set中，如果存在返回true,否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int)</span> <span class="title">HasAny</span><span class="params">(items ...<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">		<span class="keyword">if</span> s.Has(item) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算在s中存在，在s2中不存在的元素集合</span></span><br><span class="line"><span class="comment">// s1 = &#123;a1, a2, a3&#125;</span></span><br><span class="line"><span class="comment">// s2 = &#123;a1, a2, a4, a5&#125;</span></span><br><span class="line"><span class="comment">// s1.Difference(s2) = &#123;a3&#125;</span></span><br><span class="line"><span class="comment">// s2.Difference(s1) = &#123;a4, a5&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int)</span> <span class="title">Difference</span><span class="params">(s2 Int)</span> <span class="title">Int</span></span> &#123;</span><br><span class="line">	result := NewInt()</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> !s2.Has(key) &#123;</span><br><span class="line">			result.Insert(key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算集合并集</span></span><br><span class="line"><span class="comment">// s1 = &#123;a1, a2&#125;</span></span><br><span class="line"><span class="comment">// s2 = &#123;a3, a4&#125;</span></span><br><span class="line"><span class="comment">// s1.Union(s2) = &#123;a1, a2, a3, a4&#125;</span></span><br><span class="line"><span class="comment">// s2.Union(s1) = &#123;a1, a2, a3, a4&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s1 Int)</span> <span class="title">Union</span><span class="params">(s2 Int)</span> <span class="title">Int</span></span> &#123;</span><br><span class="line">	result := NewInt()</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> s1 &#123;</span><br><span class="line">		result.Insert(key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">		result.Insert(key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算集合的交集</span></span><br><span class="line"><span class="comment">// s1 = &#123;a1, a2&#125;</span></span><br><span class="line"><span class="comment">// s2 = &#123;a2, a3&#125;</span></span><br><span class="line"><span class="comment">// s1.Intersection(s2) = &#123;a2&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s1 Int)</span> <span class="title">Intersection</span><span class="params">(s2 Int)</span> <span class="title">Int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> walk, other Int</span><br><span class="line">	result := NewInt()</span><br><span class="line">	<span class="keyword">if</span> s1.Len() &lt; s2.Len() &#123;</span><br><span class="line">		walk = s1</span><br><span class="line">		other = s2</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		walk = s2</span><br><span class="line">		other = s1</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> walk &#123;</span><br><span class="line">		<span class="keyword">if</span> other.Has(key) &#123;</span><br><span class="line">			result.Insert(key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断s1是否是s2的超集，如果是返回true,否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s1 Int)</span> <span class="title">IsSuperset</span><span class="params">(s2 Int)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">		<span class="keyword">if</span> !s1.Has(item) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个集合是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s1 Int)</span> <span class="title">Equal</span><span class="params">(s2 Int)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s1) == <span class="built_in">len</span>(s2) &amp;&amp; s1.IsSuperset(s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sortableSliceOfInt []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为sortableSliceOfInt类型实现排序方法 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sortableSliceOfInt)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sortableSliceOfInt)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> lessInt(s[i], s[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s sortableSliceOfInt)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据集合内容返回排序好的切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int)</span> <span class="title">List</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>(sortableSliceOfInt, <span class="number">0</span>, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> s &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, key)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(res)</span><br><span class="line">	<span class="keyword">return</span> []<span class="keyword">int</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回未排序的切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int)</span> <span class="title">UnsortedList</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> s &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个元素(key, true)并将其删除，如果集合为空则返回(0,false)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int)</span> <span class="title">PopAny</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s.Delete(key)</span><br><span class="line">		<span class="keyword">return</span> key, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> zeroValue <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">return</span> zeroValue, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回set长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两个元素进行比较</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lessInt</span><span class="params">(lhs, rhs <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> lhs &lt; rhs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s expiring lru cache</title>
    <url>/2023/09/24/k8s-expiring-lru-cache/</url>
    <content><![CDATA[<p><code>LRUExpireCache</code> 是一种支持数据过期的 LRU（最近最少使用）缓存策略。<br>当缓存达到最大大小（maxsize）后，在<code>Add</code>操作中最近最少使用的项目将会被移除，<br>在<code>Get</code>操作中如果项目过期将会被移除。<br>下面是<code>k8s</code>源码中<code>LRUExpireCache</code>的实现。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/list"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clock defines an interface for obtaining the current time</span></span><br><span class="line"><span class="keyword">type</span> Clock <span class="keyword">interface</span> &#123;</span><br><span class="line">	Now() time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// realClock implements the Clock interface by calling time.Now()</span></span><br><span class="line"><span class="keyword">type</span> realClock <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(realClock)</span> <span class="title">Now</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123; <span class="keyword">return</span> time.Now() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRUExpireCache is a cache that ensures the mostly recently accessed keys are returned with</span></span><br><span class="line"><span class="comment">// a ttl beyond which keys are forcibly expired.</span></span><br><span class="line"><span class="comment">// LRUExpireCache 实现一个带过期时间的LRU Cache</span></span><br><span class="line"><span class="keyword">type</span> LRUExpireCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// clock is used to obtain the current time</span></span><br><span class="line">	<span class="comment">// 用于获取当前时间</span></span><br><span class="line">	clock Clock</span><br><span class="line"></span><br><span class="line">	lock sync.Mutex</span><br><span class="line"></span><br><span class="line">	maxSize      <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 官方提供的列表实现(双向链表)</span></span><br><span class="line">	evictionList list.List</span><br><span class="line">	entries      <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*list.Element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLRUExpireCache creates an expiring cache with the given size</span></span><br><span class="line"><span class="comment">// NewLRUExpireCache 创建一个指定大小LRU Expire Cache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLRUExpireCache</span><span class="params">(maxSize <span class="keyword">int</span>)</span> *<span class="title">LRUExpireCache</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewLRUExpireCacheWithClock(maxSize, realClock&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLRUExpireCacheWithClock creates an expiring cache with the given size, using the specified clock to obtain the current time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLRUExpireCacheWithClock</span><span class="params">(maxSize <span class="keyword">int</span>, clock Clock)</span> *<span class="title">LRUExpireCache</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> maxSize &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"maxSize must be &gt; 0"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;LRUExpireCache&#123;</span><br><span class="line">		clock:   clock,</span><br><span class="line">		maxSize: maxSize,</span><br><span class="line">		entries: <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*list.Element&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cacheEntry 包括key, value, expireTime</span></span><br><span class="line"><span class="keyword">type</span> cacheEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	key        <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	value      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	expireTime time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds the value to the cache at key with the specified maximum duration.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LRUExpireCache)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, value <span class="keyword">interface</span>&#123;&#125;, ttl time.Duration)</span></span> &#123;</span><br><span class="line">	c.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Key already exists</span></span><br><span class="line">	oldElement, ok := c.entries[key]</span><br><span class="line">	<span class="comment">// 如果key已经存在</span></span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="comment">// 将元素移到列表头</span></span><br><span class="line">		c.evictionList.MoveToFront(oldElement)</span><br><span class="line">		<span class="comment">// 更新值和过期时间</span></span><br><span class="line">		oldElement.Value.(*cacheEntry).value = value</span><br><span class="line">		oldElement.Value.(*cacheEntry).expireTime = c.clock.Now().Add(ttl)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make space if necessary</span></span><br><span class="line">	<span class="comment">// 如果列表长度已经大于设置的最大值</span></span><br><span class="line">	<span class="keyword">if</span> c.evictionList.Len() &gt;= c.maxSize &#123;</span><br><span class="line">		<span class="comment">// 从列表和entries删除最旧的元素</span></span><br><span class="line">		toEvict := c.evictionList.Back()</span><br><span class="line">		c.evictionList.Remove(toEvict)</span><br><span class="line">		<span class="built_in">delete</span>(c.entries, toEvict.Value.(*cacheEntry).key)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add new entry</span></span><br><span class="line">	<span class="comment">// 插入最新的元素</span></span><br><span class="line">	entry := &amp;cacheEntry&#123;</span><br><span class="line">		key:        key,</span><br><span class="line">		value:      value,</span><br><span class="line">		expireTime: c.clock.Now().Add(ttl),</span><br><span class="line">	&#125;</span><br><span class="line">	element := c.evictionList.PushFront(entry)</span><br><span class="line">	c.entries[key] = element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get returns the value at the specified key from the cache if it exists and is not</span></span><br><span class="line"><span class="comment">// expired, or returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LRUExpireCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	c.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	element, ok := c.entries[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果这个元素已过期则移除</span></span><br><span class="line">	<span class="keyword">if</span> c.clock.Now().After(element.Value.(*cacheEntry).expireTime) &#123;</span><br><span class="line">		c.evictionList.Remove(element)</span><br><span class="line">		<span class="built_in">delete</span>(c.entries, key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将元素移到列表头</span></span><br><span class="line">	c.evictionList.MoveToFront(element)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> element.Value.(*cacheEntry).value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove removes the specified key from the cache if it exists</span></span><br><span class="line"><span class="comment">// Remove 从Cache中移除指定的key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LRUExpireCache)</span> <span class="title">Remove</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	c.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	element, ok := c.entries[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.evictionList.Remove(element)</span><br><span class="line">	<span class="built_in">delete</span>(c.entries, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keys returns all unexpired keys in the cache.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Keep in mind that subsequent calls to Get() for any of the returned keys</span></span><br><span class="line"><span class="comment">// might return "not found".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Keys are returned ordered from least recently used to most recently used.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LRUExpireCache)</span> <span class="title">Keys</span><span class="params">()</span> []<span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	c.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	now := c.clock.Now()</span><br><span class="line"></span><br><span class="line">	val := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, c.evictionList.Len())</span><br><span class="line">	<span class="keyword">for</span> element := c.evictionList.Back(); element != <span class="literal">nil</span>; element = element.Prev() &#123;</span><br><span class="line">		<span class="comment">// Only return unexpired keys</span></span><br><span class="line">		<span class="keyword">if</span> !now.After(element.Value.(*cacheEntry).expireTime) &#123;</span><br><span class="line">			val = <span class="built_in">append</span>(val, element.Value.(*cacheEntry).key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:</p>
<ol>
<li><a href="https://github.com/hysyeah/kubernetes/blob/e3bc35bc1bc7b399b564f2c4efc75eb9959e70f7/staging/src/k8s.io/apimachinery/pkg/util/cache/lruexpirecache.go" target="_blank" rel="noopener">lruexpirecache.go</a></li>
</ol>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>how to write a k8s admission webhook</title>
    <url>/2023/04/21/k8s-webhook/</url>
    <content><![CDATA[<h5 id="什么是admission-webhook"><a href="#什么是admission-webhook" class="headerlink" title="什么是admission webhook"></a>什么是admission webhook</h5><p><code>Kubernetes Ａdmission　Webhook</code>是一种<code>HTTP</code>回调机制，它允许<code>Kubernetes</code>调用外部<code>Web</code>服务，以便在某些事件发生时执行自定义代码。</p>
<p><code>Admission Webhook</code>是<code>Kubernetes</code>提供的一种扩展机制，用于在资源被持久化到<code>etcd</code>之前，对资源进行验证或修改。<code>Admission Webhook</code>可以分为两种类型：<code>Validation Webhook</code>和<code>Mutating Webhook</code>。</p>
<p><code>Validation Webhook</code>用于验证资源是否符合预期的规则，如果资源不符合规则，则会拒绝资源被持久化到<code>etcd</code>。</p>
<p><code>Mutating Webhook</code>则可以对资源进行修改，在资源被持久化到<code>etcd</code>之前，将资源修改为期望的状态。允许对请求进行更改，例如对<code>Pod</code>进行注入，以添加一些特定于应用程序的设置，如日志记录、密钥管理、监视等。</p>
<p><code>Webhook</code>机制使得用户可以根据自己的需求编写和部署自己的代码，以扩展和定制<code>Kubernetes</code>平台的行为。</p>
<p><code>Webhook</code>何时调用,<br><img src="https://img.hysyeah.top/2023/4/admission-webhooks.png" alt><br>图片来源于网络</p>
<h5 id="如何编写一个webhook"><a href="#如何编写一个webhook" class="headerlink" title="如何编写一个webhook"></a>如何编写一个webhook</h5><h6 id="Webhook请求与响应"><a href="#Webhook请求与响应" class="headerlink" title="Webhook请求与响应"></a>Webhook请求与响应</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体定义了请求和响应的字段</span></span><br><span class="line"><span class="comment">// staging/src/k8s.io/api/admission/v1/types.go</span></span><br><span class="line"><span class="keyword">type</span> AdmissionReview <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">	<span class="comment">// Request describes the attributes for the admission request.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Request *AdmissionRequest <span class="string">`json:"request,omitempty" protobuf:"bytes,1,opt,name=request"`</span></span><br><span class="line">	<span class="comment">// Response describes the attributes for the admission response.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Response *AdmissionResponse <span class="string">`json:"response,omitempty" protobuf:"bytes,2,opt,name=response"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AdmissionRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	UID types.UID <span class="string">`json:"uid" protobuf:"bytes,1,opt,name=uid"`</span></span><br><span class="line">	<span class="comment">// Kind is the fully-qualified type of object being submitted (for example, v1.Pod or autoscaling.v1.Scale)</span></span><br><span class="line">	Kind metav1.GroupVersionKind <span class="string">`json:"kind" protobuf:"bytes,2,opt,name=kind"`</span></span><br><span class="line">	<span class="comment">// Resource is the fully-qualified resource being requested (for example, v1.pods)</span></span><br><span class="line">	Resource metav1.GroupVersionResource <span class="string">`json:"resource" protobuf:"bytes,3,opt,name=resource"`</span></span><br><span class="line">	<span class="comment">// SubResource is the subresource being requested, if any (for example, "status" or "scale")</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	SubResource <span class="keyword">string</span> <span class="string">`json:"subResource,omitempty" protobuf:"bytes,4,opt,name=subResource"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	RequestKind *metav1.GroupVersionKind <span class="string">`json:"requestKind,omitempty" protobuf:"bytes,13,opt,name=requestKind"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	RequestResource *metav1.GroupVersionResource <span class="string">`json:"requestResource,omitempty" protobuf:"bytes,14,opt,name=requestResource"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	RequestSubResource <span class="keyword">string</span> <span class="string">`json:"requestSubResource,omitempty" protobuf:"bytes,15,opt,name=requestSubResource"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Name is the name of the object as presented in the request.  On a CREATE operation, the client may omit name and</span></span><br><span class="line">	<span class="comment">// rely on the server to generate the name.  If that is the case, this field will contain an empty string.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name,omitempty" protobuf:"bytes,5,opt,name=name"`</span></span><br><span class="line">	<span class="comment">// Namespace is the namespace associated with the request (if any).</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Namespace <span class="keyword">string</span> <span class="string">`json:"namespace,omitempty" protobuf:"bytes,6,opt,name=namespace"`</span></span><br><span class="line">	<span class="comment">// Operation is the operation being performed. This may be different than the operation</span></span><br><span class="line">	<span class="comment">// requested. e.g. a patch can result in either a CREATE or UPDATE Operation.</span></span><br><span class="line">	Operation Operation <span class="string">`json:"operation" protobuf:"bytes,7,opt,name=operation"`</span></span><br><span class="line">	<span class="comment">// UserInfo is information about the requesting user</span></span><br><span class="line">	UserInfo authenticationv1.UserInfo <span class="string">`json:"userInfo" protobuf:"bytes,8,opt,name=userInfo"`</span></span><br><span class="line">	<span class="comment">// Object is the object from the incoming request.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Object runtime.RawExtension <span class="string">`json:"object,omitempty" protobuf:"bytes,9,opt,name=object"`</span></span><br><span class="line">	<span class="comment">// OldObject is the existing object. Only populated for DELETE and UPDATE requests.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	OldObject runtime.RawExtension <span class="string">`json:"oldObject,omitempty" protobuf:"bytes,10,opt,name=oldObject"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	DryRun *<span class="keyword">bool</span> <span class="string">`json:"dryRun,omitempty" protobuf:"varint,11,opt,name=dryRun"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Options runtime.RawExtension <span class="string">`json:"options,omitempty" protobuf:"bytes,12,opt,name=options"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AdmissionResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// UID is an identifier for the individual request/response.</span></span><br><span class="line">	<span class="comment">// This must be copied over from the corresponding AdmissionRequest.</span></span><br><span class="line">	UID types.UID <span class="string">`json:"uid" protobuf:"bytes,1,opt,name=uid"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allowed indicates whether or not the admission request was permitted.</span></span><br><span class="line">	Allowed <span class="keyword">bool</span> <span class="string">`json:"allowed" protobuf:"varint,2,opt,name=allowed"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Result contains extra details into why an admission request was denied.</span></span><br><span class="line">	<span class="comment">// This field IS NOT consulted in any way if "Allowed" is "true".</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Result *metav1.Status <span class="string">`json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The patch body. Currently we only support "JSONPatch" which implements RFC 6902.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Patch []<span class="keyword">byte</span> <span class="string">`json:"patch,omitempty" protobuf:"bytes,4,opt,name=patch"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The type of Patch. Currently we only allow "JSONPatch".</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	PatchType *PatchType <span class="string">`json:"patchType,omitempty" protobuf:"bytes,5,opt,name=patchType"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	AuditAnnotations <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`json:"auditAnnotations,omitempty" protobuf:"bytes,6,opt,name=auditAnnotations"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Warnings []<span class="keyword">string</span> <span class="string">`json:"warnings,omitempty" protobuf:"bytes,7,rep,name=warnings"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>请求: <code>Webhook</code> 发送 <code>POST</code> 请求时，请设置 <code>Content-Type: application/json</code> 并对 <code>admission.k8s.io</code> <code>API</code> 组中的 <code>AdmissionReview</code> 对象进行序列化，将所得到的 <code>JSON</code> 作为请求的主体。</li>
<li>响应: <code>Webhook</code> 使用 <code>HTTP 200</code> 状态码、<code>Content-Type: application/json</code> 和一个包含 <code>AdmissionReview</code> 对象的 <code>JSON</code> 序列化格式来发送响应。该 <code>AdmissionReview</code> 对象与发送的版本相同，且其中包含的 <code>response</code> 字段已被有效填充。<br>响应示例:<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"apiVersion"</span>: <span class="string">"admission.k8s.io/v1"</span>,</span><br><span class="line">  <span class="attr">"kind"</span>: <span class="string">"AdmissionReview"</span>,</span><br><span class="line">  <span class="attr">"response"</span>: &#123;</span><br><span class="line">    <span class="attr">"uid"</span>: <span class="string">"&lt;value from request.uid&gt;"</span>,</span><br><span class="line">    <span class="attr">"allowed"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="开始编写Webhook"><a href="#开始编写Webhook" class="headerlink" title="开始编写Webhook"></a>开始编写Webhook</h6><ol>
<li><p>配置<code>ValidatingAdmissionWebhook</code>,此准入控制器调用与请求匹配的所有验证性 Webhook。 匹配的 Webhook 将被并行调用。如果其中任何一个拒绝请求，则整个请求将失败。 该准入控制器仅在验证（Validating）阶段运行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ValidatingWebhookConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-webhook</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span>  <span class="string">pod.webhook.hysyeah.com</span></span><br><span class="line">    <span class="comment"># 定义访问的服务,如果是外部服务则指定对应的URL</span></span><br><span class="line">    <span class="attr">clientConfig:</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">pod-webhook</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">"/configmaps"</span></span><br><span class="line">      <span class="attr">caBundle:</span> <span class="string">"update &lt;&gt;"</span></span><br><span class="line">    <span class="comment"># 匹配规则,如果传入请求与rules的指定operations,groups,version,resources匹配</span></span><br><span class="line">    <span class="comment"># 则该请求将发送到webhook</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">operations:</span> <span class="string">[</span> <span class="string">"CREATE"</span><span class="string">,</span> <span class="string">"UPDATE"</span><span class="string">,</span> <span class="string">"DELETE"</span><span class="string">]</span></span><br><span class="line">        <span class="attr">apiGroups:</span> <span class="string">["apps",</span> <span class="string">""</span><span class="string">]</span></span><br><span class="line">        <span class="attr">apiVersions:</span> <span class="string">["v1"]</span></span><br><span class="line">        <span class="attr">resources:</span> <span class="string">["configmaps"]</span></span><br><span class="line">    <span class="attr">failurePolicy:</span> <span class="string">Ignore</span></span><br><span class="line">    <span class="attr">sideEffects:</span> <span class="string">None</span></span><br><span class="line">    <span class="attr">admissionReviewVersions:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置<code>MutatingWebhookConfiguration</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MutatingWebhookConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-webhook</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pod.webhook.hysyeah.com</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">        <span class="attr">apiVersions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">        <span class="attr">operations:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">CREATE</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">UPDATE</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">    <span class="attr">failurePolicy:</span> <span class="string">Ignore</span></span><br><span class="line">    <span class="attr">sideEffects:</span> <span class="string">None</span></span><br><span class="line">    <span class="attr">admissionReviewVersions:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">clientConfig:</span></span><br><span class="line">      <span class="comment"># base64 -w 0 ca.crt</span></span><br><span class="line">      <span class="attr">caBundle:</span> <span class="string">"update &lt;&gt;"</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">pod-webhook</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">"/add-label"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构建镜像<br><code>nerdctl build -t hysyeah/pod-webhook:v3 .</code></p>
</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.18</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> . .</span><br><span class="line"><span class="keyword">RUN</span> go env -w GO111MODULE=on</span><br><span class="line"><span class="keyword">RUN</span> go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line"><span class="keyword">RUN</span> go build -o main</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> chmod +x main</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">443</span></span><br><span class="line"><span class="keyword">CMD</span> ["./main"]</span><br></pre></td></tr></table></figure>
<ol>
<li>编写对应的<code>deployment</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-webhook</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">pod-webhook</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">pod-webhook</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pod-webhook</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hysyeah/pod-webhook:v3</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">["/app/main"]</span></span><br><span class="line">        <span class="attr">args:</span> <span class="string">["-tls-cert-file=/keys/tls.crt","-tls-private-key-file=/keys/tls.key"]</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">443</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tls-keys</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/keys</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tls-keys</span></span><br><span class="line">          <span class="attr">secret:</span></span><br><span class="line">            <span class="attr">secretName:</span> <span class="string">pod-webhook-tls</span></span><br><span class="line">            <span class="attr">items:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">tls.crt</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">tls.crt</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">tls.key</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">tls.key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-webhook</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">pod-webhook</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tcp</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>部署<code>webhook</code><br>执行<code>kubectl apply -f deployment.yaml</code></p>
</li>
<li><p>验证<code>webhook</code></p>
</li>
</ol>
<ul>
<li><p>新建一个pod,发现pod添加了label: <code>added-label=yes</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME                         READY   STATUS    RESTARTS   AGE     LABELS</span><br><span class="line">my-curl                      1/1     Running   0          170m    added-label=yes,app=my-curl</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建一个<code>configmap</code>,包含<code>webhook-e2e-test: webhook-disallow</code><br>结果如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error from server (the configmap contains unwanted key and value): error when creating "configmap.yaml": admission webhook "pod.webhook.hysyeah.com" denied the request: the configmap contains unwanted key and value</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>完整的代码可查看<a href="https://github.com/hysyeah/admission-webhook-example" target="_blank" rel="noopener">完整代码</a></p>
<hr>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>确保启用 <code>MutatingAdmissionWebhook</code> 和<code>ValidatingAdmissionWebhook</code>控制器</li>
<li>确保启用了 <code>admissionregistration.k8s.io/v1</code> API</li>
<li>确保您的代码不会影响Kubernetes集群的稳定性和安全性</li>
<li>当用户尝试创建的对象与返回的对象不同时，用户可能会感到困惑。</li>
<li>与覆盖原始请求中设置的字段相比，使用原始请求未设置的字段会引起问题的可能性较小。 应尽量避免覆盖原始请求中的字段设置</li>
</ul>
<hr>
<p>REF:<br>1.<a href="https://github.com/jpeeler/podpreset-crd/tree/master/webhook" target="_blank" rel="noopener">https://github.com/jpeeler/podpreset-crd/tree/master/webhook</a><br>2.<a href="https://github.com/kubernetes/kubernetes/tree/release-1.21/test/images/agnhost/webhook" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/tree/release-1.21/test/images/agnhost/webhook</a><br>3.<a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/</a><br>4.<a href="https://banzaicloud.com/blog/k8s-admission-webhooks/" target="_blank" rel="noopener">https://banzaicloud.com/blog/k8s-admission-webhooks/</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s webhook生成ssl证书</title>
    <url>/2023/07/30/k8s-webhook%E7%94%9F%E6%88%90ssl%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>当我们使用<code>k8s</code>的<code>webhook</code>机制时，<code>webhook</code>服务必须是<code>https</code>服务。如果不是<code>https</code>服务 ，则会报如下错误。<br><code>http: server gave HTTP response to HTTPS client</code></p>
<p>记录下证书生成的步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl req -new -newkey rsa:2048 -nodes -keyout server.key -out server.csr -config san.cnf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>##</span><br><span class="line">openssl req 命令用于为服务器生成一个新的证书签名请求 (CSR)。该命令中指定的选项如下：</span><br><span class="line"></span><br><span class="line">-new：该选项指定要生成一个新的 CSR。</span><br><span class="line">-newkey rsa:2048：该选项指定要生成一个新的 RSA 密钥对，密钥长度为 2048 位。</span><br><span class="line">-nodes：该选项指定私钥不应该使用密码加密。</span><br><span class="line">-keyout server.key：该选项指定私钥应该写入的文件名。</span><br><span class="line">-out server.csr：该选项指定 CSR 应该写入的文件名。</span><br><span class="line">-config san.cnf：该选项指定生成 CSR 时要使用的配置文件。在本例中，配置文件是 san.cnf，其中包含有关证书主体的信息和应包含在证书中的任何主题备用名称 (SANs)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> ca.crt, ca.key 为k8s集群中的文件， 在/etc/kubenetes/pki目录下</span><br><span class="line">openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -extensions v3_req -extfile san.cnf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>##</span><br><span class="line">openssl x509 命令用于将证书签名请求 (CSR) 签名为一个 SSL/TLS 证书。该命令中指定的选项如下：</span><br><span class="line"></span><br><span class="line">-req：该选项指定输入文件是一个证书请求。</span><br><span class="line">-days 365：该选项指定证书的有效期限，以天为单位。在本例中，证书的有效期限为 365 天。</span><br><span class="line">-in server.csr：该选项指定输入文件是一个证书请求，该请求应该签名为一个 SSL/TLS 证书。在本例中，输入文件是 server.csr。</span><br><span class="line">-CA ca.crt：该选项指定用于签名证书的 CA 证书。在本例中，CA 证书是 ca.crt。</span><br><span class="line">-CAkey ca.key：该选项指定用于签名证书的 CA 私钥。在本例中，CA 私钥是 ca.key。</span><br><span class="line">-CAcreateserial：该选项指定在签名证书时创建一个新的序列号文件。在本例中，序列号文件将被创建并用于签名证书。</span><br><span class="line">-out server.crt：该选项指定输出文件是签名后的 SSL/TLS 证书。在本例中，输出文件是 server.crt。</span><br><span class="line">-extensions v3_req：该选项指定证书应包含的证书扩展。在本例中，证书扩展是 v3_req。</span><br><span class="line">-extfile san.cnf：该选项指定证书扩展应该包含的信息。在本例中，证书扩展信息包含在 san.cnf 文件中。</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> san.cnf</span><br><span class="line">[req]</span><br><span class="line">req_extensions = v3_req</span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line"></span><br><span class="line">[req_distinguished_name]</span><br><span class="line">countryName = US</span><br><span class="line">stateOrProvinceName = California</span><br><span class="line">localityName = San Francisco</span><br><span class="line">organizationName = Example Corp</span><br><span class="line">organizationalUnitName = IT Department</span><br><span class="line">commonName = example.com</span><br><span class="line"></span><br><span class="line">[v3_req]</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 = example.com</span><br><span class="line">DNS.2 = www.example.com</span><br><span class="line">IP.1 = 192.0.2.1</span><br></pre></td></tr></table></figure>
<p>san.cnf 文件是一个 OpenSSL 配置文件，用于指定要在 SSL/TLS 证书中包含的主题备用名称 (SANs)。<br>在上面的示例中，[req] 段指定了一些请求相关的选项，例如不提示用户输入信息 (prompt = no)。[req_distinguished_name] 段指定了证书请求的主题信息，例如国家、州、城市和组织名。[v3_req] 段指定了证书扩展信息，其中 subjectAltName 指定了一个名为 alt_names 的部分，该部分列出了所有的 SANs。在 [alt_names] 段中，DNS.1 指定了一个 DNS 名称 example.com，IP.1 指定了一个 IP 地址 192.168.1.1。</p>
<p>在实际使用中，可以根据需要添加、修改或删除 san.cnf 文件中的 SANs，以便生成适合特定环境的证书请求。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 证书生成</span></span><br><span class="line">openssl genrsa -out ca.key <span class="number">2048</span></span><br><span class="line">openssl req -<span class="built_in">new</span> -x509 -days <span class="number">3650</span> -key ca.key -out ca.crt -subj <span class="string">"/CN=hysyeah CA/O=hysyeah/C=CN"</span></span><br><span class="line">openssl req -<span class="built_in">new</span> -newkey rsa:<span class="number">2048</span> -nodes -keyout server.key -out server.csr -config san.cnf</span><br><span class="line">openssl x509 -req -days <span class="number">3650</span> -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -extensions v3_req -extfile san.cnf</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s list请求源码分析</title>
    <url>/2023/10/05/k8s-list%E8%AF%B7%E6%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>我们知道在<code>k8s</code>中<code>List</code>请求是很常见的一种操作，用于获取一种资源对象的列表，如<code>pod</code>的<code>List</code>方法用于获取<code>k8s</code>集群中的所有<code>pod</code>资源。</p>
<p>在深入理解<code>List</code>操作之前，我们需要了解<code>resourceVersion</code>这个参数。</p>
<p>在每<code>k8s</code>资源对象中都有一个字段<code>resourceVersion</code>用于标识当前资源的版本，可用于乐观并发控制和获取资源的方式。</p>
<p>在<code>k8s</code>中有三种操作方法支持<code>resourceVersion</code>参数。<code>apiserver</code>根据不同的请求方法和不同的参数,对<code>resourceVersion</code><br>都有不同的解释。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>resourceVersion unset</th>
<th>resourceVersion=”0”</th>
<th>resourceVersion=”{value other than 0}”</th>
</tr>
</thead>
<tbody>
<tr>
<td>Most Recent</td>
<td>Any</td>
<td>Not older than</td>
</tr>
</tbody>
</table>
</div>
<p>Most Recent: 从etcd中取数据<br>Any: 优先用最新的，但不保证一定是最新的<br>Not older than: 不低于某个版本号  </p>
<p>从 <code>v1.19</code>开始,<code>List</code>方法开始支持<code>resourceVersionMatch</code>,如果你设置了<code>resourceVersionMatch</code>参数，将会决定<code>apiserver</code>如何解析<code>resourceVersion</code><br>官方文档建议当在<code>List</code>请求中如果使用了<code>resourceVersion</code>应该带上<code>resourceVersionMatch</code>参数。当然也会处理好一些特殊情况<code>apiserver</code>会忽略<code>resourceVersonMatch</code>。<br>除非你有很强的一致性要求，建议使用<code>resourceVersionMatch=NotOlderThan</code>以获得更好的性能。<br>如果你设置了<code>resourceVersionMatch</code>而没设置<code>resourceVersion</code>将会是无效的。</p>
<p><code>resourceVersion</code>与<code>resourceVersionMatch</code>的关系可以查看官方文档中的表格</p>
<hr>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go</span></span><br><span class="line"><span class="comment">// List 返回匹配labels和field的资源对象列表</span></span><br><span class="line"><span class="comment">// fieldSelector只支持官方指定的字段，不支持CRD中的自定义字段</span></span><br><span class="line"><span class="comment">// List 方法请求入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">List</span><span class="params">(ctx context.Context, options *metainternalversion.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 分别设置label 和 field</span></span><br><span class="line">	label := labels.Everything()</span><br><span class="line">	<span class="keyword">if</span> options != <span class="literal">nil</span> &amp;&amp; options.LabelSelector != <span class="literal">nil</span> &#123;</span><br><span class="line">		label = options.LabelSelector</span><br><span class="line">	&#125;</span><br><span class="line">	field := fields.Everything()</span><br><span class="line">	<span class="keyword">if</span> options != <span class="literal">nil</span> &amp;&amp; options.FieldSelector != <span class="literal">nil</span> &#123;</span><br><span class="line">		field = options.FieldSelector</span><br><span class="line">	&#125;</span><br><span class="line">	out, err := e.ListPredicate(ctx, e.PredicateFunc(label, field), options)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> e.Decorator != <span class="literal">nil</span> &#123;</span><br><span class="line">		e.Decorator(out)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListPredicate returns a list of all the items matching the given</span></span><br><span class="line"><span class="comment">// SelectionPredicate.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">ListPredicate</span><span class="params">(ctx context.Context, p storage.SelectionPredicate, options *metainternalversion.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果option == nil, ResourceVersion=""</span></span><br><span class="line">	<span class="keyword">if</span> options == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// By default we should serve the request from etcd.</span></span><br><span class="line">		options = &amp;metainternalversion.ListOptions&#123;ResourceVersion: <span class="string">""</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	p.Limit = options.Limit</span><br><span class="line">	p.Continue = options.Continue</span><br><span class="line">	list := e.NewListFunc()</span><br><span class="line">	qualifiedResource := e.qualifiedResourceFromContext(ctx)</span><br><span class="line">	<span class="comment">// 设置ListOptions,SelectionPredicate中包含了labelSelector和fieldSelector</span></span><br><span class="line">	storageOpts := storage.ListOptions&#123;</span><br><span class="line">		ResourceVersion:      options.ResourceVersion,</span><br><span class="line">		ResourceVersionMatch: options.ResourceVersionMatch,</span><br><span class="line">		Predicate:            p,</span><br><span class="line">		Recursive:            <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if we're not already namespace-scoped, see if the field selector narrows the scope of the watch</span></span><br><span class="line">	<span class="keyword">if</span> requestNamespace, _ := genericapirequest.NamespaceFrom(ctx); <span class="built_in">len</span>(requestNamespace) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> selectorNamespace, ok := p.MatchesSingleNamespace(); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(validation.ValidateNamespaceName(selectorNamespace, <span class="literal">false</span>)) == <span class="number">0</span> &#123;</span><br><span class="line">				ctx = genericapirequest.WithNamespace(ctx, selectorNamespace)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否匹配单个资源</span></span><br><span class="line">	<span class="keyword">if</span> name, ok := p.MatchesSingle(); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> key, err := e.KeyFunc(ctx, name); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			storageOpts.Recursive = <span class="literal">false</span></span><br><span class="line">			<span class="comment">// 这里指定了key,应该是单个资源的名称</span></span><br><span class="line">			err := e.Storage.GetList(ctx, key, storageOpts, list)</span><br><span class="line">			<span class="keyword">return</span> list, storeerr.InterpretListError(err, qualifiedResource)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// if we cannot extract a key based on the current context, the optimization is skipped</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用获取列表的接口</span></span><br><span class="line">	err := e.Storage.GetList(ctx, e.KeyRootFunc(ctx), storageOpts, list)</span><br><span class="line">	<span class="keyword">return</span> list, storeerr.InterpretListError(err, qualifiedResource)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/storage/cacher/cacher.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DryRunnableStorage)</span> <span class="title">GetList</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, opts storage.ListOptions, listObj runtime.Object)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.Storage.GetList(ctx, key, opts, listObj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// GetList implements storage.Interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">GetList</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, opts storage.ListOptions, listObj runtime.Object)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	recursive := opts.Recursive</span><br><span class="line">	resourceVersion := opts.ResourceVersion</span><br><span class="line">	pred := opts.Predicate</span><br><span class="line">	<span class="comment">// 判断是否需要从etcd中读取数据</span></span><br><span class="line">	<span class="keyword">if</span> shouldDelegateList(opts) &#123;</span><br><span class="line">		<span class="keyword">return</span> c.storage.GetList(ctx, key, opts, listObj)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	listRV, err := c.versioner.ParseResourceVersion(resourceVersion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// resourceVersion=0 &amp;&amp; apiserver缓存未建好</span></span><br><span class="line">	<span class="keyword">if</span> listRV == <span class="number">0</span> &amp;&amp; !c.ready.check() &#123;</span><br><span class="line">		<span class="comment">// If Cacher is not yet initialized and we don't require any specific</span></span><br><span class="line">		<span class="comment">// minimal resource version, simply forward the request to storage.</span></span><br><span class="line">		<span class="comment">// 从etcd中读取数据</span></span><br><span class="line">		<span class="keyword">return</span> c.storage.GetList(ctx, key, opts, listObj)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> listRV == <span class="number">0</span> &amp;&amp; utilfeature.DefaultFeatureGate.Enabled(features.ConsistentListFromCache) &#123;</span><br><span class="line">		<span class="comment">// 从etcd中获取resourceVersion</span></span><br><span class="line">		listRV, err = c.getCurrentResourceVersionFromStorage(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx, span := tracing.Start(ctx, <span class="string">"cacher list"</span>,</span><br><span class="line">		attribute.String(<span class="string">"audit-id"</span>, audit.GetAuditIDTruncated(ctx)),</span><br><span class="line">		attribute.Stringer(<span class="string">"type"</span>, c.groupResource))</span><br><span class="line">	<span class="keyword">defer</span> span.End(<span class="number">500</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := c.ready.wait(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.NewServiceUnavailable(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	span.AddEvent(<span class="string">"Ready"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// List elements with at least 'listRV' from cache.</span></span><br><span class="line">	<span class="comment">// 从缓存中读取数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回指向Items的指针</span></span><br><span class="line">	listPtr, err := meta.GetItemsPtr(listObj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确保指针是有效的，并指针指向的值(reflect.Value)</span></span><br><span class="line">	listVal, err := conversion.EnforcePtr(listPtr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// listVal的kind必须是slice</span></span><br><span class="line">	<span class="keyword">if</span> listVal.Kind() != reflect.Slice &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"need a pointer to slice, got %v"</span>, listVal.Kind())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回filter函数</span></span><br><span class="line">	filter := filterWithAttrsFunction(key, pred)</span><br><span class="line"></span><br><span class="line">	objs, readResourceVersion, indexUsed, err := c.listItems(ctx, listRV, key, pred, recursive)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	span.AddEvent(<span class="string">"Listed items from cache"</span>, attribute.Int(<span class="string">"count"</span>, <span class="built_in">len</span>(objs)))</span><br><span class="line">	<span class="comment">// store pointer of eligible objects,</span></span><br><span class="line">	<span class="comment">// Why not directly put object in the items of listObj?</span></span><br><span class="line">	<span class="comment">//   the elements in ListObject are Struct type, making slice will bring excessive memory consumption.</span></span><br><span class="line">	<span class="comment">//   so we try to delay this action as much as possible</span></span><br><span class="line">	<span class="keyword">var</span> selectedObjects []runtime.Object</span><br><span class="line">	<span class="keyword">for</span> _, obj := <span class="keyword">range</span> objs &#123;</span><br><span class="line">		elem, ok := obj.(*storeElement)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"non *storeElement returned from storage: %v"</span>, obj)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> filter(elem.Key, elem.Labels, elem.Fields) &#123;</span><br><span class="line">			selectedObjects = <span class="built_in">append</span>(selectedObjects, elem.Object)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(selectedObjects) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Ensure that we never return a nil Items pointer in the result for consistency.</span></span><br><span class="line">		listVal.Set(reflect.MakeSlice(listVal.Type(), <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Resize the slice appropriately, since we already know that size of result set</span></span><br><span class="line">		listVal.Set(reflect.MakeSlice(listVal.Type(), <span class="built_in">len</span>(selectedObjects), <span class="built_in">len</span>(selectedObjects)))</span><br><span class="line">		span.AddEvent(<span class="string">"Resized result"</span>)</span><br><span class="line">		<span class="keyword">for</span> i, o := <span class="keyword">range</span> selectedObjects &#123;</span><br><span class="line">			listVal.Index(i).Set(reflect.ValueOf(o).Elem())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	span.AddEvent(<span class="string">"Filtered items"</span>, attribute.Int(<span class="string">"count"</span>, listVal.Len()))</span><br><span class="line">	<span class="keyword">if</span> c.versioner != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := c.versioner.UpdateList(listObj, readResourceVersion, <span class="string">""</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	metrics.RecordListCacheMetrics(c.resourcePrefix, indexUsed, <span class="built_in">len</span>(objs), listVal.Len())</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要从etcd中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldDelegateList</span><span class="params">(opts storage.ListOptions)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	resourceVersion := opts.ResourceVersion</span><br><span class="line">	pred := opts.Predicate</span><br><span class="line">	match := opts.ResourceVersionMatch</span><br><span class="line">	pagingEnabled := utilfeature.DefaultFeatureGate.Enabled(features.APIListChunking)</span><br><span class="line">	consistentListFromCacheEnabled := utilfeature.DefaultFeatureGate.Enabled(features.ConsistentListFromCache)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Serve consistent reads from storage if ConsistentListFromCache is disabled</span></span><br><span class="line">	<span class="comment">// 如果resourceVersion=""且ConsistentListFromCache=false,从etcd读取数据</span></span><br><span class="line">	consistentReadFromStorage := resourceVersion == <span class="string">""</span> &amp;&amp; !consistentListFromCacheEnabled</span><br><span class="line">	<span class="comment">// Watch cache doesn't support continuations, so serve them from etcd.</span></span><br><span class="line">	<span class="comment">// 如果开启了分页且len(pred.Continue)&gt;0,从etcd读取数据</span></span><br><span class="line">	hasContinuation := pagingEnabled &amp;&amp; <span class="built_in">len</span>(pred.Continue) &gt; <span class="number">0</span></span><br><span class="line">	<span class="comment">// Serve paginated requests about revision "0" from watch cache to avoid overwhelming etcd.</span></span><br><span class="line">	<span class="comment">// 如果开启了分页且pred.Limit&gt;0 且resourceVersion!="0",从etcd中读取数据</span></span><br><span class="line">	hasLimit := pagingEnabled &amp;&amp; pred.Limit &gt; <span class="number">0</span> &amp;&amp; resourceVersion != <span class="string">"0"</span></span><br><span class="line">	<span class="comment">// Watch cache only supports ResourceVersionMatchNotOlderThan (default).</span></span><br><span class="line">	<span class="comment">// 如果match！=""且!=ResourceVersionMatchNotOlderThan,从etcd中读取数据</span></span><br><span class="line">	unsupportedMatch := match != <span class="string">""</span> &amp;&amp; match != metav1.ResourceVersionMatchNotOlderThan</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> consistentReadFromStorage || hasContinuation || hasLimit || unsupportedMatch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:</p>
<ol>
<li><a href="http://arthurchiao.art/blog/k8s-reliability-list-data-zh/#33-%E6%8C%87%E5%AE%9A-specnodenamenode1resourceversion0-vs-specnodenamenode1" target="_blank" rel="noopener">http://arthurchiao.art/blog/k8s-reliability-list-data-zh/#33-%E6%8C%87%E5%AE%9A-specnodenamenode1resourceversion0-vs-specnodenamenode1</a></li>
<li><a href="https://kubernetes.io/docs/reference/using-api/api-concepts/#the-resourceversion-parameter" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/using-api/api-concepts/#the-resourceversion-parameter</a></li>
</ol>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s subresource status</title>
    <url>/2024/06/01/k8s-subresource-status/</url>
    <content><![CDATA[<h3 id="什么是subresource-status"><a href="#什么是subresource-status" class="headerlink" title="什么是subresource status"></a>什么是subresource status</h3><p><code>status</code>是<code>k8s</code>中常见的一种子资源。</p>
<ol>
<li><code>/status</code> 子资源用于更新和获取主资源的状态部</li>
<li>通常由控制器或操作系统更新，以反映系统中对象的当前状态</li>
<li>通过将状态更新与主资源的其他修改隔离开来，可以防止用户意外覆盖状态信息</li>
</ol>
<h3 id="subresource-status的作用与限制"><a href="#subresource-status的作用与限制" class="headerlink" title="subresource status的作用与限制"></a>subresource status的作用与限制</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status" target="_blank" rel="noopener">spec-and-status</a></p>
<ol>
<li>在Kubernetes API中，在使用PUT或POST动词对Kubernetes对象进行操作时，必须忽略对象的status字段。这是为了防止在读取-修改-写入（read-modify-write）的场景中意外地覆盖status字段。PUT方法不能更新很多理解，防止意外覆盖status,使用POST也不能写入status字段(如果status没有定义为subresource POST和PUT方法是可以写入的)，应该是和status的作用有关，一般由控制器来更新，所以在POST方法中也不能设置status。</li>
<li>通过subresource这一概念可以将对象的spec与status分开，设置不同的访问权限。</li>
<li>必须提供单独的方法来对<code>status</code>进行修改</li>
</ol>
<h3 id="如何定义一个subresource"><a href="#如何定义一个subresource" class="headerlink" title="如何定义一个subresource"></a>如何定义一个subresource</h3><p>在结构体上加上<code>//+kubebuilder:subresource:status</code>就可以将<code>status</code>定义为<code>subresource</code>。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1alpha1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"><span class="comment">// +kubebuilder:subresource:status</span></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo is a specification for a Foo resource</span></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta   <span class="string">`json:",inline"`</span></span><br><span class="line">	metav1.ObjectMeta <span class="string">`json:"metadata,omitempty"`</span></span><br><span class="line"></span><br><span class="line">	Spec   FooSpec   <span class="string">`json:"spec"`</span></span><br><span class="line">	Status FooStatus <span class="string">`json:"status"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooSpec is the spec for a Foo resource</span></span><br><span class="line"><span class="keyword">type</span> FooSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">	DeploymentName <span class="keyword">string</span> <span class="string">`json:"deploymentName"`</span></span><br><span class="line">	Replicas       *<span class="keyword">int32</span> <span class="string">`json:"replicas"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooStatus is the status for a Foo resource</span></span><br><span class="line"><span class="keyword">type</span> FooStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">	AvailableReplicas <span class="keyword">int32</span> <span class="string">`json:"availableReplicas"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FooList is a list of Foo resources</span></span><br><span class="line"><span class="keyword">type</span> FooList <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">	metav1.ListMeta <span class="string">`json:"metadata"`</span></span><br><span class="line"></span><br><span class="line">	Items []Foo <span class="string">`json:"items"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="crd-server"><a href="#crd-server" class="headerlink" title="crd server"></a>crd server</h3><p>在<code>k8s</code>中<code>crd</code>这类资源的创建走的接口是和原生资源不一样的，<code>crd</code>资源调用的接口是<code>apis/&lt;group&gt;/&lt;version/&lt;cr-name&gt;</code>。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// vendor/k8s.io/apiextensions-apiserver/pkg/apiserver/apiserver.go</span></span><br><span class="line"><span class="comment">// 创建crdHandler</span></span><br><span class="line">   crdHandler, err := NewCustomResourceDefinitionHandler(</span><br><span class="line">	versionDiscoveryHandler,</span><br><span class="line">	groupDiscoveryHandler,</span><br><span class="line">	s.Informers.Apiextensions().V1().CustomResourceDefinitions(),</span><br><span class="line">	delegateHandler,</span><br><span class="line">	c.ExtraConfig.CRDRESTOptionsGetter,</span><br><span class="line">	c.GenericConfig.AdmissionControl,</span><br><span class="line">	establishingController,</span><br><span class="line">	c.ExtraConfig.ServiceResolver,</span><br><span class="line">	c.ExtraConfig.AuthResolverWrapper,</span><br><span class="line">	c.ExtraConfig.MasterCount,</span><br><span class="line">	s.GenericAPIServer.Authorizer,</span><br><span class="line">	c.GenericConfig.RequestTimeout,</span><br><span class="line">	time.Duration(c.GenericConfig.MinRequestTimeout)*time.Second,</span><br><span class="line">	apiGroupInfo.StaticOpenAPISpec,</span><br><span class="line">	c.GenericConfig.MaxRequestBodyBytes,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// url为/apis或者以/apis/为前缀的请求都会调用crdhandler</span></span><br><span class="line">s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(<span class="string">"/apis"</span>, crdHandler)</span><br><span class="line">s.GenericAPIServer.Handler.NonGoRestfulMux.HandlePrefix(<span class="string">"/apis/"</span>, crdHandler)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">crdHandler实现了自己的ServeHTTP方法</span><br><span class="line"><span class="comment">// vendor/k8s.io/apiextensions-apiserver/pkg/apiserver/customresource_handler.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有url为/apis或/apis/的请求都会进入这一方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *crdHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	ctx := req.Context()</span><br><span class="line">	requestInfo, ok := apirequest.RequestInfoFrom(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		responsewriters.ErrorNegotiated(</span><br><span class="line">			apierrors.NewInternalError(fmt.Errorf(<span class="string">"no RequestInfo found in the context"</span>)),</span><br><span class="line">			Codecs, schema.GroupVersion&#123;&#125;, w, req,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !requestInfo.IsResourceRequest &#123;</span><br><span class="line">		pathParts := splitPath(requestInfo.Path)</span><br><span class="line">		<span class="comment">// only match /apis/&lt;group&gt;/&lt;version&gt;</span></span><br><span class="line">		<span class="comment">// only registered under /apis</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(pathParts) == <span class="number">3</span> &#123;</span><br><span class="line">			r.versionDiscoveryHandler.ServeHTTP(w, req)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// only match /apis/&lt;group&gt;</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(pathParts) == <span class="number">2</span> &#123;</span><br><span class="line">			r.groupDiscoveryHandler.ServeHTTP(w, req)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		r.delegate.ServeHTTP(w, req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	crdName := requestInfo.Resource + <span class="string">"."</span> + requestInfo.APIGroup</span><br><span class="line">	crd, err := r.crdLister.Get(crdName)</span><br><span class="line">	<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">		r.delegate.ServeHTTP(w, req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(err)</span><br><span class="line">		responsewriters.ErrorNegotiated(</span><br><span class="line">			apierrors.NewInternalError(fmt.Errorf(<span class="string">"error resolving resource"</span>)),</span><br><span class="line">			Codecs, schema.GroupVersion&#123;Group: requestInfo.APIGroup, Version: requestInfo.APIVersion&#125;, w, req,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if the scope in the CRD and the scope in request differ (with exception of the verbs in possiblyAcrossAllNamespacesVerbs</span></span><br><span class="line">	<span class="comment">// for namespaced resources), pass request to the delegate, which is supposed to lead to a 404.</span></span><br><span class="line">	namespacedCRD, namespacedReq := crd.Spec.Scope == apiextensionsv1.NamespaceScoped, <span class="built_in">len</span>(requestInfo.Namespace) &gt; <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> !namespacedCRD &amp;&amp; namespacedReq &#123;</span><br><span class="line">		r.delegate.ServeHTTP(w, req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> namespacedCRD &amp;&amp; !namespacedReq &amp;&amp; !possiblyAcrossAllNamespacesVerbs.Has(requestInfo.Verb) &#123;</span><br><span class="line">		r.delegate.ServeHTTP(w, req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !apiextensionshelpers.HasServedCRDVersion(crd, requestInfo.APIVersion) &#123;</span><br><span class="line">		r.delegate.ServeHTTP(w, req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// There is a small chance that a CRD is being served because NamesAccepted condition is true,</span></span><br><span class="line">	<span class="comment">// but it becomes "unserved" because another names update leads to a conflict</span></span><br><span class="line">	<span class="comment">// and EstablishingController wasn't fast enough to put the CRD into the Established condition.</span></span><br><span class="line">	<span class="comment">// We accept this as the problem is small and self-healing.</span></span><br><span class="line">	<span class="keyword">if</span> !apiextensionshelpers.IsCRDConditionTrue(crd, apiextensionsv1.NamesAccepted) &amp;&amp;</span><br><span class="line">		!apiextensionshelpers.IsCRDConditionTrue(crd, apiextensionsv1.Established) &#123;</span><br><span class="line">		r.delegate.ServeHTTP(w, req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	terminating := apiextensionshelpers.IsCRDConditionTrue(crd, apiextensionsv1.Terminating)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取crd信息，如果已经存在于系统中则直接返回，否则会进行一些设置加载到系统中</span></span><br><span class="line">	crdInfo, err := r.getOrCreateServingInfoFor(crd.UID, crd.Name)</span><br><span class="line">	<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">		r.delegate.ServeHTTP(w, req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(err)</span><br><span class="line">		responsewriters.ErrorNegotiated(</span><br><span class="line">			apierrors.NewInternalError(fmt.Errorf(<span class="string">"error resolving resource"</span>)),</span><br><span class="line">			Codecs, schema.GroupVersion&#123;Group: requestInfo.APIGroup, Version: requestInfo.APIVersion&#125;, w, req,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !hasServedCRDVersion(crdInfo.spec, requestInfo.APIVersion) &#123;</span><br><span class="line">		r.delegate.ServeHTTP(w, req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	deprecated := crdInfo.deprecated[requestInfo.APIVersion]</span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> crdInfo.warnings[requestInfo.APIVersion] &#123;</span><br><span class="line">		warning.AddWarning(req.Context(), <span class="string">""</span>, w)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	verb := strings.ToUpper(requestInfo.Verb)</span><br><span class="line">	resource := requestInfo.Resource</span><br><span class="line">	subresource := requestInfo.Subresource</span><br><span class="line">	scope := metrics.CleanScope(requestInfo)</span><br><span class="line">	supportedTypes := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="keyword">string</span>(types.JSONPatchType),</span><br><span class="line">		<span class="keyword">string</span>(types.MergePatchType),</span><br><span class="line">		<span class="keyword">string</span>(types.ApplyPatchType),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> handlerFunc http.HandlerFunc</span><br><span class="line">	subresources, err := apiextensionshelpers.GetSubresourcesForVersion(crd, requestInfo.APIVersion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(err)</span><br><span class="line">		responsewriters.ErrorNegotiated(</span><br><span class="line">			apierrors.NewInternalError(fmt.Errorf(<span class="string">"could not properly serve the subresource"</span>)),</span><br><span class="line">			Codecs, schema.GroupVersion&#123;Group: requestInfo.APIGroup, Version: requestInfo.APIVersion&#125;, w, req,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> subresource == <span class="string">"status"</span> &amp;&amp; subresources != <span class="literal">nil</span> &amp;&amp; subresources.Status != <span class="literal">nil</span>:</span><br><span class="line">        <span class="comment">// 如果是对status的操作，走serveStatus</span></span><br><span class="line">		handlerFunc = r.serveStatus(w, req, requestInfo, crdInfo, terminating, supportedTypes)</span><br><span class="line">	<span class="keyword">case</span> subresource == <span class="string">"scale"</span> &amp;&amp; subresources != <span class="literal">nil</span> &amp;&amp; subresources.Scale != <span class="literal">nil</span>:</span><br><span class="line">		handlerFunc = r.serveScale(w, req, requestInfo, crdInfo, terminating, supportedTypes)</span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(subresource) == <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 创建crd时走的是serveResource</span></span><br><span class="line">		handlerFunc = r.serveResource(w, req, requestInfo, crdInfo, crd, terminating, supportedTypes)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		responsewriters.ErrorNegotiated(</span><br><span class="line">			apierrors.NewNotFound(schema.GroupResource&#123;Group: requestInfo.APIGroup, Resource: requestInfo.Resource&#125;, requestInfo.Name),</span><br><span class="line">			Codecs, schema.GroupVersion&#123;Group: requestInfo.APIGroup, Version: requestInfo.APIVersion&#125;, w, req,</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> handlerFunc != <span class="literal">nil</span> &#123;</span><br><span class="line">		handlerFunc = metrics.InstrumentHandlerFunc(verb, requestInfo.APIGroup, requestInfo.APIVersion, resource, subresource, scope, metrics.APIServerComponent, deprecated, <span class="string">""</span>, handlerFunc)</span><br><span class="line">		handler := genericfilters.WithWaitGroup(handlerFunc, longRunningFilter, crdInfo.waitGroup)</span><br><span class="line">		handler.ServeHTTP(w, req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *crdHandler)</span> <span class="title">getOrCreateServingInfoFor</span><span class="params">(uid types.UID, name <span class="keyword">string</span>)</span> <span class="params">(*crdInfo, error)</span></span> &#123;</span><br><span class="line">	storageMap := r.customStorage.Load().(crdStorageMap)</span><br><span class="line">	<span class="keyword">if</span> ret, ok := storageMap[uid]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.customStorageLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.customStorageLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the up-to-date CRD when we have the lock, to avoid racing with updateCustomResourceDefinition.</span></span><br><span class="line">	<span class="comment">// If updateCustomResourceDefinition sees an update and happens later, the storage will be deleted and</span></span><br><span class="line">	<span class="comment">// we will re-create the updated storage on demand. If updateCustomResourceDefinition happens before,</span></span><br><span class="line">	<span class="comment">// we make sure that we observe the same up-to-date CRD.</span></span><br><span class="line">	crd, err := r.crdLister.Get(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	storageMap = r.customStorage.Load().(crdStorageMap)</span><br><span class="line">	<span class="keyword">if</span> ret, ok := storageMap[crd.UID]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	storageVersion, err := apiextensionshelpers.GetCRDStorageVersion(crd)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> statusSpec *apiextensionsinternal.CustomResourceSubresourceStatus</span><br><span class="line">		<span class="keyword">var</span> statusValidator apiservervalidation.SchemaValidator</span><br><span class="line">        <span class="comment">// 获取subresources</span></span><br><span class="line">		subresources, err := apiextensionshelpers.GetSubresourcesForVersion(crd, v.Name)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"the server could not properly serve the CR subresources"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> subresources != <span class="literal">nil</span> &amp;&amp; subresources.Status != <span class="literal">nil</span> &#123;</span><br><span class="line">			equivalentResourceRegistry.RegisterKindFor(resource, <span class="string">"status"</span>, kind)</span><br><span class="line">            <span class="comment">// 如果status是subresource则设置statusSpec</span></span><br><span class="line">			statusSpec = &amp;apiextensionsinternal.CustomResourceSubresourceStatus&#123;&#125;</span><br><span class="line">			<span class="keyword">if</span> err := apiextensionsv1.Convert_v1_CustomResourceSubresourceStatus_To_apiextensions_CustomResourceSubresourceStatus(subresources.Status, statusSpec, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed converting CRD status subresource to internal version: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// for the status subresource, validate only against the status schema</span></span><br><span class="line">			<span class="keyword">if</span> internalValidationSchema != <span class="literal">nil</span> &amp;&amp; internalValidationSchema.OpenAPIV3Schema != <span class="literal">nil</span> &amp;&amp; internalValidationSchema.OpenAPIV3Schema.Properties != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> statusSchema, ok := internalValidationSchema.OpenAPIV3Schema.Properties[<span class="string">"status"</span>]; ok &#123;</span><br><span class="line">					statusValidator, _, err = apiservervalidation.NewSchemaValidator(&amp;statusSchema)</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> scaleSpec *apiextensionsinternal.CustomResourceSubresourceScale</span><br><span class="line">		<span class="keyword">if</span> subresources != <span class="literal">nil</span> &amp;&amp; subresources.Scale != <span class="literal">nil</span> &#123;</span><br><span class="line">			equivalentResourceRegistry.RegisterKindFor(resource, <span class="string">"scale"</span>, autoscalingv1.SchemeGroupVersion.WithKind(<span class="string">"Scale"</span>))</span><br><span class="line">			scaleSpec = &amp;apiextensionsinternal.CustomResourceSubresourceScale&#123;&#125;</span><br><span class="line">			<span class="keyword">if</span> err := apiextensionsv1.Convert_v1_CustomResourceSubresourceScale_To_apiextensions_CustomResourceSubresourceScale(subresources.Scale, scaleSpec, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed converting CRD status subresource to internal version: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		columns, err := getColumnsForVersion(crd, v.Name)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"the server could not properly serve the CR columns"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		table, err := tableconvertor.New(columns)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">"The CRD for %v has an invalid printer specification, falling back to default printing: %v"</span>, kind, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		storages[v.Name] = customresource.NewStorage(</span><br><span class="line">			resource.GroupResource(),</span><br><span class="line">			singularResource.GroupResource(),</span><br><span class="line">			kind,</span><br><span class="line">			schema.GroupVersionKind&#123;Group: crd.Spec.Group, Version: v.Name, Kind: crd.Status.AcceptedNames.ListKind&#125;,</span><br><span class="line">            <span class="comment">// 创建strategy, 不同的crd对应的不同的crd</span></span><br><span class="line">			customresource.NewStrategy(</span><br><span class="line">				typer,</span><br><span class="line">				crd.Spec.Scope == apiextensionsv1.NamespaceScoped,</span><br><span class="line">				kind,</span><br><span class="line">				validator,</span><br><span class="line">				statusValidator,</span><br><span class="line">				structuralSchemas,</span><br><span class="line">				statusSpec,</span><br><span class="line">				scaleSpec,</span><br><span class="line">			),</span><br><span class="line">			crdConversionRESTOptionsGetter&#123;</span><br><span class="line">				RESTOptionsGetter:     r.restOptionsGetter,</span><br><span class="line">				converter:             safeConverter,</span><br><span class="line">				decoderVersion:        schema.GroupVersion&#123;Group: crd.Spec.Group, Version: v.Name&#125;,</span><br><span class="line">				encoderVersion:        schema.GroupVersion&#123;Group: crd.Spec.Group, Version: storageVersion&#125;,</span><br><span class="line">				structuralSchemas:     structuralSchemas,</span><br><span class="line">				structuralSchemaGK:    kind.GroupKind(),</span><br><span class="line">				preserveUnknownFields: crd.Spec.PreserveUnknownFields,</span><br><span class="line">			&#125;,</span><br><span class="line">			crd.Status.AcceptedNames.Categories,</span><br><span class="line">			table,</span><br><span class="line">			replicasPathInCustomResource,</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		clusterScoped := crd.Spec.Scope == apiextensionsv1.ClusterScoped</span><br><span class="line"></span><br><span class="line">		<span class="comment">// CRDs explicitly do not support protobuf, but some objects returned by the API server do</span></span><br><span class="line">		negotiatedSerializer := unstructuredNegotiatedSerializer&#123;</span><br><span class="line">			typer:                 typer,</span><br><span class="line">			creator:               creator,</span><br><span class="line">			converter:             safeConverter,</span><br><span class="line">			structuralSchemas:     structuralSchemas,</span><br><span class="line">			structuralSchemaGK:    kind.GroupKind(),</span><br><span class="line">			preserveUnknownFields: crd.Spec.PreserveUnknownFields,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> standardSerializers []runtime.SerializerInfo</span><br><span class="line">		<span class="keyword">for</span> _, s := <span class="keyword">range</span> negotiatedSerializer.SupportedMediaTypes() &#123;</span><br><span class="line">			<span class="keyword">if</span> s.MediaType == runtime.ContentTypeProtobuf &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			standardSerializers = <span class="built_in">append</span>(standardSerializers, s)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		reqScope := handlers.RequestScope&#123;</span><br><span class="line">			Namer: handlers.ContextBasedNaming&#123;</span><br><span class="line">				Namer:         meta.NewAccessor(),</span><br><span class="line">				ClusterScoped: clusterScoped,</span><br><span class="line">			&#125;,</span><br><span class="line">			Serializer:          negotiatedSerializer,</span><br><span class="line">			ParameterCodec:      parameterCodec,</span><br><span class="line">			StandardSerializers: standardSerializers,</span><br><span class="line"></span><br><span class="line">			Creater:         creator,</span><br><span class="line">			Convertor:       safeConverter,</span><br><span class="line">			Defaulter:       unstructuredDefaulter&#123;parameterScheme, structuralSchemas, kind.GroupKind()&#125;,</span><br><span class="line">			Typer:           typer,</span><br><span class="line">			UnsafeConvertor: unsafeConverter,</span><br><span class="line"></span><br><span class="line">			EquivalentResourceMapper: equivalentResourceRegistry,</span><br><span class="line"></span><br><span class="line">			Resource: schema.GroupVersionResource&#123;Group: crd.Spec.Group, Version: v.Name, Resource: crd.Status.AcceptedNames.Plural&#125;,</span><br><span class="line">			Kind:     kind,</span><br><span class="line"></span><br><span class="line">			<span class="comment">// a handler for a specific group-version of a custom resource uses that version as the in-memory representation</span></span><br><span class="line">			HubGroupVersion: kind.GroupVersion(),</span><br><span class="line"></span><br><span class="line">			MetaGroupVersion: metav1.SchemeGroupVersion,</span><br><span class="line"></span><br><span class="line">			TableConvertor: storages[v.Name].CustomResource,</span><br><span class="line"></span><br><span class="line">			Authorizer: r.authorizer,</span><br><span class="line"></span><br><span class="line">			MaxRequestBodyBytes: r.maxRequestBodyBytes,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		resetFields := storages[v.Name].CustomResource.GetResetFields()</span><br><span class="line">		reqScope, err = scopeWithFieldManager(</span><br><span class="line">			typeConverter,</span><br><span class="line">			reqScope,</span><br><span class="line">			resetFields,</span><br><span class="line">			<span class="string">""</span>,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		requestScopes[v.Name] = &amp;reqScope</span><br><span class="line"></span><br><span class="line">		scaleColumns, err := getScaleColumnsForVersion(crd, v.Name)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"the server could not properly serve the CR scale subresource columns %w"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		scaleTable, _ := tableconvertor.New(scaleColumns)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// override scale subresource values</span></span><br><span class="line">		<span class="comment">// shallow copy</span></span><br><span class="line">		scaleScope := *requestScopes[v.Name]</span><br><span class="line">		scaleConverter := scale.NewScaleConverter()</span><br><span class="line">		scaleScope.Subresource = <span class="string">"scale"</span></span><br><span class="line">		scaleScope.Serializer = serializer.NewCodecFactory(scaleConverter.Scheme())</span><br><span class="line">		scaleScope.Kind = autoscalingv1.SchemeGroupVersion.WithKind(<span class="string">"Scale"</span>)</span><br><span class="line">		scaleScope.Namer = handlers.ContextBasedNaming&#123;</span><br><span class="line">			Namer:         meta.NewAccessor(),</span><br><span class="line">			ClusterScoped: clusterScoped,</span><br><span class="line">		&#125;</span><br><span class="line">		scaleScope.TableConvertor = scaleTable</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> subresources != <span class="literal">nil</span> &amp;&amp; subresources.Scale != <span class="literal">nil</span> &#123;</span><br><span class="line">			scaleScope, err = scopeWithFieldManager(</span><br><span class="line">				typeConverter,</span><br><span class="line">				scaleScope,</span><br><span class="line">				<span class="literal">nil</span>,</span><br><span class="line">				<span class="string">"scale"</span>,</span><br><span class="line">			)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		scaleScopes[v.Name] = &amp;scaleScope</span><br><span class="line"></span><br><span class="line">		<span class="comment">// override status subresource values</span></span><br><span class="line">		<span class="comment">// shallow copy</span></span><br><span class="line">		statusScope := *requestScopes[v.Name]</span><br><span class="line">		statusScope.Subresource = <span class="string">"status"</span></span><br><span class="line">		statusScope.Namer = handlers.ContextBasedNaming&#123;</span><br><span class="line">			Namer:         meta.NewAccessor(),</span><br><span class="line">			ClusterScoped: clusterScoped,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> subresources != <span class="literal">nil</span> &amp;&amp; subresources.Status != <span class="literal">nil</span> &#123;</span><br><span class="line">			resetFields := storages[v.Name].Status.GetResetFields()</span><br><span class="line">			statusScope, err = scopeWithFieldManager(</span><br><span class="line">				typeConverter,</span><br><span class="line">				statusScope,</span><br><span class="line">				resetFields,</span><br><span class="line">				<span class="string">"status"</span>,</span><br><span class="line">			)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		statusScopes[v.Name] = &amp;statusScope</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> v.Deprecated &#123;</span><br><span class="line">			deprecated[v.Name] = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">if</span> v.DeprecationWarning != <span class="literal">nil</span> &#123;</span><br><span class="line">				warnings[v.Name] = <span class="built_in">append</span>(warnings[v.Name], *v.DeprecationWarning)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				warnings[v.Name] = <span class="built_in">append</span>(warnings[v.Name], defaultDeprecationWarning(v.Name, crd.Spec))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret := &amp;crdInfo&#123;</span><br><span class="line">		spec:                &amp;crd.Spec,</span><br><span class="line">		acceptedNames:       &amp;crd.Status.AcceptedNames,</span><br><span class="line">		storages:            storages,</span><br><span class="line">		requestScopes:       requestScopes,</span><br><span class="line">		scaleRequestScopes:  scaleScopes,</span><br><span class="line">		statusRequestScopes: statusScopes,</span><br><span class="line">		deprecated:          deprecated,</span><br><span class="line">		warnings:            warnings,</span><br><span class="line">		storageVersion:      storageVersion,</span><br><span class="line">		waitGroup:           &amp;utilwaitgroup.SafeWaitGroup&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy because we cannot write to storageMap without a race</span></span><br><span class="line">	<span class="comment">// as it is used without locking elsewhere.</span></span><br><span class="line">	storageMap2 := storageMap.clone()</span><br><span class="line"></span><br><span class="line">	storageMap2[crd.UID] = ret</span><br><span class="line">	r.customStorage.Store(storageMap2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *crdHandler)</span> <span class="title">serveResource</span><span class="params">(w http.ResponseWriter, req *http.Request, requestInfo *apirequest.RequestInfo, crdInfo *crdInfo, crd *apiextensionsv1.CustomResourceDefinition, terminating <span class="keyword">bool</span>, supportedTypes []<span class="keyword">string</span>)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	requestScope := crdInfo.requestScopes[requestInfo.APIVersion]</span><br><span class="line">	storage := crdInfo.storages[requestInfo.APIVersion].CustomResource</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> requestInfo.Verb &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"get"</span>:</span><br><span class="line">		<span class="keyword">return</span> handlers.GetResource(storage, requestScope)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"list"</span>:</span><br><span class="line">		forceWatch := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span> handlers.ListResource(storage, storage, requestScope, forceWatch, r.minRequestTimeout)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"watch"</span>:</span><br><span class="line">		forceWatch := <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> handlers.ListResource(storage, storage, requestScope, forceWatch, r.minRequestTimeout)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"create"</span>:</span><br><span class="line">		<span class="comment">// we want to track recently created CRDs so that in HA environments we don't have server A allow a create and server B</span></span><br><span class="line">		<span class="comment">// not have observed the established, so a followup get,update,delete results in a 404. We've observed about 800ms</span></span><br><span class="line">		<span class="comment">// delay in some CI environments.  Two seconds looks long enough and reasonably short for hot retriers.</span></span><br><span class="line">		justCreated := time.Since(apiextensionshelpers.FindCRDCondition(crd, apiextensionsv1.Established).LastTransitionTime.Time) &lt; <span class="number">2</span>*time.Second</span><br><span class="line">		<span class="keyword">if</span> justCreated &#123;</span><br><span class="line">			time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> terminating &#123;</span><br><span class="line">			err := apierrors.NewMethodNotSupported(schema.GroupResource&#123;Group: requestInfo.APIGroup, Resource: requestInfo.Resource&#125;, requestInfo.Verb)</span><br><span class="line">			err.ErrStatus.Message = fmt.Sprintf(<span class="string">"%v not allowed while custom resource definition is terminating"</span>, requestInfo.Verb)</span><br><span class="line">			responsewriters.ErrorNegotiated(err, Codecs, schema.GroupVersion&#123;Group: requestInfo.APIGroup, Version: requestInfo.APIVersion&#125;, w, req)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> handlers.CreateResource(storage, requestScope, r.admission)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"update"</span>:</span><br><span class="line">		<span class="keyword">return</span> handlers.UpdateResource(storage, requestScope, r.admission)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"patch"</span>:</span><br><span class="line">		<span class="keyword">return</span> handlers.PatchResource(storage, requestScope, r.admission, supportedTypes)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"delete"</span>:</span><br><span class="line">		allowsOptions := <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> handlers.DeleteResource(storage, allowsOptions, requestScope, r.admission)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"deletecollection"</span>:</span><br><span class="line">		checkBody := <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> handlers.DeleteCollection(storage, checkBody, requestScope, r.admission)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		responsewriters.ErrorNegotiated(</span><br><span class="line">			apierrors.NewMethodNotSupported(schema.GroupResource&#123;Group: requestInfo.APIGroup, Resource: requestInfo.Resource&#125;, requestInfo.Verb),</span><br><span class="line">			Codecs, schema.GroupVersion&#123;Group: requestInfo.APIGroup, Version: requestInfo.APIVersion&#125;, w, req,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/apiserver/pkg/endpoints/handlers/create.go</span></span><br><span class="line"><span class="comment">// CreateResource returns a function that will handle a resource creation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateResource</span><span class="params">(r rest.Creater, scope *RequestScope, admission admission.Interface)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> createHandler(&amp;namedCreaterAdapter&#123;r&#125;, scope, admission, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vendor/k8s.io/apiserver/pkg/registry/generic/registry/store.go</span></span><br><span class="line"><span class="comment">// 最终走的还是Store实现的Create,这个方法是往etcd中写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">Create</span><span class="params">(ctx context.Context, obj runtime.Object, createValidation rest.ValidateObjectFunc, options *metav1.CreateOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> finishCreate FinishFunc = finishNothing</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init metadata as early as possible.</span></span><br><span class="line">	<span class="keyword">if</span> objectMeta, err := meta.Accessor(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rest.FillObjectMetaSystemFields(objectMeta)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(objectMeta.GetGenerateName()) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(objectMeta.GetName()) == <span class="number">0</span> &#123;</span><br><span class="line">			objectMeta.SetName(e.CreateStrategy.GenerateName(objectMeta.GetGenerateName()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> e.BeginCreate != <span class="literal">nil</span> &#123;</span><br><span class="line">		fn, err := e.BeginCreate(ctx, obj, options)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		finishCreate = fn</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			finishCreate(ctx, <span class="literal">false</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := rest.BeforeCreate(e.CreateStrategy, ctx, obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// at this point we have a fully formed object.  It is time to call the validators that the apiserver</span></span><br><span class="line">	<span class="comment">// handling chain wants to enforce.</span></span><br><span class="line">	<span class="keyword">if</span> createValidation != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := createValidation(ctx, obj.DeepCopyObject()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	name, err := e.ObjectNameFunc(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	key, err := e.KeyFunc(ctx, name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	qualifiedResource := e.qualifiedResourceFromContext(ctx)</span><br><span class="line">	ttl, err := e.calculateTTL(obj, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	out := e.NewFunc()</span><br><span class="line">	<span class="keyword">if</span> err := e.Storage.Create(ctx, key, obj, out, ttl, dryrun.IsDryRun(options.DryRun)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = storeerr.InterpretCreateError(err, qualifiedResource, name)</span><br><span class="line">		err = rest.CheckGeneratedNameError(ctx, e.CreateStrategy, err, obj)</span><br><span class="line">		<span class="keyword">if</span> !apierrors.IsAlreadyExists(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> errGet := e.Storage.Get(ctx, key, storage.GetOptions&#123;&#125;, out); errGet != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		accessor, errGetAcc := meta.Accessor(out)</span><br><span class="line">		<span class="keyword">if</span> errGetAcc != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> accessor.GetDeletionTimestamp() != <span class="literal">nil</span> &#123;</span><br><span class="line">			msg := &amp;err.(*apierrors.StatusError).ErrStatus.Message</span><br><span class="line">			*msg = fmt.Sprintf(<span class="string">"object is being deleted: %s"</span>, *msg)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// The operation has succeeded.  Call the finish function if there is one,</span></span><br><span class="line">	<span class="comment">// and then make sure the defer doesn't call it again.</span></span><br><span class="line">	fn := finishCreate</span><br><span class="line">	finishCreate = finishNothing</span><br><span class="line">	fn(ctx, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> e.AfterCreate != <span class="literal">nil</span> &#123;</span><br><span class="line">		e.AfterCreate(out, options)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> e.Decorator != <span class="literal">nil</span> &#123;</span><br><span class="line">		e.Decorator(out)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="subresource-status是怎么忽略的"><a href="#subresource-status是怎么忽略的" class="headerlink" title="subresource status是怎么忽略的"></a>subresource status是怎么忽略的</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">在上面的<span class="string">`Create`</span>方法中会调用， <span class="string">`rest.BeforeCreat`</span>这个方法会执行<span class="string">`customResource`</span>的策略， 最终会调用<span class="string">`func (a customResourceStrategy) PrepareForCreate`</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging/src/k8s.io/apiextensions-apiserver/pkg/registry/customresource/strategy.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PrepareForCreate clears the status of a CustomResource before creation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a customResourceStrategy)</span> <span class="title">PrepareForCreate</span><span class="params">(ctx context.Context, obj runtime.Object)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果subresource status != nil, 则会删除status,所以在创建方法中的status会被忽略</span></span><br><span class="line">	<span class="keyword">if</span> a.status != <span class="literal">nil</span> &#123;</span><br><span class="line">		customResourceObject := obj.(*unstructured.Unstructured)</span><br><span class="line">		customResource := customResourceObject.UnstructuredContent()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// create cannot set status</span></span><br><span class="line">		<span class="built_in">delete</span>(customResource, <span class="string">"status"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	accessor, _ := meta.Accessor(obj)</span><br><span class="line">	accessor.SetGeneration(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="status更新"><a href="#status更新" class="headerlink" title="status更新"></a>status更新</h3><p>如果是<code>subresource</code>,<code>code-gen</code>生成代码会为status生成<code>UpdateStatus</code>方法，可以使用这个方法对status进行更新操作。<br>对status的更新也会增加对象的<code>ResourceVersion</code>,并产生更新事件。</p>
<h3 id="kubectl-edit修改status"><a href="#kubectl-edit修改status" class="headerlink" title="kubectl edit修改status"></a>kubectl edit修改status</h3><p>如果你使用<code>kubectl edit</code>命令对status进行修改发现根本不了。使用<code>kubectl edit</code>修改<code>crd</code>调用的接口是<code>apis/&lt;group&gt;/&lt;version/&lt;cr-name&gt;</code>,http方法是<code>PATCH</code>。假如把status中的availableReplicas更新为2,则<br><code>patchType =&quot;application/merge-patch+json&quot;</code><br><code>patchBytes = {&quot;status&quot;:{&quot;availableReplicas&quot;:2}}</code></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/apiserver/pkg/registry/generic/registry/store.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">Update</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, objInfo rest.UpdatedObjectInfo, createValidation rest.ValidateObjectFunc, updateValidation rest.ValidateObjectUpdateFunc, forceAllowCreate <span class="keyword">bool</span>, options *metav1.UpdateOptions)</span> <span class="params">(runtime.Object, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    		<span class="keyword">if</span> err := rest.BeforeUpdate(e.UpdateStrategy, ctx, obj, existing); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vendor/k8s.io/apiserver/pkg/registry/rest/update.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BeforeUpdate</span><span class="params">(strategy RESTUpdateStrategy, ctx context.Context, obj, old runtime.Object)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	objectMeta, kind, kerr := objectMetaAndKind(strategy, obj)</span><br><span class="line">	<span class="keyword">if</span> kerr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> kerr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ensure namespace on the object is correct, or error if a conflicting namespace was set in the object</span></span><br><span class="line">	requestNamespace, ok := genericapirequest.NamespaceFrom(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.NewInternalError(fmt.Errorf(<span class="string">"no namespace information found in request context"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	objectMeta.SetGeneration(oldMeta.GetGeneration())</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">	strategy.PrepareForUpdate(ctx, obj, old)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging/src/k8s.io/apiextensions-apiserver/pkg/registry/customresource/strategy.go</span></span><br><span class="line"><span class="comment">// PrepareForUpdate clears fields that are not allowed to be set by end users on update.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a customResourceStrategy)</span> <span class="title">PrepareForUpdate</span><span class="params">(ctx context.Context, obj, old runtime.Object)</span></span> &#123;</span><br><span class="line">	newCustomResourceObject := obj.(*unstructured.Unstructured)</span><br><span class="line">	oldCustomResourceObject := old.(*unstructured.Unstructured)</span><br><span class="line"></span><br><span class="line">	newCustomResource := newCustomResourceObject.UnstructuredContent()</span><br><span class="line">	oldCustomResource := oldCustomResourceObject.UnstructuredContent()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the /status subresource endpoint is installed, update is not allowed to set status.</span></span><br><span class="line">    <span class="comment">// a.status!=nil表明status是subresource,会使用旧的status覆盖新的status</span></span><br><span class="line">	<span class="keyword">if</span> a.status != <span class="literal">nil</span> &#123;</span><br><span class="line">		_, ok1 := newCustomResource[<span class="string">"status"</span>]</span><br><span class="line">		_, ok2 := oldCustomResource[<span class="string">"status"</span>]</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> ok2:</span><br><span class="line">			newCustomResource[<span class="string">"status"</span>] = oldCustomResource[<span class="string">"status"</span>]</span><br><span class="line">		<span class="keyword">case</span> ok1:</span><br><span class="line">			<span class="built_in">delete</span>(newCustomResource, <span class="string">"status"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// except for the changes to `metadata`, any other changes</span></span><br><span class="line">	<span class="comment">// cause the generation to increment.</span></span><br><span class="line">	newCopyContent := copyNonMetadata(newCustomResource)</span><br><span class="line">	oldCopyContent := copyNonMetadata(oldCustomResource)</span><br><span class="line">	<span class="keyword">if</span> !apiequality.Semantic.DeepEqual(newCopyContent, oldCopyContent) &#123;</span><br><span class="line">		oldAccessor, _ := meta.Accessor(oldCustomResourceObject)</span><br><span class="line">		newAccessor, _ := meta.Accessor(newCustomResourceObject)</span><br><span class="line">		newAccessor.SetGeneration(oldAccessor.GetGeneration() + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ol>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status" target="_blank" rel="noopener">k8s-spec-and-status</a></li>
<li><a href="https://github.com/kubernetes/sample-controller/blob/master/pkg/apis/samplecontroller/v1alpha1/types.go" target="_blank" rel="noopener">https://github.com/kubernetes/sample-controller/blob/master/pkg/apis/samplecontroller/v1alpha1/types.go</a></li>
</ol>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s-workqueue</title>
    <url>/2021/07/25/k8s-workqueue/</url>
    <content><![CDATA[<p><code>workqueue</code>提供了如下特性<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">- 公平: 队列中的元素以先进先出的方式进行处理</span><br><span class="line">- Stingy(翻译为:吝啬的): 在高并发情况下和一元素在处理之前添加了多次的情况下,队列中的元素只会被处理一次</span><br><span class="line">- 并发性:多消费者和生产者.支持元素被正在处理的情况下重新入队</span><br><span class="line">- 通知机制：ShutDown方法通过信号量通知队列不再接收新的元素</span><br></pre></td></tr></table></figure></p>
<p>Kubernetes 中使用 WorkQueue 的好处主要有以下几点:</p>
<ul>
<li><p>降低并发冲突：WorkQueue 可以确保每个任务都被串行处理，这意味着每个任务将独立地执行，而不会受到其他任务的干扰，从而降低并发冲突的可能性。</p>
</li>
<li><p>控制任务执行速率：使用 WorkQueue 可以限制并控制任务的执行速率，这对于资源敏感的应用程序和需要限制负载的场景非常有用。</p>
</li>
<li><p>实现重试逻辑：WorkQueue 支持任务重试，当一个任务失败时，它可以将任务重新排队，以便在稍后的时间再次尝试执行该任务，从而实现重试逻辑。</p>
</li>
<li><p>消除重复工作：使用 WorkQueue 可以有效地避免重复处理相同的任务，以提高应用程序的性能和效率。</p>
</li>
</ul>
<h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/client-go/util/workqueue/queue.go</span></span><br><span class="line"><span class="comment">// 定义了队列常用的方法 </span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Add(item <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// 添加一个元素到队列</span></span><br><span class="line">	Len() <span class="keyword">int</span> <span class="comment">// 元素个数</span></span><br><span class="line">	Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="keyword">bool</span>)　<span class="comment">// 获取一个元素,shutdown标记队列是否关闭</span></span><br><span class="line">	Done(item <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// 标记一个元素已经处理完</span></span><br><span class="line">	ShutDown() <span class="comment">// 关闭队列</span></span><br><span class="line">	ShutDownWithDrain() <span class="comment">// 关闭队列,但是等待队列中的元素处理完</span></span><br><span class="line">	ShuttingDown() <span class="keyword">bool</span>　<span class="comment">// 队列是否正在关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> empty <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> set <span class="keyword">map</span>[t]empty</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列的实现</span></span><br><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 实际存储元素的地方,此处的每个元素应该存在于dirty中而不存在于processing set</span></span><br><span class="line">	queue []t</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有需要被处理的item,类型是集合</span></span><br><span class="line">	dirty set</span><br><span class="line"></span><br><span class="line">	<span class="comment">// processing用于标记一个元素是否正在处理.在并发场景下这些元素也可能存在dirty set.</span></span><br><span class="line">	<span class="comment">// 当我们处理完这个事件之后会将其移除,然后检查其是否存在于dirty set,如果存在将其入队.</span></span><br><span class="line">	processing set</span><br><span class="line"></span><br><span class="line">	cond *sync.Cond</span><br><span class="line"></span><br><span class="line">	shuttingDown <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	metrics queueMetrics</span><br><span class="line"></span><br><span class="line">	unfinishedWorkUpdatePeriod time.Duration</span><br><span class="line">	clock                      clock.Clock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">Add</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    <span class="comment">// 如果队列是处理shuttingDown状态下,直接返回，不再进行入队操作</span></span><br><span class="line">	<span class="keyword">if</span> q.shuttingDown &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果dirty set存在这个元素，则不会再次入队,保证元素在处理前只会进行一次入队操作</span></span><br><span class="line">	<span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	q.metrics.add(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入dirty set</span></span><br><span class="line">    q.dirty.insert(item)</span><br><span class="line">    <span class="comment">// 如果元素存在于processing set中,则返回</span></span><br><span class="line">	<span class="keyword">if</span> q.processing.has(item) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素添加到队列中</span></span><br><span class="line">	q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">	q.cond.Signal()　<span class="comment">// 通知getter有新元素到来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回队列长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	q.cond.L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(q.queue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get取出队列头部元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    <span class="comment">// 如果队列长度为0且处于shuttingDown状态下,阻塞</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &amp;&amp; !q.shuttingDown &#123;</span><br><span class="line">		<span class="comment">// 接收到q.cond.Signal()后结束阻塞</span></span><br><span class="line">		q.cond.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// We must be shutting down.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 对队列头部元素进行出队操作</span></span><br><span class="line">	item, q.queue = q.queue[<span class="number">0</span>], q.queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">	q.metrics.get(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素插入processing set 并且将其从dirty set删除 </span></span><br><span class="line">	q.processing.insert(item)</span><br><span class="line">	q.dirty.<span class="built_in">delete</span>(item)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> item, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记一个元素已被处理完</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">Done</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	q.cond.L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">	q.metrics.done(item)</span><br><span class="line">    <span class="comment">// 从processing set中移除item</span></span><br><span class="line">    q.processing.<span class="built_in">delete</span>(item)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果元素在处理过程中又插入了相同的元素，重新将元素入队</span></span><br><span class="line">	<span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">		q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">		q.cond.Signal()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShutDown 如果队列处于shuttingDown状态下，将不会往队列中添加新的元素</span></span><br><span class="line"><span class="comment">// 当工作的协程将队列中的元素处理完之后，它们将会退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">ShutDown</span><span class="params">()</span></span> &#123;</span><br><span class="line">	q.cond.L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">	q.shuttingDown = <span class="literal">true</span></span><br><span class="line">	q.cond.Broadcast()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">ShuttingDown</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	q.cond.L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> q.shuttingDown</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个例子学习<code>workqueue</code>的工作原理<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/util/workqueue"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	down :=  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	q := workqueue.New()</span><br><span class="line">	q.Add(<span class="number">1</span>)</span><br><span class="line">	q.Add(<span class="number">2</span>)</span><br><span class="line">    q.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持Stingy的特性的微妙之处就在于这,如果元素已经存在于队列中且不存在于processing set中，将不会入队.</span></span><br><span class="line"></span><br><span class="line">    q.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行完4次Add操作后，队列中的元素内容如下</span></span><br><span class="line">    <span class="comment">// queue      --&gt; [1, 2, 3]</span></span><br><span class="line">    <span class="comment">// dirty      --&gt; &#123;1, 2, 3&#125;</span></span><br><span class="line">    <span class="comment">// processing --&gt; &#123;&#125;    // queue      --&gt; [2, 3]</span></span><br><span class="line">    <span class="comment">// dirty      --&gt; &#123;1, 2, 3&#125;</span></span><br><span class="line">    <span class="comment">// processing --&gt; &#123;1&#125;</span></span><br><span class="line"></span><br><span class="line">	item,_ := q.Get()</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		fmt.Println(<span class="string">"processing"</span>,item)</span><br><span class="line">        &lt;-down</span><br><span class="line">        <span class="comment">// 执行q.Done(item)之后的状态</span></span><br><span class="line">        <span class="comment">// queue      --&gt; [2, 3, 1]</span></span><br><span class="line">        <span class="comment">// dirty      --&gt; &#123;1, 2, 3&#125;</span></span><br><span class="line">        <span class="comment">// processing --&gt; &#123;&#125;</span></span><br><span class="line">        <span class="comment">// 此时元素1重新入队</span></span><br><span class="line">        q.Done(item)</span><br><span class="line">        </span><br><span class="line">		fmt.Println(<span class="string">"processed"</span>,item)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 在q.Add(1)执行之前此时状态为</span></span><br><span class="line">    <span class="comment">// queue      --&gt; [2, 3]</span></span><br><span class="line">    <span class="comment">// dirty      --&gt; &#123;2, 3&#125;</span></span><br><span class="line">    <span class="comment">// processing --&gt; &#123;1&#125;</span></span><br><span class="line"></span><br><span class="line">    q.Add(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在执行q.Add(1)之后此时状态为</span></span><br><span class="line">    <span class="comment">// queue      --&gt; [2, 3]</span></span><br><span class="line">    <span class="comment">// dirty      --&gt; &#123;1, 2, 3&#125;</span></span><br><span class="line">    <span class="comment">// processing --&gt; &#123;1&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// queue      --&gt; [2, 3]</span></span><br><span class="line">    <span class="comment">// dirty      --&gt; &#123;1, 2, 3&#125;</span></span><br><span class="line">    <span class="comment">// processing --&gt; &#123;1&#125;</span></span><br><span class="line">	down&lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>小结:<br>Stingy这一特性在高并发情况下是通过互斥锁来保证元素只会被处理一次;而对于同一元素多次入队的情况，如果该元素还未被处理，则会直接丢弃。</p>
<hr>
<h5 id="DelayingQueue"><a href="#DelayingQueue" class="headerlink" title="DelayingQueue"></a>DelayingQueue</h5><p>顺便看k8s中的延迟队列,延迟队列基于FIFO队列实现，在原有的基础上添加了AddAfter方法.在延迟一段时间后将元素插入到队列中<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/client-go/util/workqueue/delaying_queue.go</span></span><br><span class="line"><span class="keyword">type</span> DelayingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Interface</span><br><span class="line">	<span class="comment">// AddAfter adds an item to the workqueue after the indicated duration has passed</span></span><br><span class="line">	AddAfter(item <span class="keyword">interface</span>&#123;&#125;, duration time.Duration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delayingType 提供延迟入队操作</span></span><br><span class="line"><span class="keyword">type</span> delayingType <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 嵌套普通队列queue</span></span><br><span class="line">	Interface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// clock tracks time for delayed firing</span></span><br><span class="line">	clock clock.Clock</span><br><span class="line"></span><br><span class="line">	<span class="comment">// stopCh lets us signal a shutdown to the waiting loop</span></span><br><span class="line">	stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// stopOnce guarantees we only signal shutdown a single time</span></span><br><span class="line">	stopOnce sync.Once</span><br><span class="line"></span><br><span class="line">	<span class="comment">// heartbeat ensures we wait no more than maxWait before firing</span></span><br><span class="line">	heartbeat clock.Ticker</span><br><span class="line"></span><br><span class="line">	<span class="comment">// waitingForAddCh is a buffered channel that feeds waitingForAdd</span></span><br><span class="line">	waitingForAddCh <span class="keyword">chan</span> *waitFor</span><br><span class="line"></span><br><span class="line">	<span class="comment">// metrics counts the number of retries</span></span><br><span class="line">	metrics retryMetrics</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newDelayingQueue 真正实例化延迟队列的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDelayingQueue</span><span class="params">(clock clock.Clock, q Interface, name <span class="keyword">string</span>)</span> *<span class="title">delayingType</span></span> &#123;</span><br><span class="line">	ret := &amp;delayingType&#123;</span><br><span class="line">		Interface:       q,</span><br><span class="line">		clock:           clock,</span><br><span class="line">		heartbeat:       clock.NewTicker(maxWait),</span><br><span class="line">		stopCh:          <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		waitingForAddCh: <span class="built_in">make</span>(<span class="keyword">chan</span> *waitFor, <span class="number">1000</span>),</span><br><span class="line">		metrics:         newRetryMetrics(name),</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 运行一个循环</span></span><br><span class="line">	<span class="keyword">go</span> ret.waitingLoop()</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// waitingLoop 不断的检查waitForPriorityQueue的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *delayingType)</span> <span class="title">waitingLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 队里没有元素时等待</span></span><br><span class="line">	never := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> time.Time)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make a timer that expires when the item at the head of the waiting queue is ready</span></span><br><span class="line">	<span class="keyword">var</span> nextReadyAtTimer clock.Timer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造一个优先级队列</span></span><br><span class="line">	waitingForQueue := &amp;waitForPriorityQueue&#123;&#125;</span><br><span class="line">	heap.Init(waitingForQueue)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于处理重复添加逻辑</span></span><br><span class="line">	waitingEntryByData := <span class="keyword">map</span>[t]*waitFor&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> q.Interface.ShuttingDown() &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		now := q.clock.Now()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add ready entries</span></span><br><span class="line">		<span class="keyword">for</span> waitingForQueue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">            entry := waitingForQueue.Peek().(*waitFor)</span><br><span class="line">            <span class="comment">// 如果元素中的readyAt 在now之后，则退出</span></span><br><span class="line">			<span class="keyword">if</span> entry.readyAt.After(now) &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从优先级队列中取出顶部元素，添加到workqueue中</span></span><br><span class="line">			entry = heap.Pop(waitingForQueue).(*waitFor)</span><br><span class="line">			q.Add(entry.data)</span><br><span class="line">			<span class="built_in">delete</span>(waitingEntryByData, entry.data)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set up a wait for the first item's readyAt (if one exists)</span></span><br><span class="line">		nextReadyAt := never</span><br><span class="line">		<span class="keyword">if</span> waitingForQueue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> nextReadyAtTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">				nextReadyAtTimer.Stop()</span><br><span class="line">			&#125;</span><br><span class="line">            entry := waitingForQueue.Peek().(*waitFor)</span><br><span class="line">            <span class="comment">// 返回一个定时器对象,时间间隔是：entry.readyAt-now</span></span><br><span class="line">            nextReadyAtTimer = q.clock.NewTimer(entry.readyAt.Sub(now))</span><br><span class="line">            <span class="comment">// 猜测这样做是不用一直占用cpu资源，在优先级最高的元素入队的时间未到之前可以挂起</span></span><br><span class="line">			nextReadyAt = nextReadyAtTimer.C()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-q.stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-q.heartbeat.C():</span><br><span class="line">			<span class="comment">// continue the loop, which will add ready items</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-nextReadyAt:</span><br><span class="line">			<span class="comment">// continue the loop, which will add ready items</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> waitEntry := &lt;-q.waitingForAddCh:</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">			<span class="keyword">if</span> waitEntry.readyAt.After(q.clock.Now()) &#123;</span><br><span class="line">				insert(waitingForQueue, waitingEntryByData, waitEntry)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				q.Add(waitEntry.data)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			drained := <span class="literal">false</span></span><br><span class="line">			<span class="keyword">for</span> !drained &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> waitEntry := &lt;-q.waitingForAddCh:</span><br><span class="line">					<span class="keyword">if</span> waitEntry.readyAt.After(q.clock.Now()) &#123;</span><br><span class="line">						insert(waitingForQueue, waitingEntryByData, waitEntry)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						q.Add(waitEntry.data)</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					drained = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素到优先级队列，如果元素已存在则更新其readyAt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(q *waitForPriorityQueue, knownEntries <span class="keyword">map</span>[t]*waitFor, entry *waitFor)</span></span> &#123;</span><br><span class="line">	<span class="comment">// if the entry already exists, update the time only if it would cause the item to be queued sooner</span></span><br><span class="line">	existing, exists := knownEntries[entry.data]</span><br><span class="line">	<span class="keyword">if</span> exists &#123;</span><br><span class="line">		<span class="keyword">if</span> existing.readyAt.After(entry.readyAt) &#123;</span><br><span class="line">			existing.readyAt = entry.readyAt</span><br><span class="line">			heap.Fix(q, existing.index)</span><br><span class="line">		&#125;做</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 插入优先级队列</span></span><br><span class="line">	heap.Push(q, entry)</span><br><span class="line">	knownEntries[entry.data] = entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于记录入队的元素以及需要被入队的时间 </span></span><br><span class="line"><span class="keyword">type</span> waitFor <span class="keyword">struct</span> &#123;</span><br><span class="line">	data    t</span><br><span class="line">	readyAt time.Time</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列(堆)中的索引</span></span><br><span class="line">	index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// waitForPriorityQueue 为一个优先级队列,实现了heap.Interface中的方法 </span></span><br><span class="line"><span class="comment">// 值readyAt最小的元素是顶点(index 0).</span></span><br><span class="line"><span class="comment">// Peek返回索引0中的元素</span></span><br><span class="line"><span class="comment">// Pop 将元素从队列中移除</span></span><br><span class="line"><span class="comment">// Push将元素插入到队列中</span></span><br><span class="line"><span class="keyword">type</span> waitForPriorityQueue []*waitFor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// AddAfter </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *delayingType)</span> <span class="title">AddAfter</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, duration time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="comment">// don't add if we're already shutting down</span></span><br><span class="line">	<span class="keyword">if</span> q.ShuttingDown() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	q.metrics.retry()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// immediately add things with no delay</span></span><br><span class="line">	<span class="keyword">if</span> duration &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		q.Add(item)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-q.stopCh:</span><br><span class="line">        <span class="comment">// unblock if ShutDown() is called</span></span><br><span class="line">        <span class="comment">// 将元素添加到waitingForAddCh 中，此channel中的数据将在waitingLoop方法中被处理</span></span><br><span class="line">	<span class="keyword">case</span> q.waitingForAddCh &lt;- &amp;waitFor&#123;data: item, readyAt: q.clock.Now().Add(duration)&#125;:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// waitForPriorityQueue实现了heap.Interface接口,最小堆</span></span><br><span class="line"><span class="comment">// Push adds an item to the queue. Push should not be called directly; instead,</span></span><br><span class="line"><span class="comment">// use `heap.Push`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *waitForPriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(*pq)</span><br><span class="line">	item := x.(*waitFor)</span><br><span class="line">	item.index = n</span><br><span class="line">	*pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop removes an item from the queue. Pop should not be called directly;</span></span><br><span class="line"><span class="comment">// instead, use `heap.Pop`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *waitForPriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(*pq)</span><br><span class="line">	item := (*pq)[n<span class="number">-1</span>]</span><br><span class="line">	item.index = <span class="number">-1</span></span><br><span class="line">	*pq = (*pq)[<span class="number">0</span>:(n - <span class="number">1</span>)]</span><br><span class="line">	<span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Peek returns the item at the beginning of the queue, without removing the</span></span><br><span class="line"><span class="comment">// item or otherwise mutating the queue. It is safe to call directly.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq waitForPriorityQueue)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> pq[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RateLimitingQueue"><a href="#RateLimitingQueue" class="headerlink" title="RateLimitingQueue"></a>RateLimitingQueue</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/client-go/util/workqueue/rate_limiting_queue.go</span></span><br><span class="line"><span class="comment">// RateLimitingInterface is an interface that rate limits items being added to the queue.</span></span><br><span class="line"><span class="keyword">type</span> RateLimitingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	DelayingInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AddRateLimited adds an item to the workqueue after the rate limiter says it's ok</span></span><br><span class="line">	AddRateLimited(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Forget indicates that an item is finished being retried.  Doesn't matter whether it's for perm failing</span></span><br><span class="line">	<span class="comment">// or for success, we'll stop the rate limiter from tracking it.  This only clears the `rateLimiter`, you</span></span><br><span class="line">	<span class="comment">// still have to call `Done` on the queue.</span></span><br><span class="line">	<span class="comment">// 结束重试　</span></span><br><span class="line">	Forget(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumRequeues returns back how many times the item was requeued</span></span><br><span class="line">	<span class="comment">// 重新入队次数</span></span><br><span class="line">	NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现RateLimitingInterface的结构体</span></span><br><span class="line"><span class="keyword">type</span> rateLimitingType <span class="keyword">struct</span> &#123;</span><br><span class="line">	DelayingInterface</span><br><span class="line"></span><br><span class="line">	rateLimiter RateLimiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *rateLimitingType)</span> <span class="title">AddRateLimited</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	q.DelayingInterface.AddAfter(item, q.rateLimiter.When(item))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心对象RateLimiter</span></span><br><span class="line"><span class="comment">// vendor/k8s.io/client-go/util/workqueue/default_rate_limiters.go</span></span><br><span class="line"><span class="keyword">type</span> RateLimiter <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// When gets an item and gets to decide how long that item should wait</span></span><br><span class="line">	When(item <span class="keyword">interface</span>&#123;&#125;) time.Duration</span><br><span class="line">	<span class="comment">// Forget indicates that an item is finished being retried.  Doesn't matter whether it's for failing</span></span><br><span class="line">	<span class="comment">// or for success, we'll stop tracking it</span></span><br><span class="line">	Forget(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// NumRequeues returns back how many failures the item has had</span></span><br><span class="line">	NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个接口有５个实现</span></span><br><span class="line"><span class="comment">// BucketRateLimiter</span></span><br><span class="line"><span class="comment">// 使用golang.org/x/time/rate.Limiter实现</span></span><br><span class="line"><span class="keyword">type</span> BucketRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	*rate.Limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ RateLimiter = &amp;BucketRateLimiter&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span> <span class="title">When</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Limiter.Reserve().Delay()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span> <span class="title">NumRequeues</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span> <span class="title">Forget</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ItemExponentialFailureRateLimiter</span></span><br><span class="line"><span class="comment">// 失败次数越多，间隔时间越长</span></span><br><span class="line"><span class="keyword">type</span> ItemExponentialFailureRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	failuresLock sync.Mutex</span><br><span class="line">	failures     <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	baseDelay time.Duration</span><br><span class="line">	maxDelay  time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ItemExponentialFailureRateLimiter)</span> <span class="title">When</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">	r.failuresLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.failuresLock.Unlock()</span><br><span class="line"></span><br><span class="line">	exp := r.failures[item]</span><br><span class="line">	r.failures[item] = r.failures[item] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The backoff is capped such that 'calculated' value never overflows.</span></span><br><span class="line">	backoff := <span class="keyword">float64</span>(r.baseDelay.Nanoseconds()) * math.Pow(<span class="number">2</span>, <span class="keyword">float64</span>(exp))</span><br><span class="line">	<span class="keyword">if</span> backoff &gt; math.MaxInt64 &#123;</span><br><span class="line">		<span class="keyword">return</span> r.maxDelay</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	calculated := time.Duration(backoff)</span><br><span class="line">	<span class="keyword">if</span> calculated &gt; r.maxDelay &#123;</span><br><span class="line">		<span class="keyword">return</span> r.maxDelay</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> calculated</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ItemFastSlowRateLimiter</span></span><br><span class="line"><span class="comment">// 快慢指的是定义一个阈值，达到阈值之前快速重试，超过了就慢慢重试</span></span><br><span class="line"><span class="keyword">type</span> ItemFastSlowRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	failuresLock sync.Mutex</span><br><span class="line">	failures     <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	maxFastAttempts <span class="keyword">int</span></span><br><span class="line">	fastDelay       time.Duration</span><br><span class="line">	slowDelay       time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ItemFastSlowRateLimiter)</span> <span class="title">When</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">	r.failuresLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.failuresLock.Unlock()</span><br><span class="line"></span><br><span class="line">	r.failures[item] = r.failures[item] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> r.failures[item] &lt;= r.maxFastAttempts &#123;</span><br><span class="line">		<span class="keyword">return</span> r.fastDelay</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r.slowDelay</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxOfRateLimiter</span></span><br><span class="line"><span class="comment">// 过维护多个限速器列表，然后返回其中限速最严格的一个延时</span></span><br><span class="line"><span class="comment">// MaxOfRateLimiter calls every RateLimiter and returns the worst case response</span></span><br><span class="line"><span class="comment">// When used with a token bucket limiter, the burst could be apparently exceeded in cases where particular items</span></span><br><span class="line"><span class="comment">// were separately delayed a longer time.</span></span><br><span class="line"><span class="keyword">type</span> MaxOfRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	limiters []RateLimiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *MaxOfRateLimiter)</span> <span class="title">When</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">	ret := time.Duration(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, limiter := <span class="keyword">range</span> r.limiters &#123;</span><br><span class="line">		curr := limiter.When(item)</span><br><span class="line">		<span class="keyword">if</span> curr &gt; ret &#123;</span><br><span class="line">			ret = curr</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithMaxWaitRateLimiter</span></span><br><span class="line"><span class="comment">// 加入最大延迟属性，如果到了最大延时则返回</span></span><br><span class="line"><span class="keyword">type</span> WithMaxWaitRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	limiter  RateLimiter</span><br><span class="line">	maxDelay time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w WithMaxWaitRateLimiter)</span> <span class="title">When</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">	delay := w.limiter.When(item)</span><br><span class="line">	<span class="keyword">if</span> delay &gt; w.maxDelay &#123;</span><br><span class="line">		<span class="keyword">return</span> w.maxDelay</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> delay</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://pkg.go.dev/k8s.io/client-go/util/workqueue" target="_blank" rel="noopener">https://pkg.go.dev/k8s.io/client-go/util/workqueue</a><br>2.Kubernetes源码剖析</p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s之hello-world</title>
    <url>/2019/08/01/k8s%E4%B9%8Bhello-world/</url>
    <content><![CDATA[<p>环境：CentOs 7.2</p>
<p>一、使用k8s搭建hello-world,安装kubernetes<br>1.关闭CentOS自带的防火墙<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></p>
<p>2.安装etcd和kubernetes<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y etcd kubernetes</span><br></pre></td></tr></table></figure></p>
<p>3.修改配置文件/etc/sysconfig/docker和/etc/kubernetes/apiserver为如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/sysconfig/docker/</span><br><span class="line"></span><br><span class="line">OPTIONS=&apos;--selinux-enabled=false --log-driver=journald --signature-verification=false&apos;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将--admission-control参数中的ServiceAccount删除</span><br><span class="line">/etc/kubernetes/apiserver</span><br><span class="line">KUBE_ADMISSION_CONTROL=&quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota&quot;</span><br></pre></td></tr></table></figure>
<p>4.按如下顺序启动所有的服务<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start etcd</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line">systemctl start kube-controller-manager</span><br><span class="line">systemctl start kube-scheduler</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl start kube-proxy</span><br></pre></td></tr></table></figure></p>
<p>二、搭建hello-world案例<br><img src="http://img.hysyeah.top/2019/08/01/helloworld-k8s.png" alt="image"><br>1.拉取镜像<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull kubeguide/guestbook-php-frontend  # php web服务</span><br><span class="line">docker pull kubeguide/redis-master</span><br><span class="line">docker pull kubeguide/guestbook-redis-slave</span><br></pre></td></tr></table></figure></p>
<ol>
<li>创建redis-master Pod和服务</li>
</ol>
<ul>
<li><p>为redis-master服务创建名为redis-master的RC定义文件：redis-master-controller.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-master</span><br><span class="line">  labels:</span><br><span class="line">    name: redis-master</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    name: redis-master</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: redis-master</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: master</span><br><span class="line">        image: kubeguide/redis-master</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 6379</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布到集群中<br><code>kubectl create -f redis-master-controller.yaml</code></p>
</li>
<li><p>创建与之关联的Service,编辑文件<code>redis-master-service.yaml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-master</span><br><span class="line">  labels:</span><br><span class="line">    name: redis-master</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 6379</span><br><span class="line">    targetPort: 6379</span><br><span class="line">  selector:</span><br><span class="line">    name: redis-master</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布Service<br><code>kubectl create -f redis-master-service.yaml</code></p>
</li>
</ul>
<p>3.创建redis-slave Pod和服务</p>
<ul>
<li><p>创建Pod<br><code>vim redis-slave-controller.yaml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-slave</span><br><span class="line">  labels:</span><br><span class="line">    name: redis-slave</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    name: redis-slave</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: redis-slave</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: slave</span><br><span class="line">        image: kubeguide/guestbook-redis-slave</span><br><span class="line">        env:</span><br><span class="line">        - name: GET_HOSTS_FROM</span><br><span class="line">          value: env</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 6379</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布Pod到集群<br><code>kubectl  create -f redis-slave-controller.yaml</code></p>
</li>
<li><p>创建Service<br><code>vim redis-slave-service.yaml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-slave</span><br><span class="line">  labels:</span><br><span class="line">    name: redis-slave</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 6379</span><br><span class="line">  selector:</span><br><span class="line">    name: redis-slave</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布服务<br><code>kubectl create -f redis-slave-service.yaml</code></p>
</li>
</ul>
<p>4.创建frontend Pod和服务</p>
<ul>
<li><p>创建Pod<br><code>vim frontend-controller.yaml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">  labels:</span><br><span class="line">    name: frontend</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    name: frontend</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: frontend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: frontend</span><br><span class="line">          image: kubeguide/guestbook-php-frontend</span><br><span class="line">          env:</span><br><span class="line">            - name: GET_HOSTS_FROM</span><br><span class="line">              value: env</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 80</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布Pod到集群<br><code>kubectl create -f frontend-controller.yaml</code></p>
</li>
<li><p>创建服务<br><code>vim frontend-service.yaml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">  labels:</span><br><span class="line">    name: frontend</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 80</span><br><span class="line">      nodePort: 30001</span><br><span class="line">  selector:</span><br><span class="line">    name: frontend</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布Service<br><code>kubectl create -f frontend-service.yaml</code></p>
</li>
</ul>
<p>5.查看Pod和服务状态<br><img src="http://img.hysyeah.top/2019/08/01/helloworld-status.png" alt="image"></p>
<p>集群中其它Pod如何访问redis-master中的服务？<br>redis-master服务被分配了一个值为10.254.187.40的虚拟IP,kubernetes集群中的其它Pod就可以通过这个IP访问redis-master服务。由于IP地址是在服务创建后由kebernetes系统自动分配的,其它Pod中无法预先知道某个Service的虚拟IP,为此kuberntes通过使用环境变量来实现服务发现,在每个Pod的容器里都增加了一组Service相关的环境变量,用来记录从服务名到虚拟IP地址的映射关系。<br><img src="http://img.hysyeah.top/2019/08/04/frontend_env.png" alt="image"><br><img src="http://img.hysyeah.top/2019/08/04/redis_slave_env.png" alt="image"></p>
<p>5.通过浏览器访问网页,输入URL: <a href="http://虚拟机IP:30001" target="_blank" rel="noopener">http://虚拟机IP:30001</a><br><img src="http://img.hysyeah.top/2019/08/01/k8s-guestbook.png" alt="image"></p>
<hr>
<p>在创建过程中可能会用到的命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods    #查看pod状态</span><br><span class="line">kubectl get rc      #查看RC</span><br><span class="line">kubectl get service #查看服务</span><br><span class="line"></span><br><span class="line">kubectl logs [pod-name]   # 查看日志</span><br><span class="line">kubectl delete pods [pod-name]  #删除pod</span><br><span class="line">kubectl delete rc [rc-name]          #删除rc</span><br><span class="line">kubectl delete service [service-name]   #删除服务</span><br></pre></td></tr></table></figure></p>
<hr>
<p>所遇问题：<br>1.docker启动失败,提示Error starting daemon: SELinux is not supported with the overlay2 graph driver on this kernel. Either boot into a newer kernel or disable selinux in docker (—selinux-enabled=false)</p>
<p><code>vim /etc/sysconfig/docker</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS=&apos;--selinux-enabled --log-driver=journald --signature-verification=false&apos;</span><br></pre></td></tr></table></figure></p>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS=&apos;--selinux-enabled=false --log-driver=journald --signature-verification=false&apos;</span><br></pre></td></tr></table></figure>
<p>2.创建pod一直处于ContainerCreating状态,原因是不能拉取pod的基础镜像,[<a href="https://blog.csdn.net/weixin_34054866/article/details/87525597" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34054866/article/details/87525597</a>]<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y *rhsm*</span><br><span class="line"> </span><br><span class="line">wget http://mirror.centos.org/centos/7/os/x86_64/Packages/python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm</span><br><span class="line"> </span><br><span class="line">rpm2cpio python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm | cpio -iv --to-stdout ./etc/rhsm/ca/redhat-uep.pem | tee /etc/rhsm/ca/redhat-uep.pem</span><br></pre></td></tr></table></figure></p>
<p>3.启动frontend pod时报错, AH00534: apache2: Configuration error: No MPM loaded<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop docker              //停掉docker服务</span><br><span class="line">rm -rf /var/lib/docker             //注意会清掉docker images的镜像,需重新拉取镜像</span><br><span class="line">vi /etc/sysconfig/docker-storage   //将文件里的overlay2改成devicemapper即可</span><br><span class="line">DOCKER_STORAGE_OPTIONS=&quot;--storage-driver overlay2 &quot;  #修改前</span><br><span class="line">DOCKER_STORAGE_OPTIONS=&quot;--storage-driver devicemapper &quot;   #修改后</span><br></pre></td></tr></table></figure></p>
<p>重启docker服务<br><code>systemctl start docker</code></p>
<hr>
<p>Ref：<br>1.kubernetes权威指南<br>2.<a href="https://blog.csdn.net/a1010256340/article/details/80106156" target="_blank" rel="noopener">https://blog.csdn.net/a1010256340/article/details/80106156</a><br>3.<a href="https://blog.csdn.net/weixin_34054866/article/details/87525597" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34054866/article/details/87525597</a><br>4.<a href="https://www.cnblogs.com/guyeshanrenshiwoshifu/p/9147238.html" target="_blank" rel="noopener">https://www.cnblogs.com/guyeshanrenshiwoshifu/p/9147238.html</a></p>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s之kube-proxy[上]</title>
    <url>/2023/05/20/k8s%E4%B9%8Bkube-proxy/</url>
    <content><![CDATA[<p><code>kube-proxy</code> 是集群中每个节点（node）上所运行的网络代理， 是实现 <code>Kubernetes</code> 服务（Service） 概念的一部分。</p>
<p><code>kube-proxy</code> 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p>
<hr>
<p>一次请求过程中需要<code>kube-proxy</code>参与吗？</p>
<p>做个实验:在<code>kube-proxy</code>正常工作的情况下使用上面的<code>yaml</code>文件创建<code>Service</code>,发现服务能正常访问。关闭<code>kube-proxy</code>发现服务也能正常访问。<br>关闭<code>kube-proxy</code>重新创建<code>Service</code>然后你会发现服务不能访问。这里可以先得出一个结论: <code>kube-proxy</code>只会在<code>Service</code>创建时创建一些规则(iptables/ipvs),<br>然后在<code>Service</code>在被访问的过程,<code>kube-proxy</code>并不参与。</p>
<hr>
<p>使用下面的<code>yaml</code>文件创建<code>Service</code><br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-curl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-curl</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">my-curl</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-curl</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">hysyeah/my-curl:v1</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-curl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-curl</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure></p>
<p><code>iptables</code>的每条链下面的规则处理顺序都是从上往下逐条遍历，除非遇到<code>DROP</code>,<code>REJECT</code>,<code>RETURN</code>。如果链下面是自定义链，则跳转到<br>对应的自定义链执行链下的所有规则,然后跳转回来执行原来那条链后面的规则。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> </span><br><span class="line"><span class="meta">#</span> ServiceIP: 10.98.75.173</span><br><span class="line"><span class="meta">#</span> PodIP: 10.244.0.221</span><br><span class="line">➜ ✗ sudo iptables -L -n -t nat</span><br><span class="line"></span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-SERVICES  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-SERVICES  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-POSTROUTING  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */</span><br><span class="line">MASQUERADE  all  --  192.168.250.0/24    !192.168.250.0/24     /* managed by anbox-bridge */</span><br><span class="line">FLANNEL-POSTRTG  all  --  0.0.0.0/0            0.0.0.0/0            /* flanneld masq */</span><br><span class="line"></span><br><span class="line">Chain FLANNEL-POSTRTG (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">RETURN     all  --  0.0.0.0/0            0.0.0.0/0            mark match 0x4000/0x4000 /* flanneld masq */</span><br><span class="line">RETURN     all  --  10.244.0.0/24        10.244.0.0/16        /* flanneld masq */</span><br><span class="line">RETURN     all  --  10.244.0.0/16        10.244.0.0/24        /* flanneld masq */</span><br><span class="line">RETURN     all  -- !10.244.0.0/16        10.244.0.0/24        /* flanneld masq */</span><br><span class="line">MASQUERADE  all  --  10.244.0.0/16       !224.0.0.0/4          /* flanneld masq */ random-fully</span><br><span class="line">MASQUERADE  all  -- !10.244.0.0/16        10.244.0.0/16        /* flanneld masq */ random-fully</span><br><span class="line"></span><br><span class="line">Chain KUBE-EXT-W7DCC3F5ZN5NE3KW (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  all  --  0.0.0.0/0            0.0.0.0/0            /* masquerade traffic for default/my-curl:http external destinations */</span><br><span class="line">KUBE-SVC-W7DCC3F5ZN5NE3KW  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain KUBE-KUBELET-CANARY (0 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain KUBE-MARK-DROP (0 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">MARK       all  --  0.0.0.0/0            0.0.0.0/0            MARK or 0x8000</span><br><span class="line"></span><br><span class="line">Chain KUBE-MARK-MASQ (14 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">MARK       all  --  0.0.0.0/0            0.0.0.0/0            MARK or 0x4000</span><br><span class="line"></span><br><span class="line">Chain KUBE-NODEPORTS (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-EXT-W7DCC3F5ZN5NE3KW  tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/my-curl:http */ tcp dpt:31122</span><br><span class="line"></span><br><span class="line">Chain KUBE-POSTROUTING (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">RETURN     all  --  0.0.0.0/0            0.0.0.0/0            mark match ! 0x4000/0x4000</span><br><span class="line">MARK       all  --  0.0.0.0/0            0.0.0.0/0            MARK xor 0x4000</span><br><span class="line">MASQUERADE  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service traffic requiring SNAT */ random-fully</span><br><span class="line"></span><br><span class="line">Chain KUBE-PROXY-CANARY (0 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-2KOR5GS2OWGIGVHG (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  all  --  10.244.0.220         0.0.0.0/0            /* kube-system/kube-dns:dns-tcp */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:dns-tcp */ tcp to:10.244.0.220:53</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-E5ZPFNRTFC3O2YGB (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  all  --  192.168.2.123        0.0.0.0/0            /* default/kubernetes:https */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/kubernetes:https */ tcp to:192.168.2.123:6443</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-ELL5SOECSE25BPHX (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  all  --  10.244.0.220         0.0.0.0/0            /* kube-system/kube-dns:dns */</span><br><span class="line">DNAT       udp  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:dns */ udp to:10.244.0.220:53</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-G3W5CCH2EXTJTWNT (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  all  --  10.244.0.219         0.0.0.0/0            /* kube-system/kube-dns:metrics */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:metrics */ tcp to:10.244.0.219:9153</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-G5TPU3TRPGLSSBUB (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  all  --  10.244.0.220         0.0.0.0/0            /* kube-system/kube-dns:metrics */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:metrics */ tcp to:10.244.0.220:9153</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-IJMQAJ4HGPA7P6ZX (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  all  --  10.244.0.219         0.0.0.0/0            /* kube-system/kube-dns:dns */</span><br><span class="line">DNAT       udp  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:dns */ udp to:10.244.0.219:53</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-SZ5GI3C7S6AQLVNR (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  all  --  10.244.0.221         0.0.0.0/0            /* default/my-curl:http */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/my-curl:http */ tcp to:10.244.0.221:8080</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-ZXBKTOI5KHHUPKIG (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  all  --  10.244.0.219         0.0.0.0/0            /* kube-system/kube-dns:dns-tcp */</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:dns-tcp */ tcp to:10.244.0.219:53</span><br><span class="line"></span><br><span class="line">Chain KUBE-SERVICES (2 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-SVC-JD5MR3NA4I4DYORP  tcp  --  0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:metrics cluster IP */ tcp dpt:9153</span><br><span class="line">KUBE-SVC-W7DCC3F5ZN5NE3KW  tcp  --  0.0.0.0/0            10.98.75.173         /* default/my-curl:http cluster IP */ tcp dpt:8080</span><br><span class="line">KUBE-SVC-NPX46M4PTMTKRN6Y  tcp  --  0.0.0.0/0            10.96.0.1            /* default/kubernetes:https cluster IP */ tcp dpt:443</span><br><span class="line">KUBE-SVC-TCOU7JCQXEZGVUNU  udp  --  0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns cluster IP */ udp dpt:53</span><br><span class="line">KUBE-SVC-ERIFXISQEP7F7OF4  tcp  --  0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns-tcp cluster IP */ tcp dpt:53</span><br><span class="line">KUBE-NODEPORTS  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service nodeports; NOTE: this must be the last rule in this chain */ ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain KUBE-SVC-ERIFXISQEP7F7OF4 (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  tcp  -- !10.244.0.0/16        10.96.0.10           /* kube-system/kube-dns:dns-tcp cluster IP */ tcp dpt:53</span><br><span class="line">KUBE-SEP-ZXBKTOI5KHHUPKIG  all  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:dns-tcp -&gt; 10.244.0.219:53 */ statistic mode random probability 0.50000000000</span><br><span class="line">KUBE-SEP-2KOR5GS2OWGIGVHG  all  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:dns-tcp -&gt; 10.244.0.220:53 */</span><br><span class="line"></span><br><span class="line">Chain KUBE-SVC-JD5MR3NA4I4DYORP (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  tcp  -- !10.244.0.0/16        10.96.0.10           /* kube-system/kube-dns:metrics cluster IP */ tcp dpt:9153</span><br><span class="line">KUBE-SEP-G3W5CCH2EXTJTWNT  all  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:metrics -&gt; 10.244.0.219:9153 */ statistic mode random probability 0.50000000000</span><br><span class="line">KUBE-SEP-G5TPU3TRPGLSSBUB  all  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:metrics -&gt; 10.244.0.220:9153 */</span><br><span class="line"></span><br><span class="line">Chain KUBE-SVC-NPX46M4PTMTKRN6Y (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  tcp  -- !10.244.0.0/16        10.96.0.1            /* default/kubernetes:https cluster IP */ tcp dpt:443</span><br><span class="line">KUBE-SEP-E5ZPFNRTFC3O2YGB  all  --  0.0.0.0/0            0.0.0.0/0            /* default/kubernetes:https -&gt; 192.168.2.123:6443 */</span><br><span class="line"></span><br><span class="line">Chain KUBE-SVC-TCOU7JCQXEZGVUNU (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  udp  -- !10.244.0.0/16        10.96.0.10           /* kube-system/kube-dns:dns cluster IP */ udp dpt:53</span><br><span class="line">KUBE-SEP-IJMQAJ4HGPA7P6ZX  all  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:dns -&gt; 10.244.0.219:53 */ statistic mode random probability 0.50000000000</span><br><span class="line">KUBE-SEP-ELL5SOECSE25BPHX  all  --  0.0.0.0/0            0.0.0.0/0            /* kube-system/kube-dns:dns -&gt; 10.244.0.220:53 */</span><br><span class="line"></span><br><span class="line">Chain KUBE-SVC-W7DCC3F5ZN5NE3KW (2 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  tcp  -- !10.244.0.0/16        10.98.75.173         /* default/my-curl:http cluster IP */ tcp dpt:8080</span><br><span class="line">KUBE-SEP-SZ5GI3C7S6AQLVNR  all  --  0.0.0.0/0            0.0.0.0/0            /* default/my-curl:http -&gt; 10.244.0.221:8080 */</span><br></pre></td></tr></table></figure>
<p>在<code>Chain PREROUTING</code>中的规则执行顺序如下：<br><code>KUBE-SERVICES</code>我们只关注我们创建的<code>Service</code>这条链<code>KUBE-SVC-W7DCC3F5ZN5NE3KW</code></p>
<p><code>KUBE-SERVICES</code> —&gt; <code>KUBE-SERVICES</code> —&gt; <code>KUBE-SVC-W7DCC3F5ZN5NE3KW</code> —&gt; <code>KUBE-MARK-MASQ</code> —&gt; <code>KUBE-SEP-SZ5GI3C7S6AQLVNR</code><br>—&gt; <code>KUBE-MARK-MASQ</code> —&gt; <code>DNAT</code> —&gt; <code>KUBE-NODEPORTS</code> —&gt; <code>KUBE-EXT-W7DCC3F5ZN5NE3KW</code> —&gt; <code>KUBE-MARK-MASQ</code> —&gt;<br><code>KUBE-SVC-W7DCC3F5ZN5NE3KW</code> —&gt; <code>KUBE-MARK-MASQ</code> —&gt; <code>KUBE-SEP-SZ5GI3C7S6AQLVNR</code><br>—&gt; <code>KUBE-MARK-MASQ</code> —&gt; <code>DNAT</code>(10.244.0.221:8080)<br>最终会把请求转发到<code>pod</code>内。</p>
<p>在链<code>KUBE-SERVICES</code>下每一个<code>Service</code>都会有一条自定义链，在一次请求过程中需要一个一个遍历执行，如果<code>Service</code>过多则有很大的性能消耗。</p>
<hr>
<p>这些<code>iptables</code>规则是怎么生成的呢？</p>
<p><code>kube-proxy</code>会监听以下资源：</p>
<p><code>Endpoints</code>：<code>kube-proxy</code>会监听<code>Service</code>和<code>Endpoints</code>之间的变化。当<code>Service</code>的<code>Endpoint</code>发生变化时，<code>kube-proxy</code>会更新相应的<code>iptables</code>规则或<code>IPVS</code>规则，以确保流量正确地路由到新的<code>Endpoints</code>。</p>
<p><code>Service</code>：<code>kube-proxy</code>会监听<code>Service</code>的创建、更新和删除。当<code>Service</code>发生变化时，<code>kube-proxy</code>会相应地更新相应的<code>iptables</code>规则或<code>IPVS</code>规则。</p>
<p><code>Node</code>：<code>kube-proxy</code>会监听<code>Node</code>的变化，例如节点的加入或离开集群。当节点发生变化时，<code>kube-proxy</code>会相应地更新<code>iptables</code>规则或<code>IPVS</code>规则，以确保流量正确地路由到可用的节点。</p>
<p>通过监听这些资源的变化，<code>kube-proxy</code>能够动态地更新网络规则，以确保流量能够正确地路由到集群中的<code>Pod</code></p>
<p>下篇文章我们将讲下<code>kube-proxy</code>的具体实现。</p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s之rbac</title>
    <url>/2023/05/23/k8s%E4%B9%8Brbac/</url>
    <content><![CDATA[<p>Kubernetes中的RBAC（Role-Based Access Control）是一种授权机制，用于管理和控制对Kubernetes资源的访问权限。RBAC允许管理员定义角色、角色绑定和集群角色绑定来精确控制用户、服务账号或组的权限。</p>
<p>RBAC的核心概念包括以下几个要素：</p>
<p>Role（角色）：定义了一组权限，可以授予给特定的命名空间内的用户或服务账号。Role是命名空间级别的授权对象，它只对指定命名空间内的资源起作用。</p>
<p>ClusterRole（集群角色）：类似于Role，但作用于整个集群范围内的资源。ClusterRole可以跨越多个命名空间。</p>
<p>RoleBinding（角色绑定）：将一个Role绑定到用户、组或服务账号上，以赋予其相应的权限。RoleBinding是命名空间级别的绑定，它将角色授权应用于指定命名空间的主体。</p>
<p>ClusterRoleBinding（集群角色绑定）：类似于RoleBinding，但作用于整个集群范围内的资源。</p>
<p>通过RBAC，管理员可以创建和管理角色和绑定，将权限分配给用户或服务账号，从而实现对Kubernetes资源的细粒度访问控制。RBAC提供了灵活的权限管理机制，可以根据需要授予或限制特定操作的执行，以保护集群的安全性和数据的机密性。</p>
<p>RBAC的具体实现是通过Kubernetes API服务器的授权模块实现的，它会验证用户的身份，并根据相应的角色和绑定信息来授予或拒绝对资源的请求。</p>
<p>RBAC在Kubernetes中是一项重要的安全功能，能够帮助管理员有效管理和控制对集群资源的访问权限，并确保只有经过授权的实体能够执行相应的操作。</p>
<hr>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/apis/rbac/types.go</span></span><br><span class="line"><span class="comment">// 包括角色、绑定和策略等相关结构体和接口定义</span></span><br><span class="line"><span class="comment">//  PolicyRule存储了描述策略规则的信息</span></span><br><span class="line"><span class="keyword">type</span> PolicyRule <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 存储支持的Verbs,如"GET","CREATE"..., "*"表示全部支持</span></span><br><span class="line">	Verbs []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// APIGroups是包含资源的APIGroup的名称。</span></span><br><span class="line">    <span class="comment">// ""表示核心API组，"*"表示所有API组。</span></span><br><span class="line">	APIGroups []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则作用的资源对象，"*"表示指定apiGroups下的所有资源，"*/foo"表示指定apiGroups下所有子资源"foo"</span></span><br><span class="line">	Resources []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ResourceNames是规则适用于的可选名称白名单。空集表示允许所有内容。</span></span><br><span class="line">	ResourceNames []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path</span></span><br><span class="line">	<span class="comment">// If an action is not a resource API request, then the URL is split on '/' and is checked against the NonResourceURLs to look for a match.</span></span><br><span class="line">	<span class="comment">// Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.</span></span><br><span class="line">	<span class="comment">// Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.</span></span><br><span class="line">	NonResourceURLs []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subject包含对角色绑定适用于的对象或用户标识的引用。它可以包含直接的API对象引用，也可以包含非对象（如用户和组名）的值</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 此API组定义的值有"User"、"Group"和"ServiceAccount"。如果授权器不识别该类型值，则应报错</span></span><br><span class="line">	Kind <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 引用对象所属的APIGroup</span></span><br><span class="line">    <span class="comment">// ""表示ServiceAccount subjects</span></span><br><span class="line">    <span class="comment">// "rbac.authorization.k8s.io" for User and Group subjects</span></span><br><span class="line">	APIGroup <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 引用对象名称</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 引用对象所属的命名空间</span></span><br><span class="line">    <span class="comment">// 如果对象类型是非命名空间类型（如"User"或"Group"），并且此值不为空，则授权器应报错</span></span><br><span class="line">	Namespace <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向正在使用的角色</span></span><br><span class="line"><span class="keyword">type</span> RoleRef <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// APIGroup is the group for the resource being referenced</span></span><br><span class="line">	APIGroup <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Kind is the type of resource being referenced</span></span><br><span class="line">	Kind <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Name is the name of resource being referenced</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 角色</span></span><br><span class="line"><span class="keyword">type</span> Role <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta</span><br><span class="line">	<span class="comment">// Standard object's metadata.</span></span><br><span class="line">	metav1.ObjectMeta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Rules holds all the PolicyRules for this Role</span></span><br><span class="line">	Rules []PolicyRule</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RoleBinding引用一个角色，但不包含角色本身。它可以绑定同一命名空间中的*Role*或ClusterRole</span></span><br><span class="line"><span class="comment">// 它通过Subjects添加了关于用户的信息，并通过所在的命名空间添加了命名空间信息。在给定的命名空间中的RoleBinding只在该命名空间中生效。</span></span><br><span class="line"><span class="keyword">type</span> RoleBinding <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta</span><br><span class="line">	metav1.ObjectMeta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Subjects holds references to the objects the role applies to.</span></span><br><span class="line">	Subjects []Subject</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RoleRef can reference a Role in the current namespace or a ClusterRole in the global namespace.</span></span><br><span class="line">	<span class="comment">// If the RoleRef cannot be resolved, the Authorizer must return an error.</span></span><br><span class="line">	<span class="comment">// This field is immutable.</span></span><br><span class="line">	RoleRef RoleRef</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RoleBinding列表</span></span><br><span class="line"><span class="keyword">type</span> RoleBindingList <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta</span><br><span class="line">	<span class="comment">// Standard object's metadata.</span></span><br><span class="line">	metav1.ListMeta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Items is a list of roleBindings</span></span><br><span class="line">	Items []RoleBinding</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RoleList <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta</span><br><span class="line">	<span class="comment">// Standard object's metadata.</span></span><br><span class="line">	metav1.ListMeta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Items is a list of roles</span></span><br><span class="line">	Items []Role</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.</span></span><br><span class="line"><span class="keyword">type</span> ClusterRole <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta</span><br><span class="line">	<span class="comment">// Standard object's metadata.</span></span><br><span class="line">	metav1.ObjectMeta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Rules holds all the PolicyRules for this ClusterRole</span></span><br><span class="line">	Rules []PolicyRule</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AggregationRule is an optional field that describes how to build the Rules for this ClusterRole.</span></span><br><span class="line">	<span class="comment">// If AggregationRule is set, then the Rules are controller managed and direct changes to Rules will be</span></span><br><span class="line">	<span class="comment">// stomped by the controller.</span></span><br><span class="line">	AggregationRule *AggregationRule</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole</span></span><br><span class="line"><span class="keyword">type</span> AggregationRule <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and create the rules.</span></span><br><span class="line">	<span class="comment">// If any of the selectors match, then the ClusterRole's permissions will be added</span></span><br><span class="line">	ClusterRoleSelectors []metav1.LabelSelector</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace,</span></span><br><span class="line"><span class="comment">// and adds who information via Subject.</span></span><br><span class="line"><span class="keyword">type</span> ClusterRoleBinding <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta</span><br><span class="line">	<span class="comment">// Standard object's metadata.</span></span><br><span class="line">	metav1.ObjectMeta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Subjects holds references to the objects the role applies to.</span></span><br><span class="line">	Subjects []Subject</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RoleRef can only reference a ClusterRole in the global namespace.</span></span><br><span class="line">	<span class="comment">// If the RoleRef cannot be resolved, the Authorizer must return an error.</span></span><br><span class="line">	<span class="comment">// This field is immutable.</span></span><br><span class="line">	RoleRef RoleRef</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ClusterRoleBindingList is a collection of ClusterRoleBindings</span></span><br><span class="line"><span class="keyword">type</span> ClusterRoleBindingList <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta</span><br><span class="line">	<span class="comment">// Standard object's metadata.</span></span><br><span class="line">	metav1.ListMeta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Items is a list of ClusterRoleBindings</span></span><br><span class="line">	Items []ClusterRoleBinding</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ClusterRoleList is a collection of ClusterRoles</span></span><br><span class="line"><span class="keyword">type</span> ClusterRoleList <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta</span><br><span class="line">	<span class="comment">// Standard object's metadata.</span></span><br><span class="line">	metav1.ListMeta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Items is a list of ClusterRoles</span></span><br><span class="line">	Items []ClusterRole</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/server/config.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultBuildHandlerChain</span><span class="params">(apiHandler http.Handler, c *Config)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	handler := filterlatency.TrackCompleted(apiHandler)</span><br><span class="line">	handler = genericapifilters.WithAuthorization(handler, c.Authorization.Authorizer, c.Serializer)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">New</span><span class="params">(name <span class="keyword">string</span>, delegationTarget DelegationTarget)</span> <span class="params">(*GenericAPIServer, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	handlerChainBuilder := <span class="function"><span class="keyword">func</span><span class="params">(handler http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.BuildHandlerChainFunc(handler, c.Config)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> debugSocket *routes.DebugSocket</span><br><span class="line">	<span class="keyword">if</span> c.DebugSocketPath != <span class="string">""</span> &#123;</span><br><span class="line">		debugSocket = routes.NewDebugSocket(c.DebugSocketPath)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	apiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>在一次请求过程中会执行<code>withAuthorization</code></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withAuthorization</span><span class="params">(handler http.Handler, a authorizer.Authorizer, s runtime.NegotiatedSerializer, metrics recordAuthorizationMetricsFunc)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Warning(<span class="string">"Authorization is disabled"</span>)</span><br><span class="line">		<span class="keyword">return</span> handler</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		ctx := req.Context()</span><br><span class="line">		authorizationStart := time.Now()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 提取鉴权所需的信息</span></span><br><span class="line">		attributes, err := GetAuthorizerAttributes(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			responsewriters.InternalError(w, req, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		authorized, reason, err := a.Authorize(ctx, attributes)</span><br><span class="line"></span><br><span class="line">		authorizationFinish := time.Now()</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			metrics(ctx, authorized, err, authorizationStart, authorizationFinish)</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// an authorizer like RBAC could encounter evaluation errors and still allow the request, so authorizer decision is checked before error here.</span></span><br><span class="line">		<span class="keyword">if</span> authorized == authorizer.DecisionAllow &#123;</span><br><span class="line">			audit.AddAuditAnnotations(ctx,</span><br><span class="line">				decisionAnnotationKey, decisionAllow,</span><br><span class="line">				reasonAnnotationKey, reason)</span><br><span class="line">			handler.ServeHTTP(w, req)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			audit.AddAuditAnnotation(ctx, reasonAnnotationKey, reasonError)</span><br><span class="line">			responsewriters.InternalError(w, req, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">"Forbidden"</span>, <span class="string">"URI"</span>, req.RequestURI, <span class="string">"reason"</span>, reason)</span><br><span class="line">		audit.AddAuditAnnotations(ctx,</span><br><span class="line">			decisionAnnotationKey, decisionForbid,</span><br><span class="line">			reasonAnnotationKey, reason)</span><br><span class="line">		responsewriters.Forbidden(ctx, attributes, w, req, reason, s)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/authorization/union/union.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(authzHandler unionAuthzHandler)</span> <span class="title">Authorize</span><span class="params">(ctx context.Context, a authorizer.Attributes)</span> <span class="params">(authorizer.Decision, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		errlist    []error</span><br><span class="line">		reasonlist []<span class="keyword">string</span></span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// authzHandler 包括authorizerfactory.privilegedGroupAuthorizer</span></span><br><span class="line">	<span class="comment">// node.NodeAuthorizer, rbac.RBACAuthorizer</span></span><br><span class="line">	<span class="comment">// 只要任何一个handler返回Allow或者Deny，函数直接返回</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> _, currAuthzHandler := <span class="keyword">range</span> authzHandler &#123;</span><br><span class="line">		decision, reason, err := currAuthzHandler.Authorize(ctx, a)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errlist = <span class="built_in">append</span>(errlist, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(reason) != <span class="number">0</span> &#123;</span><br><span class="line">			reasonlist = <span class="built_in">append</span>(reasonlist, reason)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> decision &#123;</span><br><span class="line">		<span class="keyword">case</span> authorizer.DecisionAllow, authorizer.DecisionDeny:</span><br><span class="line">			<span class="keyword">return</span> decision, reason, err</span><br><span class="line">		<span class="keyword">case</span> authorizer.DecisionNoOpinion:</span><br><span class="line">			<span class="comment">// continue to the next authorizer</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> authorizer.DecisionNoOpinion, strings.Join(reasonlist, <span class="string">"\n"</span>), utilerrors.NewAggregate(errlist)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plugin/pkg/auth/authorizer/rbac/rbac.go</span></span><br><span class="line"><span class="comment">// 如果是RBAC会执行下面的代码进行鉴权</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RBACAuthorizer)</span> <span class="title">Authorize</span><span class="params">(ctx context.Context, requestAttributes authorizer.Attributes)</span> <span class="params">(authorizer.Decision, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	ruleCheckingVisitor := &amp;authorizingVisitor&#123;requestAttributes: requestAttributes&#125;</span><br><span class="line"></span><br><span class="line">	r.authorizationRuleResolver.VisitRulesFor(requestAttributes.GetUser(), requestAttributes.GetNamespace(), ruleCheckingVisitor.visit)</span><br><span class="line">	<span class="keyword">if</span> ruleCheckingVisitor.allowed &#123;</span><br><span class="line">		<span class="keyword">return</span> authorizer.DecisionAllow, ruleCheckingVisitor.reason, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build a detailed log of the denial.</span></span><br><span class="line">	<span class="comment">// Make the whole block conditional so we don't do a lot of string-building we won't use.</span></span><br><span class="line">	<span class="keyword">if</span> klogV := klog.V(<span class="number">5</span>); klogV.Enabled() &#123;</span><br><span class="line">		<span class="keyword">var</span> operation <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">if</span> requestAttributes.IsResourceRequest() &#123;</span><br><span class="line">			b := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">			b.WriteString(<span class="string">`"`</span>)</span><br><span class="line">			b.WriteString(requestAttributes.GetVerb())</span><br><span class="line">			b.WriteString(<span class="string">`" resource "`</span>)</span><br><span class="line">			b.WriteString(requestAttributes.GetResource())</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(requestAttributes.GetAPIGroup()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				b.WriteString(<span class="string">`.`</span>)</span><br><span class="line">				b.WriteString(requestAttributes.GetAPIGroup())</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(requestAttributes.GetSubresource()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				b.WriteString(<span class="string">`/`</span>)</span><br><span class="line">				b.WriteString(requestAttributes.GetSubresource())</span><br><span class="line">			&#125;</span><br><span class="line">			b.WriteString(<span class="string">`"`</span>)</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(requestAttributes.GetName()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				b.WriteString(<span class="string">` named "`</span>)</span><br><span class="line">				b.WriteString(requestAttributes.GetName())</span><br><span class="line">				b.WriteString(<span class="string">`"`</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			operation = b.String()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			operation = fmt.Sprintf(<span class="string">"%q nonResourceURL %q"</span>, requestAttributes.GetVerb(), requestAttributes.GetPath())</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> scope <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">if</span> ns := requestAttributes.GetNamespace(); <span class="built_in">len</span>(ns) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			scope = fmt.Sprintf(<span class="string">"in namespace %q"</span>, ns)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			scope = <span class="string">"cluster-wide"</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		klogV.Infof(<span class="string">"RBAC: no rules authorize user %q with groups %q to %s %s"</span>, requestAttributes.GetUser().GetName(), requestAttributes.GetUser().GetGroups(), operation, scope)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reason := <span class="string">""</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ruleCheckingVisitor.errors) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		reason = fmt.Sprintf(<span class="string">"RBAC: %v"</span>, utilerrors.NewAggregate(ruleCheckingVisitor.errors))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> authorizer.DecisionNoOpinion, reason, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/registry/rbac/validation/rule.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *DefaultRuleResolver)</span> <span class="title">VisitRulesFor</span><span class="params">(user user.Info, namespace <span class="keyword">string</span>, visitor <span class="keyword">func</span>(source fmt.Stringer, rule *rbacv1.PolicyRule, err error)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> clusterRoleBindings, err := r.clusterRoleBindingLister.ListClusterRoleBindings(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !visitor(<span class="literal">nil</span>, <span class="literal">nil</span>, err) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sourceDescriber := &amp;clusterRoleBindingDescriber&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> _, clusterRoleBinding := <span class="keyword">range</span> clusterRoleBindings &#123;</span><br><span class="line">			subjectIndex, applies := appliesTo(user, clusterRoleBinding.Subjects, <span class="string">""</span>)</span><br><span class="line">			<span class="keyword">if</span> !applies &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 获取角色对应的PolicyRule</span></span><br><span class="line">			rules, err := r.GetRoleReferenceRules(clusterRoleBinding.RoleRef, <span class="string">""</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> !visitor(<span class="literal">nil</span>, <span class="literal">nil</span>, err) &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;GetSubresource</span><br><span class="line">			sourceDescriber.binding = clusterRoleBinding</span><br><span class="line">			sourceDescriber.subject = &amp;clusterRoleBinding.Subjects[subjectIndex]</span><br><span class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> rules &#123;</span><br><span class="line">				<span class="keyword">if</span> !visitor(sourceDescriber, &amp;rules[i], <span class="literal">nil</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(namespace) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> roleBindings, err := r.roleBindingLister.ListRoleBindings(namespace); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> !visitor(<span class="literal">nil</span>, <span class="literal">nil</span>, err) &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sourceDescriber := &amp;roleBindingDescriber&#123;&#125;</span><br><span class="line">			<span class="keyword">for</span> _, roleBinding := <span class="keyword">range</span> roleBindings &#123;</span><br><span class="line">				subjectIndex, applies := appliesTo(user, roleBinding.Subjects, namespace)</span><br><span class="line">				<span class="keyword">if</span> !applies &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				rules, err := r.GetRoleReferenceRules(roleBinding.RoleRef, namespace)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> !visitor(<span class="literal">nil</span>, <span class="literal">nil</span>, err) &#123;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				sourceDescriber.binding = roleBinding</span><br><span class="line">				sourceDescriber.subject = &amp;roleBinding.Subjects[subjectIndex]</span><br><span class="line">				<span class="keyword">for</span> i := <span class="keyword">range</span> rules &#123;</span><br><span class="line">					<span class="keyword">if</span> !visitor(sourceDescriber, &amp;rules[i], <span class="literal">nil</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果通过则修改v.allowed=true,v.reason.并返回false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *authorizingVisitor)</span> <span class="title">visit</span><span class="params">(source fmt.Stringer, rule *rbacv1.PolicyRule, err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// RuleAllows进行规则匹配</span></span><br><span class="line">	<span class="keyword">if</span> rule != <span class="literal">nil</span> &amp;&amp; RuleAllows(v.requestAttributes, rule) &#123;</span><br><span class="line">		v.allowed = <span class="literal">true</span></span><br><span class="line">		v.reason = fmt.Sprintf(<span class="string">"RBAC: allowed by %s"</span>, source.String())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		v.errors = <span class="built_in">append</span>(v.errors, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/apis/rbac/types.go" target="_blank" rel="noopener">pkg/apis/rbac/types.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/staging/src/k8s.io/apiserver/pkg/server/config.go" target="_blank" rel="noopener">staging/src/k8s.io/apiserver/pkg/server/config.go</a><br>3.<a href="staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go">staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/staging/src/k8s.io/apiserver/pkg/authorization/union/union.go" target="_blank" rel="noopener">staging/src/k8s.io/apiserver/pkg/authorization/union/union.go</a><br>5.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/plugin/pkg/auth/authorizer/rbac/rbac.go" target="_blank" rel="noopener">plugin/pkg/auth/authorizer/rbac/rbac.go</a><br>6.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/registry/rbac/validation/rule.go" target="_blank" rel="noopener">pkg/registry/rbac/validation/rule.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s之kube-proxy[下]</title>
    <url>/2023/05/23/k8s%E4%B9%8Bkube-proxy-%E4%B8%8B/</url>
    <content><![CDATA[<p><a href="https://hysyeah.top/2023/05/20/k8s%E4%B9%8Bkube-proxy/" target="_blank" rel="noopener">k8s之kube-proxy[上]</a></p>
<p><code>kube-proxy</code>是<code>Kubernetes</code>集群中的一个核心组件，负责实现服务的负载均衡和网络代理功能。</p>
<p><code>kube-proxy</code>的源码分析可以涉及多个文件和功能模块，以下是一些主要文件和功能模块的概述：</p>
<p><code>cmd/kube-proxy/app</code>：该包包含了<code>kube-proxy</code>的入口点代码，负责解析命令行参数、初始化配置和启动<code>kube-proxy</code>的主循环</p>
<p><code>pkg/proxy</code>：该目录包含了<code>kube-proxy</code>的核心功能代码</p>
<p><code>pkg/proxy/ipvs</code>：该目录包含了使用IPVS（IP Virtual Server）实现负载均衡的相关代码</p>
<p><code>pkg/proxy/iptables</code>：该目录包含了使用iptables实现负载均衡的相关代码</p>
<p><code>pkg/proxy/util</code>：该目录包含了一些辅助函数和工具类，用于支持<code>kube-proxy</code>的实现</p>
<hr>
<p><code>kube-proxy</code>入口<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/kube-proxy/proxy.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	command := app.NewProxyCommand()</span><br><span class="line">	code := cli.Run(command)</span><br><span class="line">	os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/kube-proxy/app/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Options)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(o.errCh)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(o.WriteConfigTo) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> o.writeConfigFile()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> o.CleanupAndExit &#123;</span><br><span class="line">		<span class="keyword">return</span> cleanupAndExit()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proxyServer, err := NewProxyServer(o)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	o.proxyServer = proxyServer</span><br><span class="line">	<span class="keyword">return</span> o.runLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/kube-proxy/app/server_others.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxyServer</span><span class="params">(o *Options)</span> <span class="params">(*ProxyServer, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> newProxyServer(o.config, o.master)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newProxyServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	config *proxyconfigapi.KubeProxyConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params">	master <span class="keyword">string</span>)</span> <span class="params">(*ProxyServer, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c, err := configz.New(proxyconfigapi.GroupName); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Set(config)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to register configz: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ipvsInterface utilipvs.Interface</span><br><span class="line">	<span class="keyword">var</span> ipsetInterface utilipset.Interface</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(config.ShowHiddenMetricsForVersion) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		metrics.SetShowHidden()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hostname, err := nodeutil.GetHostname(config.HostnameOverride)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	client, err := createClient(config.ClientConnection, master)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nodeIP := detectNodeIP(client, hostname, config.BindAddress)</span><br><span class="line">	klog.InfoS(<span class="string">"Detected node IP"</span>, <span class="string">"address"</span>, nodeIP.String())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create event recorder</span></span><br><span class="line">	eventBroadcaster := events.NewBroadcaster(&amp;events.EventSinkImpl&#123;Interface: client.EventsV1()&#125;)</span><br><span class="line">	recorder := eventBroadcaster.NewRecorder(scheme.Scheme, <span class="string">"kube-proxy"</span>)</span><br><span class="line"></span><br><span class="line">	nodeRef := &amp;v1.ObjectReference&#123;</span><br><span class="line">		Kind:      <span class="string">"Node"</span>,</span><br><span class="line">		Name:      hostname,</span><br><span class="line">		UID:       types.UID(hostname),</span><br><span class="line">		Namespace: <span class="string">""</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> healthzServer healthcheck.ProxierHealthUpdater</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(config.HealthzBindAddress) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		healthzServer = healthcheck.NewProxierHealthServer(config.HealthzBindAddress, <span class="number">2</span>*config.IPTables.SyncPeriod.Duration, recorder, nodeRef)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> proxier proxy.Provider</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> nodeInfo *v1.Node</span><br><span class="line">	<span class="keyword">if</span> config.DetectLocalMode == proxyconfigapi.LocalModeNodeCIDR &#123;</span><br><span class="line">		klog.InfoS(<span class="string">"Watching for node, awaiting podCIDR allocation"</span>, <span class="string">"hostname"</span>, hostname)</span><br><span class="line">		nodeInfo, err = waitForPodCIDR(client, hostname)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		klog.InfoS(<span class="string">"NodeInfo"</span>, <span class="string">"podCIDR"</span>, nodeInfo.Spec.PodCIDR, <span class="string">"podCIDRs"</span>, nodeInfo.Spec.PodCIDRs)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	primaryFamily := v1.IPv4Protocol</span><br><span class="line">	primaryProtocol := utiliptables.ProtocolIPv4</span><br><span class="line">	<span class="keyword">if</span> netutils.IsIPv6(nodeIP) &#123;</span><br><span class="line">		primaryFamily = v1.IPv6Protocol</span><br><span class="line">		primaryProtocol = utiliptables.ProtocolIPv6</span><br><span class="line">	&#125;</span><br><span class="line">	execer := exec.New()</span><br><span class="line">	iptInterface := utiliptables.New(execer, primaryProtocol)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ipt [<span class="number">2</span>]utiliptables.Interface</span><br><span class="line">	dualStack := <span class="literal">true</span> <span class="comment">// While we assume that node supports, we do further checks below</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create iptables handlers for both families, one is already created</span></span><br><span class="line">	<span class="comment">// Always ordered as IPv4, IPv6</span></span><br><span class="line">	<span class="keyword">if</span> primaryProtocol == utiliptables.ProtocolIPv4 &#123;</span><br><span class="line">		ipt[<span class="number">0</span>] = iptInterface</span><br><span class="line">		ipt[<span class="number">1</span>] = utiliptables.New(execer, utiliptables.ProtocolIPv6)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ipt[<span class="number">0</span>] = utiliptables.New(execer, utiliptables.ProtocolIPv4)</span><br><span class="line">		ipt[<span class="number">1</span>] = iptInterface</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nodePortAddresses := config.NodePortAddresses</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !ipt[<span class="number">0</span>].Present() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"iptables is not supported for primary IP family %q"</span>, primaryProtocol)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !ipt[<span class="number">1</span>].Present() &#123;</span><br><span class="line">		klog.InfoS(<span class="string">"kube-proxy running in single-stack mode: secondary ipFamily is not supported"</span>, <span class="string">"ipFamily"</span>, ipt[<span class="number">1</span>].Protocol())</span><br><span class="line">		dualStack = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Validate NodePortAddresses is single-stack</span></span><br><span class="line">		npaByFamily := proxyutil.MapCIDRsByIPFamily(config.NodePortAddresses)</span><br><span class="line">		secondaryFamily := proxyutil.OtherIPFamily(primaryFamily)</span><br><span class="line">		badAddrs := npaByFamily[secondaryFamily]</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(badAddrs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			klog.InfoS(<span class="string">"Ignoring --nodeport-addresses of the wrong family"</span>, <span class="string">"ipFamily"</span>, secondaryFamily, <span class="string">"addresses"</span>, badAddrs)</span><br><span class="line">			nodePortAddresses = npaByFamily[primaryFamily]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 根据不同的模式设置不同的proxier</span></span><br><span class="line">    <span class="comment">// 现在支持两种模式iptables,ipvs</span></span><br><span class="line">	<span class="keyword">if</span> config.Mode == proxyconfigapi.ProxyModeIPTables &#123;</span><br><span class="line">		klog.InfoS(<span class="string">"Using iptables Proxier"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> dualStack &#123;</span><br><span class="line">			klog.InfoS(<span class="string">"kube-proxy running in dual-stack mode"</span>, <span class="string">"ipFamily"</span>, iptInterface.Protocol())</span><br><span class="line">			klog.InfoS(<span class="string">"Creating dualStackProxier for iptables"</span>)</span><br><span class="line">			<span class="comment">// Always ordered to match []ipt</span></span><br><span class="line">			<span class="keyword">var</span> localDetectors [<span class="number">2</span>]proxyutiliptables.LocalTrafficDetector</span><br><span class="line">			localDetectors, err = getDualStackLocalDetectorTuple(config.DetectLocalMode, config, ipt, nodeInfo)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create proxier: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// TODO this has side effects that should only happen when Run() is invoked.</span></span><br><span class="line">			proxier, err = iptables.NewDualStackProxier(</span><br><span class="line">				ipt,</span><br><span class="line">				utilsysctl.New(),</span><br><span class="line">				execer,</span><br><span class="line">				config.IPTables.SyncPeriod.Duration,</span><br><span class="line">				config.IPTables.MinSyncPeriod.Duration,</span><br><span class="line">				config.IPTables.MasqueradeAll,</span><br><span class="line">				*config.IPTables.LocalhostNodePorts,</span><br><span class="line">				<span class="keyword">int</span>(*config.IPTables.MasqueradeBit),</span><br><span class="line">				localDetectors,</span><br><span class="line">				hostname,</span><br><span class="line">				nodeIPTuple(config.BindAddress),</span><br><span class="line">				recorder,</span><br><span class="line">				healthzServer,</span><br><span class="line">				nodePortAddresses,</span><br><span class="line">			)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Create a single-stack proxier if and only if the node does not support dual-stack (i.e, no iptables support).</span></span><br><span class="line">			<span class="keyword">var</span> localDetector proxyutiliptables.LocalTrafficDetector</span><br><span class="line">			localDetector, err = getLocalDetector(config.DetectLocalMode, config, iptInterface, nodeInfo)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create proxier: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// TODO this has side effects that should only happen when Run() is invoked.</span></span><br><span class="line">			proxier, err = iptables.NewProxier(</span><br><span class="line">				primaryFamily,</span><br><span class="line">				iptInterface,</span><br><span class="line">				utilsysctl.New(),</span><br><span class="line">				execer,</span><br><span class="line">				config.IPTables.SyncPeriod.Duration,</span><br><span class="line">				config.IPTables.MinSyncPeriod.Duration,</span><br><span class="line">				config.IPTables.MasqueradeAll,</span><br><span class="line">				*config.IPTables.LocalhostNodePorts,</span><br><span class="line">				<span class="keyword">int</span>(*config.IPTables.MasqueradeBit),</span><br><span class="line">				localDetector,</span><br><span class="line">				hostname,</span><br><span class="line">				nodeIP,</span><br><span class="line">				recorder,</span><br><span class="line">				healthzServer,</span><br><span class="line">				nodePortAddresses,</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create proxier: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		proxymetrics.RegisterMetrics()</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> config.Mode == proxyconfigapi.ProxyModeIPVS &#123;</span><br><span class="line">		kernelHandler := ipvs.NewLinuxKernelHandler()</span><br><span class="line">		ipsetInterface = utilipset.New(execer)</span><br><span class="line">		ipvsInterface = utilipvs.New()</span><br><span class="line">		<span class="keyword">if</span> err := ipvs.CanUseIPVSProxier(ipvsInterface, ipsetInterface, config.IPVS.Scheduler); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"can't use the IPVS proxier: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		klog.InfoS(<span class="string">"Using ipvs Proxier"</span>)</span><br><span class="line">		<span class="keyword">if</span> dualStack &#123;</span><br><span class="line">			klog.InfoS(<span class="string">"Creating dualStackProxier for ipvs"</span>)</span><br><span class="line"></span><br><span class="line">			nodeIPs := nodeIPTuple(config.BindAddress)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Always ordered to match []ipt</span></span><br><span class="line">			<span class="keyword">var</span> localDetectors [<span class="number">2</span>]proxyutiliptables.LocalTrafficDetector</span><br><span class="line">			localDetectors, err = getDualStackLocalDetectorTuple(config.DetectLocalMode, config, ipt, nodeInfo)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create proxier: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			proxier, err = ipvs.NewDualStackProxier(</span><br><span class="line">				ipt,</span><br><span class="line">				ipvsInterface,</span><br><span class="line">				ipsetInterface,</span><br><span class="line">				utilsysctl.New(),</span><br><span class="line">				execer,</span><br><span class="line">				config.IPVS.SyncPeriod.Duration,</span><br><span class="line">				config.IPVS.MinSyncPeriod.Duration,</span><br><span class="line">				config.IPVS.ExcludeCIDRs,</span><br><span class="line">				config.IPVS.StrictARP,</span><br><span class="line">				config.IPVS.TCPTimeout.Duration,</span><br><span class="line">				config.IPVS.TCPFinTimeout.Duration,</span><br><span class="line">				config.IPVS.UDPTimeout.Duration,</span><br><span class="line">				config.IPTables.MasqueradeAll,</span><br><span class="line">				<span class="keyword">int</span>(*config.IPTables.MasqueradeBit),</span><br><span class="line">				localDetectors,</span><br><span class="line">				hostname,</span><br><span class="line">				nodeIPs,</span><br><span class="line">				recorder,</span><br><span class="line">				healthzServer,</span><br><span class="line">				config.IPVS.Scheduler,</span><br><span class="line">				nodePortAddresses,</span><br><span class="line">				kernelHandler,</span><br><span class="line">			)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> localDetector proxyutiliptables.LocalTrafficDetector</span><br><span class="line">			localDetector, err = getLocalDetector(config.DetectLocalMode, config, iptInterface, nodeInfo)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create proxier: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			proxier, err = ipvs.NewProxier(</span><br><span class="line">				primaryFamily,</span><br><span class="line">				iptInterface,</span><br><span class="line">				ipvsInterface,</span><br><span class="line">				ipsetInterface,</span><br><span class="line">				utilsysctl.New(),</span><br><span class="line">				execer,</span><br><span class="line">				config.IPVS.SyncPeriod.Duration,</span><br><span class="line">				config.IPVS.MinSyncPeriod.Duration,</span><br><span class="line">				config.IPVS.ExcludeCIDRs,</span><br><span class="line">				config.IPVS.StrictARP,</span><br><span class="line">				config.IPVS.TCPTimeout.Duration,</span><br><span class="line">				config.IPVS.TCPFinTimeout.Duration,</span><br><span class="line">				config.IPVS.UDPTimeout.Duration,</span><br><span class="line">				config.IPTables.MasqueradeAll,</span><br><span class="line">				<span class="keyword">int</span>(*config.IPTables.MasqueradeBit),</span><br><span class="line">				localDetector,</span><br><span class="line">				hostname,</span><br><span class="line">				nodeIP,</span><br><span class="line">				recorder,</span><br><span class="line">				healthzServer,</span><br><span class="line">				config.IPVS.Scheduler,</span><br><span class="line">				nodePortAddresses,</span><br><span class="line">				kernelHandler,</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unable to create proxier: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		proxymetrics.RegisterMetrics()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;ProxyServer&#123;</span><br><span class="line">		Config:        config,</span><br><span class="line">		Client:        client,</span><br><span class="line">		Proxier:       proxier,</span><br><span class="line">		Broadcaster:   eventBroadcaster,</span><br><span class="line">		Recorder:      recorder,</span><br><span class="line">		Conntracker:   &amp;realConntracker&#123;&#125;,</span><br><span class="line">		NodeRef:       nodeRef,</span><br><span class="line">		HealthzServer: healthzServer,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/kube-proxy/app/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Options)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(o.errCh)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(o.WriteConfigTo) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> o.writeConfigFile()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> o.CleanupAndExit &#123;</span><br><span class="line">		<span class="keyword">return</span> cleanupAndExit()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proxyServer, err := NewProxyServer(o)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	o.proxyServer = proxyServer</span><br><span class="line">	<span class="keyword">return</span> o.runLoop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终调用proxyServer的Run方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Options)</span> <span class="title">runLoop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> o.watcher != <span class="literal">nil</span> &#123;</span><br><span class="line">		o.watcher.Run()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// run the proxy in goroutine</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := o.proxyServer.Run()</span><br><span class="line">		o.errCh &lt;- err</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		err := &lt;-o.errCh</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/kube-proxy/app/server.go</span></span><br><span class="line"><span class="keyword">type</span> ProxyServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	Config *kubeproxyconfig.KubeProxyConfiguration</span><br><span class="line"></span><br><span class="line">	Client        clientset.Interface</span><br><span class="line">	Broadcaster   events.EventBroadcaster</span><br><span class="line">	Recorder      events.EventRecorder</span><br><span class="line">	Conntracker   Conntracker <span class="comment">// if nil, ignored</span></span><br><span class="line">	NodeRef       *v1.ObjectReference</span><br><span class="line">	HealthzServer healthcheck.ProxierHealthUpdater</span><br><span class="line"></span><br><span class="line">	Proxier proxy.Provider</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ProxyServer)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// To help debugging, immediately log version</span></span><br><span class="line">	klog.InfoS(<span class="string">"Version info"</span>, <span class="string">"version"</span>, version.Get())</span><br><span class="line"></span><br><span class="line">	klog.InfoS(<span class="string">"Golang settings"</span>, <span class="string">"GOGC"</span>, os.Getenv(<span class="string">"GOGC"</span>), <span class="string">"GOMAXPROCS"</span>, os.Getenv(<span class="string">"GOMAXPROCS"</span>), <span class="string">"GOTRACEBACK"</span>, os.Getenv(<span class="string">"GOTRACEBACK"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TODO(vmarmol): Use container config for this.</span></span><br><span class="line">	<span class="keyword">var</span> oomAdjuster *oom.OOMAdjuster</span><br><span class="line">	<span class="keyword">if</span> s.Config.OOMScoreAdj != <span class="literal">nil</span> &#123;</span><br><span class="line">		oomAdjuster = oom.NewOOMAdjuster()</span><br><span class="line">		<span class="keyword">if</span> err := oomAdjuster.ApplyOOMScoreAdj(<span class="number">0</span>, <span class="keyword">int</span>(*s.Config.OOMScoreAdj)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">"Failed to apply OOMScore"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.Broadcaster != <span class="literal">nil</span> &#123;</span><br><span class="line">		stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		s.Broadcaster.StartRecordingToSink(stopCh)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TODO(thockin): make it possible for healthz and metrics to be on the same port.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> errCh <span class="keyword">chan</span> error</span><br><span class="line">	<span class="keyword">if</span> s.Config.BindAddressHardFail &#123;</span><br><span class="line">		errCh = <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start up a healthz server if requested</span></span><br><span class="line">	serveHealthz(s.HealthzServer, errCh)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start up a metrics server if requested</span></span><br><span class="line">	serveMetrics(s.Config.MetricsBindAddress, s.Config.Mode, s.Config.EnableProfiling, errCh)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tune conntrack, if requested</span></span><br><span class="line">	<span class="comment">// Conntracker is always nil for windows</span></span><br><span class="line">	<span class="keyword">if</span> s.Conntracker != <span class="literal">nil</span> &#123;</span><br><span class="line">		max, err := getConntrackMax(s.Config.Conntrack)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> max &gt; <span class="number">0</span> &#123;</span><br><span class="line">			err := s.Conntracker.SetMax(max)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err != errReadOnlySysFS &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// errReadOnlySysFS is caused by a known docker issue (https://github.com/docker/docker/issues/24000),</span></span><br><span class="line">				<span class="comment">// the only remediation we know is to restart the docker daemon.</span></span><br><span class="line">				<span class="comment">// Here we'll send an node event with specific reason and message, the</span></span><br><span class="line">				<span class="comment">// administrator should decide whether and how to handle this issue,</span></span><br><span class="line">				<span class="comment">// whether to drain the node and restart docker.  Occurs in other container runtimes</span></span><br><span class="line">				<span class="comment">// as well.</span></span><br><span class="line">				<span class="comment">// TODO(random-liu): Remove this when the docker bug is fixed.</span></span><br><span class="line">				<span class="keyword">const</span> message = <span class="string">"CRI error: /sys is read-only: "</span> +</span><br><span class="line">					<span class="string">"cannot modify conntrack limits, problems may arise later (If running Docker, see docker issue #24000)"</span></span><br><span class="line">				s.Recorder.Eventf(s.NodeRef, <span class="literal">nil</span>, api.EventTypeWarning, err.Error(), <span class="string">"StartKubeProxy"</span>, message)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> s.Config.Conntrack.TCPEstablishedTimeout != <span class="literal">nil</span> &amp;&amp; s.Config.Conntrack.TCPEstablishedTimeout.Duration &gt; <span class="number">0</span> &#123;</span><br><span class="line">			timeout := <span class="keyword">int</span>(s.Config.Conntrack.TCPEstablishedTimeout.Duration / time.Second)</span><br><span class="line">			<span class="keyword">if</span> err := s.Conntracker.SetTCPEstablishedTimeout(timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> s.Config.Conntrack.TCPCloseWaitTimeout != <span class="literal">nil</span> &amp;&amp; s.Config.Conntrack.TCPCloseWaitTimeout.Duration &gt; <span class="number">0</span> &#123;</span><br><span class="line">			timeout := <span class="keyword">int</span>(s.Config.Conntrack.TCPCloseWaitTimeout.Duration / time.Second)</span><br><span class="line">			<span class="keyword">if</span> err := s.Conntracker.SetTCPCloseWaitTimeout(timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	noProxyName, err := labels.NewRequirement(apis.LabelServiceProxyName, selection.DoesNotExist, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	noHeadlessEndpoints, err := labels.NewRequirement(v1.IsHeadlessService, selection.DoesNotExist, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	labelSelector := labels.NewSelector()</span><br><span class="line">	labelSelector = labelSelector.Add(*noProxyName, *noHeadlessEndpoints)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make informers that filter out objects that want a non-default service proxy.</span></span><br><span class="line">	informerFactory := informers.NewSharedInformerFactoryWithOptions(s.Client, s.Config.ConfigSyncPeriod.Duration,</span><br><span class="line">		informers.WithTweakListOptions(<span class="function"><span class="keyword">func</span><span class="params">(options *metav1.ListOptions)</span></span> &#123;</span><br><span class="line">			options.LabelSelector = labelSelector.String()</span><br><span class="line">		&#125;))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create configs (i.e. Watches for Services and EndpointSlices)</span></span><br><span class="line">	<span class="comment">// Note: RegisterHandler() calls need to happen before creation of Sources because sources</span></span><br><span class="line">	<span class="comment">// only notify on changes, and the initial update (on process start) may be lost if no handlers</span></span><br><span class="line">	<span class="comment">// are registered yet.</span></span><br><span class="line">    <span class="comment">// 这段代码可以理解为通过Informer机制监听Service</span></span><br><span class="line">	serviceConfig := config.NewServiceConfig(informerFactory.Core().V1().Services(), s.Config.ConfigSyncPeriod.Duration)</span><br><span class="line">	serviceConfig.RegisterEventHandler(s.Proxier)</span><br><span class="line">	<span class="keyword">go</span> serviceConfig.Run(wait.NeverStop)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这段代码可以理解为通过Informer机制监听EndpointSlice</span></span><br><span class="line">	endpointSliceConfig := config.NewEndpointSliceConfig(informerFactory.Discovery().V1().EndpointSlices(), s.Config.ConfigSyncPeriod.Duration)</span><br><span class="line">	endpointSliceConfig.RegisterEventHandler(s.Proxier)</span><br><span class="line">	<span class="keyword">go</span> endpointSliceConfig.Run(wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This has to start after the calls to NewServiceConfig because that</span></span><br><span class="line">	<span class="comment">// function must configure its shared informer event handlers first.</span></span><br><span class="line">	informerFactory.Start(wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make an informer that selects for our nodename.</span></span><br><span class="line">	currentNodeInformerFactory := informers.NewSharedInformerFactoryWithOptions(s.Client, s.Config.ConfigSyncPeriod.Duration,</span><br><span class="line">		informers.WithTweakListOptions(<span class="function"><span class="keyword">func</span><span class="params">(options *metav1.ListOptions)</span></span> &#123;</span><br><span class="line">			options.FieldSelector = fields.OneTermEqualSelector(<span class="string">"metadata.name"</span>, s.NodeRef.Name).String()</span><br><span class="line">		&#125;))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这段代码可以理解为通过Informer机制监听Node</span></span><br><span class="line">	nodeConfig := config.NewNodeConfig(currentNodeInformerFactory.Core().V1().Nodes(), s.Config.ConfigSyncPeriod.Duration)</span><br><span class="line">	<span class="comment">// https://issues.k8s.io/111321</span></span><br><span class="line">	<span class="keyword">if</span> s.Config.DetectLocalMode == kubeproxyconfig.LocalModeNodeCIDR &#123;</span><br><span class="line">		nodeConfig.RegisterEventHandler(&amp;proxy.NodePodCIDRHandler&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	nodeConfig.RegisterEventHandler(s.Proxier)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> nodeConfig.Run(wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This has to start after the calls to NewNodeConfig because that must</span></span><br><span class="line">	<span class="comment">// configure the shared informer event handler first.</span></span><br><span class="line">	currentNodeInformerFactory.Start(wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Birth Cry after the birth is successful</span></span><br><span class="line">	s.birthCry()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iptables/ipvs Proxier都实现了SyncLoop()</span></span><br><span class="line">	<span class="keyword">go</span> s.Proxier.SyncLoop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &lt;-errCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServiceConfig, endpointSliceConfig, nodeConfig</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/proxy/config/config.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	listerSynced  cache.InformerSynced</span><br><span class="line">	eventHandlers []ServiceHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewServiceConfig creates a new ServiceConfig.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServiceConfig</span><span class="params">(serviceInformer coreinformers.ServiceInformer, resyncPeriod time.Duration)</span> *<span class="title">ServiceConfig</span></span> &#123;</span><br><span class="line">	result := &amp;ServiceConfig&#123;</span><br><span class="line">		listerSynced: serviceInformer.Informer().HasSynced,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	serviceInformer.Informer().AddEventHandlerWithResyncPeriod(</span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc:    result.handleAddService,</span><br><span class="line">			UpdateFunc: result.handleUpdateService,</span><br><span class="line">			DeleteFunc: result.handleDeleteService,</span><br><span class="line">		&#125;,</span><br><span class="line">		resyncPeriod,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run waits for cache synced and invokes handlers after syncing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ServiceConfig)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	klog.InfoS(<span class="string">"Starting service config controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"service config"</span>, stopCh, c.listerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c.eventHandlers &#123;</span><br><span class="line">		klog.V(<span class="number">3</span>).InfoS(<span class="string">"Calling handler.OnServiceSynced()"</span>)</span><br><span class="line">        <span class="comment">// 当所有初始事件处理程序都被调用并且状态完全更新到本地缓存后调用</span></span><br><span class="line">		c.eventHandlers[i].OnServiceSynced()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NodeConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	listerSynced  cache.InformerSynced</span><br><span class="line">	eventHandlers []NodeHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNodeConfig creates a new NodeConfig.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNodeConfig</span><span class="params">(nodeInformer coreinformers.NodeInformer, resyncPeriod time.Duration)</span> *<span class="title">NodeConfig</span></span> &#123;</span><br><span class="line">	result := &amp;NodeConfig&#123;</span><br><span class="line">		listerSynced: nodeInformer.Informer().HasSynced,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nodeInformer.Informer().AddEventHandlerWithResyncPeriod(</span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc:    result.handleAddNode,</span><br><span class="line">			UpdateFunc: result.handleUpdateNode,</span><br><span class="line">			DeleteFunc: result.handleDeleteNode,</span><br><span class="line">		&#125;,</span><br><span class="line">		resyncPeriod,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run starts the goroutine responsible for calling registered handlers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *NodeConfig)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	klog.InfoS(<span class="string">"Starting node config controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"node config"</span>, stopCh, c.listerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c.eventHandlers &#123;</span><br><span class="line">		klog.V(<span class="number">3</span>).InfoS(<span class="string">"Calling handler.OnNodeSynced()"</span>)</span><br><span class="line">		c.eventHandlers[i].OnNodeSynced()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EndpointSliceConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	listerSynced  cache.InformerSynced</span><br><span class="line">	eventHandlers []EndpointSliceHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewEndpointSliceConfig creates a new EndpointSliceConfig.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEndpointSliceConfig</span><span class="params">(endpointSliceInformer discoveryinformers.EndpointSliceInformer, resyncPeriod time.Duration)</span> *<span class="title">EndpointSliceConfig</span></span> &#123;</span><br><span class="line">	result := &amp;EndpointSliceConfig&#123;</span><br><span class="line">		listerSynced: endpointSliceInformer.Informer().HasSynced,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	endpointSliceInformer.Informer().AddEventHandlerWithResyncPeriod(</span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc:    result.handleAddEndpointSlice,</span><br><span class="line">			UpdateFunc: result.handleUpdateEndpointSlice,</span><br><span class="line">			DeleteFunc: result.handleDeleteEndpointSlice,</span><br><span class="line">		&#125;,</span><br><span class="line">		resyncPeriod,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run waits for cache synced and invokes handlers after syncing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *EndpointSliceConfig)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	klog.InfoS(<span class="string">"Starting endpoint slice config controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"endpoint slice config"</span>, stopCh, c.listerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> c.eventHandlers &#123;</span><br><span class="line">		klog.V(<span class="number">3</span>).InfoS(<span class="string">"Calling handler.OnEndpointSlicesSynced()"</span>)</span><br><span class="line">		h.OnEndpointSlicesSynced()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/proxy/ipvs/proxier.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">SyncLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Update healthz timestamp at beginning in case Sync() never succeeds.</span></span><br><span class="line">	<span class="keyword">if</span> proxier.healthzServer != <span class="literal">nil</span> &#123;</span><br><span class="line">		proxier.healthzServer.Updated()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// synthesize "last change queued" time as the informers are syncing.</span></span><br><span class="line">	metrics.SyncProxyRulesLastQueuedTimestamp.SetToCurrentTime()</span><br><span class="line">    <span class="comment">// 周期性的执行对应的参数</span></span><br><span class="line">	proxier.syncRunner.Loop(wait.NeverStop)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxier</span><span class="params">(ipFamily v1.IPFamily...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// syncRunner初始化，fn为proxier.syncProxyRules</span></span><br><span class="line">    <span class="comment">// iptables,ipvs都实现了syncProxyRules</span></span><br><span class="line">    <span class="comment">// 周期性执行的方法`syncProxyRules`就是`kube-proxy`的核心逻辑，根据`Service`,`EndpointSlice`,`Node`的变化分别更新iptables或ipvs</span></span><br><span class="line">    proxier.syncRunner = async.NewBoundedFrequencyRunner(<span class="string">"sync-runner"</span>, proxier.syncProxyRules, minSyncPeriod, syncPeriod, burstSyncs)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/proxy/iptables/proxier.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">SyncLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Update healthz timestamp at beginning in case Sync() never succeeds.</span></span><br><span class="line">	<span class="keyword">if</span> proxier.healthzServer != <span class="literal">nil</span> &#123;</span><br><span class="line">		proxier.healthzServer.Updated()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// synthesize "last change queued" time as the informers are syncing.</span></span><br><span class="line">	metrics.SyncProxyRulesLastQueuedTimestamp.SetToCurrentTime()</span><br><span class="line">	proxier.syncRunner.Loop(wait.NeverStop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxier</span><span class="params">(ipFamily v1.IPFamily...)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// syncRunner初始化，fn为proxier.syncProxyRules</span></span><br><span class="line">    proxier.syncRunner = async.NewBoundedFrequencyRunner(<span class="string">"sync-runner"</span>, proxier.syncProxyRules, minSyncPeriod, time.Hour, burstSyncs)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iptables syncProxyRules<br>这函数代码太长后面再慢慢分析<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/proxy/iptables/proxier.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proxier *Proxier)</span> <span class="title">syncProxyRules</span><span class="params">()</span></span> &#123;</span><br><span class="line">	proxier.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> proxier.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// don't sync rules till we've received services and endpoints</span></span><br><span class="line">	<span class="keyword">if</span> !proxier.isInitialized() &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).InfoS(<span class="string">"Not syncing iptables until Services and Endpoints have been received from master"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The value of proxier.needFullSync may change before the defer funcs run, so</span></span><br><span class="line">	<span class="comment">// we need to keep track of whether it was set at the *start* of the sync.</span></span><br><span class="line">	tryPartialSync := !proxier.needFullSync</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Keep track of how long syncs take.</span></span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		metrics.SyncProxyRulesLatency.Observe(metrics.SinceInSeconds(start))</span><br><span class="line">		<span class="keyword">if</span> tryPartialSync &#123;</span><br><span class="line">			metrics.SyncPartialProxyRulesLatency.Observe(metrics.SinceInSeconds(start))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			metrics.SyncFullProxyRulesLatency.Observe(metrics.SinceInSeconds(start))</span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">2</span>).InfoS(<span class="string">"SyncProxyRules complete"</span>, <span class="string">"elapsed"</span>, time.Since(start))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> serviceChanged, endpointsChanged sets.Set[<span class="keyword">string</span>]</span><br><span class="line">	<span class="keyword">if</span> tryPartialSync &#123;</span><br><span class="line">		serviceChanged = proxier.serviceChanges.PendingChanges()</span><br><span class="line">		endpointsChanged = proxier.endpointsChanges.PendingChanges()</span><br><span class="line">	&#125;</span><br><span class="line">	serviceUpdateResult := proxier.svcPortMap.Update(proxier.serviceChanges)</span><br><span class="line">	endpointUpdateResult := proxier.endpointsMap.Update(proxier.endpointsChanges)</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">2</span>).InfoS(<span class="string">"Syncing iptables rules"</span>)</span><br><span class="line"></span><br><span class="line">	success := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !success &#123;</span><br><span class="line">			klog.InfoS(<span class="string">"Sync failed"</span>, <span class="string">"retryingTime"</span>, proxier.syncPeriod)</span><br><span class="line">			proxier.syncRunner.RetryAfter(proxier.syncPeriod)</span><br><span class="line">			<span class="keyword">if</span> tryPartialSync &#123;</span><br><span class="line">				metrics.IptablesPartialRestoreFailuresTotal.Inc()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// proxier.serviceChanges and proxier.endpointChanges have already</span></span><br><span class="line">			<span class="comment">// been flushed, so we've lost the state needed to be able to do</span></span><br><span class="line">			<span class="comment">// a partial sync.</span></span><br><span class="line">			proxier.needFullSync = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !tryPartialSync &#123;</span><br><span class="line">		<span class="comment">// Ensure that our jump rules (eg from PREROUTING to KUBE-SERVICES) exist.</span></span><br><span class="line">		<span class="comment">// We can't do this as part of the iptables-restore because we don't want</span></span><br><span class="line">		<span class="comment">// to specify/replace *all* of the rules in PREROUTING, etc.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// We need to create these rules when kube-proxy first starts, and we need</span></span><br><span class="line">		<span class="comment">// to recreate them if the utiliptables Monitor detects that iptables has</span></span><br><span class="line">		<span class="comment">// been flushed. In both of those cases, the code will force a full sync.</span></span><br><span class="line">		<span class="comment">// In all other cases, it ought to be safe to assume that the rules</span></span><br><span class="line">		<span class="comment">// already exist, so we'll skip this step when doing a partial sync, to</span></span><br><span class="line">		<span class="comment">// save us from having to invoke /sbin/iptables 20 times on each sync</span></span><br><span class="line">		<span class="comment">// (which will be very slow on hosts with lots of iptables rules).</span></span><br><span class="line">		<span class="keyword">for</span> _, jump := <span class="keyword">range</span> <span class="built_in">append</span>(iptablesJumpChains, iptablesKubeletJumpChains...) &#123;</span><br><span class="line">			<span class="keyword">if</span> _, err := proxier.iptables.EnsureChain(jump.table, jump.dstChain); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Failed to ensure chain exists"</span>, <span class="string">"table"</span>, jump.table, <span class="string">"chain"</span>, jump.dstChain)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			args := jump.extraArgs</span><br><span class="line">			<span class="keyword">if</span> jump.comment != <span class="string">""</span> &#123;</span><br><span class="line">				args = <span class="built_in">append</span>(args, <span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, jump.comment)</span><br><span class="line">			&#125;</span><br><span class="line">			args = <span class="built_in">append</span>(args, <span class="string">"-j"</span>, <span class="keyword">string</span>(jump.dstChain))</span><br><span class="line">			<span class="keyword">if</span> _, err := proxier.iptables.EnsureRule(utiliptables.Prepend, jump.table, jump.srcChain, args...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Failed to ensure chain jumps"</span>, <span class="string">"table"</span>, jump.table, <span class="string">"srcChain"</span>, jump.srcChain, <span class="string">"dstChain"</span>, jump.dstChain)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Below this point we will not return until we try to write the iptables rules.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reset all buffers used later.</span></span><br><span class="line">	<span class="comment">// This is to avoid memory reallocations and thus improve performance.</span></span><br><span class="line">	proxier.filterChains.Reset()</span><br><span class="line">	proxier.filterRules.Reset()</span><br><span class="line">	proxier.natChains.Reset()</span><br><span class="line">	proxier.natRules.Reset()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write chain lines for all the "top-level" chains we'll be filling in</span></span><br><span class="line">	<span class="keyword">for</span> _, chainName := <span class="keyword">range</span> []utiliptables.Chain&#123;kubeServicesChain, kubeExternalServicesChain, kubeForwardChain, kubeNodePortsChain, kubeProxyFirewallChain&#125; &#123;</span><br><span class="line">		proxier.filterChains.Write(utiliptables.MakeChainLine(chainName))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, chainName := <span class="keyword">range</span> []utiliptables.Chain&#123;kubeServicesChain, kubeNodePortsChain, kubePostroutingChain, kubeMarkMasqChain&#125; &#123;</span><br><span class="line">		proxier.natChains.Write(utiliptables.MakeChainLine(chainName))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Install the kubernetes-specific postrouting rules. We use a whole chain for</span></span><br><span class="line">	<span class="comment">// this so that it is easier to flush and change, for example if the mark</span></span><br><span class="line">	<span class="comment">// value should ever change.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> kubelet creates identical copies of these rules. If you want to change</span></span><br><span class="line">	<span class="comment">// these rules in the future, you MUST do so in a way that will interoperate</span></span><br><span class="line">	<span class="comment">// correctly with skewed versions of the rules created by kubelet. (Remove this</span></span><br><span class="line">	<span class="comment">// comment once IPTablesOwnershipCleanup is GA.)</span></span><br><span class="line"></span><br><span class="line">	proxier.natRules.Write(</span><br><span class="line">		<span class="string">"-A"</span>, <span class="keyword">string</span>(kubePostroutingChain),</span><br><span class="line">		<span class="string">"-m"</span>, <span class="string">"mark"</span>, <span class="string">"!"</span>, <span class="string">"--mark"</span>, fmt.Sprintf(<span class="string">"%s/%s"</span>, proxier.masqueradeMark, proxier.masqueradeMark),</span><br><span class="line">		<span class="string">"-j"</span>, <span class="string">"RETURN"</span>,</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// Clear the mark to avoid re-masquerading if the packet re-traverses the network stack.</span></span><br><span class="line">	proxier.natRules.Write(</span><br><span class="line">		<span class="string">"-A"</span>, <span class="keyword">string</span>(kubePostroutingChain),</span><br><span class="line">		<span class="string">"-j"</span>, <span class="string">"MARK"</span>, <span class="string">"--xor-mark"</span>, proxier.masqueradeMark,</span><br><span class="line">	)</span><br><span class="line">	masqRule := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"-A"</span>, <span class="keyword">string</span>(kubePostroutingChain),</span><br><span class="line">		<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, <span class="string">`"kubernetes service traffic requiring SNAT"`</span>,</span><br><span class="line">		<span class="string">"-j"</span>, <span class="string">"MASQUERADE"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> proxier.iptables.HasRandomFully() &#123;</span><br><span class="line">		masqRule = <span class="built_in">append</span>(masqRule, <span class="string">"--random-fully"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	proxier.natRules.Write(masqRule)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Install the kubernetes-specific masquerade mark rule. We use a whole chain for</span></span><br><span class="line">	<span class="comment">// this so that it is easier to flush and change, for example if the mark</span></span><br><span class="line">	<span class="comment">// value should ever change.</span></span><br><span class="line">	proxier.natRules.Write(</span><br><span class="line">		<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeMarkMasqChain),</span><br><span class="line">		<span class="string">"-j"</span>, <span class="string">"MARK"</span>, <span class="string">"--or-mark"</span>, proxier.masqueradeMark,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	isIPv6 := proxier.iptables.IsIPv6()</span><br><span class="line">	<span class="keyword">if</span> !isIPv6 &amp;&amp; proxier.localhostNodePorts &#123;</span><br><span class="line">		<span class="comment">// Kube-proxy's use of `route_localnet` to enable NodePorts on localhost</span></span><br><span class="line">		<span class="comment">// creates a security hole (https://issue.k8s.io/90259) which this</span></span><br><span class="line">		<span class="comment">// iptables rule mitigates.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> kubelet creates an identical copy of this rule. If you want to</span></span><br><span class="line">		<span class="comment">// change this rule in the future, you MUST do so in a way that will</span></span><br><span class="line">		<span class="comment">// interoperate correctly with skewed versions of the rule created by</span></span><br><span class="line">		<span class="comment">// kubelet. (Actually, kubelet uses "--dst"/"--src" rather than "-d"/"-s"</span></span><br><span class="line">		<span class="comment">// but that's just a command-line thing and results in the same rule being</span></span><br><span class="line">		<span class="comment">// created in the kernel.)</span></span><br><span class="line">		proxier.filterChains.Write(utiliptables.MakeChainLine(kubeletFirewallChain))</span><br><span class="line">		proxier.filterRules.Write(</span><br><span class="line">			<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeletFirewallChain),</span><br><span class="line">			<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, <span class="string">`"block incoming localnet connections"`</span>,</span><br><span class="line">			<span class="string">"-d"</span>, <span class="string">"127.0.0.0/8"</span>,</span><br><span class="line">			<span class="string">"!"</span>, <span class="string">"-s"</span>, <span class="string">"127.0.0.0/8"</span>,</span><br><span class="line">			<span class="string">"-m"</span>, <span class="string">"conntrack"</span>,</span><br><span class="line">			<span class="string">"!"</span>, <span class="string">"--ctstate"</span>, <span class="string">"RELATED,ESTABLISHED,DNAT"</span>,</span><br><span class="line">			<span class="string">"-j"</span>, <span class="string">"DROP"</span>,</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Accumulate NAT chains to keep.</span></span><br><span class="line">	activeNATChains := <span class="keyword">map</span>[utiliptables.Chain]<span class="keyword">bool</span>&#123;&#125; <span class="comment">// use a map as a set</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// To avoid growing this slice, we arbitrarily set its size to 64,</span></span><br><span class="line">	<span class="comment">// there is never more than that many arguments for a single line.</span></span><br><span class="line">	<span class="comment">// Note that even if we go over 64, it will still be correct - it</span></span><br><span class="line">	<span class="comment">// is just for efficiency, not correctness.</span></span><br><span class="line">	args := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute total number of endpoint chains across all services</span></span><br><span class="line">	<span class="comment">// to get a sense of how big the cluster is.</span></span><br><span class="line">	totalEndpoints := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> svcName := <span class="keyword">range</span> proxier.svcPortMap &#123;</span><br><span class="line">		totalEndpoints += <span class="built_in">len</span>(proxier.endpointsMap[svcName])</span><br><span class="line">	&#125;</span><br><span class="line">	proxier.largeClusterMode = (totalEndpoints &gt; largeClusterEndpointsThreshold)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// These two variables are used to publish the sync_proxy_rules_no_endpoints_total</span></span><br><span class="line">	<span class="comment">// metric.</span></span><br><span class="line">	serviceNoLocalEndpointsTotalInternal := <span class="number">0</span></span><br><span class="line">	serviceNoLocalEndpointsTotalExternal := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build rules for each service-port.</span></span><br><span class="line">	<span class="keyword">for</span> svcName, svc := <span class="keyword">range</span> proxier.svcPortMap &#123;</span><br><span class="line">		svcInfo, ok := svc.(*servicePortInfo)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">"Failed to cast serviceInfo"</span>, <span class="string">"serviceName"</span>, svcName)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		protocol := strings.ToLower(<span class="keyword">string</span>(svcInfo.Protocol()))</span><br><span class="line">		svcPortNameString := svcInfo.nameString</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Figure out the endpoints for Cluster and Local traffic policy.</span></span><br><span class="line">		<span class="comment">// allLocallyReachableEndpoints is the set of all endpoints that can be routed to</span></span><br><span class="line">		<span class="comment">// from this node, given the service's traffic policies. hasEndpoints is true</span></span><br><span class="line">		<span class="comment">// if the service has any usable endpoints on any node, not just this one.</span></span><br><span class="line">		allEndpoints := proxier.endpointsMap[svcName]</span><br><span class="line">		clusterEndpoints, localEndpoints, allLocallyReachableEndpoints, hasEndpoints := proxy.CategorizeEndpoints(allEndpoints, svcInfo, proxier.nodeLabels)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Note the endpoint chains that will be used</span></span><br><span class="line">		<span class="keyword">for</span> _, ep := <span class="keyword">range</span> allLocallyReachableEndpoints &#123;</span><br><span class="line">			<span class="keyword">if</span> epInfo, ok := ep.(*endpointsInfo); ok &#123;</span><br><span class="line">				activeNATChains[epInfo.ChainName] = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// clusterPolicyChain contains the endpoints used with "Cluster" traffic policy</span></span><br><span class="line">		clusterPolicyChain := svcInfo.clusterPolicyChainName</span><br><span class="line">		usesClusterPolicyChain := <span class="built_in">len</span>(clusterEndpoints) &gt; <span class="number">0</span> &amp;&amp; svcInfo.UsesClusterEndpoints()</span><br><span class="line">		<span class="keyword">if</span> usesClusterPolicyChain &#123;</span><br><span class="line">			activeNATChains[clusterPolicyChain] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// localPolicyChain contains the endpoints used with "Local" traffic policy</span></span><br><span class="line">		localPolicyChain := svcInfo.localPolicyChainName</span><br><span class="line">		usesLocalPolicyChain := <span class="built_in">len</span>(localEndpoints) &gt; <span class="number">0</span> &amp;&amp; svcInfo.UsesLocalEndpoints()</span><br><span class="line">		<span class="keyword">if</span> usesLocalPolicyChain &#123;</span><br><span class="line">			activeNATChains[localPolicyChain] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// internalPolicyChain is the chain containing the endpoints for</span></span><br><span class="line">		<span class="comment">// "internal" (ClusterIP) traffic. internalTrafficChain is the chain that</span></span><br><span class="line">		<span class="comment">// internal traffic is routed to (which is always the same as</span></span><br><span class="line">		<span class="comment">// internalPolicyChain). hasInternalEndpoints is true if we should</span></span><br><span class="line">		<span class="comment">// generate rules pointing to internalTrafficChain, or false if there are</span></span><br><span class="line">		<span class="comment">// no available internal endpoints.</span></span><br><span class="line">		internalPolicyChain := clusterPolicyChain</span><br><span class="line">		hasInternalEndpoints := hasEndpoints</span><br><span class="line">		<span class="keyword">if</span> svcInfo.InternalPolicyLocal() &#123;</span><br><span class="line">			internalPolicyChain = localPolicyChain</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(localEndpoints) == <span class="number">0</span> &#123;</span><br><span class="line">				hasInternalEndpoints = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		internalTrafficChain := internalPolicyChain</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Similarly, externalPolicyChain is the chain containing the endpoints</span></span><br><span class="line">		<span class="comment">// for "external" (NodePort, LoadBalancer, and ExternalIP) traffic.</span></span><br><span class="line">		<span class="comment">// externalTrafficChain is the chain that external traffic is routed to</span></span><br><span class="line">		<span class="comment">// (which is always the service's "EXT" chain). hasExternalEndpoints is</span></span><br><span class="line">		<span class="comment">// true if there are endpoints that will be reached by external traffic.</span></span><br><span class="line">		<span class="comment">// (But we may still have to generate externalTrafficChain even if there</span></span><br><span class="line">		<span class="comment">// are no external endpoints, to ensure that the short-circuit rules for</span></span><br><span class="line">		<span class="comment">// local traffic are set up.)</span></span><br><span class="line">		externalPolicyChain := clusterPolicyChain</span><br><span class="line">		hasExternalEndpoints := hasEndpoints</span><br><span class="line">		<span class="keyword">if</span> svcInfo.ExternalPolicyLocal() &#123;</span><br><span class="line">			externalPolicyChain = localPolicyChain</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(localEndpoints) == <span class="number">0</span> &#123;</span><br><span class="line">				hasExternalEndpoints = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		externalTrafficChain := svcInfo.externalChainName <span class="comment">// eventually jumps to externalPolicyChain</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// usesExternalTrafficChain is based on hasEndpoints, not hasExternalEndpoints,</span></span><br><span class="line">		<span class="comment">// because we need the local-traffic-short-circuiting rules even when there</span></span><br><span class="line">		<span class="comment">// are no externally-usable endpoints.</span></span><br><span class="line">		usesExternalTrafficChain := hasEndpoints &amp;&amp; svcInfo.ExternallyAccessible()</span><br><span class="line">		<span class="keyword">if</span> usesExternalTrafficChain &#123;</span><br><span class="line">			activeNATChains[externalTrafficChain] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Traffic to LoadBalancer IPs can go directly to externalTrafficChain</span></span><br><span class="line">		<span class="comment">// unless LoadBalancerSourceRanges is in use in which case we will</span></span><br><span class="line">		<span class="comment">// create a firewall chain.</span></span><br><span class="line">		loadBalancerTrafficChain := externalTrafficChain</span><br><span class="line">		fwChain := svcInfo.firewallChainName</span><br><span class="line">		usesFWChain := hasEndpoints &amp;&amp; <span class="built_in">len</span>(svcInfo.LoadBalancerIPStrings()) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(svcInfo.LoadBalancerSourceRanges()) &gt; <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> usesFWChain &#123;</span><br><span class="line">			activeNATChains[fwChain] = <span class="literal">true</span></span><br><span class="line">			loadBalancerTrafficChain = fwChain</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> internalTrafficFilterTarget, internalTrafficFilterComment <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">var</span> externalTrafficFilterTarget, externalTrafficFilterComment <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">if</span> !hasEndpoints &#123;</span><br><span class="line">			<span class="comment">// The service has no endpoints at all; hasInternalEndpoints and</span></span><br><span class="line">			<span class="comment">// hasExternalEndpoints will also be false, and we will not</span></span><br><span class="line">			<span class="comment">// generate any chains in the "nat" table for the service; only</span></span><br><span class="line">			<span class="comment">// rules in the "filter" table rejecting incoming packets for</span></span><br><span class="line">			<span class="comment">// the service's IPs.</span></span><br><span class="line">			internalTrafficFilterTarget = <span class="string">"REJECT"</span></span><br><span class="line">			internalTrafficFilterComment = fmt.Sprintf(<span class="string">`"%s has no endpoints"`</span>, svcPortNameString)</span><br><span class="line">			externalTrafficFilterTarget = <span class="string">"REJECT"</span></span><br><span class="line">			externalTrafficFilterComment = internalTrafficFilterComment</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> !hasInternalEndpoints &#123;</span><br><span class="line">				<span class="comment">// The internalTrafficPolicy is "Local" but there are no local</span></span><br><span class="line">				<span class="comment">// endpoints. Traffic to the clusterIP will be dropped, but</span></span><br><span class="line">				<span class="comment">// external traffic may still be accepted.</span></span><br><span class="line">				internalTrafficFilterTarget = <span class="string">"DROP"</span></span><br><span class="line">				internalTrafficFilterComment = fmt.Sprintf(<span class="string">`"%s has no local endpoints"`</span>, svcPortNameString)</span><br><span class="line">				serviceNoLocalEndpointsTotalInternal++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !hasExternalEndpoints &#123;</span><br><span class="line">				<span class="comment">// The externalTrafficPolicy is "Local" but there are no</span></span><br><span class="line">				<span class="comment">// local endpoints. Traffic to "external" IPs from outside</span></span><br><span class="line">				<span class="comment">// the cluster will be dropped, but traffic from inside</span></span><br><span class="line">				<span class="comment">// the cluster may still be accepted.</span></span><br><span class="line">				externalTrafficFilterTarget = <span class="string">"DROP"</span></span><br><span class="line">				externalTrafficFilterComment = fmt.Sprintf(<span class="string">`"%s has no local endpoints"`</span>, svcPortNameString)</span><br><span class="line">				serviceNoLocalEndpointsTotalExternal++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Capture the clusterIP.</span></span><br><span class="line">		<span class="keyword">if</span> hasInternalEndpoints &#123;</span><br><span class="line">			proxier.natRules.Write(</span><br><span class="line">				<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeServicesChain),</span><br><span class="line">				<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"%s cluster IP"`</span>, svcPortNameString),</span><br><span class="line">				<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">				<span class="string">"-d"</span>, svcInfo.ClusterIP().String(),</span><br><span class="line">				<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.Port()),</span><br><span class="line">				<span class="string">"-j"</span>, <span class="keyword">string</span>(internalTrafficChain))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// No endpoints.</span></span><br><span class="line">			proxier.filterRules.Write(</span><br><span class="line">				<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeServicesChain),</span><br><span class="line">				<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, internalTrafficFilterComment,</span><br><span class="line">				<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">				<span class="string">"-d"</span>, svcInfo.ClusterIP().String(),</span><br><span class="line">				<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.Port()),</span><br><span class="line">				<span class="string">"-j"</span>, internalTrafficFilterTarget,</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Capture externalIPs.</span></span><br><span class="line">		<span class="keyword">for</span> _, externalIP := <span class="keyword">range</span> svcInfo.ExternalIPStrings() &#123;</span><br><span class="line">			<span class="keyword">if</span> hasEndpoints &#123;</span><br><span class="line">				<span class="comment">// Send traffic bound for external IPs to the "external</span></span><br><span class="line">				<span class="comment">// destinations" chain.</span></span><br><span class="line">				proxier.natRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeServicesChain),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"%s external IP"`</span>, svcPortNameString),</span><br><span class="line">					<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">					<span class="string">"-d"</span>, externalIP,</span><br><span class="line">					<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.Port()),</span><br><span class="line">					<span class="string">"-j"</span>, <span class="keyword">string</span>(externalTrafficChain))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !hasExternalEndpoints &#123;</span><br><span class="line">				<span class="comment">// Either no endpoints at all (REJECT) or no endpoints for</span></span><br><span class="line">				<span class="comment">// external traffic (DROP anything that didn't get</span></span><br><span class="line">				<span class="comment">// short-circuited by the EXT chain.)</span></span><br><span class="line">				proxier.filterRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeExternalServicesChain),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, externalTrafficFilterComment,</span><br><span class="line">					<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">					<span class="string">"-d"</span>, externalIP,</span><br><span class="line">					<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.Port()),</span><br><span class="line">					<span class="string">"-j"</span>, externalTrafficFilterTarget,</span><br><span class="line">				)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Capture load-balancer ingress.</span></span><br><span class="line">		<span class="keyword">for</span> _, lbip := <span class="keyword">range</span> svcInfo.LoadBalancerIPStrings() &#123;</span><br><span class="line">			<span class="keyword">if</span> hasEndpoints &#123;</span><br><span class="line">				proxier.natRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeServicesChain),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"%s loadbalancer IP"`</span>, svcPortNameString),</span><br><span class="line">					<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">					<span class="string">"-d"</span>, lbip,</span><br><span class="line">					<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.Port()),</span><br><span class="line">					<span class="string">"-j"</span>, <span class="keyword">string</span>(loadBalancerTrafficChain))</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> usesFWChain &#123;</span><br><span class="line">				proxier.filterRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeProxyFirewallChain),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"%s traffic not accepted by %s"`</span>, svcPortNameString, svcInfo.firewallChainName),</span><br><span class="line">					<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">					<span class="string">"-d"</span>, lbip,</span><br><span class="line">					<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.Port()),</span><br><span class="line">					<span class="string">"-j"</span>, <span class="string">"DROP"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !hasExternalEndpoints &#123;</span><br><span class="line">			<span class="comment">// Either no endpoints at all (REJECT) or no endpoints for</span></span><br><span class="line">			<span class="comment">// external traffic (DROP anything that didn't get short-circuited</span></span><br><span class="line">			<span class="comment">// by the EXT chain.)</span></span><br><span class="line">			<span class="keyword">for</span> _, lbip := <span class="keyword">range</span> svcInfo.LoadBalancerIPStrings() &#123;</span><br><span class="line">				proxier.filterRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeExternalServicesChain),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, externalTrafficFilterComment,</span><br><span class="line">					<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">					<span class="string">"-d"</span>, lbip,</span><br><span class="line">					<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.Port()),</span><br><span class="line">					<span class="string">"-j"</span>, externalTrafficFilterTarget,</span><br><span class="line">				)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Capture nodeports.</span></span><br><span class="line">		<span class="keyword">if</span> svcInfo.NodePort() != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> hasEndpoints &#123;</span><br><span class="line">				<span class="comment">// Jump to the external destination chain.  For better or for</span></span><br><span class="line">				<span class="comment">// worse, nodeports are not subect to loadBalancerSourceRanges,</span></span><br><span class="line">				<span class="comment">// and we can't change that.</span></span><br><span class="line">				proxier.natRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeNodePortsChain),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, svcPortNameString,</span><br><span class="line">					<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">					<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.NodePort()),</span><br><span class="line">					<span class="string">"-j"</span>, <span class="keyword">string</span>(externalTrafficChain))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !hasExternalEndpoints &#123;</span><br><span class="line">				<span class="comment">// Either no endpoints at all (REJECT) or no endpoints for</span></span><br><span class="line">				<span class="comment">// external traffic (DROP anything that didn't get</span></span><br><span class="line">				<span class="comment">// short-circuited by the EXT chain.)</span></span><br><span class="line">				proxier.filterRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeExternalServicesChain),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, externalTrafficFilterComment,</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"addrtype"</span>, <span class="string">"--dst-type"</span>, <span class="string">"LOCAL"</span>,</span><br><span class="line">					<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">					<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.NodePort()),</span><br><span class="line">					<span class="string">"-j"</span>, externalTrafficFilterTarget,</span><br><span class="line">				)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Capture healthCheckNodePorts.</span></span><br><span class="line">		<span class="keyword">if</span> svcInfo.HealthCheckNodePort() != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// no matter if node has local endpoints, healthCheckNodePorts</span></span><br><span class="line">			<span class="comment">// need to add a rule to accept the incoming connection</span></span><br><span class="line">			proxier.filterRules.Write(</span><br><span class="line">				<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeNodePortsChain),</span><br><span class="line">				<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"%s health check node port"`</span>, svcPortNameString),</span><br><span class="line">				<span class="string">"-m"</span>, <span class="string">"tcp"</span>, <span class="string">"-p"</span>, <span class="string">"tcp"</span>,</span><br><span class="line">				<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.HealthCheckNodePort()),</span><br><span class="line">				<span class="string">"-j"</span>, <span class="string">"ACCEPT"</span>,</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If the SVC/SVL/EXT/FW/SEP chains have not changed since the last sync</span></span><br><span class="line">		<span class="comment">// then we can omit them from the restore input. (We have already marked</span></span><br><span class="line">		<span class="comment">// them in activeNATChains, so they won't get deleted.)</span></span><br><span class="line">		<span class="keyword">if</span> tryPartialSync &amp;&amp; !serviceChanged.Has(svcName.NamespacedName.String()) &amp;&amp; !endpointsChanged.Has(svcName.NamespacedName.String()) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set up internal traffic handling.</span></span><br><span class="line">		<span class="keyword">if</span> hasInternalEndpoints &#123;</span><br><span class="line">			args = <span class="built_in">append</span>(args[:<span class="number">0</span>],</span><br><span class="line">				<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"%s cluster IP"`</span>, svcPortNameString),</span><br><span class="line">				<span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol,</span><br><span class="line">				<span class="string">"-d"</span>, svcInfo.ClusterIP().String(),</span><br><span class="line">				<span class="string">"--dport"</span>, strconv.Itoa(svcInfo.Port()),</span><br><span class="line">			)</span><br><span class="line">			<span class="keyword">if</span> proxier.masqueradeAll &#123;</span><br><span class="line">				proxier.natRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(internalTrafficChain),</span><br><span class="line">					args,</span><br><span class="line">					<span class="string">"-j"</span>, <span class="keyword">string</span>(kubeMarkMasqChain))</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> proxier.localDetector.IsImplemented() &#123;</span><br><span class="line">				<span class="comment">// This masquerades off-cluster traffic to a service VIP. The</span></span><br><span class="line">				<span class="comment">// idea is that you can establish a static route for your</span></span><br><span class="line">				<span class="comment">// Service range, routing to any node, and that node will</span></span><br><span class="line">				<span class="comment">// bridge into the Service for you. Since that might bounce</span></span><br><span class="line">				<span class="comment">// off-node, we masquerade here.</span></span><br><span class="line">				proxier.natRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(internalTrafficChain),</span><br><span class="line">					args,</span><br><span class="line">					proxier.localDetector.IfNotLocal(),</span><br><span class="line">					<span class="string">"-j"</span>, <span class="keyword">string</span>(kubeMarkMasqChain))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set up external traffic handling (if any "external" destinations are</span></span><br><span class="line">		<span class="comment">// enabled). All captured traffic for all external destinations should</span></span><br><span class="line">		<span class="comment">// jump to externalTrafficChain, which will handle some special cases and</span></span><br><span class="line">		<span class="comment">// then jump to externalPolicyChain.</span></span><br><span class="line">		<span class="keyword">if</span> usesExternalTrafficChain &#123;</span><br><span class="line">			proxier.natChains.Write(utiliptables.MakeChainLine(externalTrafficChain))</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> !svcInfo.ExternalPolicyLocal() &#123;</span><br><span class="line">				<span class="comment">// If we are using non-local endpoints we need to masquerade,</span></span><br><span class="line">				<span class="comment">// in case we cross nodes.</span></span><br><span class="line">				proxier.natRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(externalTrafficChain),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"masquerade traffic for %s external destinations"`</span>, svcPortNameString),</span><br><span class="line">					<span class="string">"-j"</span>, <span class="keyword">string</span>(kubeMarkMasqChain))</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// If we are only using same-node endpoints, we can retain the</span></span><br><span class="line">				<span class="comment">// source IP in most cases.</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> proxier.localDetector.IsImplemented() &#123;</span><br><span class="line">					<span class="comment">// Treat all locally-originated pod -&gt; external destination</span></span><br><span class="line">					<span class="comment">// traffic as a special-case.  It is subject to neither</span></span><br><span class="line">					<span class="comment">// form of traffic policy, which simulates going up-and-out</span></span><br><span class="line">					<span class="comment">// to an external load-balancer and coming back in.</span></span><br><span class="line">					proxier.natRules.Write(</span><br><span class="line">						<span class="string">"-A"</span>, <span class="keyword">string</span>(externalTrafficChain),</span><br><span class="line">						<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"pod traffic for %s external destinations"`</span>, svcPortNameString),</span><br><span class="line">						proxier.localDetector.IfLocal(),</span><br><span class="line">						<span class="string">"-j"</span>, <span class="keyword">string</span>(clusterPolicyChain))</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Locally originated traffic (not a pod, but the host node)</span></span><br><span class="line">				<span class="comment">// still needs masquerade because the LBIP itself is a local</span></span><br><span class="line">				<span class="comment">// address, so that will be the chosen source IP.</span></span><br><span class="line">				proxier.natRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(externalTrafficChain),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"masquerade LOCAL traffic for %s external destinations"`</span>, svcPortNameString),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"addrtype"</span>, <span class="string">"--src-type"</span>, <span class="string">"LOCAL"</span>,</span><br><span class="line">					<span class="string">"-j"</span>, <span class="keyword">string</span>(kubeMarkMasqChain))</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Redirect all src-type=LOCAL -&gt; external destination to the</span></span><br><span class="line">				<span class="comment">// policy=cluster chain. This allows traffic originating</span></span><br><span class="line">				<span class="comment">// from the host to be redirected to the service correctly.</span></span><br><span class="line">				proxier.natRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(externalTrafficChain),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"route LOCAL traffic for %s external destinations"`</span>, svcPortNameString),</span><br><span class="line">					<span class="string">"-m"</span>, <span class="string">"addrtype"</span>, <span class="string">"--src-type"</span>, <span class="string">"LOCAL"</span>,</span><br><span class="line">					<span class="string">"-j"</span>, <span class="keyword">string</span>(clusterPolicyChain))</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Anything else falls thru to the appropriate policy chain.</span></span><br><span class="line">			<span class="keyword">if</span> hasExternalEndpoints &#123;</span><br><span class="line">				proxier.natRules.Write(</span><br><span class="line">					<span class="string">"-A"</span>, <span class="keyword">string</span>(externalTrafficChain),</span><br><span class="line">					<span class="string">"-j"</span>, <span class="keyword">string</span>(externalPolicyChain))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set up firewall chain, if needed</span></span><br><span class="line">		<span class="keyword">if</span> usesFWChain &#123;</span><br><span class="line">			proxier.natChains.Write(utiliptables.MakeChainLine(fwChain))</span><br><span class="line"></span><br><span class="line">			<span class="comment">// The service firewall rules are created based on the</span></span><br><span class="line">			<span class="comment">// loadBalancerSourceRanges field. This only works for VIP-like</span></span><br><span class="line">			<span class="comment">// loadbalancers that preserve source IPs. For loadbalancers which</span></span><br><span class="line">			<span class="comment">// direct traffic to service NodePort, the firewall rules will not</span></span><br><span class="line">			<span class="comment">// apply.</span></span><br><span class="line">			args = <span class="built_in">append</span>(args[:<span class="number">0</span>],</span><br><span class="line">				<span class="string">"-A"</span>, <span class="keyword">string</span>(fwChain),</span><br><span class="line">				<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"%s loadbalancer IP"`</span>, svcPortNameString),</span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// firewall filter based on each source range</span></span><br><span class="line">			allowFromNode := <span class="literal">false</span></span><br><span class="line">			<span class="keyword">for</span> _, src := <span class="keyword">range</span> svcInfo.LoadBalancerSourceRanges() &#123;</span><br><span class="line">				proxier.natRules.Write(args, <span class="string">"-s"</span>, src, <span class="string">"-j"</span>, <span class="keyword">string</span>(externalTrafficChain))</span><br><span class="line">				_, cidr, err := netutils.ParseCIDRSloppy(src)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					klog.ErrorS(err, <span class="string">"Error parsing CIDR in LoadBalancerSourceRanges, dropping it"</span>, <span class="string">"cidr"</span>, cidr)</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> cidr.Contains(proxier.nodeIP) &#123;</span><br><span class="line">					allowFromNode = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// For VIP-like LBs, the VIP is often added as a local</span></span><br><span class="line">			<span class="comment">// address (via an IP route rule).  In that case, a request</span></span><br><span class="line">			<span class="comment">// from a node to the VIP will not hit the loadbalancer but</span></span><br><span class="line">			<span class="comment">// will loop back with the source IP set to the VIP.  We</span></span><br><span class="line">			<span class="comment">// need the following rules to allow requests from this node.</span></span><br><span class="line">			<span class="keyword">if</span> allowFromNode &#123;</span><br><span class="line">				<span class="keyword">for</span> _, lbip := <span class="keyword">range</span> svcInfo.LoadBalancerIPStrings() &#123;</span><br><span class="line">					proxier.natRules.Write(</span><br><span class="line">						args,</span><br><span class="line">						<span class="string">"-s"</span>, lbip,</span><br><span class="line">						<span class="string">"-j"</span>, <span class="keyword">string</span>(externalTrafficChain))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// If the packet was able to reach the end of firewall chain,</span></span><br><span class="line">			<span class="comment">// then it did not get DNATed, so it will match the</span></span><br><span class="line">			<span class="comment">// corresponding KUBE-PROXY-FIREWALL rule.</span></span><br><span class="line">			proxier.natRules.Write(</span><br><span class="line">				<span class="string">"-A"</span>, <span class="keyword">string</span>(fwChain),</span><br><span class="line">				<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, fmt.Sprintf(<span class="string">`"other traffic to %s will be dropped by KUBE-PROXY-FIREWALL"`</span>, svcPortNameString),</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If Cluster policy is in use, create the chain and create rules jumping</span></span><br><span class="line">		<span class="comment">// from clusterPolicyChain to the clusterEndpoints</span></span><br><span class="line">		<span class="keyword">if</span> usesClusterPolicyChain &#123;</span><br><span class="line">			proxier.natChains.Write(utiliptables.MakeChainLine(clusterPolicyChain))</span><br><span class="line">			proxier.writeServiceToEndpointRules(svcPortNameString, svcInfo, clusterPolicyChain, clusterEndpoints, args)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If Local policy is in use, create the chain and create rules jumping</span></span><br><span class="line">		<span class="comment">// from localPolicyChain to the localEndpoints</span></span><br><span class="line">		<span class="keyword">if</span> usesLocalPolicyChain &#123;</span><br><span class="line">			proxier.natChains.Write(utiliptables.MakeChainLine(localPolicyChain))</span><br><span class="line">			proxier.writeServiceToEndpointRules(svcPortNameString, svcInfo, localPolicyChain, localEndpoints, args)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Generate the per-endpoint chains.</span></span><br><span class="line">		<span class="keyword">for</span> _, ep := <span class="keyword">range</span> allLocallyReachableEndpoints &#123;</span><br><span class="line">			epInfo, ok := ep.(*endpointsInfo)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				klog.ErrorS(<span class="literal">nil</span>, <span class="string">"Failed to cast endpointsInfo"</span>, <span class="string">"endpointsInfo"</span>, ep)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			endpointChain := epInfo.ChainName</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Create the endpoint chain</span></span><br><span class="line">			proxier.natChains.Write(utiliptables.MakeChainLine(endpointChain))</span><br><span class="line">			activeNATChains[endpointChain] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">			args = <span class="built_in">append</span>(args[:<span class="number">0</span>], <span class="string">"-A"</span>, <span class="keyword">string</span>(endpointChain))</span><br><span class="line">			args = proxier.appendServiceCommentLocked(args, svcPortNameString)</span><br><span class="line">			<span class="comment">// Handle traffic that loops back to the originator with SNAT.</span></span><br><span class="line">			proxier.natRules.Write(</span><br><span class="line">				args,</span><br><span class="line">				<span class="string">"-s"</span>, epInfo.IP(),</span><br><span class="line">				<span class="string">"-j"</span>, <span class="keyword">string</span>(kubeMarkMasqChain))</span><br><span class="line">			<span class="comment">// Update client-affinity lists.</span></span><br><span class="line">			<span class="keyword">if</span> svcInfo.SessionAffinityType() == v1.ServiceAffinityClientIP &#123;</span><br><span class="line">				args = <span class="built_in">append</span>(args, <span class="string">"-m"</span>, <span class="string">"recent"</span>, <span class="string">"--name"</span>, <span class="keyword">string</span>(endpointChain), <span class="string">"--set"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// DNAT to final destination.</span></span><br><span class="line">			args = <span class="built_in">append</span>(args, <span class="string">"-m"</span>, protocol, <span class="string">"-p"</span>, protocol, <span class="string">"-j"</span>, <span class="string">"DNAT"</span>, <span class="string">"--to-destination"</span>, epInfo.Endpoint)</span><br><span class="line">			proxier.natRules.Write(args)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delete chains no longer in use. Since "iptables-save" can take several seconds</span></span><br><span class="line">	<span class="comment">// to run on hosts with lots of iptables rules, we don't bother to do this on</span></span><br><span class="line">	<span class="comment">// every sync in large clusters. (Stale chains will not be referenced by any</span></span><br><span class="line">	<span class="comment">// active rules, so they're harmless other than taking up memory.)</span></span><br><span class="line">	<span class="keyword">if</span> !proxier.largeClusterMode || time.Since(proxier.lastIPTablesCleanup) &gt; proxier.syncPeriod &#123;</span><br><span class="line">		<span class="keyword">var</span> existingNATChains <span class="keyword">map</span>[utiliptables.Chain]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">		proxier.iptablesData.Reset()</span><br><span class="line">		<span class="keyword">if</span> err := proxier.iptables.SaveInto(utiliptables.TableNAT, proxier.iptablesData); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			existingNATChains = utiliptables.GetChainsFromTable(proxier.iptablesData.Bytes())</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> chain := <span class="keyword">range</span> existingNATChains &#123;</span><br><span class="line">				<span class="keyword">if</span> !activeNATChains[chain] &#123;</span><br><span class="line">					chainString := <span class="keyword">string</span>(chain)</span><br><span class="line">					<span class="keyword">if</span> !isServiceChainName(chainString) &#123;</span><br><span class="line">						<span class="comment">// Ignore chains that aren't ours.</span></span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// We must (as per iptables) write a chain-line</span></span><br><span class="line">					<span class="comment">// for it, which has the nice effect of flushing</span></span><br><span class="line">					<span class="comment">// the chain. Then we can remove the chain.</span></span><br><span class="line">					proxier.natChains.Write(utiliptables.MakeChainLine(chain))</span><br><span class="line">					proxier.natRules.Write(<span class="string">"-X"</span>, chainString)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			proxier.lastIPTablesCleanup = time.Now()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.ErrorS(err, <span class="string">"Failed to execute iptables-save: stale chains will not be deleted"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, tail-call to the nodePorts chain.  This needs to be after all</span></span><br><span class="line">	<span class="comment">// other service portal rules.</span></span><br><span class="line">	nodeAddresses, err := proxier.nodePortAddresses.GetNodeAddresses(proxier.networkInterfacer)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">"Failed to get node ip address matching nodeport cidrs, services with nodeport may not work as intended"</span>, <span class="string">"CIDRs"</span>, proxier.nodePortAddresses)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// nodeAddresses may contain dual-stack zero-CIDRs if proxier.nodePortAddresses is empty.</span></span><br><span class="line">	<span class="comment">// Ensure nodeAddresses only contains the addresses for this proxier's IP family.</span></span><br><span class="line">	<span class="keyword">for</span> addr := <span class="keyword">range</span> nodeAddresses &#123;</span><br><span class="line">		<span class="keyword">if</span> utilproxy.IsZeroCIDR(addr) &amp;&amp; isIPv6 == netutils.IsIPv6CIDRString(addr) &#123;</span><br><span class="line">			<span class="comment">// if any of the addresses is zero cidr of this IP family, non-zero IPs can be excluded.</span></span><br><span class="line">			nodeAddresses = sets.New[<span class="keyword">string</span>](addr)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> address := <span class="keyword">range</span> nodeAddresses &#123;</span><br><span class="line">		<span class="keyword">if</span> utilproxy.IsZeroCIDR(address) &#123;</span><br><span class="line">			destinations := []<span class="keyword">string</span>&#123;<span class="string">"-m"</span>, <span class="string">"addrtype"</span>, <span class="string">"--dst-type"</span>, <span class="string">"LOCAL"</span>&#125;</span><br><span class="line">			<span class="keyword">if</span> isIPv6 &#123;</span><br><span class="line">				<span class="comment">// For IPv6, Regardless of the value of localhostNodePorts is true</span></span><br><span class="line">				<span class="comment">// or false, we should disable access to the nodePort via localhost. Since it never works and always</span></span><br><span class="line">				<span class="comment">// cause kernel warnings.</span></span><br><span class="line">				destinations = <span class="built_in">append</span>(destinations, <span class="string">"!"</span>, <span class="string">"-d"</span>, <span class="string">"::1/128"</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> !proxier.localhostNodePorts &amp;&amp; !isIPv6 &#123;</span><br><span class="line">				<span class="comment">// If set localhostNodePorts to "false"(route_localnet=0), We should generate iptables rules that</span></span><br><span class="line">				<span class="comment">// disable NodePort services to be accessed via localhost. Since it doesn't work and causes</span></span><br><span class="line">				<span class="comment">// the kernel to log warnings if anyone tries.</span></span><br><span class="line">				destinations = <span class="built_in">append</span>(destinations, <span class="string">"!"</span>, <span class="string">"-d"</span>, <span class="string">"127.0.0.0/8"</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			proxier.natRules.Write(</span><br><span class="line">				<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeServicesChain),</span><br><span class="line">				<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, <span class="string">`"kubernetes service nodeports; NOTE: this must be the last rule in this chain"`</span>,</span><br><span class="line">				destinations,</span><br><span class="line">				<span class="string">"-j"</span>, <span class="keyword">string</span>(kubeNodePortsChain))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Ignore IP addresses with incorrect version</span></span><br><span class="line">		<span class="keyword">if</span> isIPv6 &amp;&amp; !netutils.IsIPv6String(address) || !isIPv6 &amp;&amp; netutils.IsIPv6String(address) &#123;</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">"IP has incorrect IP version"</span>, <span class="string">"IP"</span>, address)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// For ipv6, Regardless of the value of localhostNodePorts is true or false, we should disallow access</span></span><br><span class="line">		<span class="comment">// to the nodePort via lookBack address.</span></span><br><span class="line">		<span class="keyword">if</span> isIPv6 &amp;&amp; utilproxy.IsLoopBack(address) &#123;</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">"disallow nodePort services to be accessed via ipv6 localhost address"</span>, <span class="string">"IP"</span>, address)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// For ipv4, When localhostNodePorts is set to false, Ignore ipv4 lookBack address</span></span><br><span class="line">		<span class="keyword">if</span> !isIPv6 &amp;&amp; utilproxy.IsLoopBack(address) &amp;&amp; !proxier.localhostNodePorts &#123;</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">"disallow nodePort services to be accessed via ipv4 localhost address"</span>, <span class="string">"IP"</span>, address)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// create nodeport rules for each IP one by one</span></span><br><span class="line">		proxier.natRules.Write(</span><br><span class="line">			<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeServicesChain),</span><br><span class="line">			<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, <span class="string">`"kubernetes service nodeports; NOTE: this must be the last rule in this chain"`</span>,</span><br><span class="line">			<span class="string">"-d"</span>, address,</span><br><span class="line">			<span class="string">"-j"</span>, <span class="keyword">string</span>(kubeNodePortsChain))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Drop the packets in INVALID state, which would potentially cause</span></span><br><span class="line">	<span class="comment">// unexpected connection reset.</span></span><br><span class="line">	<span class="comment">// https://github.com/kubernetes/kubernetes/issues/74839</span></span><br><span class="line">	proxier.filterRules.Write(</span><br><span class="line">		<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeForwardChain),</span><br><span class="line">		<span class="string">"-m"</span>, <span class="string">"conntrack"</span>,</span><br><span class="line">		<span class="string">"--ctstate"</span>, <span class="string">"INVALID"</span>,</span><br><span class="line">		<span class="string">"-j"</span>, <span class="string">"DROP"</span>,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the masqueradeMark has been added then we want to forward that same</span></span><br><span class="line">	<span class="comment">// traffic, this allows NodePort traffic to be forwarded even if the default</span></span><br><span class="line">	<span class="comment">// FORWARD policy is not accept.</span></span><br><span class="line">	proxier.filterRules.Write(</span><br><span class="line">		<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeForwardChain),</span><br><span class="line">		<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, <span class="string">`"kubernetes forwarding rules"`</span>,</span><br><span class="line">		<span class="string">"-m"</span>, <span class="string">"mark"</span>, <span class="string">"--mark"</span>, fmt.Sprintf(<span class="string">"%s/%s"</span>, proxier.masqueradeMark, proxier.masqueradeMark),</span><br><span class="line">		<span class="string">"-j"</span>, <span class="string">"ACCEPT"</span>,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The following rule ensures the traffic after the initial packet accepted</span></span><br><span class="line">	<span class="comment">// by the "kubernetes forwarding rules" rule above will be accepted.</span></span><br><span class="line">	proxier.filterRules.Write(</span><br><span class="line">		<span class="string">"-A"</span>, <span class="keyword">string</span>(kubeForwardChain),</span><br><span class="line">		<span class="string">"-m"</span>, <span class="string">"comment"</span>, <span class="string">"--comment"</span>, <span class="string">`"kubernetes forwarding conntrack rule"`</span>,</span><br><span class="line">		<span class="string">"-m"</span>, <span class="string">"conntrack"</span>,</span><br><span class="line">		<span class="string">"--ctstate"</span>, <span class="string">"RELATED,ESTABLISHED"</span>,</span><br><span class="line">		<span class="string">"-j"</span>, <span class="string">"ACCEPT"</span>,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	metrics.IptablesRulesTotal.WithLabelValues(<span class="keyword">string</span>(utiliptables.TableFilter)).Set(<span class="keyword">float64</span>(proxier.filterRules.Lines()))</span><br><span class="line">	metrics.IptablesRulesTotal.WithLabelValues(<span class="keyword">string</span>(utiliptables.TableNAT)).Set(<span class="keyword">float64</span>(proxier.natRules.Lines()))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sync rules.</span></span><br><span class="line">	proxier.iptablesData.Reset()</span><br><span class="line">	proxier.iptablesData.WriteString(<span class="string">"*filter\n"</span>)</span><br><span class="line">	proxier.iptablesData.Write(proxier.filterChains.Bytes())</span><br><span class="line">	proxier.iptablesData.Write(proxier.filterRules.Bytes())</span><br><span class="line">	proxier.iptablesData.WriteString(<span class="string">"COMMIT\n"</span>)</span><br><span class="line">	proxier.iptablesData.WriteString(<span class="string">"*nat\n"</span>)</span><br><span class="line">	proxier.iptablesData.Write(proxier.natChains.Bytes())</span><br><span class="line">	proxier.iptablesData.Write(proxier.natRules.Bytes())</span><br><span class="line">	proxier.iptablesData.WriteString(<span class="string">"COMMIT\n"</span>)</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">2</span>).InfoS(<span class="string">"Reloading service iptables data"</span>,</span><br><span class="line">		<span class="string">"numServices"</span>, <span class="built_in">len</span>(proxier.svcPortMap),</span><br><span class="line">		<span class="string">"numEndpoints"</span>, totalEndpoints,</span><br><span class="line">		<span class="string">"numFilterChains"</span>, proxier.filterChains.Lines(),</span><br><span class="line">		<span class="string">"numFilterRules"</span>, proxier.filterRules.Lines(),</span><br><span class="line">		<span class="string">"numNATChains"</span>, proxier.natChains.Lines(),</span><br><span class="line">		<span class="string">"numNATRules"</span>, proxier.natRules.Lines(),</span><br><span class="line">	)</span><br><span class="line">	klog.V(<span class="number">9</span>).InfoS(<span class="string">"Restoring iptables"</span>, <span class="string">"rules"</span>, proxier.iptablesData.Bytes())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> NoFlushTables is used so we don't flush non-kubernetes chains in the table</span></span><br><span class="line">	err = proxier.iptables.RestoreAll(proxier.iptablesData.Bytes(), utiliptables.NoFlushTables, utiliptables.RestoreCounters)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> pErr, ok := err.(utiliptables.ParseError); ok &#123;</span><br><span class="line">			lines := utiliptables.ExtractLines(proxier.iptablesData.Bytes(), pErr.Line(), <span class="number">3</span>)</span><br><span class="line">			klog.ErrorS(pErr, <span class="string">"Failed to execute iptables-restore"</span>, <span class="string">"rules"</span>, lines)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.ErrorS(err, <span class="string">"Failed to execute iptables-restore"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		metrics.IptablesRestoreFailuresTotal.Inc()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	success = <span class="literal">true</span></span><br><span class="line">	proxier.needFullSync = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> name, lastChangeTriggerTimes := <span class="keyword">range</span> endpointUpdateResult.LastChangeTriggerTimes &#123;</span><br><span class="line">		<span class="keyword">for</span> _, lastChangeTriggerTime := <span class="keyword">range</span> lastChangeTriggerTimes &#123;</span><br><span class="line">			latency := metrics.SinceInSeconds(lastChangeTriggerTime)</span><br><span class="line">			metrics.NetworkProgrammingLatency.Observe(latency)</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">"Network programming"</span>, <span class="string">"endpoint"</span>, klog.KRef(name.Namespace, name.Name), <span class="string">"elapsed"</span>, latency)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	metrics.SyncProxyRulesNoLocalEndpointsTotal.WithLabelValues(<span class="string">"internal"</span>).Set(<span class="keyword">float64</span>(serviceNoLocalEndpointsTotalInternal))</span><br><span class="line">	metrics.SyncProxyRulesNoLocalEndpointsTotal.WithLabelValues(<span class="string">"external"</span>).Set(<span class="keyword">float64</span>(serviceNoLocalEndpointsTotalExternal))</span><br><span class="line">	<span class="keyword">if</span> proxier.healthzServer != <span class="literal">nil</span> &#123;</span><br><span class="line">		proxier.healthzServer.Updated()</span><br><span class="line">	&#125;</span><br><span class="line">	metrics.SyncProxyRulesLastTimestamp.SetToCurrentTime()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update service healthchecks.  The endpoints list might include services that are</span></span><br><span class="line">	<span class="comment">// not "OnlyLocal", but the services list will not, and the serviceHealthServer</span></span><br><span class="line">	<span class="comment">// will just drop those endpoints.</span></span><br><span class="line">	<span class="keyword">if</span> err := proxier.serviceHealthServer.SyncServices(proxier.svcPortMap.HealthCheckNodePorts()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">"Error syncing healthcheck services"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := proxier.serviceHealthServer.SyncEndpoints(proxier.endpointsMap.LocalReadyEndpoints()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">"Error syncing healthcheck endpoints"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finish housekeeping, clear stale conntrack entries for UDP Services</span></span><br><span class="line">	conntrack.CleanStaleEntries(proxier.iptables.IsIPv6(), proxier.exec, proxier.svcPortMap, serviceUpdateResult, endpointUpdateResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/cmd/kube-proxy/proxy.go" target="_blank" rel="noopener">cmd/kube-proxy/proxy.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/cmd/kube-proxy/app/server.go" target="_blank" rel="noopener">cmd/kube-proxy/app/server.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/cmd/kube-proxy/app/server_others.go" target="_blank" rel="noopener">cmd/kube-proxy/app/server_others.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/proxy/config/config.go" target="_blank" rel="noopener">pkg/proxy/config/config.go</a><br>5.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/proxy/ipvs/proxier.go" target="_blank" rel="noopener">pkg/proxy/ipvs/proxier.go</a><br>6.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/proxy/iptables/proxier.go" target="_blank" rel="noopener">pkg/proxy/iptables/proxier.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s Deployment滚动升级可可靠吗</title>
    <url>/2023/04/19/k8s%E6%97%A0%E6%8D%9F%E5%8D%87%E7%BA%A7%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p><code>Kubernetes Deployment</code>使用滚动升级策略进行升级，可以保证升级过程中的可靠性和容错性。</p>
<p>滚动升级通过逐步将新版本的<code>Pod</code>逐步添加到服务中，同时逐步停止旧版本的<code>Pod</code>，实现了服务的无停机升级。在升级过程中，<code>Kubernetes</code>会监控新版本Pod的运行状态，并在满足指定的健康检查条件之后才继续升级下一个<code>Pod</code>，确保服务的稳定性和可靠性。<br>使用<code>Deployment</code>滚动升级虽说可以实现无停机服务，但是它是完全客户端无感吗?<br>答案是否定的!!!</p>
<p>我们来做个实验,使用go提供一个简单的接口。<br>超时时间为30s,方便实验。</p>
<h5 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个HTTP服务器</span></span><br><span class="line">	server := &amp;http.Server&#123;</span><br><span class="line">		Addr: <span class="string">":8080"</span>,</span><br><span class="line">		Handler: http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">			<span class="comment">// 处理请求</span></span><br><span class="line">			time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">			fmt.Fprintln(w, <span class="string">"Hello, World!"</span>)</span><br><span class="line">		&#125;),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置超时时间为30秒</span></span><br><span class="line">	server.ReadTimeout = <span class="number">30</span> * time.Second</span><br><span class="line">	server.WriteTimeout = <span class="number">30</span> * time.Second</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动服务器</span></span><br><span class="line">	err := server.ListenAndServe()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"服务器启动失败:"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM golang:1.17-alpine AS builder</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line">RUN go build -o main</span><br><span class="line"></span><br><span class="line">RUN chmod +x main</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [&quot;./main&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ curl http://127.0.0.1:8080</span><br><span class="line">curl: (52) Empty reply from server</span><br></pre></td></tr></table></figure>
<h5 id="构建一个镜像"><a href="#构建一个镜像" class="headerlink" title="构建一个镜像"></a>构建一个镜像</h5><p>将下面的代码保存为<code>Dockerfile</code>,然后使用<code>nerdctl</code>构建镜像,也可以直接拉取。<code>nerdctl</code>的安装可参考附录。<br><code>sudo nerdctl build -t hysyeah/my-curl:v1 .</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM golang:1.17-alpine AS builder</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line">RUN go build -o main</span><br><span class="line"></span><br><span class="line">RUN chmod +x main</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [&quot;./main&quot;]</span><br></pre></td></tr></table></figure>
<h5 id="以Deployment形式启动"><a href="#以Deployment形式启动" class="headerlink" title="以Deployment形式启动"></a>以Deployment形式启动</h5><p>设置3个复本，策略为<code>RollingUpdate</code>。<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-curl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-curl</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">my-curl</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-curl</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">hysyeah/my-curl:v1</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-curl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-curl</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p>
<h5 id="测试滚动升级"><a href="#测试滚动升级" class="headerlink" title="测试滚动升级"></a>测试滚动升级</h5><h6 id="启动Deployment"><a href="#启动Deployment" class="headerlink" title="启动Deployment"></a>启动Deployment</h6><p><code>kubectl apply -f deployment.yaml</code></p>
<h6 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h6><p><code>curl http://127.0.0.1:31918</code></p>
<h5 id="升级Deployment"><a href="#升级Deployment" class="headerlink" title="升级Deployment"></a>升级Deployment</h5><p>在服务返回之前，升级Deployment(直接修改image,然后apply)，然后你会得到如下错误。<br>说明<code>Deployment</code>升级对客户端是有影响。为什么会有影响可以参考<a href="https://hysyeah.top/2023/04/18/%E4%B8%80%E4%B8%AApod%E7%9A%84%E7%BB%88%E6%AD%A2%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">一个pod的终止流程</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ curl http://127.0.0.1:31918</span><br><span class="line">curl: (52) Empty reply from server</span><br></pre></td></tr></table></figure>
<p>原因是虽说是滚动升级，<code>Deployment</code>只保证在升级过程中服务不会中止并不会保证，已有的请求它并不会保证处理完。</p>
<h5 id="如何对客户端无感"><a href="#如何对客户端无感" class="headerlink" title="如何对客户端无感"></a>如何对客户端无感</h5><h6 id="在应用中优雅退出"><a href="#在应用中优雅退出" class="headerlink" title="在应用中优雅退出"></a>在应用中优雅退出</h6><p>在退出中使用优雅退出机制，监听<code>SIGTERM</code>信号。可以参考<a href="https://hysyeah.top/2023/04/18/%E4%B8%80%E4%B8%AApod%E7%9A%84%E7%BB%88%E6%AD%A2%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">一个pod的终止流程</a>，了解<code>pod</code>是如何退出的。</p>
<h6 id="使用pre-stop-hook"><a href="#使用pre-stop-hook" class="headerlink" title="使用pre-stop hook"></a>使用pre-stop hook</h6><p>Pod钩子是在Pod生命周期的不同阶段中执行的命令或脚本。使用Pod钩子，可以在Pod启动之前或之后，容器启动之前或之后，容器退出之前或之后等时刻执行定制化的逻辑。</p>
<p>Pod钩子支持的钩子类型有以下四种：</p>
<p>PostStart: Pod创建后，容器创建前执行。<br>PreStop: 容器退出前执行，可用于准备容器退出前的工作，如保存状态、备份数据等。<br>PreStart: Pod创建后，容器创建前执行，但只在容器是第一个启动的容器时才执行。<br>PostStop: 容器退出后执行，用于清理容器退出后的工作。</p>
<p>可以使用<code>pre-stop</code> hook在容器退出前执行一段代码或脚本。<br>添加preStop在容器退出前休眠20s,再次执行<code>curl</code>命令和升级操作发现接口能被正常处理。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-curl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-curl</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">my-curl</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-curl</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">hysyeah/my-curl:gracefulv2</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">lifecycle:</span></span><br><span class="line">            <span class="attr">preStop:</span></span><br><span class="line">              <span class="attr">exec:</span></span><br><span class="line">                <span class="attr">command:</span> <span class="string">["sleep","20"]</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<hr>
<h5 id="附录-nerdctl套装安装"><a href="#附录-nerdctl套装安装" class="headerlink" title="附录-nerdctl套装安装"></a>附录-nerdctl套装安装</h5><p><a href="https://github.com/containerd/nerdctl/releases" target="_blank" rel="noopener">下载</a>对应的压缩包,解压执行如下命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ cp lib/systemd/system/buildkit.service /lib/systemd/system/</span><br><span class="line">➜ sudo cp bin/buildkitd /usr/local/bin/</span><br><span class="line">➜ sudo cp bin/nerdctl /usr/local/bin/</span><br><span class="line">➜ sudo cp bin/buildctl /usr/local/bin/</span><br><span class="line"></span><br><span class="line">➜ sudo systemctl start buildkit </span><br><span class="line">➜ systemctl status buildkit</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://iximiuz.com/en/posts/containerd-command-line-clients/" target="_blank" rel="noopener">https://iximiuz.com/en/posts/containerd-command-line-clients/</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s Golang代码编码规范</title>
    <url>/2020/06/24/k8s%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>总结下k8s项目编码规范，加深记忆。</p>
<p>编码规范可参阅<a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a>.</p>
<h4 id="1-Gofmt"><a href="#1-Gofmt" class="headerlink" title="1.Gofmt"></a>1.Gofmt</h4><p> 所有的代码都必须使用<code>gofmt</code>进行格式化，可选的工具还包括<code>goimports</code>(可看作gofmt的超集)</p>
<h4 id="2-注释语句"><a href="#2-注释语句" class="headerlink" title="2.注释语句"></a>2.注释语句</h4><p> 注释必须完整，清楚，允许一定的冗余。注释应该必须以描述的资源开头。<br> 比如你注释的是一个函数就应该以函数名开头，注释的是一个结构体就应该以结构体的名称开头并以<code>.</code>结尾<br> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Request represents a request to run a command.</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123; ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode writes the JSON encoding of req to w.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(w io.Writer, req *Request)</span></span> &#123; ...</span><br></pre></td></tr></table></figure></p>
<h4 id="3-Context"><a href="#3-Context" class="headerlink" title="3.Context"></a>3.Context</h4><p>如果一个函数中有参数类型为<code>Context</code>,一般把它作为第一个Ref<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">(ctx context.Context, /* other arguments */)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-复制"><a href="#4-复制" class="headerlink" title="4.复制"></a>4.复制</h4><p>To avoid unexpected aliasing, be careful when copying a struct from another package. For example, the bytes.Buffer type contains a []byte slice. If you copy a Buffer, the slice in the copy may alias the array in the original, causing subsequent method calls to have surprising effects.</p>
<p>In general, do not copy a value of type T if its methods are associated with the pointer type, *T.</p>
<h4 id="5-Crypto-Rand"><a href="#5-Crypto-Rand" class="headerlink" title="5.Crypto Rand"></a>5.Crypto Rand</h4><p>不要使用<code>math/rand</code>来生成私钥，即使只生成一次。如果没有设置种子，生成器生成的随机数完成是可预测的。使用<code>time.Nanosecond()</code>作为种子，种子差异比较小，使用<code>crypto/rand</code>来生成。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"crypto/rand"</span></span><br><span class="line">	<span class="comment">// "encoding/base64"</span></span><br><span class="line">	<span class="comment">// "encoding/hex"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Key</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>)</span><br><span class="line">	_, err := rand.Read(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)  <span class="comment">// out of randomness, should never happen</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%x"</span>, buf)</span><br><span class="line">	<span class="comment">// or hex.EncodeToString(buf)</span></span><br><span class="line">	<span class="comment">// or base64.StdEncoding.EncodeToString(buf)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-空切片"><a href="#6-空切片" class="headerlink" title="6.空切片"></a>6.空切片</h4><p>定义一个空切片，使用<code>var t []string</code>而不是<code>t := []string{}</code>。前者描述的是一个空的切片,后者是non-nil但长度为0的切片。两者在功能上是一样的(len和cap都为0)，但是我们倾向于使用前者。</p>
<p>当编码为一个<code>JSON</code>对象时，<code>nil</code>—&gt; null,<code>[]string{}</code> —&gt; <code>JSON array []</code>。</p>
<h4 id="7-文档注释－Doc-Comments"><a href="#7-文档注释－Doc-Comments" class="headerlink" title="7.文档注释－Doc Comments"></a>7.文档注释－Doc Comments</h4><p>All top-level, exported names should have doc comments, as should non-trivial unexported type or function declarations. See <a href="https://golang.org/doc/effective_go.html#commentary" target="_blank" rel="noopener">https://golang.org/doc/effective_go.html#commentary</a> for more information about commentary conventions.</p>
<h4 id="8-Don’t-Panic"><a href="#8-Don’t-Panic" class="headerlink" title="8.Don’t Panic"></a>8.Don’t Panic</h4><p>不要使用<code>panic</code>处理普通的错误。使用多返回值进行处理。</p>
<h4 id="9-Error-Strings"><a href="#9-Error-Strings" class="headerlink" title="9.Error Strings"></a>9.Error Strings</h4><p>日志字符串，一般不进行首字母大写(除非是专有名词)<br>use<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">fmt.Errorf(<span class="string">"something bad"</span>)</span><br></pre></td></tr></table></figure></p>
<p>not<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">fmt.Errorf(<span class="string">"Something bad"</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="10-示例"><a href="#10-示例" class="headerlink" title="10.示例"></a>10.示例</h4><p>当我们新增一个<code>package</code>时，需要提供一些可运行的例子或者简单的测试例子。</p>
<p><a href="https://blog.golang.org/examples" target="_blank" rel="noopener">https://blog.golang.org/examples</a></p>
<h4 id="11-Goroutine生命周期"><a href="#11-Goroutine生命周期" class="headerlink" title="11.Goroutine生命周期"></a>11.Goroutine生命周期</h4><p>Goroutine会导致内存泄漏当channel阻塞于发送或接收：垃圾收集器并不会终止Goroutine即使channel一直阻塞。<br>尽量使并发代码简单明了，Goroutine生命周期明显。如果过于复杂，可以添加注释表明Goroutine何时和为什么退出.</p>
<h4 id="12-处理错误"><a href="#12-处理错误" class="headerlink" title="12.处理错误"></a>12.处理错误</h4><p><a href="https://golang.org/doc/effective_go.html#errors" target="_blank" rel="noopener">https://golang.org/doc/effective_go.html#errors</a></p>
<h4 id="13-Imports"><a href="#13-Imports" class="headerlink" title="13. Imports"></a>13. Imports</h4><p>避免重命名imports,除非为了避免命名冲突;好的模块名一般不需要进行重命名。</p>
<p>对imports进行分类排序，<code>goimports</code>可以帮你完成这个操作。</p>
<h4 id="14-控制流"><a href="#14-控制流" class="headerlink" title="14. 控制流"></a>14. 控制流</h4><p>use<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// error handling</span></span><br><span class="line">	<span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br></pre></td></tr></table></figure></p>
<p>not<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// normal code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="15-首字母缩略词"><a href="#15-首字母缩略词" class="headerlink" title="15. 首字母缩略词"></a>15. 首字母缩略词</h4><p> 专有名词缩略词采用全大写。<br> 如：<code>URL</code>,<code>URLPony</code>,<code>ServeHTTP</code>,<code>appID</code></p>
<h4 id="16-Interfaces"><a href="#16-Interfaces" class="headerlink" title="16.Interfaces"></a>16.Interfaces</h4><p>Go接口通常属于使用接口类型的值的包，而不是实现这些值的包。 实现包应返回具体的（通常是指针或结构）类型：这样，可以将新方法添加到实现中，而无需进行大量重构。</p>
<p>不要在“用于模拟”的API的实现者端定义接口； 而是设计API，以便可以使用实际实现的公共API对其进行测试。</p>
<p>在使用接口之前，不要先定义它们：如果没有实际的用法示例，很难知道接口是否是必需的，更不用说接口应该包含什么方法了。</p>
<h4 id="17-模块注释"><a href="#17-模块注释" class="headerlink" title="17.模块注释"></a>17.模块注释</h4><p>模块注释必须在<code>package main</code>上面，而且不能有空格。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package math provides basic constants and mathematical functions.</span></span><br><span class="line"><span class="keyword">package</span> math</span><br></pre></td></tr></table></figure></p>
<h4 id="18-模块"><a href="#18-模块" class="headerlink" title="18.模块"></a>18.模块</h4><ul>
<li>Import Blank<br><code>import _ &quot;pkg</code>,<code>_</code>操作其实是引入该包,不直接使用包里面的函数,而是调用了该包里的init函数。不要这样使用，除非在<code>main package</code>中或者测试需要<br>－ Import Dot<br><code>import . &quot;fmt&quot;</code>可以省略包名调用包中的函数，这样会使代码可读性变差。除了在以一测试这种情况下尽量不要使用这种导入。<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> foo_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bar/testutil"</span> <span class="comment">// also imports "foo"</span></span><br><span class="line">	. <span class="string">"foo"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在上面这种情况下，测试文件不能导入<code>package foo</code>因为<code>bar/testutil</code>中已经导入了<code>foo</code>。<br>使用<code>import .</code>表示假装引入了包。这里还是有点不太明白？<br>  － Package Names<br>所有对包内资源的引用都必须通过包名，所以包名的命名是很重要的而且你可以适当省略掉一些无用的名称。<br>如<code>chubby.File</code>better than <code>chubby.ChubbyFile</code>。</p>
<h4 id="19-传值"><a href="#19-传值" class="headerlink" title="19.传值"></a>19.传值</h4><p>不要试图通过传递指针来节省空间。常见的实例包括传递指向字符串的指针（<em> string）或指向接口值的指针（</em> io.Reader）。 在这两种情况下，值本身都是固定大小，可以直接传递。 此建议不适用于大型<code>struct</code>，甚至不适用于可能增长的小型<code>struct</code>。</p>
<h4 id="20-接收者名称与接收者类型"><a href="#20-接收者名称与接收者类型" class="headerlink" title="20.接收者名称与接收者类型"></a>20.接收者名称与接收者类型</h4><p>  － 接收者名称<br>接收者名称必须使用有意义的名称，不能使用一些通用的名称，如<code>me,this,self</code>等。<br>  － 接收者类型<br>1.如果接收者是<code>map,func,chan</code>,不要使用指针。如果接收者是<code>slice</code>而且函数没有对<code>slice</code>进行reslice和reallocate操作，不要使用指针。<br>2.如果函数需要对接收都进行修改，则必须使用指针。<br>3.如果接收者是一个结构体并且包含<code>sync.Mutext</code>或者类似的同步字段，必须使用指针防止拷贝。<br>4.如果接收者是大的数组，结构体，使用指针会更高效。<br>Assume it’s equivalent to passing all its elements as arguments to the method. If that feels too large, it’s also too large for the receiver。<br>5.如果接收者是<code>struct,array,slice</code>，它们其中有字段指向可变的结构，最好使用指针。<br>6.如果接收方是一个很小的数组或结构，自然是一个值类型（例如，诸如time.Time类型），没有可变字段且没有指针，或者仅仅是一个简单的基本类型（如int或string），则<code>value</code>接收者是有道理的。 值接收器可以减少可以生成的垃圾数量； 如果将值传递给value方法，则可以使用堆栈上的副本来代替在堆上分配。 （编译器会尽量避免这种分配，但是它不可能总是成功。）由于这个原因，请勿在没有进行概要分析的情况下选择值接收器类型。<br>7.如果不确认使用如种类型，使用指针接收者。</p>
<h4 id="21-同步函数"><a href="#21-同步函数" class="headerlink" title="21.同步函数"></a>21.同步函数</h4><p>最好使用同步函数，同步函数直接返回结果，在返回之前完成所的调用或<code>channel ops</code>。同步函数更容易使用<code>goroutine</code>,更好的避免内存泄漏和数据竞争。还有一个好处就是使用同步方法可以更好的进行测试。如果调用者需要更高的并发性，可以将这个改造成一个单独的<code>goroutine</code>。</p>
<h4 id="22-出现错误必须提供有用的信息"><a href="#22-出现错误必须提供有用的信息" class="headerlink" title="22.出现错误必须提供有用的信息"></a>22.出现错误必须提供有用的信息</h4><p>对必要的地方，可能出错的地方打印日志。应该包含如下信息<code>什么错误，输入是什么，实际的结果是什么，预期的结果是什么</code>。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> got != tt.want &#123;</span><br><span class="line">	t.Errorf(<span class="string">"Foo(%q) = %d; want %d"</span>, tt.in, got, tt.want) <span class="comment">// or Fatalf, if test can't test anything more past this point</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="23-变量名称"><a href="#23-变量名称" class="headerlink" title="23.变量名称"></a>23.变量名称</h4><p>在<code>Go</code>中变量尽量简单明了。对于有限作用域的局部变量，尽量使用简短的变量。如<code>lincCount</code>—&gt;<code>c</code>,<code>sliceIndex</code>—&gt;<code>i</code>。</p>
<hr>
<p>内建函数<code>new</code>和<code>make</code>。<code>new</code>这个一个用来分配内存的内建函数，但它不初始化内存，只是将其置零。<code>new(T)</code>会为<code>T</code>类型的新项目分配被置零的存储，并且返回它的地址，一个类型为<code>*T</code>的值(返回一个指向新分配的类型为<code>T</code>,值为零的指针)<br>。<br><code>new([]int)</code>返回一个指向新分配的，被置零的<code>slice</code>结构体的指针，即指向<code>nil slice</code>值的指针。</p>
<p>内建函数<code>make(T, args)</code>与<code>new(T)的用途不一样，它只用于来创建</code>slice,map,channel<code>,并且返回一个初始化的的(而不是置零)，类型为</code>T`的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var p *[]int = new([]int)</span><br><span class="line">var v []int = make([]int, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<hr>
<p>Ref：<br>1.<a href="https://github.com/kubernetes/community/blob/master/contributors/guide/coding-conventions.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/guide/coding-conventions.md</a><br>2.<a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">effective-go</a><br>3.<a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">https://godoc.org/golang.org/x/tools/cmd/goimports</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s expiring cache</title>
    <url>/2023/09/23/k8s-expiring-cache/</url>
    <content><![CDATA[<p>如何实现一个带<code>ttl</code>的缓存。今天来学习下<code>k8s</code>源码中是怎么实现的。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/heap"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"k8s.io/utils/clock"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewExpiring 返回初始化后的Expiring</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewExpiring</span><span class="params">()</span> *<span class="title">Expiring</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewExpiringWithClock(clock.RealClock&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewExpiringWithClock 与NewExpiring的不同之处在于可以传入一个clock参数，方便在测试中使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewExpiringWithClock</span><span class="params">(clock clock.Clock)</span> *<span class="title">Expiring</span></span> &#123;</span><br><span class="line">    <span class="comment">// clock使用的是k8s封装过后的clock</span></span><br><span class="line">	<span class="keyword">return</span> &amp;Expiring&#123;</span><br><span class="line">		clock: clock,</span><br><span class="line">		cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]entry),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expiring is a map whose entries expire after a per-entry timeout.</span></span><br><span class="line"><span class="comment">// Expiring 实现一个可以设置过期时间的的缓存</span></span><br><span class="line"><span class="keyword">type</span> Expiring <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// AllowExpiredGet causes the expiration check to be skipped on Get.</span></span><br><span class="line">	<span class="comment">// It should only be used when a key always corresponds to the exact same value.</span></span><br><span class="line">	<span class="comment">// Thus when this field is true, expired keys are considered valid</span></span><br><span class="line">	<span class="comment">// until the next call to Set (which causes the GC to run).</span></span><br><span class="line">	<span class="comment">// It may not be changed concurrently with calls to Get.</span></span><br><span class="line">	<span class="comment">// 如果AllowExpiredGet为true, Get操作跳过过期检查</span></span><br><span class="line">	AllowExpiredGet <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	clock clock.Clock</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mu protects the below fields</span></span><br><span class="line">	mu sync.RWMutex</span><br><span class="line">	<span class="comment">// cache is the internal map that backs the cache.</span></span><br><span class="line">	cache <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]entry</span><br><span class="line">	<span class="comment">// generation is used as a cheap resource version for cache entries. Cleanups</span></span><br><span class="line">	<span class="comment">// are scheduled with a key and generation. When the cleanup runs, it first</span></span><br><span class="line">	<span class="comment">// compares its generation with the current generation of the entry. It</span></span><br><span class="line">	<span class="comment">// deletes the entry iff the generation matches. This prevents cleanups</span></span><br><span class="line">	<span class="comment">// scheduled for earlier versions of an entry from deleting later versions of</span></span><br><span class="line">	<span class="comment">// an entry when Set() is called multiple times with the same key.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The integer value of the generation of an entry is meaningless.</span></span><br><span class="line">	<span class="comment">// 当进行多次Set操作时,上次Set 操作中的gc可能还没有完成</span></span><br><span class="line">	<span class="comment">// 如果generation 与entry中的generation不一致,则说明值是新值</span></span><br><span class="line">	<span class="comment">// 则会跳过删除操作</span></span><br><span class="line">	generation <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	heap expiringHeap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	val        <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	expiry     time.Time</span><br><span class="line">	generation <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get looks up an entry in the cache.</span></span><br><span class="line"><span class="comment">// Get 根据key从map中获取对应的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Expiring)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(val <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	c.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">	e, ok := c.cache[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果不是跳过过期检查且key已经过期，返回nil, false</span></span><br><span class="line">	<span class="keyword">if</span> !c.AllowExpiredGet &amp;&amp; !c.clock.Now().Before(e.expiry) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> e.val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set sets a key/value/expiry entry in the map, overwriting any previous entry</span></span><br><span class="line"><span class="comment">// with the same key. The entry expires at the given expiry time, but its TTL</span></span><br><span class="line"><span class="comment">// may be lengthened or shortened by additional calls to Set(). Garbage</span></span><br><span class="line"><span class="comment">// collection of expired entries occurs during calls to Set(), however calls to</span></span><br><span class="line"><span class="comment">// Get() will not return expired entries that have not yet been garbage</span></span><br><span class="line"><span class="comment">// collected.</span></span><br><span class="line"><span class="comment">// Set 设置值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Expiring)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, val <span class="keyword">interface</span>&#123;&#125;, ttl time.Duration)</span></span> &#123;</span><br><span class="line">	now := c.clock.Now()</span><br><span class="line">	expiry := now.Add(ttl)</span><br><span class="line"></span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加generation</span></span><br><span class="line">	c.generation++</span><br><span class="line"></span><br><span class="line">	c.cache[key] = entry&#123;</span><br><span class="line">		val:        val,</span><br><span class="line">		expiry:     expiry,</span><br><span class="line">		generation: c.generation,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run GC inline before pushing the new entry.</span></span><br><span class="line">	<span class="comment">// 进行gc操作</span></span><br><span class="line">    <span class="comment">// 会一直进行gc清除操作直到队列长度等于0或者不存在过期的数据</span></span><br><span class="line">	c.gc(now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到优先队列中</span></span><br><span class="line">	heap.Push(&amp;c.heap, &amp;expiringHeapEntry&#123;</span><br><span class="line">		key:        key,</span><br><span class="line">		expiry:     expiry,</span><br><span class="line">		generation: c.generation,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete deletes an entry in the map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Expiring)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	c.del(key, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// del deletes the entry for the given key. The generation argument is the</span></span><br><span class="line"><span class="comment">// generation of the entry that should be deleted. If the generation has been</span></span><br><span class="line"><span class="comment">// changed (e.g. if a set has occurred on an existing element but the old</span></span><br><span class="line"><span class="comment">// cleanup still runs), this is a noop. If the generation argument is 0, the</span></span><br><span class="line"><span class="comment">// entry's generation is ignored and the entry is deleted.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// del must be called under the write lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Expiring)</span> <span class="title">del</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, generation <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	e, ok := c.cache[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这里会对generation进行比较，如果不相等则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> generation != <span class="number">0</span> &amp;&amp; generation != e.generation &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(c.cache, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len returns the number of items in the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Expiring)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	c.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(c.cache)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Expiring)</span> <span class="title">gc</span><span class="params">(now time.Time)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Return from gc if the heap is empty or the next element is not yet</span></span><br><span class="line">		<span class="comment">// expired.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// heap[0] is a peek at the next element in the heap, which is not obvious</span></span><br><span class="line">		<span class="comment">// from looking at the (*expiringHeap).Pop() implementation below.</span></span><br><span class="line">		<span class="comment">// heap.Pop() swaps the first entry with the last entry of the heap, then</span></span><br><span class="line">		<span class="comment">// calls (*expiringHeap).Pop() which returns the last element.</span></span><br><span class="line">		<span class="comment">// 如果heap长度为0 且第一个key没有过期,则直接返回</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(c.heap) == <span class="number">0</span> || now.Before(c.heap[<span class="number">0</span>].expiry) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从堆中pop, 然后删除map中的数据</span></span><br><span class="line">		cleanup := heap.Pop(&amp;c.heap).(*expiringHeapEntry)</span><br><span class="line">		c.del(cleanup.key, cleanup.generation)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> expiringHeapEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	key        <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	expiry     time.Time</span><br><span class="line">	generation <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// expiringHeap is a min-heap ordered by expiration time of its entries. The</span></span><br><span class="line"><span class="comment">// expiring cache uses this as a priority queue to efficiently organize entries</span></span><br><span class="line"><span class="comment">// which will be garbage collected once they expire.</span></span><br><span class="line"><span class="comment">// expiringHeap 使用的是最小堆，根据过期时间进行排序</span></span><br><span class="line"><span class="comment">// expiring cache使用最小堆作为一个优先队列，实现快速的过期删除</span></span><br><span class="line"><span class="keyword">type</span> expiringHeap []*expiringHeapEntry</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ heap.Interface = &amp;expiringHeap&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cq expiringHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(cq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less 较小的时间排在前面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cq expiringHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cq[i].expiry.Before(cq[j].expiry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cq expiringHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	cq[i], cq[j] = cq[j], cq[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cq *expiringHeap)</span> <span class="title">Push</span><span class="params">(c <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	*cq = <span class="built_in">append</span>(*cq, c.(*expiringHeapEntry))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cq *expiringHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	c := (*cq)[cq.Len()<span class="number">-1</span>]</span><br><span class="line">	*cq = (*cq)[:cq.Len()<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:</p>
<ol>
<li><a href="https://github.com/kubernetes/kubernetes/blob/e3bc35bc1bc7b399b564f2c4efc75eb9959e70f7/staging/src/k8s.io/apimachinery/pkg/util/cache/expiring.go" target="_blank" rel="noopener">expiring.go</a></li>
</ol>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码结构</title>
    <url>/2020/06/26/k8s%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>源码目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmd/</td>
<td>存放可执行文件的入口代码，每个可执行文件都会对应一个main函数</td>
</tr>
<tr>
<td>pkg/</td>
<td>存放核心库代码，可被项目内部或外部直接引用</td>
</tr>
<tr>
<td>vendor/</td>
<td>存放项目依赖的库代码，一般为每三方库代码</td>
</tr>
<tr>
<td>api/</td>
<td>存放OpenAPI/Swagger文件</td>
</tr>
<tr>
<td>build/</td>
<td>存放构建相关的脚本</td>
</tr>
<tr>
<td>test/</td>
<td>存放测试工具及测试数据</td>
</tr>
<tr>
<td>docs/</td>
<td>存放设计或用户使用文档</td>
</tr>
<tr>
<td>hack/</td>
<td>存放与构建，测试等相关的脚本</td>
</tr>
<tr>
<td>third_party/</td>
<td>存放第三方工具，代码或其他组件</td>
</tr>
<tr>
<td>plugin/</td>
<td>存放Kubernetes插件代码目录，例如认证，授权等相关插件</td>
</tr>
<tr>
<td>staging/</td>
<td>存放部分核心库的暂存目录</td>
</tr>
<tr>
<td>translations/</td>
<td>存放il8n(国际化)语言包的相关文件，可以在不修改内部代码的情况下支持不同语言及地区</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h6 id="k8s-io-kubernetes-cmd-kubectl-kubectl-go"><a href="#k8s-io-kubernetes-cmd-kubectl-kubectl-go" class="headerlink" title="k8s.io/kubernetes/cmd/kubectl/kubectl.go"></a>k8s.io/kubernetes/cmd/kubectl/kubectl.go</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano()) <span class="comment">//随机数种子</span></span><br><span class="line"></span><br><span class="line">	command := cmd.NewDefaultKubectlCommand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class="line">	<span class="comment">// cliflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class="line">	<span class="comment">// normalize func and add the go flag set by hand.</span></span><br><span class="line">	pflag.CommandLine.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)</span><br><span class="line">	pflag.CommandLine.AddGoFlagSet(goflag.CommandLine)</span><br><span class="line">	<span class="comment">// cliflag.InitFlags()</span></span><br><span class="line">	logs.InitLogs()</span><br><span class="line">	<span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>Makefile: 顶层Makefile文件，描述了整个项目所有代码文件的编译顺序，编译规则及编译后的二进制输出等<br>Makefile.generated_files:描述了代码生成的逻辑</p>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install cloc //代码统计工具</span><br></pre></td></tr></table></figure>
<p>结构体，json,protobuf<br>k8s.io/kubernetes/staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/types.go<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> APIResource <span class="keyword">struct</span> &#123;</span><br><span class="line">	</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name" protobuf:"bytes,1,opt,name=name"`</span></span><br><span class="line">	</span><br><span class="line">	SingularName <span class="keyword">string</span> <span class="string">`json:"singularName" protobuf:"bytes,6,opt,name=singularName"`</span></span><br><span class="line">	</span><br><span class="line">	Namespaced <span class="keyword">bool</span> <span class="string">`json:"namespaced" protobuf:"varint,2,opt,name=namespaced"`</span></span><br><span class="line">	</span><br><span class="line">	Group <span class="keyword">string</span> <span class="string">`json:"group,omitempty" protobuf:"bytes,8,opt,name=group"`</span></span><br><span class="line">	</span><br><span class="line">	Version <span class="keyword">string</span> <span class="string">`json:"version,omitempty" protobuf:"bytes,9,opt,name=version"`</span></span><br><span class="line">	</span><br><span class="line">	Kind <span class="keyword">string</span> <span class="string">`json:"kind" protobuf:"bytes,3,opt,name=kind"`</span></span><br><span class="line">	</span><br><span class="line">	ShortNames []<span class="keyword">string</span> <span class="string">`json:"shortNames,omitempty" protobuf:"bytes,5,rep,name=shortNames"`</span></span><br><span class="line"></span><br><span class="line">	Categories []<span class="keyword">string</span> <span class="string">`json:"categories,omitempty" protobuf:"bytes,7,rep,name=categories"`</span></span><br><span class="line">	StorageVersionHash <span class="keyword">string</span> <span class="string">`json:"storageVersionHash,omitempty" protobuf:"bytes,10,opt,name=storageVersionHash"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/apimachinery/pkg/runtime/schema/group_version.go</span></span><br><span class="line"><span class="comment">// 标识一个资源</span></span><br><span class="line"><span class="keyword">type</span> GroupVersionResource <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group    <span class="keyword">string</span></span><br><span class="line">	Version  <span class="keyword">string</span></span><br><span class="line">	Resource <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupKind <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group <span class="keyword">string</span></span><br><span class="line">	Kind  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupVersion <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group   <span class="keyword">string</span></span><br><span class="line">	Version <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> GroupResource <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group    <span class="keyword">string</span></span><br><span class="line">	Resource <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GroupVersionKind <span class="keyword">struct</span> &#123;</span><br><span class="line">	Group   <span class="keyword">string</span></span><br><span class="line">	Version <span class="keyword">string</span></span><br><span class="line">	Kind    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">Kind与Resource有何区别？</span><br><span class="line"></span><br><span class="line">Kind the name of a particular object schema (e.g. the <span class="string">"Cat"</span> and <span class="string">"Dog"</span> kinds would have different attributes and properties)</span><br><span class="line"></span><br><span class="line">Resource a representation of a system entity, sent or retrieved as JSON via HTTP to the server. Resources are exposed via:</span><br><span class="line"> - Collections - a list of resources of the same <span class="keyword">type</span>, which may be queryable</span><br><span class="line"> - Elements - an individual resource, addressable via a URL</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeMeta <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Kind is a string value representing the REST resource this object represents.</span></span><br><span class="line">	Kind <span class="keyword">string</span> <span class="string">`json:"kind,omitempty" protobuf:"bytes,1,opt,name=kind"`</span></span><br><span class="line"></span><br><span class="line">	APIVersion <span class="keyword">string</span> <span class="string">`json:"apiVersion,omitempty" protobuf:"bytes,2,opt,name=apiVersion"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部版本的资源定义在<code>vendor/k8s.io/api</code>目录下，完整路径为<code>vendor/k8s.io/api/&lt;group&gt;/&lt;version&gt;/&lt;resource file&gt;</code></p>
<p><code>kubectl api-versions</code>列出当前支持的资源组和资源版本<br><code>kubectl api-resources</code>列出当前 支持的资源列表</p>
<h5 id="k8s-io-kubernetes-vendor-k8s-io-apimachinery-pkg-runtime-interfaces-go"><a href="#k8s-io-kubernetes-vendor-k8s-io-apimachinery-pkg-runtime-interfaces-go" class="headerlink" title="k8s.io/kubernetes/vendor/k8s.io/apimachinery/pkg/runtime/interfaces.go"></a>k8s.io/kubernetes/vendor/k8s.io/apimachinery/pkg/runtime/interfaces.go</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object interface must be supported by all API types registered with Scheme. Since objects in a scheme are</span></span><br><span class="line"><span class="comment">// expected to be serialized to the wire, the interface an Object must provide to the Scheme allows</span></span><br><span class="line"><span class="comment">// serializers to set the kind, version, and group the object is represented as. An Object may choose</span></span><br><span class="line"><span class="comment">// to return a no-op ObjectKindAccessor in cases where it is not expected to be serialized.</span></span><br><span class="line"><span class="keyword">type</span> Object <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetObjectKind() schema.ObjectKind</span><br><span class="line">	DeepCopyObject() Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前Kubernetes系统中的所有资源类型都已注册到Scheme资源注册表中，其是一个内存型的注册表<br>UnversionedType:无版本资源类型<br>KnownType:有版本资源类型</p>
<p>yamlSerializer使用第三方库gopkg.in/yaml.v2来实现序列化和反序列化操作。</p>
<p>github.com/json-iteractor/go</p>
<p>可通过kubectl convert命令进行资源版本转换</p>
<p>// pkg/util/tail/tail.go<br>FindTailLineStartIndex</p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码中的一些实现</title>
    <url>/2023/06/15/k8s%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>本文主要记录<code>k8s</code>中源码中一些函数实现。持续更新。</p>
<h5 id="函数批量调用"><a href="#函数批量调用" class="headerlink" title="函数批量调用"></a>函数批量调用</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/replicaset/replica_set.go</span></span><br><span class="line"><span class="comment">// slowStartBatch 尝试调用fn总共count次，刚开始以较小的并发batchSize调用fn函数(用于检查是否发生错误)</span></span><br><span class="line"><span class="comment">// 如果未发生错误则增加batchSize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数进行分批调用，起始值为initialBatchSize和count之间的最小值，在每一批的函数调用是并发执行的</span></span><br><span class="line"><span class="comment">// 如果一次批调用都成功了，一下次批调用将会对batchSize翻倍。</span></span><br><span class="line"><span class="comment">// 如果在一次批调用过程中发生了错误，会等待当前批次的调用执行完。但余下的批次将不会执行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果initialBatchSize为1，则batchSize变化为</span></span><br><span class="line"><span class="comment">// 1, 2, 4, 8, 16...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回成功调用fn的次数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slowStartBatch</span><span class="params">(count <span class="keyword">int</span>, initialBatchSize <span class="keyword">int</span>, fn <span class="keyword">func</span>()</span> <span class="title">error</span>) <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// remaining统计fn剩余调用的次数</span></span><br><span class="line">	remaining := count</span><br><span class="line">	successes := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> batchSize := integer.IntMin(remaining, initialBatchSize); batchSize &gt; <span class="number">0</span>; batchSize = integer.IntMin(<span class="number">2</span>*batchSize, remaining) &#123;</span><br><span class="line">        <span class="comment">// errCh用于统计调用失败的次数</span></span><br><span class="line">		errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, batchSize)</span><br><span class="line">		<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">		wg.Add(batchSize)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; batchSize; i++ &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="keyword">defer</span> wg.Done()</span><br><span class="line">				<span class="keyword">if</span> err := fn(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					errCh &lt;- err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		curSuccesses := batchSize - <span class="built_in">len</span>(errCh)</span><br><span class="line">		successes += curSuccesses</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(errCh) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> successes, &lt;-errCh</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 更新remaining</span></span><br><span class="line">		remaining -= batchSize</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> successes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vendor/k8s.io/utils/integer/integer.go</span></span><br><span class="line"><span class="comment">// IntMin returns the minimum of the params</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntMin</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b &lt; a &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="FindTailLineStartIndex"><a href="#FindTailLineStartIndex" class="headerlink" title="FindTailLineStartIndex"></a>FindTailLineStartIndex</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/util/tail/tail.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回倒数第n行的起始字节数</span></span><br><span class="line"><span class="comment">// If n &lt; 0, 返回文件起始位置</span></span><br><span class="line"><span class="comment">// If n &gt;=0, 返回倒数第n行的起始字节数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果最后一行没有换行符将不会统计</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindTailLineStartIndex</span><span class="params">(f io.ReadSeeker, n <span class="keyword">int64</span>)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 获取文件大小</span></span><br><span class="line">	size, err := f.Seek(<span class="number">0</span>, io.SeekEnd)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> left, cnt <span class="keyword">int64</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, blockSize)</span><br><span class="line">	<span class="keyword">for</span> right := size; right &gt; <span class="number">0</span> &amp;&amp; cnt &lt;= n; right -= blockSize &#123;</span><br><span class="line">		left = right - blockSize</span><br><span class="line">		<span class="keyword">if</span> left &lt; <span class="number">0</span> &#123;</span><br><span class="line">			left = <span class="number">0</span></span><br><span class="line">			buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, right)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _, err := f.Seek(left, io.SeekStart); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _, err := f.Read(buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 统计行数</span></span><br><span class="line">		cnt += <span class="keyword">int64</span>(bytes.Count(buf, eol))</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 假设文件为"hello\nworld\n",则size=12</span></span><br><span class="line">    <span class="comment">// cnt = 2, 此时left为0</span></span><br><span class="line">    <span class="comment">// 假设n=1,则cnt&gt;n进入循环</span></span><br><span class="line">	<span class="keyword">for</span> ; cnt &gt; n; cnt-- &#123;</span><br><span class="line">        <span class="comment">// idx=6</span></span><br><span class="line">		idx := bytes.Index(buf, eol) + <span class="number">1</span></span><br><span class="line">		buf = buf[idx:]</span><br><span class="line">		left += <span class="keyword">int64</span>(idx)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// left=6</span></span><br><span class="line">	<span class="keyword">return</span> left, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	blockSize = <span class="number">1024</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// eol is the end-of-line sign in the log.</span></span><br><span class="line">	eol = []<span class="keyword">byte</span>&#123;<span class="string">'\n'</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="并行拉取镜像"><a href="#并行拉取镜像" class="headerlink" title="并行拉取镜像"></a>并行拉取镜像</h5><p>最大并行镜像拉取数量：<br>特性状态： Kubernetes v1.27 [alpha]<br>当 serializeImagePulls 被设置为 false 时，kubelet 默认对同时拉取的最大镜像数量没有限制。 如果你想限制并行镜像拉取的数量，可以在 kubelet 配置中设置字段 maxParallelImagePulls。 当 maxParallelImagePulls 设置为 n 时，只能同时拉取 n 个镜像， 超过 n 的任何镜像都必须等到至少一个正在进行拉取的镜像拉取完成后，才能拉取。</p>
<p>当启用并行镜像拉取时，限制并行镜像拉取的数量可以防止镜像拉取消耗过多的网络带宽或磁盘 I/O。</p>
<p>你可以将 maxParallelImagePulls 设置为大于或等于 1 的正数。 如果将 maxParallelImagePulls 设置为大于等于 2，则必须将 serializeImagePulls 设置为 false。 kubelet 在无效的 maxParallelImagePulls 设置下会启动失败。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// pkg/kubelet/images/puller.go</span></span><br><span class="line"><span class="keyword">type</span> parallelImagePuller <span class="keyword">struct</span> &#123;</span><br><span class="line">	imageService kubecontainer.ImageService</span><br><span class="line">	tokens       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newParallelImagePuller</span><span class="params">(imageService kubecontainer.ImageService, maxParallelImagePulls *<span class="keyword">int32</span>)</span> <span class="title">imagePuller</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> maxParallelImagePulls == <span class="literal">nil</span> || *maxParallelImagePulls &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;parallelImagePuller&#123;imageService, <span class="literal">nil</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// tokens的大小为maxParallelImagePulls</span></span><br><span class="line">	<span class="comment">// maxParallelImagePulls并发的goroutine数</span></span><br><span class="line">	<span class="keyword">return</span> &amp;parallelImagePuller&#123;imageService, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, *maxParallelImagePulls)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pip *parallelImagePuller)</span> <span class="title">pullImage</span><span class="params">(ctx context.Context, spec kubecontainer.ImageSpec, pullSecrets []v1.Secret, pullChan <span class="keyword">chan</span>&lt;- pullResult, podSandboxConfig *runtimeapi.PodSandboxConfig)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> pip.tokens != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 每启动一个goroutine拉取镜像，往tokens写入struct&#123;&#125;&#123;&#125;</span></span><br><span class="line">            <span class="comment">// 如果tokens已经满了，则会阻塞</span></span><br><span class="line">			pip.tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            <span class="comment">// 镜像拉取成功后，释放空间</span></span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-pip.tokens &#125;()</span><br><span class="line">		&#125;</span><br><span class="line">		startTime := time.Now()</span><br><span class="line">		imageRef, err := pip.imageService.PullImage(ctx, spec, pullSecrets, podSandboxConfig)</span><br><span class="line">		pullChan &lt;- pullResult&#123;</span><br><span class="line">			imageRef:     imageRef,</span><br><span class="line">			err:          err,</span><br><span class="line">			pullDuration: time.Since(startTime),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *imageManager)</span> <span class="title">EnsureImageExists</span><span class="params">(ctx context.Context, pod *v1.Pod, container *v1.Container, pullSecrets []v1.Secret, podSandboxConfig *runtimeapi.PodSandboxConfig)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	pullChan := <span class="built_in">make</span>(<span class="keyword">chan</span> pullResult)</span><br><span class="line">	<span class="comment">// 调用pullImage并行拉取镜像</span></span><br><span class="line">	m.puller.pullImage(ctx, spec, pullSecrets, pullChan, podSandboxConfig)</span><br><span class="line">	<span class="comment">// 串行获取镜像拉取结果</span></span><br><span class="line">	imagePullResult := &lt;-pullChan</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="串行镜像拉取"><a href="#串行镜像拉取" class="headerlink" title="串行镜像拉取"></a>串行镜像拉取</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/images/puller.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以进入排队的最大镜像拉取请求数</span></span><br><span class="line"><span class="keyword">const</span> maxImagePullRequests = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> serialImagePuller <span class="keyword">struct</span> &#123;</span><br><span class="line">	imageService kubecontainer.ImageService</span><br><span class="line">	pullRequests <span class="keyword">chan</span> *imagePullRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSerialImagePuller</span><span class="params">(imageService kubecontainer.ImageService)</span> <span class="title">imagePuller</span></span> &#123;</span><br><span class="line">	imagePuller := &amp;serialImagePuller&#123;imageService, <span class="built_in">make</span>(<span class="keyword">chan</span> *imagePullRequest, maxImagePullRequests)&#125;</span><br><span class="line">    <span class="comment">// 启动一个不会退出的goroutine, 不断的从pullRequests中取出信息，然后拉取镜像</span></span><br><span class="line">	<span class="keyword">go</span> wait.Until(imagePuller.processImagePullRequests, time.Second, wait.NeverStop)</span><br><span class="line">	<span class="keyword">return</span> imagePuller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> imagePullRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	ctx              context.Context</span><br><span class="line">	spec             kubecontainer.ImageSpec</span><br><span class="line">	pullSecrets      []v1.Secret</span><br><span class="line">	pullChan         <span class="keyword">chan</span>&lt;- pullResult</span><br><span class="line">	podSandboxConfig *runtimeapi.PodSandboxConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sip *serialImagePuller)</span> <span class="title">pullImage</span><span class="params">(ctx context.Context, spec kubecontainer.ImageSpec, pullSecrets []v1.Secret, pullChan <span class="keyword">chan</span>&lt;- pullResult, podSandboxConfig *runtimeapi.PodSandboxConfig)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里只是把镜像拉取请求发送到pullRequests,实现的拉取镜像动作是在processImagePullRequests</span></span><br><span class="line">	sip.pullRequests &lt;- &amp;imagePullRequest&#123;</span><br><span class="line">		ctx:              ctx,</span><br><span class="line">		spec:             spec,</span><br><span class="line">		pullSecrets:      pullSecrets,</span><br><span class="line">		pullChan:         pullChan,</span><br><span class="line">		podSandboxConfig: podSandboxConfig,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sip *serialImagePuller)</span> <span class="title">processImagePullRequests</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 遍历pullRequests,串行拉取镜像</span></span><br><span class="line">	<span class="keyword">for</span> pullRequest := <span class="keyword">range</span> sip.pullRequests &#123;</span><br><span class="line">		startTime := time.Now()</span><br><span class="line">		imageRef, err := sip.imageService.PullImage(pullRequest.ctx, pullRequest.spec, pullRequest.pullSecrets, pullRequest.podSandboxConfig)</span><br><span class="line">		pullRequest.pullChan &lt;- pullResult&#123;</span><br><span class="line">			imageRef:     imageRef,</span><br><span class="line">			err:          err,</span><br><span class="line">			pullDuration: time.Since(startTime),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/replicaset/replica_set.go" target="_blank" rel="noopener">pkg/controller/replicaset/replica_set.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/vendor/k8s.io/utils/integer/integer.go" target="_blank" rel="noopener">vendor/k8s.io/utils/integer/integer.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/util/tail/tail.go" target="_blank" rel="noopener">pkg/util/tail/tail.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/images/puller.go" target="_blank" rel="noopener">pkg/kubelet/images/puller.go</a><br>5.<a href="https://kubernetes.io/zh-cn/docs/concepts/containers/images/#maximum-parallel-image-pulls" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/concepts/containers/images/#maximum-parallel-image-pulls</a><br>6.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/images/image_manager.go" target="_blank" rel="noopener">pkg/kubelet/images/image_manager.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Adapter</title>
    <url>/2023/04/10/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BAdapter/</url>
    <content><![CDATA[<h5 id="什么是Adapter"><a href="#什么是Adapter" class="headerlink" title="什么是Adapter"></a>什么是Adapter</h5><p><code>Adapter</code>也就是<a href="https://refactoringguru.cn/design-patterns/adapter" target="_blank" rel="noopener">适配器模式</a></p>
<p>适配器模式是一种结构型设计模式，它将一个接口转换成另一个客户端所期望的接口，从而使得原本不兼容的接口能够协同工作。适配器模式常常用于将一个旧接口适配成新接口，或将一个外部库的接口适配成当前应用程序所需的接口</p>
<p>适配器模式由三个主要角色组成：客户端、适配器和被适配者。其中，客户端使用目标接口来与适配器交互，适配器将客户端的请求转换为被适配者的请求并进行处理，被适配者则是适配器所需要的接口。</p>
<h5 id="k8s中适配器模式"><a href="#k8s中适配器模式" class="headerlink" title="k8s中适配器模式"></a>k8s中适配器模式</h5><p><code>k8s</code>中有很多不同的资源，对于创建资源，<code>k8s</code>实现了<code>createHandler</code>方法来处理</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.go</span></span><br><span class="line"><span class="comment">// 这里返回http.HandlerFunc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createHandler</span><span class="params">(r rest.NamedCreater, scope *RequestScope, admit admission.Interface, includeName <span class="keyword">bool</span>)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		ctx := req.Context()</span><br><span class="line">		<span class="comment">// For performance tracking purposes.</span></span><br><span class="line">		ctx, span := tracing.Start(ctx, <span class="string">"Create"</span>, traceFields(req)...)</span><br><span class="line">		<span class="keyword">defer</span> span.End(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">        ...</span><br><span class="line">		namespace, name, err := scope.Namer.Name(req)</span><br><span class="line">		requestFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 调用r实现的Create方法，上层可以实现这个接口实现适配</span></span><br><span class="line">			<span class="keyword">return</span> r.Create(</span><br><span class="line">				ctx,</span><br><span class="line">				name,</span><br><span class="line">				obj,</span><br><span class="line">				rest.AdmissionToValidateObjectFunc(admit, admissionAttributes, scope),</span><br><span class="line">				options,</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateNamedResource returns a function that will handle a resource creation with name.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNamedResource</span><span class="params">(r rest.NamedCreater, scope *RequestScope, admission admission.Interface)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> createHandler(r, scope, admission, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateResource returns a function that will handle a resource creation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateResource</span><span class="params">(r rest.Creater, scope *RequestScope, admission admission.Interface)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> createHandler(&amp;namedCreaterAdapter&#123;r&#125;, scope, admission, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过namedCreaterAdapter实现Create方法，适配createHandler. createHandler将调用对应的Create方法</span></span><br><span class="line"><span class="keyword">type</span> namedCreaterAdapter <span class="keyword">struct</span> &#123;</span><br><span class="line">	rest.Creater</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *namedCreaterAdapter)</span> <span class="title">Create</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, obj runtime.Object, createValidatingAdmission rest.ValidateObjectFunc, options *metav1.CreateOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Creater.Create(ctx, obj, createValidatingAdmission, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.go" target="_blank" rel="noopener">staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Chan of Responsibility</title>
    <url>/2023/04/09/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BChan-of-Responsibility/</url>
    <content><![CDATA[<h5 id="Chan-of-Responsibility我们常说的责任链模式"><a href="#Chan-of-Responsibility我们常说的责任链模式" class="headerlink" title="Chan of Responsibility我们常说的责任链模式"></a><code>Chan of Responsibility</code>我们常说的<a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility" target="_blank" rel="noopener">责任链模式</a></h5><h5 id="k8s中的实现"><a href="#k8s中的实现" class="headerlink" title="k8s中的实现"></a>k8s中的实现</h5><p>kube-apiserver中的admission控制器通过责任链模式实现。每个admission控制器都实现了一个AdmissionHandler接口，该接口包含一个名为Admit的方法，用于验证请求是否符合规则。多个admission控制器按照注册顺序形成一个责任链。当请求进来时，apiserver会遍历这个责任链，逐一调用每个admission控制器的Admit方法，只有当所有控制器都通过验证后，请求才会被通过。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/apiserver/pkg/admission/chain.go</span></span><br><span class="line"><span class="comment">// 下面定义了两种性质的webhook,修改性质在验证性质的之前被调用</span></span><br><span class="line"><span class="comment">// chainAdmissionHandler is an instance of admission.NamedHandler that performs admission control using</span></span><br><span class="line"><span class="comment">// a chain of admission handlers</span></span><br><span class="line"><span class="keyword">type</span> chainAdmissionHandler []Interface</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewChainHandler creates a new chain handler from an array of handlers. Used for testing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChainHandler</span><span class="params">(handlers ...Interface)</span> <span class="title">chainAdmissionHandler</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> chainAdmissionHandler(handlers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Admit performs an admission control check using a chain of handlers, and returns immediately on first error</span></span><br><span class="line"><span class="comment">// 修改性质的webhook，此类handler实现了MutationInterface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(admissionHandler chainAdmissionHandler)</span> <span class="title">Admit</span><span class="params">(ctx context.Context, a Attributes, o ObjectInterfaces)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, handler := <span class="keyword">range</span> admissionHandler &#123;</span><br><span class="line">		<span class="keyword">if</span> !handler.Handles(a.GetOperation()) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> mutator, ok := handler.(MutationInterface); ok &#123;</span><br><span class="line">			err := mutator.Admit(ctx, a, o)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate performs an admission control check using a chain of handlers, and returns immediately on first error</span></span><br><span class="line"><span class="comment">// 验证性质的webhook, 此类handler实现了ValidationInterface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(admissionHandler chainAdmissionHandler)</span> <span class="title">Validate</span><span class="params">(ctx context.Context, a Attributes, o ObjectInterfaces)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, handler := <span class="keyword">range</span> admissionHandler &#123;</span><br><span class="line">		<span class="keyword">if</span> !handler.Handles(a.GetOperation()) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> validator, ok := handler.(ValidationInterface); ok &#123;</span><br><span class="line">			err := validator.Validate(ctx, a, o)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handles will return true if any of the handlers handles the given operation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(admissionHandler chainAdmissionHandler)</span> <span class="title">Handles</span><span class="params">(operation Operation)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, handler := <span class="keyword">range</span> admissionHandler &#123;</span><br><span class="line">		<span class="keyword">if</span> handler.Handles(operation) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="admission-Interface"><a href="#admission-Interface" class="headerlink" title="admission Interface"></a>admission Interface</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/apiserver/pkg/admission/interfaces.go</span></span><br><span class="line"><span class="comment">// Interface is an abstract, pluggable interface for Admission Control decisions.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Handles returns true if this admission controller can handle the given operation</span></span><br><span class="line">	<span class="comment">// where operation can be one of CREATE, UPDATE, DELETE, or CONNECT</span></span><br><span class="line">	Handles(operation Operation) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MutationInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Interface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Admit makes an admission decision based on the request attributes.</span></span><br><span class="line">	<span class="comment">// Context is used only for timeout/deadline/cancellation and tracing information.</span></span><br><span class="line">	Admit(ctx context.Context, a Attributes, o ObjectInterfaces) (err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ValidationInterface is an abstract, pluggable interface for Admission Control decisions.</span></span><br><span class="line"><span class="keyword">type</span> ValidationInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Interface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate makes an admission decision based on the request attributes.  It is NOT allowed to mutate</span></span><br><span class="line">	<span class="comment">// Context is used only for timeout/deadline/cancellation and tracing information.</span></span><br><span class="line">	Validate(ctx context.Context, a Attributes, o ObjectInterfaces) (err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h5><h6 id="Matation"><a href="#Matation" class="headerlink" title="Matation"></a>Matation</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.go</span></span><br><span class="line"><span class="comment">// 把有Post请求都会经过CreateHandler方法，这里使用了装饰器模式返回http.HandlerFunc</span></span><br><span class="line"><span class="comment">// 代码过长删除了部分逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createHandler</span><span class="params">(r rest.NamedCreater, scope *RequestScope, admit admission.Interface, includeName <span class="keyword">bool</span>)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		ctx := req.Context()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">		result, err := finisher.FinishRequest(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> scope.FieldManager != <span class="literal">nil</span> &#123;</span><br><span class="line">				liveObj, err := scope.Creater.New(scope.Kind)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to create new object (Create for %v): %v"</span>, scope.Kind, err)</span><br><span class="line">				&#125;</span><br><span class="line">				obj = scope.FieldManager.UpdateNoErrors(liveObj, obj, managerOrUserAgent(options.FieldManager, req.UserAgent()))</span><br><span class="line">				admit = fieldmanager.NewManagedFieldsValidatingAdmissionController(admit)</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 执行admission handler</span></span><br><span class="line">			<span class="keyword">if</span> mutatingAdmission, ok := admit.(admission.MutationInterface); ok &amp;&amp; mutatingAdmission.Handles(admission.Create) &#123;</span><br><span class="line">				<span class="keyword">if</span> err := mutatingAdmission.Admit(ctx, admissionAttributes, scope); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Dedup owner references again after mutating admission happens</span></span><br><span class="line">			dedupOwnerReferencesAndAddWarning(obj, req.Context(), <span class="literal">true</span>)</span><br><span class="line">			result, err := requestFunc()</span><br><span class="line">			<span class="comment">// If the object wasn't committed to storage because it's serialized size was too large,</span></span><br><span class="line">			<span class="comment">// it is safe to remove managedFields (which can be large) and try again.</span></span><br><span class="line">			<span class="keyword">if</span> isTooLargeError(err) &#123;</span><br><span class="line">				<span class="keyword">if</span> accessor, accessorErr := meta.Accessor(obj); accessorErr == <span class="literal">nil</span> &#123;</span><br><span class="line">					accessor.SetManagedFields(<span class="literal">nil</span>)</span><br><span class="line">					result, err = requestFunc()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result, err</span><br><span class="line">		&#125;)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 调用Store中的Create方法，这里的Create方法是对etcd的一层封装</span></span><br><span class="line">        <span class="comment">// 可以看到AdmissionToValidateObjectFunc</span></span><br><span class="line">        requestFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> r.Create(</span><br><span class="line">				ctx,</span><br><span class="line">				name,</span><br><span class="line">				obj,</span><br><span class="line">				rest.AdmissionToValidateObjectFunc(admit, admissionAttributes, scope),</span><br><span class="line">				options,</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line">        ...</span><br><span class="line">        result, err := requestFunc()</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/apiserver/pkg/registry/generic/registry/store.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">Create</span><span class="params">(ctx context.Context, obj runtime.Object, createValidation rest.ValidateObjectFunc, options *metav1.CreateOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里将会执行validate</span></span><br><span class="line">    <span class="keyword">if</span> createValidation != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := createValidation(ctx, obj.DeepCopyObject()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.go" target="_blank" rel="noopener">staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/admission/chain.go" target="_blank" rel="noopener">staging/src/k8s.io/apiserver/pkg/admission/chain.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/admission/interfaces.go" target="_blank" rel="noopener">staging/src/k8s.io/apiserver/pkg/admission/interfaces.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go" target="_blank" rel="noopener">staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Builder</title>
    <url>/2023/04/06/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder/</url>
    <content><![CDATA[<h6 id="Builder模式也叫生成器模式，也叫建造者模式"><a href="#Builder模式也叫生成器模式，也叫建造者模式" class="headerlink" title="Builder模式也叫生成器模式，也叫建造者模式"></a>Builder模式也叫生成器模式，也叫建造者模式</h6><p>关于生成器模式详情可查看<a href="https://refactoringguru.cn/design-patterns/builder" target="_blank" rel="noopener">文章</a></p>
<h5 id="记录下k8s源码中使用到的Builder模式。"><a href="#记录下k8s源码中使用到的Builder模式。" class="headerlink" title="记录下k8s源码中使用到的Builder模式。"></a>记录下k8s源码中使用到的Builder模式。</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/client-go/rest/request.go</span></span><br><span class="line"><span class="comment">// Request 构建一个请求发送给kube-apiserver.</span></span><br><span class="line"><span class="comment">// 其中有很多元素需要设置，但只一些是必须的</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	c *RESTClient</span><br><span class="line"></span><br><span class="line">	warningHandler WarningHandler</span><br><span class="line"></span><br><span class="line">	rateLimiter flowcontrol.RateLimiter</span><br><span class="line">	backoff     BackoffManager</span><br><span class="line">	timeout     time.Duration</span><br><span class="line">	maxRetries  <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// generic components accessible via method setters</span></span><br><span class="line">	verb       <span class="keyword">string</span></span><br><span class="line">	pathPrefix <span class="keyword">string</span></span><br><span class="line">	subpath    <span class="keyword">string</span></span><br><span class="line">	params     url.Values</span><br><span class="line">	headers    http.Header</span><br><span class="line"></span><br><span class="line">	<span class="comment">// structural elements of the request that are part of the Kubernetes API conventions</span></span><br><span class="line">	namespace    <span class="keyword">string</span></span><br><span class="line">	namespaceSet <span class="keyword">bool</span></span><br><span class="line">	resource     <span class="keyword">string</span></span><br><span class="line">	resourceName <span class="keyword">string</span></span><br><span class="line">	subresource  <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// output</span></span><br><span class="line">	err error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// only one of body / bodyBytes may be set. requests using body are not retriable.</span></span><br><span class="line">	body      io.Reader</span><br><span class="line">	bodyBytes []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	retryFn requestRetryFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewRequest 方法创建一个Request结构体并返回指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(c *RESTClient)</span> *<span class="title">Request</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	r := &amp;Request&#123;</span><br><span class="line">		c:              c,</span><br><span class="line">		rateLimiter:    c.rateLimiter,</span><br><span class="line">		backoff:        backoff,</span><br><span class="line">		timeout:        timeout,</span><br><span class="line">		pathPrefix:     pathPrefix,</span><br><span class="line">		maxRetries:     <span class="number">10</span>,</span><br><span class="line">		retryFn:        defaultRequestRetryFn,</span><br><span class="line">		warningHandler: c.warningHandler,</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Verb</span><span class="params">(verb <span class="keyword">string</span>)</span> *<span class="title">Request</span></span> &#123;</span><br><span class="line">	r.verb = verb</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Prefix</span><span class="params">(segments ...<span class="keyword">string</span>)</span> *<span class="title">Request</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">	&#125;</span><br><span class="line">	r.pathPrefix = path.Join(r.pathPrefix, path.Join(segments...))</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Suffix</span><span class="params">(segments ...<span class="keyword">string</span>)</span> *<span class="title">Request</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">	&#125;</span><br><span class="line">	r.subpath = path.Join(r.subpath, path.Join(segments...))</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">r := NewRequest(clientSet)</span><br><span class="line">r.Verb(<span class="string">"Post"</span>).Prefix(<span class="string">"apps"</span>)</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/rest/request.go" target="_blank" rel="noopener">client-go/rest/request.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Clone</title>
    <url>/2023/04/10/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BClone/</url>
    <content><![CDATA[<p><a href="https://refactoringguru.cn/design-patterns/prototype" target="_blank" rel="noopener">原型模式</a>是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p>
<p><code>k8s</code>使用代码生成的方式为每个资源对象实现了<code>DeepCopy()</code>方法。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/apis/core/types.go</span></span><br><span class="line"><span class="comment">// Pod的定义</span></span><br><span class="line"><span class="comment">// Pod is a collection of containers, used as either input (create, update) or as output (list, get).</span></span><br><span class="line"><span class="keyword">type</span> Pod <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta</span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	metav1.ObjectMeta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Spec defines the behavior of a pod.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Spec PodSpec</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Status represents the current information about a pod. This data may not be up</span></span><br><span class="line">	<span class="comment">// to date.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Status PodStatus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newPod := pod.DeepCopy()可以调用DeepCopy()复制一个对象</span></span><br><span class="line"><span class="comment">// pkg/apis/core/zz_generated.deepcopy.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *Pod)</span> <span class="title">DeepCopy</span><span class="params">()</span> *<span class="title">Pod</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> in == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	out := <span class="built_in">new</span>(Pod)</span><br><span class="line">	in.DeepCopyInto(out)</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *Pod)</span> <span class="title">DeepCopyInto</span><span class="params">(out *Pod)</span></span> &#123;</span><br><span class="line">	*out = *in</span><br><span class="line">	out.TypeMeta = in.TypeMeta</span><br><span class="line">	in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)</span><br><span class="line">	in.Spec.DeepCopyInto(&amp;out.Spec)</span><br><span class="line">	in.Status.DeepCopyInto(&amp;out.Status)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go" target="_blank" rel="noopener">pkg/apis/core/types.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/zz_generated.deepcopy.go" target="_blank" rel="noopener">pkg/apis/core/zz_generated.deepcopy.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Flyweight</title>
    <url>/2023/04/11/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BFlyweight/</url>
    <content><![CDATA[<p><a href="https://refactoringguru.cn/design-patterns/flyweight" target="_blank" rel="noopener">Flyweight</a>也叫<code>缓存</code>，<code>Cache</code>,<code>享元模式</code>。</p>
<p>享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p>
<p>在 Kubernetes 源码中，有多个地方使用了享元模式（Flyweight Pattern），其中最常见的就是 client-go 中的 cache 包。该包实现了 Kubernetes 中的各种资源对象的本地缓存，并使用享元模式来尽可能地重用缓存对象，以降低内存消耗和提高效率。</p>
<p>在<code>Informers Factory</code>中，每个类型的资源（如<code>Pods</code>，<code>Services</code>，<code>Deployments</code>等）只需要创建一个<code>Informer</code>即可，因为每个<code>Informer</code>可以观察到同一类型的所有资源对象。因此，在创建<code>Informer</code>之前，需要首先判断该类型的<code>Informer</code>是否已经存在。如果存在，则直接返回已经存在的<code>Informer</code>；否则，创建新的<code>Informer</code>并存储到<code>f.informers</code>中供以后使用。</p>
<p>这种设计方式减少了<code>Informer</code>的创建次数，提高了<code>Informer</code>的重用率，减少了系统开销，同时也降低了代码的复杂度。这正是享元模式的优点所在。</p>
<h5 id="k8s中informer创建"><a href="#k8s中informer创建" class="headerlink" title="k8s中informer创建"></a>k8s中informer创建</h5><p><code>k8s</code>中的<code>informer</code>创建使用了<code>享元模式</code>。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/client-go/informers/factory.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">InformerFor</span><span class="params">(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	informerType := reflect.TypeOf(obj)</span><br><span class="line">    <span class="comment">// 判断是否已经存在</span></span><br><span class="line">	informer, exists := f.informers[informerType]</span><br><span class="line">	<span class="keyword">if</span> exists &#123;</span><br><span class="line">		<span class="keyword">return</span> informer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resyncPeriod, exists := f.customResync[informerType]</span><br><span class="line">	<span class="keyword">if</span> !exists &#123;</span><br><span class="line">		resyncPeriod = f.defaultResync</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	informer = newFunc(f.client, resyncPeriod)</span><br><span class="line">	f.informers[informerType] = informer</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/factory.go" target="_blank" rel="noopener">client-go/informers/factory.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Composite</title>
    <url>/2023/04/11/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BComposite/</url>
    <content><![CDATA[<p><a href="https://refactoringguru.cn/design-patterns/composite" target="_blank" rel="noopener">组合模式</a>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。<br>在<code>Golang</code>中可以使用多个<code>interface</code>组合在一起实现组合的功能。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/client-go/kubernetes/typed/core/v1/pod.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是k8s中的一个示例</span></span><br><span class="line"><span class="keyword">type</span> PodInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Create(ctx context.Context, pod *v1.Pod, opts metav1.CreateOptions) (*v1.Pod, error)</span><br><span class="line">	Update(ctx context.Context, pod *v1.Pod, opts metav1.UpdateOptions) (*v1.Pod, error)</span><br><span class="line">	UpdateStatus(ctx context.Context, pod *v1.Pod, opts metav1.UpdateOptions) (*v1.Pod, error)</span><br><span class="line">	Delete(ctx context.Context, name <span class="keyword">string</span>, opts metav1.DeleteOptions) error</span><br><span class="line">	DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error</span><br><span class="line">	Get(ctx context.Context, name <span class="keyword">string</span>, opts metav1.GetOptions) (*v1.Pod, error)</span><br><span class="line">	List(ctx context.Context, opts metav1.ListOptions) (*v1.PodList, error)</span><br><span class="line">	Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)</span><br><span class="line">	Patch(ctx context.Context, name <span class="keyword">string</span>, pt types.PatchType, data []<span class="keyword">byte</span>, opts metav1.PatchOptions, subresources ...<span class="keyword">string</span>) (result *v1.Pod, err error)</span><br><span class="line">	Apply(ctx context.Context, pod *corev1.PodApplyConfiguration, opts metav1.ApplyOptions) (result *v1.Pod, err error)</span><br><span class="line">	ApplyStatus(ctx context.Context, pod *corev1.PodApplyConfiguration, opts metav1.ApplyOptions) (result *v1.Pod, err error)</span><br><span class="line">	UpdateEphemeralContainers(ctx context.Context, podName <span class="keyword">string</span>, pod *v1.Pod, opts metav1.UpdateOptions) (*v1.Pod, error)</span><br><span class="line"></span><br><span class="line">	PodExpansion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/kubernetes/typed/core/v1/pod.go" target="_blank" rel="noopener">taging/src/k8s.io/client-go/kubernetes/typed/core/v1/pod.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Factory</title>
    <url>/2023/04/06/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BFactory/</url>
    <content><![CDATA[<h5 id="工厂方法是一种创建型设计模式，详情可参考工厂方法"><a href="#工厂方法是一种创建型设计模式，详情可参考工厂方法" class="headerlink" title="工厂方法是一种创建型设计模式，详情可参考工厂方法"></a>工厂方法是一种创建型设计模式，详情可参考<a href="https://refactoringguru.cn/design-patterns/factory-method" target="_blank" rel="noopener">工厂方法</a></h5><h6 id="如何创建一个informer"><a href="#如何创建一个informer" class="headerlink" title="如何创建一个informer"></a>如何创建一个informer</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 创建对应资源的informer</span></span><br><span class="line">factory := informers.NewSharedInformerFactory(clientset, time.Minute)</span><br><span class="line">informer := factory.Core().V1().Pods().Informer()</span><br></pre></td></tr></table></figure>
<h6 id="工厂方法构造"><a href="#工厂方法构造" class="headerlink" title="工厂方法构造"></a>工厂方法构造</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个结构体sharedInformerFactory指针,该结构体实现了接口SharedInformerFactory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSharedInformerFactory</span><span class="params">(client kubernetes.Interface, defaultResync time.Duration)</span> <span class="title">SharedInformerFactory</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewSharedInformerFactoryWithOptions(client, defaultResync)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSharedInformerFactoryWithOptions</span><span class="params">(client kubernetes.Interface, defaultResync time.Duration, options ...SharedInformerOption)</span> <span class="title">SharedInformerFactory</span></span> &#123;</span><br><span class="line">	factory := &amp;sharedInformerFactory&#123;</span><br><span class="line">		client:           client,</span><br><span class="line">		namespace:        v1.NamespaceAll,</span><br><span class="line">		defaultResync:    defaultResync,</span><br><span class="line">		informers:        <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]cache.SharedIndexInformer),</span><br><span class="line">		startedInformers: <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]<span class="keyword">bool</span>),</span><br><span class="line">		customResync:     <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]time.Duration),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Apply all options</span></span><br><span class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> options &#123;</span><br><span class="line">		factory = opt(factory)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> factory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SharedInformerFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">	internalinterfaces.SharedInformerFactory</span><br><span class="line">	ForResource(resource schema.GroupVersionResource) (GenericInformer, error)</span><br><span class="line">	WaitForCacheSync(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="keyword">map</span>[reflect.Type]<span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	Admissionregistration() admissionregistration.Interface</span><br><span class="line">	Internal() apiserverinternal.Interface</span><br><span class="line">	Apps() apps.Interface</span><br><span class="line">	Autoscaling() autoscaling.Interface</span><br><span class="line">	Batch() batch.Interface</span><br><span class="line">	Certificates() certificates.Interface</span><br><span class="line">	Coordination() coordination.Interface</span><br><span class="line">	Core() core.Interface</span><br><span class="line">	Discovery() discovery.Interface</span><br><span class="line">	Events() events.Interface</span><br><span class="line">	Extensions() extensions.Interface</span><br><span class="line">	Flowcontrol() flowcontrol.Interface</span><br><span class="line">	Networking() networking.Interface</span><br><span class="line">	Node() node.Interface</span><br><span class="line">	Policy() policy.Interface</span><br><span class="line">	Rbac() rbac.Interface</span><br><span class="line">	Scheduling() scheduling.Interface</span><br><span class="line">	Storage() storage.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以Core()方法为例，实现了V1()方法，返回值为一个接口</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// V1 provides access to shared informers for resources in V1.</span></span><br><span class="line">	V1() v1.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v1.Interface</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// ComponentStatuses returns a ComponentStatusInformer.</span></span><br><span class="line">	ComponentStatuses() 设计模式ComponentStatusInformer</span><br><span class="line">	<span class="comment">// ConfigMaps returns a ConfigMapInformer.</span></span><br><span class="line">	ConfigMaps() ConfigMapInformer</span><br><span class="line">	<span class="comment">// Endpoints returns a EndpointsInformer.</span></span><br><span class="line">	Endpoints() EndpointsInformer</span><br><span class="line">	<span class="comment">// Events returns a EventInformer.</span></span><br><span class="line">	Events() EventInformer</span><br><span class="line">	<span class="comment">// LimitRanges returns a 设计模式LimitRangeInformer.</span></span><br><span class="line">	LimitRanges() LimitRangeInformer</span><br><span class="line">	<span class="comment">// Namespaces returns a NamespaceInformer.</span></span><br><span class="line">	Namespaces() NamespaceInformer</span><br><span class="line">	<span class="comment">// Nodes returns a NodeInformer.</span></span><br><span class="line">	Nodes() NodeInformer</span><br><span class="line">	<span class="comment">// PersistentVolumes returns a PersistentVolumeInformer.</span></span><br><span class="line">	PersistentVolumes() PersistentVolumeInformer</span><br><span class="line">	<span class="comment">// PersistentVolumeClaims returns a PersistentVolumeClaimInformer.</span></span><br><span class="line">	PersistentVolumeClaims() PersistentVolumeClaimInformer</span><br><span class="line">	<span class="comment">// Pods returns a PodInformer.</span></span><br><span class="line">	Pods() PodInformer</span><br><span class="line">	<span class="comment">// PodTemplates returns a PodTemplateInformer.</span></span><br><span class="line">	PodTemplates() PodTemplateInformer</span><br><span class="line">	<span class="comment">// ReplicationControllers returns a ReplicationControllerInformer.</span></span><br><span class="line">	ReplicationControllers() ReplicationControllerInformer</span><br><span class="line">	<span class="comment">// ResourceQuotas returns a ResourceQuotaInformer.</span></span><br><span class="line">	ResourceQuotas() ResourceQuotaInformer</span><br><span class="line">	<span class="comment">// Secrets returns a SecretInformer.</span></span><br><span class="line">	Secrets() SecretInformer</span><br><span class="line">	<span class="comment">// Services returns a ServiceInformer.</span></span><br><span class="line">	Services() ServiceInformer</span><br><span class="line">	<span class="comment">// ServiceAccounts returns a ServiceAccountInformer.</span></span><br><span class="line">	ServiceAccounts() ServiceAccountInformer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以Pods()为例，该方法返回PodInformer接口</span></span><br><span class="line"><span class="comment">// 实现了Informer和Lister()方法</span></span><br><span class="line"><span class="keyword">type</span> PodInformer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Informer() cache.SharedIndexInformer</span><br><span class="line">	Lister() v1.PodLister</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="factory-Core-V1-Pods-Informer"><a href="#factory-Core-V1-Pods-Informer" class="headerlink" title="factory.Core().V1().Pods().Informer()"></a>factory.Core().V1().Pods().Informer()</h6><p>1.首先调用Core()方法<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Core()返回结构体group指针，group实现了V1()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">Core</span><span class="params">()</span> <span class="title">core</span>.<span class="title">Interface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> core.New(f, f.namespace, f.tweakListOptions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> group <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory          internalinterfaces.SharedInformerFactory</span><br><span class="line">	namespace        <span class="keyword">string</span></span><br><span class="line">	tweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *group)</span> <span class="title">V1</span><span class="params">()</span> <span class="title">v1</span>.<span class="title">Interface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v1.New(g.factory, g.namespace, g.tweakListOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.调用V1()方法<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// V1()返回结构体version的指针，version实现了v1.Interface中的所有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *group)</span> <span class="title">V1</span><span class="params">()</span> <span class="title">v1</span>.<span class="title">Interface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v1.New(g.factory, g.namespace, g.tweakListOptions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> version <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory          internalinterfaces.SharedInformerFactory</span><br><span class="line">	namespace        <span class="keyword">string</span></span><br><span class="line">	tweakListOptions internalinterfaces.TweakListOptionsFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>４.调用Pods()方法<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回podInformer指针，podInformer实现了Informer(),Lister()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *version)</span> <span class="title">Pods</span><span class="params">()</span> <span class="title">PodInformer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;podInformer&#123;factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.最后调用Informer()方法,完成对象创建<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用InformerFor</span></span><br><span class="line"><span class="comment">// staging/src/k8s.io/client-go/informers/core/v1/pod.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *podInformer)</span> <span class="title">Informer</span><span class="params">()</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f.factory.InformerFor(&amp;corev1.Pod&#123;&#125;, f.defaultInformer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging/src/k8s.io/client-go/informers/factory.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">InformerFor</span><span class="params">(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	informerType := reflect.TypeOf(obj)</span><br><span class="line">    <span class="comment">//　此处会检查informer是否存在，如果存在则直接返回</span></span><br><span class="line">    <span class="comment">// 复用informer,节省资源</span></span><br><span class="line">	informer, exists := f.info设计模式rmers[informerType]</span><br><span class="line">	<span class="keyword">if</span> exists &#123;</span><br><span class="line">		<span class="keyword">return</span> informer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resyncPeriod, exists := f.customResync[informerType]</span><br><span class="line">	<span class="keyword">if</span> !exists &#123;</span><br><span class="line">		resyncPeriod = f.defaultResync</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	informer = newFunc(f.client, resyncPeriod)</span><br><span class="line">	f.informers[informerType] = informer</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/factory.go" target="_blank" rel="noopener">client-go/informers/factory.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/core/interface.go" target="_blank" rel="noopener">client-go/informers/core/interface.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/core/v1/interface.go" target="_blank" rel="noopener">client-go/informers/core/v1/interface.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/core/v1/pod.go" target="_blank" rel="noopener">client-go/informers/core/v1/pod.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Observer</title>
    <url>/2023/04/10/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BObserver/</url>
    <content><![CDATA[<p><a href="https://refactoringguru.cn/design-patterns/observer" target="_blank" rel="noopener">观察者模式</a>,也叫事件订阅,监听者,Listener,Observer。<br>观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p>
<h5 id="k8s中的观察者模式"><a href="#k8s中的观察者模式" class="headerlink" title="k8s中的观察者模式"></a>k8s中的观察者模式</h5><p>Kubernetes中观察者模式主要是通过watch机制实现的。watch机制是一种持续性的HTTP请求(通过块传输)，当资源的状态发生变化时，服务器会返回该资源的新状态。客户端通过不断发起HTTP请求获取新状态，从而实现对资源的观察。watch机制是基于长轮询机制实现的，即服务器在有新状态时才会立即返回结果，否则会一直等待一段时间再返回结果。</p>
<p>在Kubernetes中，kube-apiserver负责处理客户端的watch请求。当客户端订阅一个资源时，kube-apiserver会在内部创建一个watcher对象，然后将其添加到对应资源的watcher列表中。当资源状态发生变化时，kube-apiserver会遍历watcher列表，并向所有订阅该资源的客户端发送新状态。客户端在收到新状态后，需要通过比较前后两个状态的差异来判断资源状态是否发生变化，并进行相应的处理。</p>
<p>执行命令<code>kubectl get deployment use -n default -w</code>可以监听名称为<code>use</code>的<code>deployment</code>的变化。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当这条语句执行会调用Watch</span></span><br><span class="line"><span class="comment">// newCacheWatcher创建一个watcher</span></span><br><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/storage/cacher/cacher.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">Watch</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, opts storage.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    	watcher := newCacheWatcher(</span><br><span class="line">		chanSize,</span><br><span class="line">		filterWithAttrsFunction(key, pred),</span><br><span class="line">		emptyFunc,</span><br><span class="line">		c.versioner,</span><br><span class="line">		deadline,</span><br><span class="line">		pred.AllowWatchBookmarks,</span><br><span class="line">		c.groupResource,</span><br><span class="line">		identifier,</span><br><span class="line">	)</span><br><span class="line">    ...</span><br><span class="line">    	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		c.Lock()</span><br><span class="line">		<span class="keyword">defer</span> c.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> generation, ok := c.ready.checkAndReadGeneration(); generation != readyGeneration || !ok &#123;</span><br><span class="line">			<span class="comment">// We went unready or are already on a different generation.</span></span><br><span class="line">			<span class="comment">// Avoid registering and starting the watch as it will have to be</span></span><br><span class="line">			<span class="comment">// terminated immediately anyway.</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update watcher.forget function once we can compute it.</span></span><br><span class="line">		watcher.forget = forgetWatcher(c, watcher, c.watcherIdx, scope, triggerValue, triggerSupported)</span><br><span class="line">		<span class="comment">// Update the bookMarkAfterResourceVersion</span></span><br><span class="line">		watcher.setBookmarkAfterResourceVersion(bookmarkAfterResourceVersionFn())</span><br><span class="line">        <span class="comment">// 将创建的watcher添加到Cacher中的watchers</span></span><br><span class="line">		c.watchers.addWatcher(watcher, c.watcherIdx, scope, triggerValue, triggerSupported)</span><br><span class="line">		addedWatcher = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add it to the queue only when the client support watch bookmarks.</span></span><br><span class="line">		<span class="keyword">if</span> watcher.allowWatchBookmarks &#123;</span><br><span class="line">			c.bookmarkWatchers.addWatcher(watcher)</span><br><span class="line">		&#125;</span><br><span class="line">		c.watcherIdx++</span><br><span class="line">	&#125;()</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 启动一个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> watcher.processInterval(ctx, cacheInterval, startWatchRV)</span><br><span class="line">    <span class="keyword">return</span> watcher, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/storage/cacher/cache_watcher.go</span></span><br><span class="line"><span class="keyword">type</span> cacheWatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">	input     <span class="keyword">chan</span> *watchCacheEvent</span><br><span class="line">	result    <span class="keyword">chan</span> watch.Event</span><br><span class="line">	done      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	filter    filterWithAttrsFunc</span><br><span class="line">	stopped   <span class="keyword">bool</span></span><br><span class="line">	forget    <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">bool</span>)</span></span></span><br><span class="line">	versioner storage.Versioner</span><br><span class="line">	deadline            time.Time</span><br><span class="line">	allowWatchBookmarks <span class="keyword">bool</span></span><br><span class="line">	groupResource       schema.GroupResource</span><br><span class="line"></span><br><span class="line">	identifier <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	drainInputBuffer <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	bookmarkAfterResourceVersion <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// stateMutex protects state</span></span><br><span class="line">	stateMutex sync.Mutex</span><br><span class="line">	state <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheWatcher)</span> <span class="title">processInterval</span><span class="params">(ctx context.Context, cacheInterval *watchCacheInterval, resourceVersion <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(c.result)</span><br><span class="line">	<span class="keyword">defer</span> c.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check how long we are processing initEvents.</span></span><br><span class="line">	<span class="comment">// As long as these are not processed, we are not processing</span></span><br><span class="line">	<span class="comment">// any incoming events, so if it takes long, we may actually</span></span><br><span class="line">	<span class="comment">// block all watchers for some time.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> From the logs it seems that there happens processing</span></span><br><span class="line">	<span class="comment">// times even up to 1s which is very long. However, this doesn't</span></span><br><span class="line">	<span class="comment">// depend that much on the number of initEvents. E.g. from the</span></span><br><span class="line">	<span class="comment">// 2000-node Kubemark run we have logs like this, e.g.:</span></span><br><span class="line">	<span class="comment">// ... processing 13862 initEvents took 66.808689ms</span></span><br><span class="line">	<span class="comment">// ... processing 14040 initEvents took 993.532539ms</span></span><br><span class="line">	<span class="comment">// We should understand what is blocking us in those cases (e.g.</span></span><br><span class="line">	<span class="comment">// is it lack of CPU, network, or sth else) and potentially</span></span><br><span class="line">	<span class="comment">// consider increase size of result buffer in those cases.</span></span><br><span class="line">	<span class="keyword">const</span> initProcessThreshold = <span class="number">500</span> * time.Millisecond</span><br><span class="line">	startTime := time.Now()</span><br><span class="line"></span><br><span class="line">	initEventCount := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		event, err := cacheInterval.Next()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// An error indicates that the cache interval</span></span><br><span class="line">			<span class="comment">// has been invalidated and can no longer serve</span></span><br><span class="line">			<span class="comment">// events.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Initially we considered sending an "out-of-history"</span></span><br><span class="line">			<span class="comment">// Error event in this case, but because historically</span></span><br><span class="line">			<span class="comment">// such events weren't sent out of the watchCache, we</span></span><br><span class="line">			<span class="comment">// decided not to. This is still ok, because on watch</span></span><br><span class="line">			<span class="comment">// closure, the watcher will try to re-instantiate the</span></span><br><span class="line">			<span class="comment">// watch and then will get an explicit "out-of-history"</span></span><br><span class="line">			<span class="comment">// window. There is potential for optimization, but for</span></span><br><span class="line">			<span class="comment">// now, in order to be on the safe side and not break</span></span><br><span class="line">			<span class="comment">// custom clients, the cost of it is something that we</span></span><br><span class="line">			<span class="comment">// are fully accepting.</span></span><br><span class="line">			klog.Warningf(<span class="string">"couldn't retrieve watch event to serve: %#v"</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> event == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 转换成watchEvent,并发送到c.result</span></span><br><span class="line">		c.sendWatchCacheEvent(event)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> event.ResourceVersion &gt; resourceVersion &#123;</span><br><span class="line">			resourceVersion = event.ResourceVersion</span><br><span class="line">		&#125;</span><br><span class="line">		initEventCount++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> initEventCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		metrics.InitCounter.WithLabelValues(c.groupResource.String()).Add(<span class="keyword">float64</span>(initEventCount))</span><br><span class="line">	&#125;</span><br><span class="line">	processingTime := time.Since(startTime)</span><br><span class="line">	<span class="keyword">if</span> processingTime &gt; initProcessThreshold &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).Infof(<span class="string">"processing %d initEvents of %s (%s) took %v"</span>, initEventCount, c.groupResource, c.identifier, processingTime)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.process(ctx, resourceVersion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dispatchEvents --&gt; dispatchEvent --&gt; watcher.add</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cacher)</span> <span class="title">dispatchEvent</span><span class="params">(event *watchCacheEvent)</span></span> &#123;</span><br><span class="line">	c.startDispatching(event)</span><br><span class="line">	<span class="keyword">defer</span> c.finishDispatching()</span><br><span class="line">	<span class="comment">// Watchers stopped after startDispatching will be delayed to finishDispatching,</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Since add() can block, we explicitly add when cacher is unlocked.</span></span><br><span class="line">	<span class="comment">// Dispatching event in nonblocking way first, which make faster watchers</span></span><br><span class="line">	<span class="comment">// not be blocked by slower ones.</span></span><br><span class="line">	<span class="keyword">if</span> event.Type == watch.Bookmark &#123;</span><br><span class="line">		<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchersBuffer &#123;</span><br><span class="line">			watcher.nonblockingAdd(event)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		wcEvent := *event</span><br><span class="line">		setCachingObjects(&amp;wcEvent, c.versioner)</span><br><span class="line">		event = &amp;wcEvent</span><br><span class="line"></span><br><span class="line">		c.blockedWatchers = c.blockedWatchers[:<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.watchersBuffer &#123;</span><br><span class="line">			<span class="keyword">if</span> !watcher.nonblockingAdd(event) &#123;</span><br><span class="line">				c.blockedWatchers = <span class="built_in">append</span>(c.blockedWatchers, watcher)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(c.blockedWatchers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// dispatchEvent is called very often, so arrange</span></span><br><span class="line">			<span class="comment">// to reuse timers instead of constantly allocating.</span></span><br><span class="line">			startTime := time.Now()</span><br><span class="line">			timeout := c.dispatchTimeoutBudget.takeAvailable()</span><br><span class="line">			c.timer.Reset(timeout)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Send event to all blocked watchers. As long as timer is running,</span></span><br><span class="line">			<span class="comment">// `add` will wait for the watcher to unblock. After timeout,</span></span><br><span class="line">			<span class="comment">// `add` will not wait, but immediately close a still blocked watcher.</span></span><br><span class="line">			<span class="comment">// Hence, every watcher gets the chance to unblock itself while timer</span></span><br><span class="line">			<span class="comment">// is running, not only the first ones in the list.</span></span><br><span class="line">			timer := c.timer</span><br><span class="line">			<span class="keyword">for</span> _, watcher := <span class="keyword">range</span> c.blockedWatchers &#123;</span><br><span class="line">				<span class="keyword">if</span> !watcher.add(event, timer) &#123;</span><br><span class="line">					<span class="comment">// fired, clean the timer by set it to nil.</span></span><br><span class="line">					timer = <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Stop the timer if it is not fired</span></span><br><span class="line">			<span class="keyword">if</span> timer != <span class="literal">nil</span> &amp;&amp; !timer.Stop() &#123;</span><br><span class="line">				<span class="comment">// Consume triggered (but not yet received) timer event</span></span><br><span class="line">				<span class="comment">// so that future reuse does not get a spurious timeout.</span></span><br><span class="line">				&lt;-timer.C</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			c.dispatchTimeoutBudget.returnUnused(timeout - time.Since(startTime))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/cacher/cacher.go" target="_blank" rel="noopener">staging/src/k8s.io/apiserver/pkg/storage/cacher/cacher.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/cacher/cache_watcher.go" target="_blank" rel="noopener">staging/src/k8s.io/apiserver/pkg/storage/cacher/cache_watcher.go)</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/cacher/watch_cache.go" target="_blank" rel="noopener">staging/src/k8s.io/apiserver/pkg/storage/cacher/watch_cache.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Iterator</title>
    <url>/2023/04/17/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BIterator/</url>
    <content><![CDATA[<h5 id="迭代器模式也叫Iterator"><a href="#迭代器模式也叫Iterator" class="headerlink" title="迭代器模式也叫Iterator"></a>迭代器模式也叫Iterator</h5><p>迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// plugins/ipam/host-local/backend/allocator/allocator.go</span><br><span class="line">// 对RangeIter实现Next()方法以实现对RangeSet的遍历</span><br><span class="line">type RangeIter struct &#123;</span><br><span class="line">	rangeset *RangeSet</span><br><span class="line"></span><br><span class="line">	// The current range id</span><br><span class="line">    // 记录当前访问的索引</span><br><span class="line">	rangeIdx int</span><br><span class="line"></span><br><span class="line">	// Our current position</span><br><span class="line">    // 当前的ip</span><br><span class="line">	cur net.IP</span><br><span class="line"></span><br><span class="line">	// The IP where we started iterating; if we hit this again, we&apos;re done.</span><br><span class="line">    // 开始访问的IP,如果再次访问表示已迭代完成</span><br><span class="line">	startIP net.IP</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (i *RangeIter) Next() (*net.IPNet, net.IP) &#123;</span><br><span class="line">    // 获取索引为rangeIdx的元素(Range)</span><br><span class="line">	r := (*i.rangeset)[i.rangeIdx]</span><br><span class="line"></span><br><span class="line">	// 第一次开始迭代</span><br><span class="line">	if i.cur == nil &#123;</span><br><span class="line">		i.cur = r.RangeStart</span><br><span class="line">		i.startIP = i.cur</span><br><span class="line">		if i.cur.Equal(r.Gateway) &#123;</span><br><span class="line">			return i.Next()</span><br><span class="line">		&#125;</span><br><span class="line">		return &amp;net.IPNet&#123;IP: i.cur, Mask: r.Subnet.Mask&#125;, r.Gateway</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// If we&apos;ve reached the end of this range, we need to advance the range</span><br><span class="line">	// RangeEnd is inclusive as well</span><br><span class="line">	if i.cur.Equal(r.RangeEnd) &#123;</span><br><span class="line">		i.rangeIdx++</span><br><span class="line">		i.rangeIdx %= len(*i.rangeset)</span><br><span class="line">		r = (*i.rangeset)[i.rangeIdx]</span><br><span class="line"></span><br><span class="line">		i.cur = r.RangeStart</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		i.cur = ip.NextIP(i.cur)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if i.startIP == nil &#123;</span><br><span class="line">		i.startIP = i.cur</span><br><span class="line">	&#125; else if i.cur.Equal(i.startIP) &#123;</span><br><span class="line">		// IF we&apos;ve looped back to where we started, give up</span><br><span class="line">		return nil, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if i.cur.Equal(r.Gateway) &#123;</span><br><span class="line">		return i.Next()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return &amp;net.IPNet&#123;IP: i.cur, Mask: r.Subnet.Mask&#125;, r.Gateway</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *IPAllocator) GetIter() (*RangeIter, error) &#123;</span><br><span class="line">	iter := RangeIter&#123;</span><br><span class="line">		rangeset: a.rangeset,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Round-robin by trying to allocate from the last reserved IP + 1</span><br><span class="line">	startFromLastReservedIP := false</span><br><span class="line"></span><br><span class="line">	// We might get a last reserved IP that is wrong if the range indexes changed.</span><br><span class="line">	// This is not critical, we just lose round-robin this one time.</span><br><span class="line">	lastReservedIP, err := a.store.LastReservedIP(a.rangeID)</span><br><span class="line">	if err != nil &amp;&amp; !os.IsNotExist(err) &#123;</span><br><span class="line">		log.Printf(&quot;Error retrieving last reserved ip: %v&quot;, err)</span><br><span class="line">	&#125; else if lastReservedIP != nil &#123;</span><br><span class="line">		startFromLastReservedIP = a.rangeset.Contains(lastReservedIP)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Find the range in the set with this IP</span><br><span class="line">	if startFromLastReservedIP &#123;</span><br><span class="line">		for i, r := range *a.rangeset &#123;</span><br><span class="line">			if r.Contains(lastReservedIP) &#123;</span><br><span class="line">				iter.rangeIdx = i</span><br><span class="line"></span><br><span class="line">				// We advance the cursor on every Next(), so the first call</span><br><span class="line">				// to next() will return lastReservedIP + 1</span><br><span class="line">				iter.cur = lastReservedIP</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		iter.rangeIdx = 0</span><br><span class="line">		iter.startIP = (*a.rangeset)[0].RangeStart</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;iter, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用Iter</span><br><span class="line">func (a *IPAllocator) Get(id string, ifname string, requestedIP net.IP) (*current.IPConfig, error) &#123;</span><br><span class="line">    ...</span><br><span class="line">    iter, err := a.GetIter()</span><br><span class="line">    for &#123;</span><br><span class="line">        reservedIP, gw := iter.Next()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// plugins/ipam/host-local/backend/allocator/config.go</span><br><span class="line">type RangeSet []Range</span><br><span class="line"></span><br><span class="line">type Range struct &#123;</span><br><span class="line">	RangeStart net.IP      `json:&quot;rangeStart,omitempty&quot;` // The first ip, inclusive</span><br><span class="line">	RangeEnd   net.IP      `json:&quot;rangeEnd,omitempty&quot;`   // The last ip, inclusive</span><br><span class="line">	Subnet     types.IPNet `json:&quot;subnet&quot;`</span><br><span class="line">	Gateway    net.IP      `json:&quot;gateway,omitempty&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/containernetworking/plugins/blob/release-1.1/plugins/ipam/host-local/backend/allocator/config.go" target="_blank" rel="noopener">plugins/ipam/host-local/backend/allocator/config.go</a><br>2.<a href="https://github.com/containernetworking/plugins/blob/release-1.1/plugins/ipam/host-local/backend/allocator/allocator.go" target="_blank" rel="noopener">plugins/ipam/host-local/backend/allocator/allocator.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Proxy</title>
    <url>/2023/04/11/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BProxy/</url>
    <content><![CDATA[<p><code>Proxy</code>也就是<a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">代理模式</a></p>
<p>代理模式是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p>
<p>在<code>upgradeawarehandler.go</code>文件中还定义了一个<code>UpgradeAwareHandler</code>结构体，它可以将<code>HTTP</code>请求转换为<code>WebSocket</code>请求，并将转换后的<code>WebSocket</code>请求传递给目标组件，以支持使用WebSocket协议与目标组件进行通信。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go</span></span><br><span class="line"><span class="comment">// UpgradeAwareHandler实现了ServeHTTP方法</span></span><br><span class="line"><span class="keyword">type</span> UpgradeAwareHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// UpgradeRequired will reject non-upgrade connections if true.</span></span><br><span class="line">	UpgradeRequired <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Location is the location of the upstream proxy. It is used as the location to Dial on the upstream server</span></span><br><span class="line">	<span class="comment">// for upgrade requests unless UseRequestLocationOnUpgrade is true.</span></span><br><span class="line">	Location *url.URL</span><br><span class="line">	<span class="comment">// AppendLocationPath determines if the original path of the Location should be appended to the upstream proxy request path</span></span><br><span class="line">	AppendLocationPath <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Transport provides an optional round tripper to use to proxy. If nil, the default proxy transport is used</span></span><br><span class="line">	Transport http.RoundTripper</span><br><span class="line">	<span class="comment">// UpgradeTransport, if specified, will be used as the backend transport when upgrade requests are provided.</span></span><br><span class="line">	<span class="comment">// This allows clients to disable HTTP/2.</span></span><br><span class="line">	UpgradeTransport UpgradeRequestRoundTripper</span><br><span class="line">	<span class="comment">// WrapTransport indicates whether the provided Transport should be wrapped with default proxy transport behavior (URL rewriting, X-Forwarded-* header setting)</span></span><br><span class="line">	WrapTransport <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// UseRequestLocation will use the incoming request URL when talking to the backend server.</span></span><br><span class="line">	UseRequestLocation <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// UseLocationHost overrides the HTTP host header in requests to the backend server to use the Host from Location.</span></span><br><span class="line">	<span class="comment">// This will override the req.Host field of a request, while UseRequestLocation will override the req.URL field</span></span><br><span class="line">	<span class="comment">// of a request. The req.URL.Host specifies the server to connect to, while the req.Host field</span></span><br><span class="line">	<span class="comment">// specifies the Host header value to send in the HTTP request. If this is false, the incoming req.Host header will</span></span><br><span class="line">	<span class="comment">// just be forwarded to the backend server.</span></span><br><span class="line">	UseLocationHost <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// FlushInterval controls how often the standard HTTP proxy will flush content from the upstream.</span></span><br><span class="line">	FlushInterval time.Duration</span><br><span class="line">	<span class="comment">// MaxBytesPerSec controls the maximum rate for an upstream connection. No rate is imposed if the value is zero.</span></span><br><span class="line">	MaxBytesPerSec <span class="keyword">int64</span></span><br><span class="line">	<span class="comment">// Responder is passed errors that occur while setting up proxying.</span></span><br><span class="line">	Responder ErrorResponder</span><br><span class="line">	<span class="comment">// Reject to forward redirect response</span></span><br><span class="line">	RejectForwardingRedirects <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxyStream proxies stream to url.</span></span><br><span class="line"><span class="comment">// pkg/kubelet/server/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">proxyStream</span><span class="params">(w http.ResponseWriter, r *http.Request, url *url.URL)</span></span> &#123;</span><br><span class="line">	<span class="comment">// TODO(random-liu): Set MaxBytesPerSec to throttle the stream.</span></span><br><span class="line">	handler := proxy.NewUpgradeAwareHandler(url, <span class="literal">nil</span> <span class="comment">/*transport*/</span>, <span class="literal">false</span> <span class="comment">/*wrapTransport*/</span>, <span class="literal">true</span> <span class="comment">/*upgradeRequired*/</span>, &amp;responder&#123;&#125;)</span><br><span class="line">	handler.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go" target="_blank" rel="noopener">staging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/server/server.go" target="_blank" rel="noopener">pkg/kubelet/server/server.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之State</title>
    <url>/2023/04/13/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BState/</url>
    <content><![CDATA[<p><code>State</code>也就是<a href="https://refactoringguru.cn/design-patterns/state" target="_blank" rel="noopener">状态模式</a>是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p>
<p>在<code>Kubernetes</code> 中，<code>DeploymentController</code> 作为控制器之一，主要负责维护 <code>Deployment</code> 对象的状态，即根据用户定义的 <code>Deployment</code> 规范，创建、更新、删除 <code>ReplicaSet</code> 和 <code>Pod</code> 等资源，确保应用的正确运行。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/apis/apps/types.go</span></span><br><span class="line"><span class="comment">// DeploymentConditionType有三种类型,Available,Progressing,ReplicaFailure.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Available means the deployment is available, ie. at least the minimum available</span></span><br><span class="line">	<span class="comment">// replicas required are up and running for at least minReadySeconds.</span></span><br><span class="line">	DeploymentAvailable DeploymentConditionType = <span class="string">"Available"</span></span><br><span class="line">	<span class="comment">// Progressing means the deployment is progressing. Progress for a deployment is</span></span><br><span class="line">	<span class="comment">// considered when a new replica set is created or adopted, and when new pods scale</span></span><br><span class="line">	<span class="comment">// up or old pods scale down. Progress is not estimated for paused deployments or</span></span><br><span class="line">	<span class="comment">// when progressDeadlineSeconds is not specified.</span></span><br><span class="line">	DeploymentProgressing DeploymentConditionType = <span class="string">"Progressing"</span></span><br><span class="line">	<span class="comment">// ReplicaFailure is added in a deployment when one of its pods fails to be created</span></span><br><span class="line">	<span class="comment">// or deleted.</span></span><br><span class="line">	DeploymentReplicaFailure DeploymentConditionType = <span class="string">"ReplicaFailure"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// DeploymentCondition 记录了Deployment的状态</span></span><br><span class="line"><span class="comment">// DeploymentCondition describes the state of a deployment at a certain point.</span></span><br><span class="line"><span class="keyword">type</span> DeploymentCondition <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Type of deployment condition.</span></span><br><span class="line">	Type DeploymentConditionType</span><br><span class="line">	<span class="comment">// Status of the condition, one of True, False, Unknown.</span></span><br><span class="line">	Status api.ConditionStatus</span><br><span class="line">	<span class="comment">// The last time this condition was updated.</span></span><br><span class="line">	LastUpdateTime metav1.Time</span><br><span class="line">	<span class="comment">// Last time the condition transitioned from one status to another.</span></span><br><span class="line">	LastTransitionTime metav1.Time</span><br><span class="line">	<span class="comment">// The reason for the condition's last transition.</span></span><br><span class="line">	Reason <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// A human readable message indicating details about the transition.</span></span><br><span class="line">	Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeploymentStatus holds information about the observed status of a deployment.</span></span><br><span class="line"><span class="keyword">type</span> DeploymentStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The generation observed by the deployment controller.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	ObservedGeneration <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Total number of non-terminated pods targeted by this deployment (their labels match the selector).</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Replicas <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Total number of non-terminated pods targeted by this deployment that have the desired template spec.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	UpdatedReplicas <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Total number of ready pods targeted by this deployment.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	ReadyReplicas <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	AvailableReplicas <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Total number of unavailable pods targeted by this deployment. This is the total number of</span></span><br><span class="line">	<span class="comment">// pods that are still required for the deployment to have 100% available capacity. They may</span></span><br><span class="line">	<span class="comment">// either be pods that are running but not yet available or pods that still have not been created.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	UnavailableReplicas <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Represents the latest available observations of a deployment's current state.</span></span><br><span class="line">	Conditions []DeploymentCondition</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Count of hash collisions for the Deployment. The Deployment controller uses this</span></span><br><span class="line">	<span class="comment">// field as a collision avoidance mechanism when it needs to create the name for the</span></span><br><span class="line">	<span class="comment">// newest ReplicaSet.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	CollisionCount *<span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这段代码是 <code>DeploymentController</code> 在检测 <code>Deployment</code> 的部署状态时，使用状态模式进行状态转换的一个例子。该控制器使用 <code>DeploymentCondition</code> 对象来跟踪 <code>Deployment</code> 的状态。在这里，根据 <code>Deployment</code> 是否已经完成（<code>DeploymentComplete</code>）、是否在进行中（<code>DeploymentProgressing</code>）以及是否已经超时（<code>DeploymentTimedOut</code>）等三种状态，来执行不同的操作。</p>
<p>首先，如果 <code>Deployment</code> 已经完成，则会创建一个新的 <code>DeploymentCondition</code> 对象，将其状态设置为 <code>True</code>，原因设置为 <code>NewReplicaSetAvailable</code>，具体是哪个取决于新创建的 <code>ReplicaSet</code> 是否存在。然后，使用 <code>SetDeploymentCondition</code> 方法将其设置为<code>Deployment</code> 的新状态。</p>
<p>其次，如果 <code>Deployment</code> 正在进行中，则会创建一个的 <code>DeploymentCondition</code> 对象。如果<code>currentCond</code>不为<code>nil</code>且该对象的状态为 <code>True</code>，则将其上次转换时间 <code>condition.LastTransitionTime</code>设置为<code>currentCond.LastTransitionTime</code>。然后使用 <code>SetDeploymentCondition</code> 方法更新。</p>
<p>最后，如果 <code>Deployment</code> 已经超时，则会创建一个新的 <code>DeploymentCondition</code> 对象，将其状态设置为 <code>False</code>，原因设置为 <code>TimedOutReason</code>，并使用 <code>SetDeploymentCondition</code> 方法将其设置为 <code>Deployment</code> 的新状态。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/deployment/progress.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">syncRolloutStatus</span><span class="params">(ctx context.Context, allRSs []*apps.ReplicaSet, newRS *apps.ReplicaSet, d *apps.Deployment)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	newStatus := calculateStatus(allRSs, newRS, d)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If there is no progressDeadlineSeconds set, remove any Progressing condition.</span></span><br><span class="line">	<span class="keyword">if</span> !util.HasProgressDeadline(d) &#123;</span><br><span class="line">		util.RemoveDeploymentCondition(&amp;newStatus, apps.DeploymentProgressing)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If there is only one replica set that is active then that means we are not running</span></span><br><span class="line">	<span class="comment">// a new rollout and this is a resync where we don't need to estimate any progress.</span></span><br><span class="line">	<span class="comment">// In such a case, we should simply not estimate any progress for this deployment.</span></span><br><span class="line">	currentCond := util.GetDeploymentCondition(d.Status, apps.DeploymentProgressing)</span><br><span class="line">	isCompleteDeployment := newStatus.Replicas == newStatus.UpdatedReplicas &amp;&amp; currentCond != <span class="literal">nil</span> &amp;&amp; currentCond.Reason == util.NewRSAvailableReason</span><br><span class="line">	<span class="comment">// Check for progress only if there is a progress deadline set and the latest rollout</span></span><br><span class="line">	<span class="comment">// hasn't completed yet.</span></span><br><span class="line">	<span class="keyword">if</span> util.HasProgressDeadline(d) &amp;&amp; !isCompleteDeployment &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> util.DeploymentComplete(d, &amp;newStatus):</span><br><span class="line">			<span class="comment">// Update the deployment conditions with a message for the new replica set that</span></span><br><span class="line">			<span class="comment">// was successfully deployed. If the condition already exists, we ignore this update.</span></span><br><span class="line">			msg := fmt.Sprintf(<span class="string">"Deployment %q has successfully progressed."</span>, d.Name)</span><br><span class="line">			<span class="keyword">if</span> newRS != <span class="literal">nil</span> &#123;</span><br><span class="line">				msg = fmt.Sprintf(<span class="string">"ReplicaSet %q has successfully progressed."</span>, newRS.Name)</span><br><span class="line">			&#125;</span><br><span class="line">			condition := util.NewDeploymentCondition(apps.DeploymentProgressing, v1.ConditionTrue, util.NewRSAvailableReason, msg)</span><br><span class="line">			util.SetDeploymentCondition(&amp;newStatus, *condition)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> util.DeploymentProgressing(d, &amp;newStatus):</span><br><span class="line">			<span class="comment">// If there is any progress made, continue by not checking if the deployment failed. This</span></span><br><span class="line">			<span class="comment">// behavior emulates the rolling updater progressDeadline check.</span></span><br><span class="line">			msg := fmt.Sprintf(<span class="string">"Deployment %q is progressing."</span>, d.Name)</span><br><span class="line">			<span class="keyword">if</span> newRS != <span class="literal">nil</span> &#123;</span><br><span class="line">				msg = fmt.Sprintf(<span class="string">"ReplicaSet %q is progressing."</span>, newRS.Name)</span><br><span class="line">			&#125;</span><br><span class="line">			condition := util.NewDeploymentCondition(apps.DeploymentProgressing, v1.ConditionTrue, util.ReplicaSetUpdatedReason, msg)</span><br><span class="line">			<span class="comment">// Update the current Progressing condition or add a new one if it doesn't exist.</span></span><br><span class="line">			<span class="comment">// If a Progressing condition with status=true already exists, we should update</span></span><br><span class="line">			<span class="comment">// everything but lastTransitionTime. SetDeploymentCondition already does that but</span></span><br><span class="line">			<span class="comment">// it also is not updating conditions when the reason of the new condition is the</span></span><br><span class="line">			<span class="comment">// same as the old. The Progressing condition is a special case because we want to</span></span><br><span class="line">			<span class="comment">// update with the same reason and change just lastUpdateTime iff we notice any</span></span><br><span class="line">			<span class="comment">// progress. That's why we handle it here.</span></span><br><span class="line">			<span class="keyword">if</span> currentCond != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> currentCond.Status == v1.ConditionTrue &#123;</span><br><span class="line">					condition.LastTransitionTime = currentCond.LastTransitionTime</span><br><span class="line">				&#125;</span><br><span class="line">				util.RemoveDeploymentCondition(&amp;newStatus, apps.DeploymentProgressing)</span><br><span class="line">			&#125;</span><br><span class="line">			util.SetDeploymentCondition(&amp;newStatus, *condition)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> util.DeploymentTimedOut(ctx, d, &amp;newStatus):</span><br><span class="line">			<span class="comment">// Update the deployment with a timeout condition. If the condition already exists,</span></span><br><span class="line">			<span class="comment">// we ignore this update.</span></span><br><span class="line">			msg := fmt.Sprintf(<span class="string">"Deployment %q has timed out progressing."</span>, d.Name)</span><br><span class="line">			<span class="keyword">if</span> newRS != <span class="literal">nil</span> &#123;</span><br><span class="line">				msg = fmt.Sprintf(<span class="string">"ReplicaSet %q has timed out progressing."</span>, newRS.Name)</span><br><span class="line">			&#125;</span><br><span class="line">			condition := util.NewDeploymentCondition(apps.DeploymentProgressing, v1.ConditionFalse, util.TimedOutReason, msg)</span><br><span class="line">			util.SetDeploymentCondition(&amp;newStatus, *condition)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Move failure conditions of all replica sets in deployment conditions. For now,</span></span><br><span class="line">	<span class="comment">// only one failure condition is returned from getReplicaFailures.</span></span><br><span class="line">	<span class="keyword">if</span> replicaFailureCond := dc.getReplicaFailures(allRSs, newRS); <span class="built_in">len</span>(replicaFailureCond) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// There will be only one ReplicaFailure condition on the replica set.</span></span><br><span class="line">		util.SetDeploymentCondition(&amp;newStatus, replicaFailureCond[<span class="number">0</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		util.RemoveDeploymentCondition(&amp;newStatus, apps.DeploymentReplicaFailure)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do not update if there is nothing new to add.</span></span><br><span class="line">	<span class="keyword">if</span> reflect.DeepEqual(d.Status, newStatus) &#123;</span><br><span class="line">		<span class="comment">// Requeue the deployment if required.</span></span><br><span class="line">		dc.requeueStuckDeployment(ctx, d, newStatus)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newDeployment := d</span><br><span class="line">	newDeployment.Status = newStatus</span><br><span class="line">	_, err := dc.client.AppsV1().Deployments(newDeployment.Namespace).UpdateStatus(ctx, newDeployment, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式可以将状态转换的逻辑从主控制器中分离出来，这样做可以使代码更加清晰、易于维护。</p>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/progress.go" target="_blank" rel="noopener">pkg/controller/deployment/progress.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/apps/types.go" target="_blank" rel="noopener">hpkg/apis/apps/types.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Strategy</title>
    <url>/2023/04/07/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BStrategy/</url>
    <content><![CDATA[<p> Strategy也就是<a href="https://refactoringguru.cn/design-patterns/strategy" target="_blank" rel="noopener">策略模式</a></p>
<h6 id="k8s中策略模式的实现"><a href="#k8s中策略模式的实现" class="headerlink" title="k8s中策略模式的实现"></a>k8s中策略模式的实现</h6><p>k8s中为不同的资源对象实现了不同的策略。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/apiserver/pkg/registry/generic/registry/store.go</span></span><br><span class="line"><span class="comment">// Store实现了k8s.io/apiserver/pkg/registry/rest.StandardStorage接口,</span></span><br><span class="line"><span class="comment">// 它允许使用者实现任何需要的非通用函数</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">	NewFunc <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span></span><br><span class="line">	NewListFunc <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 对应的策略</span></span><br><span class="line">	CreateStrategy rest.RESTCreateStrategy</span><br><span class="line">	UpdateStrategy rest.RESTUpdateStrategy</span><br><span class="line">	DeleteStrategy rest.RESTDeleteStrategy</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Deployment实现的策略"><a href="#Deployment实现的策略" class="headerlink" title="Deployment实现的策略"></a>Deployment实现的策略</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pkg/registry/apps/deployment/strategy.go</span></span><br><span class="line"><span class="keyword">type</span> deploymentStrategy <span class="keyword">struct</span> &#123;</span><br><span class="line">	runtime.ObjectTyper</span><br><span class="line">	names.NameGenerator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Strategy is the default logic that applies when creating and updating Deployment</span></span><br><span class="line"><span class="comment">// objects via the REST API.</span></span><br><span class="line"><span class="keyword">var</span> Strategy = deploymentStrategy&#123;legacyscheme.Scheme, names.SimpleNameGenerator&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// PrepareForCreate clears fields that are not allowed to be set by end users on creation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deploymentStrategy)</span> <span class="title">PrepareForCreate</span><span class="params">(ctx context.Context, obj runtime.Object)</span></span> &#123;</span><br><span class="line">	deployment := obj.(*apps.Deployment)</span><br><span class="line">	deployment.Status = apps.DeploymentStatus&#123;&#125;</span><br><span class="line">	deployment.Generation = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	pod.DropDisabledTemplateFields(&amp;deployment.Spec.Template, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate validates a new deployment.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deploymentStrategy)</span> <span class="title">Validate</span><span class="params">(ctx context.Context, obj runtime.Object)</span> <span class="title">field</span>.<span class="title">ErrorList</span></span> &#123;</span><br><span class="line">	deployment := obj.(*apps.Deployment)</span><br><span class="line">	opts := pod.GetValidationOptionsFromPodTemplate(&amp;deployment.Spec.Template, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> appsvalidation.ValidateDeployment(deployment, opts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="ReplicaSet实现的策略"><a href="#ReplicaSet实现的策略" class="headerlink" title="ReplicaSet实现的策略"></a>ReplicaSet实现的策略</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/registry/apps/replicaset/strategy.go</span></span><br><span class="line"><span class="keyword">type</span> rsStrategy <span class="keyword">struct</span> &#123;</span><br><span class="line">	runtime.ObjectTyper</span><br><span class="line">	names.NameGenerator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Strategy is the default logic that applies when creating and updating ReplicaSet objects.</span></span><br><span class="line"><span class="keyword">var</span> Strategy = rsStrategy&#123;legacyscheme.Scheme, names.SimpleNameGenerator&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsStrategy)</span> <span class="title">Validate</span><span class="params">(ctx context.Context, obj runtime.Object)</span> <span class="title">field</span>.<span class="title">ErrorList</span></span> &#123;</span><br><span class="line">	rs := obj.(*apps.ReplicaSet)</span><br><span class="line">	opts := pod.GetValidationOptionsFromPodTemplate(&amp;rs.Spec.Template, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> appsvalidation.ValidateReplicaSet(rs, opts)</span><br><span class="line">&#125;</span><br><span class="line">https:<span class="comment">//groups.google.com/g/kubernetes-sig-apps/c/IGuguCg-vv8rnings for the creation of the given object.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsStrategy)</span> <span class="title">WarningsOnCreate</span><span class="params">(ctx context.Context, obj runtime.Object)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	newRS := obj.(*apps.ReplicaSet)</span><br><span class="line">	<span class="keyword">var</span> warnings []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">if</span> msgs := utilvalidation.IsDNS1123Label(newRS.Name); <span class="built_in">len</span>(msgs) != <span class="number">0</span> &#123;</span><br><span class="line">		warnings = <span class="built_in">append</span>(warnings, fmt.Sprintf(<span class="string">"metadata.name: this is used in Pod names and hostnames, which can result in surprising behavior; a DNS label is recommended: %v"</span>, msgs))</span><br><span class="line">	&#125;</span><br><span class="line">	warnings = <span class="built_in">append</span>(warnings, pod.GetWarningsForPodTemplate(ctx, field.NewPath(<span class="string">"spec"</span>, <span class="string">"template"</span>), &amp;newRS.Spec.Template, <span class="literal">nil</span>)...)</span><br><span class="line">	<span class="keyword">return</span> warnings</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Store如何与对应的Strategy关联"><a href="#Store如何与对应的Strategy关联" class="headerlink" title="Store如何与对应的Strategy关联"></a>Store如何与对应的Strategy关联</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建对应store时指定了Deployment对应的strategy</span></span><br><span class="line"><span class="comment">// pkg/registry/apps/deployment/storage/storage.go</span></span><br><span class="line"><span class="comment">// NewREST returns a RESTStorage object that will work against deployments.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewREST</span><span class="params">(optsGetter generic.RESTOptionsGetter)</span> <span class="params">(*REST, *StatusREST, *RollbackREST, error)</span></span> &#123;</span><br><span class="line">	store := &amp;genericregistry.Store&#123;</span><br><span class="line">		NewFunc:                   <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;apps.Deployment&#123;&#125; &#125;,</span><br><span class="line">		NewListFunc:               <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;apps.DeploymentList&#123;&#125; &#125;,</span><br><span class="line">		DefaultQualifiedResource:  apps.Resource(<span class="string">"deployments"</span>),</span><br><span class="line">		SingularQualifiedResource: apps.Resource(<span class="string">"deployment"</span>),</span><br><span class="line"></span><br><span class="line">		CreateStrategy:      deployment.Strategy,</span><br><span class="line">		UpdateStrategy:      deployment.Strategy,</span><br><span class="line">		DeleteStrategy:      deployment.Strategy,</span><br><span class="line">		ResetFieldsStrategy: deployment.Strategy,</span><br><span class="line"></span><br><span class="line">		TableConvertor: printerstorage.TableConvertor&#123;TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	options := &amp;generic.StoreOptions&#123;RESTOptions: optsGetter&#125;</span><br><span class="line">	<span class="keyword">if</span> err := store.CompleteWithOptions(options); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	statusStore := *store</span><br><span class="line">	statusStore.UpdateStrategy = deployment.StatusStrategy</span><br><span class="line">	statusStore.ResetFieldsStrategy = deployment.StatusStrategy</span><br><span class="line">	<span class="keyword">return</span> &amp;REST&#123;store&#125;, &amp;StatusREST&#123;store: &amp;statusStore&#125;, &amp;RollbackREST&#123;store: store&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对应store时指定了ReplicaSet对应的strategy</span></span><br><span class="line"><span class="comment">// pkg/registry/apps/replicaset/storage/storage.go</span></span><br><span class="line"><span class="comment">// NewREST returns a RESTStorage object that will work against ReplicaSet.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewREST</span><span class="params">(optsGetter generic.RESTOptionsGetter)</span> <span class="params">(*REST, *StatusREST, error)</span></span> &#123;</span><br><span class="line">	store := &amp;genericregistry.Store&#123;</span><br><span class="line">		NewFunc:                   <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;apps.ReplicaSet&#123;&#125; &#125;,</span><br><span class="line">		NewListFunc:               <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">runtime</span>.<span class="title">Object</span></span> &#123; <span class="keyword">return</span> &amp;apps.ReplicaSetList&#123;&#125; &#125;,</span><br><span class="line">		PredicateFunc:             replicaset.MatchReplicaSet,</span><br><span class="line">		DefaultQualifiedResource:  apps.Resource(<span class="string">"replicasets"</span>),</span><br><span class="line">		SingularQualifiedResource: apps.Resource(<span class="string">"replicaset"</span>),</span><br><span class="line"></span><br><span class="line">		CreateStrategy:      replicaset.Strategy,</span><br><span class="line">		UpdateStrategy:      replicaset.Strategy,</span><br><span class="line">		DeleteStrategy:      replicaset.Strategy,</span><br><span class="line">		ResetFieldsStrategy: replicaset.Strategy,</span><br><span class="line"></span><br><span class="line">		TableConvertor: printerstorage.TableConvertor&#123;TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	options := &amp;generic.StoreOptions&#123;RESTOptions: optsGetter, AttrFunc: replicaset.GetAttrs&#125;</span><br><span class="line">	<span class="keyword">if</span> err := store.CompleteWithOptions(options); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	statusStore := *store</span><br><span class="line">	statusStore.UpdateStrategy = replicaset.StatusStrategy</span><br><span class="line">	statusStore.ResetFieldsStrategy = replicaset.StatusStrategy</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;REST&#123;store&#125;, &amp;StatusREST&#123;store: &amp;statusStore&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="何时调用Strategy"><a href="#何时调用Strategy" class="headerlink" title="何时调用Strategy"></a>何时调用Strategy</h6><p>例如CreateStrategy,在创建<code>Deployment</code>的时候会执行<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">Create</span><span class="params">(ctx context.Context, obj runtime.Object, createValidation rest.ValidateObjectFunc, options *metav1.CreateOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> finishCreate FinishFunc = finishNothing</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init metadata as early as possible.</span></span><br><span class="line">	<span class="keyword">if</span> objectMeta, err := meta.Accessor(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rest.FillObjectMetaSystemFields(objectMeta)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(objectMeta.GetGenerateName()) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(objectMeta.GetName()) == <span class="number">0</span> &#123;</span><br><span class="line">			objectMeta.SetName(e.CreateStrategy.GenerateName(objectMeta.GetGenerateName()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> err := rest.BeforeCreate(e.CreateStrategy, ctx, obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go" target="_blank" rel="noopener">pkg/registry/generic/registry/store.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/registry/apps/replicaset/strategy.go" target="_blank" rel="noopener">pkg/registry/apps/replicaset/strategy.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/registry/apps/replicaset/storage/storage.go" target="_blank" rel="noopener">pkg/registry/apps/replicaset/storage/storage.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/registry/apps/deployment/strategy.go" target="_blank" rel="noopener">pkg/registry/apps/deployment/strategy.go</a><br>5.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/registry/apps/deployment/storage/storage.go" target="_blank" rel="noopener">pkg/registry/apps/deployment/storage/storage.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Template Method</title>
    <url>/2023/04/10/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BTemplate-Method/</url>
    <content><![CDATA[<p><a href="https://refactoringguru.cn/design-patterns/template-method" target="_blank" rel="noopener">模板方法</a>是一种行为设计模式，用于定义一个操作的算法骨架，而将一些步骤的实现推迟到子类中。它可以使子类在不改变算法结构的情况下重定义算法中的某些步骤。</p>
<p>k8s源码中<code>client-go</code>中模版方法</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/client-go/rest/client.go</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetRateLimiter() flowcontrol.RateLimiter</span><br><span class="line">	Verb(verb <span class="keyword">string</span>) *Request</span><br><span class="line">	Post() *Request</span><br><span class="line">	Put() *Request</span><br><span class="line">	Patch(pt types.PatchType) *Request</span><br><span class="line">	Get() *Request</span><br><span class="line">	Delete() *Request</span><br><span class="line">	APIVersion() schema.GroupVersion</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RESTClient实现了Interface</span></span><br><span class="line"><span class="keyword">type</span> RESTClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// base is the root URL for all invocations of the client</span></span><br><span class="line">	base *url.URL</span><br><span class="line">	<span class="comment">// versionedAPIPath is a path segment connecting the base URL to the resource root</span></span><br><span class="line">	versionedAPIPath <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// content describes how a RESTClient encodes and decodes responses.</span></span><br><span class="line">	content ClientContentConfig</span><br><span class="line"></span><br><span class="line">	<span class="comment">// creates BackoffManager that is passed to requests.</span></span><br><span class="line">	createBackoffMgr <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">BackoffManager</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// rateLimiter is shared among all requests created by this client unless specifically</span></span><br><span class="line">	<span class="comment">// overridden.</span></span><br><span class="line">	rateLimiter flowcontrol.RateLimiter</span><br><span class="line"></span><br><span class="line">	<span class="comment">// warningHandler is shared among all requests created by this client.</span></span><br><span class="line">	<span class="comment">// If not set, defaultWarningHandler is used.</span></span><br><span class="line">	warningHandler WarningHandler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set specific behavior of the client.  If not set http.DefaultClient will be used.</span></span><br><span class="line">	Client *http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/client-go/dynamic/simple.go</span></span><br><span class="line"><span class="keyword">type</span> DynamicClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	client rest.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dynamicResourceClient对需要重写的方法进行了重写</span></span><br><span class="line"><span class="keyword">type</span> dynamicResourceClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	client    *DynamicClient</span><br><span class="line">	namespace <span class="keyword">string</span></span><br><span class="line">	resource  schema.GroupVersionResource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/rest/client.go" target="_blank" rel="noopener">staging/src/k8s.io/client-go/rest/client.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/dynamic/simple.go" target="_blank" rel="noopener">staging/src/k8s.io/client-go/dynamic/simple.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s设计模式之Command</title>
    <url>/2023/04/16/k8s%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BCommand/</url>
    <content><![CDATA[<p><a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener">命令模式</a>也叫<code>动作</code>,<code>事务</code>,<code>Action</code>,<code>Transaction</code>,<code>Command</code>。</p>
<p>命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/config/config.go</span></span><br><span class="line"><span class="comment">// 处理Pod配置的相关操作</span></span><br><span class="line"><span class="keyword">type</span> PodConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 存储当前kubelet所管理的所有的Pod信息</span></span><br><span class="line">	pods *podStorage</span><br><span class="line">    <span class="comment">// 用于合并多个Pod配置来源的更新,</span></span><br><span class="line">	mux  *config.Mux</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the channel of denormalized changes passed to listeners</span></span><br><span class="line">    <span class="comment">// 通常被用于将不同来源的更新合并并发送给订阅者。订阅者可以通过该通道获取最新的 Pod 配置信息</span></span><br><span class="line">	updates <span class="keyword">chan</span> kubetypes.PodUpdate</span><br><span class="line"></span><br><span class="line">	<span class="comment">// contains the list of all configured sources</span></span><br><span class="line">	sourcesLock sync.Mutex</span><br><span class="line">    <span class="comment">// Pod配置来源，i.e.(file, api)</span></span><br><span class="line">	sources     sets.String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// podStorage管理当前Pod状态,确保更新信息在updates通道是严格有序的传递</span></span><br><span class="line"><span class="keyword">type</span> podStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">	podLock sync.RWMutex</span><br><span class="line">	<span class="comment">// map of source name to pod uid to pod reference</span></span><br><span class="line">	pods <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[types.UID]*v1.Pod</span><br><span class="line">	mode PodConfigNotificationMode</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ensures that updates are delivered in strict order</span></span><br><span class="line">	<span class="comment">// on the updates channel</span></span><br><span class="line">	updateLock sync.Mutex</span><br><span class="line">        <span class="comment">// 表示的是Pod状态的更新</span></span><br><span class="line">	updates    <span class="keyword">chan</span>&lt;- kubetypes.PodUpdate</span><br><span class="line"></span><br><span class="line">	<span class="comment">// contains the set of all sources that have sent at least one SET</span></span><br><span class="line">	sourcesSeenLock sync.RWMutex</span><br><span class="line">	sourcesSeen     sets.String</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the EventRecorder to use</span></span><br><span class="line">	recorder record.EventRecorder</span><br><span class="line"></span><br><span class="line">	startupSLIObserver podStartupSLIObserver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PodConfig</code> 结构体使用了<code>命令模式</code>的思想，将多个来源的 <code>Pod</code> 配置信息抽象为一个接口，通过 <code>mux</code> 对象实现了命令对象的统一管理和执行，同时通过 <code>updates</code> 通道将执行结果传递给其他组件。这样做的好处是可以很方便地扩展 <code>Pod</code> 配置来源的种类，也可以保证不同来源的更新按顺序执行，避免了竞态问题。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/kubelet.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startKubelet</span><span class="params">(k kubelet.Bootstrap, podCfg *config.PodConfig, kubeCfg *kubeletconfiginternal.KubeletConfiguration, kubeDeps *kubelet.Dependencies, enableServer <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// start the kubelet</span></span><br><span class="line">	<span class="keyword">go</span> k.Run(podCfg.Updates())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start the kubelet server</span></span><br><span class="line">	<span class="keyword">if</span> enableServer &#123;</span><br><span class="line">		<span class="keyword">go</span> k.ListenAndServe(kubeCfg, kubeDeps.TLSOptions, kubeDeps.Auth, kubeDeps.TracerProvider)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> kubeCfg.ReadOnlyPort &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> k.ListenAndServeReadOnly(netutils.ParseIPSloppy(kubeCfg.Address), <span class="keyword">uint</span>(kubeCfg.ReadOnlyPort))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.KubeletPodResources) &#123;</span><br><span class="line">		<span class="keyword">go</span> k.ListenAndServePodResources()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run starts the kubelet reacting to config updates</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">Run</span><span class="params">(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate)</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	<span class="keyword">if</span> kl.logServer == <span class="literal">nil</span> &#123;</span><br><span class="line">		file := http.FileServer(http.Dir(nodeLogDir))</span><br><span class="line">		<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.NodeLogQuery) &amp;&amp; kl.kubeletConfiguration.EnableSystemLogQuery &#123;</span><br><span class="line">			kl.logServer = http.StripPrefix(<span class="string">"/logs/"</span>, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> nlq, errs := newNodeLogQuery(req.URL.Query()); <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">					http.Error(w, errs.ToAggregate().Error(), http.StatusBadRequest)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> nlq != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> req.URL.Path != <span class="string">"/"</span> &amp;&amp; req.URL.Path != <span class="string">""</span> &#123;</span><br><span class="line">						http.Error(w, <span class="string">"path not allowed in query mode"</span>, http.StatusNotAcceptable)</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> errs := nlq.validate(); <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						http.Error(w, errs.ToAggregate().Error(), http.StatusNotAcceptable)</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// Validation ensures that the request does not query services and files at the same time</span></span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(nlq.Services) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						journal.ServeHTTP(w, req)</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// Validation ensures that the request does not explicitly query multiple files at the same time</span></span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(nlq.Files) == <span class="number">1</span> &#123;</span><br><span class="line">						<span class="comment">// Account for the \ being used on Windows clients</span></span><br><span class="line">						req.URL.Path = filepath.ToSlash(nlq.Files[<span class="number">0</span>])</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Fall back in case the caller is directly trying to query a file</span></span><br><span class="line">				<span class="comment">// Example: kubectl get --raw /api/v1/nodes/$name/proxy/logs/foo.log</span></span><br><span class="line">				file.ServeHTTP(w, req)</span><br><span class="line">			&#125;))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			kl.logServer = http.StripPrefix(<span class="string">"/logs/"</span>, file)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> kl.kubeClient == <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.InfoS(<span class="string">"No API server defined - no node status update will be sent"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the cloud provider sync manager</span></span><br><span class="line">	<span class="keyword">if</span> kl.cloudResourceSyncManager != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> kl.cloudResourceSyncManager.Run(wait.NeverStop)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := kl.initializeModules(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		kl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.KubeletSetupFailed, err.Error())</span><br><span class="line">		klog.ErrorS(err, <span class="string">"Failed to initialize internal modules"</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start volume manager</span></span><br><span class="line">	<span class="keyword">go</span> kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kl.kubeClient != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Start two go-routines to update the status.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// The first will report to the apiserver every nodeStatusUpdateFrequency and is aimed to provide regular status intervals,</span></span><br><span class="line">		<span class="comment">// while the second is used to provide a more timely status update during initialization and runs an one-shot update to the apiserver</span></span><br><span class="line">		<span class="comment">// once the node becomes ready, then exits afterwards.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Introduce some small jittering to ensure that over time the requests won't start</span></span><br><span class="line">		<span class="comment">// accumulating at approximately the same time from the set of nodes due to priority and</span></span><br><span class="line">		<span class="comment">// fairness effect.</span></span><br><span class="line">		<span class="keyword">go</span> wait.JitterUntil(kl.syncNodeStatus, kl.nodeStatusUpdateFrequency, <span class="number">0.04</span>, <span class="literal">true</span>, wait.NeverStop)</span><br><span class="line">		<span class="keyword">go</span> kl.fastStatusUpdateOnce()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// start syncing lease</span></span><br><span class="line">		<span class="keyword">go</span> kl.nodeLeaseController.Run(context.Background())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> wait.Until(kl.updateRuntimeUp, <span class="number">5</span>*time.Second, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set up iptables util rules</span></span><br><span class="line">	<span class="keyword">if</span> kl.makeIPTablesUtilChains &#123;</span><br><span class="line">		kl.initNetworkUtil()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start component sync loops.</span></span><br><span class="line">	kl.statusManager.Start()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start syncing RuntimeClasses if enabled.</span></span><br><span class="line">	<span class="keyword">if</span> kl.runtimeClassManager != <span class="literal">nil</span> &#123;</span><br><span class="line">		kl.runtimeClassManager.Start(wait.NeverStop)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the pod lifecycle event generator.</span></span><br><span class="line">	kl.pleg.Start()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start eventedPLEG only if EventedPLEG feature gate is enabled.</span></span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.EventedPLEG) &#123;</span><br><span class="line">		kl.eventedPleg.Start()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// syncLoop 是一个处理变化的主循环,监听三个通道(file, apiserver, http)</span></span><br><span class="line">	kl.syncLoop(ctx, updates, kl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/command</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/config/config.go" target="_blank" rel="noopener">pkg/kubelet/config/config.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet.go" target="_blank" rel="noopener">pkg/kubelet/kubelet.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s源码设计模式之Visitor</title>
    <url>/2023/04/07/k8s%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BVisitor/</url>
    <content><![CDATA[<p>Visitor模式也叫<a href="https://refactoringguru.cn/design-patterns/visitor" target="_blank" rel="noopener">访问模式</a></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/cli-runtime/pkg/resource/interfaces.go</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">	Visit(VisitorFunc) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VisitorFunc <span class="function"><span class="keyword">func</span><span class="params">(*Info, error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendor/k8s.io/cli-runtime/pkg/resource/visitor.go</span></span><br><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">	Client RESTClient</span><br><span class="line"></span><br><span class="line">	Mapping *meta.RESTMapping</span><br><span class="line"></span><br><span class="line">	Namespace <span class="keyword">string</span></span><br><span class="line">	Name      <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	Source <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	Object runtime.Object</span><br><span class="line">	ResourceVersion <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	Subresource <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从io.Reader读取数据</span></span><br><span class="line"><span class="keyword">type</span> StreamVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	io.Reader</span><br><span class="line">	*mapper</span><br><span class="line"></span><br><span class="line">	Source <span class="keyword">string</span></span><br><span class="line">	Schema ContentValidator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的Visitor处理不同的对象，比如URLVisitor处理URL,FileVisitor处理文件</span></span><br><span class="line"><span class="comment">// 从URL中下载文件</span></span><br><span class="line"><span class="keyword">type</span> URLVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	URL *url.URL</span><br><span class="line">	*StreamVisitor</span><br><span class="line">	HttpAttemptCount <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FileVisitor is wrapping around a StreamVisitor, to handle open/close files</span></span><br><span class="line"><span class="keyword">type</span> FileVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	*StreamVisitor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visit函数在一个流中实现了Visitor接口。StreamVisitor可以在一个流中区分多个资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *StreamVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	d := yaml.NewYAMLOrJSONDecoder(v.Reader, <span class="number">4096</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		ext := runtime.RawExtension&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> err := d.Decode(&amp;ext); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"error parsing %s: %v"</span>, v.Source, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> This needs to be able to handle object in other encodings and schemas.</span></span><br><span class="line">		ext.Raw = bytes.TrimSpace(ext.Raw)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(ext.Raw) == <span class="number">0</span> || bytes.Equal(ext.Raw, []<span class="keyword">byte</span>(<span class="string">"null"</span>)) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := ValidateSchema(ext.Raw, v.Schema); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"error validating %q: %v"</span>, v.Source, err)</span><br><span class="line">		&#125;</span><br><span class="line">		info, err := v.infoForData(ext.Raw, v.Source)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> fnErr := fn(info, err); fnErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> fnErr</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := fn(info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Visit in a FileVisitor is just taking care of opening/closing files</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *FileVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f *os.File</span><br><span class="line">	<span class="keyword">if</span> v.Path == constSTDINstr &#123;</span><br><span class="line">		f = os.Stdin</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		f, err = os.Open(v.Path)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> f.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Consider adding a flag to force to UTF16, apparently some</span></span><br><span class="line">	<span class="comment">// Windows tools don't write the BOM</span></span><br><span class="line">	utf16bom := unicode.BOMOverride(unicode.UTF8.NewDecoder())</span><br><span class="line">	v.StreamVisitor.Reader = transform.NewReader(f, utf16bom)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> v.StreamVisitor.Visit(fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造r.visitor</span></span><br><span class="line"><span class="comment">// 这里有两层嵌套，ContinueOnErrorVisitor,NewDecoratedVisitor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Do</span><span class="params">()</span> *<span class="title">Result</span></span> &#123;</span><br><span class="line">	r := b.visitorResult()</span><br><span class="line">	r.mapper = b.Mapper()</span><br><span class="line">	<span class="keyword">if</span> r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b.flatten &#123;</span><br><span class="line">		r.visitor = NewFlattenListVisitor(r.visitor, b.objectTyper, b.mapper)</span><br><span class="line">	&#125;</span><br><span class="line">	helpers := []VisitorFunc&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> b.defaultNamespace &#123;</span><br><span class="line">		helpers = <span class="built_in">append</span>(helpers, SetNamespace(b.namespace))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b.requireNamespace &#123;</span><br><span class="line">		helpers = <span class="built_in">append</span>(helpers, RequireNamespace(b.namespace))</span><br><span class="line">	&#125;</span><br><span class="line">	helpers = <span class="built_in">append</span>(helpers, FilterNamespace)</span><br><span class="line">	<span class="keyword">if</span> b.requireObject &#123;</span><br><span class="line">		helpers = <span class="built_in">append</span>(helpers, RetrieveLazy)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b.continueOnError &#123;</span><br><span class="line">		r.visitor = ContinueOnErrorVisitor&#123;Visitor: r.visitor&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r.visitor = NewDecoratedVisitor(r.visitor, helpers...)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *CreateOptions)</span> <span class="title">RunCreate</span><span class="params">(f cmdutil.Factory, cmd *cobra.Command)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会构造一个嵌套的visitor</span></span><br><span class="line">	r := f.NewBuilder().</span><br><span class="line">		Unstructured().</span><br><span class="line">		Schema(schema).</span><br><span class="line">		ContinueOnError().</span><br><span class="line">		NamespaceParam(cmdNamespace).DefaultNamespace().</span><br><span class="line">		FilenameParam(enforceNamespace, &amp;o.FilenameOptions).</span><br><span class="line">		LabelSelectorParam(o.Selector).</span><br><span class="line">		Flatten().</span><br><span class="line">		Do()</span><br><span class="line">	err = r.Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 调用Result的Vistor</span></span><br><span class="line">    <span class="comment">// 会调用不同的Visitor并填充info结构体　</span></span><br><span class="line">	err = r.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *resource.Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := util.CreateOrUpdateAnnotation(cmdutil.GetFlagBool(cmd, cmdutil.ApplyAnnotationsFlag), info.Object, scheme.DefaultJSONEncoder()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> cmdutil.AddSourceToErr(<span class="string">"creating"</span>, info.Source, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := o.Recorder.Record(info.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"error recording current command: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> o.DryRunStrategy != cmdutil.DryRunClient &#123;</span><br><span class="line">            <span class="comment">// 构造请求通过RESTClient向apiserver发送一个Post请求</span></span><br><span class="line">			obj, err := resource.</span><br><span class="line">				NewHelper(info.Client, info.Mapping).</span><br><span class="line">				DryRun(o.DryRunStrategy == cmdutil.DryRunServer).</span><br><span class="line">				WithFieldManager(o.fieldManager).</span><br><span class="line">				WithFieldValidation(o.ValidationDirective).</span><br><span class="line">				Create(info.Namespace, <span class="literal">true</span>, info.Object)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> cmdutil.AddSourceToErr(<span class="string">"creating"</span>, info.Source, err)</span><br><span class="line">			&#125;</span><br><span class="line">			info.Refresh(obj, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		count++</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> o.PrintObj(info.Object)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"no objects passed to create"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面是一层一层Visit方法的调用</span></span><br><span class="line"><span class="comment">// DecoratedVisitor.Visit</span></span><br><span class="line"><span class="comment">// ContinueOnErrorVisitor.Visit</span></span><br><span class="line"><span class="comment">// FlattenListVisitor.Visit</span></span><br><span class="line"><span class="comment">// FlattenListVisitor.Visit</span></span><br><span class="line"><span class="comment">// EagerVisitorList.Visit</span></span><br><span class="line"><span class="comment">// FileVisitor.Visit</span></span><br><span class="line"><span class="comment">// StreamVisitor.Visit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Result)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r.err</span><br><span class="line">	&#125;</span><br><span class="line">	err := r.visitor.Visit(fn)</span><br><span class="line">	<span class="keyword">return</span> utilerrors.FilterOut(err, r.ignoreErrors...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DecoratedVistor,这里使用的是装饰器模式</span></span><br><span class="line"><span class="comment">// golang不像python那样提供语法糖，所以只能通过这种方式实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v DecoratedVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> v.decorators &#123;</span><br><span class="line">			<span class="keyword">if</span> err := v.decorators[i](info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		r := fn(info, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ContinueOnErrorVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> errs []error</span><br><span class="line">	err := v.Visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := fn(info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(errs) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errs[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v FlattenListVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.visitor.Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> info.Object == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fn(info, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !meta.IsListType(info.Object) &#123;</span><br><span class="line">			<span class="keyword">return</span> fn(info, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		items := []runtime.Object&#123;&#125;</span><br><span class="line">		itemsToProcess := []runtime.Object&#123;info.Object&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(itemsToProcess); i++ &#123;</span><br><span class="line">			currObj := itemsToProcess[i]</span><br><span class="line">			<span class="keyword">if</span> !meta.IsListType(currObj) &#123;</span><br><span class="line">				items = <span class="built_in">append</span>(items, currObj)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			currItems, err := meta.ExtractList(currObj)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> errs := runtime.DecodeList(currItems, v.mapper.decoder); <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">			&#125;</span><br><span class="line">			itemsToProcess = <span class="built_in">append</span>(itemsToProcess, currItems...)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If we have a GroupVersionKind on the list, prioritize that when asking for info on the objects contained in the list</span></span><br><span class="line">		<span class="keyword">var</span> preferredGVKs []schema.GroupVersionKind</span><br><span class="line">		<span class="keyword">if</span> info.Mapping != <span class="literal">nil</span> &amp;&amp; !info.Mapping.GroupVersionKind.Empty() &#123;</span><br><span class="line">			preferredGVKs = <span class="built_in">append</span>(preferredGVKs, info.Mapping.GroupVersionKind)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> errs []error</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> items &#123;</span><br><span class="line">			item, err := v.mapper.infoForObject(items[i], v.typer, preferredGVKs)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(info.ResourceVerEagerVisitorListsion) != <span class="number">0</span> &#123;</span><br><span class="line">				item.ResourceVersion = info.ResourceVersion</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// propagate list source to items source</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(info.Source) != <span class="number">0</span> &#123;</span><br><span class="line">				item.Source = info.Source</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := fn(item, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l EagerVisitorList)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> errs []error</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> l &#123;</span><br><span class="line">		err := l[i].Visit(<span class="function"><span class="keyword">func</span><span class="params">(info *Info, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := fn(info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *FileVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f *os.File</span><br><span class="line">	<span class="keyword">if</span> v.Path == constSTDINstr &#123;</span><br><span class="line">		f = os.Stdin</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		f, err = os.Open(v.Path)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> f.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	utf16bom := unicode.BOMOverride(unicode.UTF8.NewDecoder())</span><br><span class="line">	v.StreamVisitor.Reader = transform.NewReader(f, utf16bom)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> v.StreamVisitor.Visit(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *StreamVisitor)</span> <span class="title">Visit</span><span class="params">(fn VisitorFunc)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	d := yaml.NewYAMLOrJSONDecoder(v.Reader, <span class="number">4096</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		ext := runtime.RawExtension&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> err := d.Decode(&amp;ext); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"error parsing %s: %v"</span>, v.Source, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> This needs to be able to handle object in other encodings and schemas.</span></span><br><span class="line">		ext.Raw = bytes.TrimSpace(ext.Raw)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(ext.Raw) == <span class="number">0</span> || bytes.Equal(ext.Raw, []<span class="keyword">byte</span>(<span class="string">"null"</span>)) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := ValidateSchema(ext.Raw, v.Schema); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"error validating %q: %v"</span>, v.Source, err)</span><br><span class="line">		&#125;</span><br><span class="line">		info, err := v.infoForData(ext.Raw, v.Source)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> fnErr := fn(info, err); fnErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> fnErr</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := fn(info, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://coolshell.cn/articles/21263.html" target="_blank" rel="noopener">https://coolshell.cn/articles/21263.html</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cli-runtime/pkg/resource/builder.go" target="_blank" rel="noopener">staging/src/k8s.io/cli-runtime/pkg/resource/builder.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cli-runtime/pkg/resource/builder.go" target="_blank" rel="noopener">staging/src/k8s.io/cli-runtime/pkg/resource/visitor.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubectl/pkg/cmd/create/create.go" target="_blank" rel="noopener">staging/src/k8s.io/kubectl/pkg/cmd/create/create.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller-manager</title>
    <url>/2023/04/27/kube-controller-manager/</url>
    <content><![CDATA[<p><code>kube-controller-manager</code>是<code>k8s</code>中一个非常重要的组件,它主要负责管理<code>k8s</code>集群中的各种资源调节到预期状态。<code>kube-controller-manager</code>中有多种内置的<code>controller</code>，它们其实就是一个永不停止的循环，不断的调节系统达到预期的状态。<br><code>k8s</code>中有多种内置的<code>controller</code>，接下来这段时间会对这些<code>controller</code>一个一个分析。<br><em>X</em> <a href>certificate-controller</a><br><em>X</em> <a href>cronjob-controller</a><br><a href="https://hysyeah.top/2023/06/16/kube-controller%E4%B9%8Bdaemonset/" target="_blank" rel="noopener">daemon-controller</a><br><a href="https://hysyeah.top/2023/05/08/kube-controller%E4%B9%8Bdeployment/" target="_blank" rel="noopener">deployment-controller</a><br><em>X</em> <a href>disruption-controller</a><br><a href="https://hysyeah.top/2023/05/03/kube-controller%E4%B9%8Bendpoint/" target="_blank" rel="noopener">endpoint-controller</a><br><a href="https://hysyeah.top/2023/05/07/kube-controller%E4%B9%8Bendpointslice/" target="_blank" rel="noopener">endpointslice-controller</a><br><em>X</em> <a href>endpointslicemirroring-controller</a><br><em>X</em> <a href>garbagecollector-controller</a><br><a href="https://hysyeah.top/2023/06/25/kube-controller%E4%B9%8Bhistory/" target="_blank" rel="noopener">history-controller</a><br><a href="https://hysyeah.top/2023/06/21/kube-controller%E4%B9%8Bjob/" target="_blank" rel="noopener">job-controller</a><br><a href="https://hysyeah.top/2023/05/11/kube-controller%E4%B9%8Bnamespace/" target="_blank" rel="noopener">namespace-controller</a><br><em>X</em> <a href>nodeipam-controller</a><br><em>X</em> <a href>nodelifecycle-controller</a><br><a href="https://hysyeah.top/2023/06/14/kube-controller%E4%B9%8Bhpa/" target="_blank" rel="noopener">podautoscaler-controller</a><br><a href="https://hysyeah.top/2023/05/12/kube-controller%E4%B9%8Bpodgc" target="_blank" rel="noopener">podgc-controller</a><br><a href="https://hysyeah.top/2023/05/10/kube-controller%E4%B9%8Breplicaset/" target="_blank" rel="noopener">replicaset-controller</a><br><em>X</em> <a href>replication-controller</a><br><a href="https://hysyeah.top/2023/06/18/kube-controller%E4%B9%8Bresourceclaim/" target="_blank" rel="noopener">resourceclaim-controller</a><br><a href="https://hysyeah.top/2023/06/15/kube-controller%E4%B9%8Bresource-quota" target="_blank" rel="noopener">resourcequota-controller</a><br><a href="https://hysyeah.top/2023/05/24/kube-controller%E4%B9%8BServiceAccounts/" target="_blank" rel="noopener">serviceaccount-controller</a><br><a href="https://hysyeah.top/2023/07/15/kube-controller%E4%B9%8Bstatefulset/" target="_blank" rel="noopener">statefulset-controller</a><br><a href="https://hysyeah.top/2023/07/30/kube-controller%E4%B9%8Bstorageversion/" target="_blank" rel="noopener">storageversiongc-controller</a><br><a href="https://hysyeah.top/2023/06/17/kube-controller%E4%B9%8Bttl/" target="_blank" rel="noopener">ttl-controller</a><br><a href="https://hysyeah.top/2023/06/24/kube-controller%E4%B9%8Bttlafterfinished/" target="_blank" rel="noopener">ttlafterfinished-controller</a><br><em>X</em> <a href>volume-controller</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之ServiceAccounts</title>
    <url>/2023/05/24/kube-controller%E4%B9%8BServiceAccounts/</url>
    <content><![CDATA[<p>ServiceAccountsController 是 Kubernetes 中的一个控制器，负责管理和维护 Service Account 资源。</p>
<p>Service Account 是 Kubernetes 中用于身份验证和授权的一种机制。它与 Pod 关联，为 Pod 提供一个身份标识。通过 Service Account，Pod 可以与 API 服务器进行身份验证，并根据其与 Service Account 关联的角色和权限来访问集群中的资源。</p>
<p>ServiceAccountsController 的主要职责包括以下几个方面：</p>
<ol>
<li>创建Service Account：当创建Namespace 时，ServiceAccountsController 会检查该Namespace下是否存在”default” ServiceAccounts,如果不存在则创建。</li>
</ol>
<hr>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultServiceAccountsControllerOptions</span><span class="params">()</span> <span class="title">ServiceAccountsControllerOptions</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ServiceAccountsControllerOptions&#123;</span><br><span class="line">		ServiceAccounts: []v1.ServiceAccount&#123;</span><br><span class="line">			&#123;ObjectMeta: metav1.ObjectMeta&#123;Name: <span class="string">"default"</span>&#125;&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/controller/serviceaccount/serviceaccounts_controller.go</span></span><br><span class="line"><span class="keyword">type</span> ServiceAccountsController <span class="keyword">struct</span> &#123;</span><br><span class="line">	client                  clientset.Interface</span><br><span class="line">	serviceAccountsToEnsure []v1.ServiceAccount</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To allow injection for testing.</span></span><br><span class="line">	syncHandler <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">	saLister       corelisters.ServiceAccountLister</span><br><span class="line">	saListerSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	nsLister       corelisters.NamespaceLister</span><br><span class="line">	nsListerSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewServiceAccountsController 监听两种资源对象</span></span><br><span class="line"><span class="comment">// ServiceAccounts 监听删除事件,将key入队</span></span><br><span class="line"><span class="comment">// Namespaces 监听创建和更新事件,将key入队</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServiceAccountsController</span><span class="params">(saInformer coreinformers.ServiceAccountInformer, nsInformer coreinformers.NamespaceInformer, cl clientset.Interface, options ServiceAccountsControllerOptions)</span> <span class="params">(*ServiceAccountsController, error)</span></span> &#123;</span><br><span class="line">	e := &amp;ServiceAccountsController&#123;</span><br><span class="line">		client:                  cl,</span><br><span class="line">        <span class="comment">// serviceAccountsToEnsure, 有一个名为"default"的serviceAccount</span></span><br><span class="line">		serviceAccountsToEnsure: options.ServiceAccounts,</span><br><span class="line">		queue:                   workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"serviceaccount"</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	saHandler, _ := saInformer.Informer().AddEventHandlerWithResyncPeriod(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		DeleteFunc: e.serviceAccountDeleted,</span><br><span class="line">	&#125;, options.ServiceAccountResync)</span><br><span class="line">	e.saLister = saInformer.Lister()</span><br><span class="line">	e.saListerSynced = saHandler.HasSynced</span><br><span class="line"></span><br><span class="line">	nsHandler, _ := nsInformer.Informer().AddEventHandlerWithResyncPeriod(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc:    e.namespaceAdded,</span><br><span class="line">		UpdateFunc: e.namespaceUpdated,</span><br><span class="line">	&#125;, options.NamespaceResync)</span><br><span class="line">	e.nsLister = nsInformer.Lister()</span><br><span class="line">	e.nsListerSynced = nsHandler.HasSynced</span><br><span class="line"></span><br><span class="line">    <span class="comment">// syncHandler为syncNamespace</span></span><br><span class="line">	e.syncHandler = e.syncNamespace</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> e, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ServiceAccountsController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> c.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	klog.FromContext(ctx).Info(<span class="string">"Starting service account controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> klog.FromContext(ctx).Info(<span class="string">"Shutting down service account controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"service account"</span>, ctx.Done(), c.saListerSynced, c.nsListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, c.runWorker, time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ServiceAccountsController)</span> <span class="title">runWorker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> c.processNextWorkItem(ctx) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processNextWorkItem deals with one key off the queue.  It returns false when it's time to quit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ServiceAccountsController)</span> <span class="title">processNextWorkItem</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	key, quit := c.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> c.queue.Done(key)</span><br><span class="line"></span><br><span class="line">	err := c.syncHandler(ctx, key.(<span class="keyword">string</span>))</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.queue.Forget(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	utilruntime.HandleError(fmt.Errorf(<span class="string">"%v failed with : %v"</span>, key, err))</span><br><span class="line">	c.queue.AddRateLimited(key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ServiceAccountsController)</span> <span class="title">syncNamespace</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		klog.FromContext(ctx).V(<span class="number">4</span>).Info(<span class="string">"Finished syncing namespace"</span>, <span class="string">"namespace"</span>, key, <span class="string">"duration"</span>, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	ns, err := c.nsLister.Get(key)</span><br><span class="line">	<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Namespace状态不是Active,不做任何事</span></span><br><span class="line">	<span class="keyword">if</span> ns.Status.Phase != v1.NamespaceActive &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	createFailures := []error&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, sa := <span class="keyword">range</span> c.serviceAccountsToEnsure &#123;</span><br><span class="line">        <span class="comment">// 判断对应的命名空间下有没有名为"default"的ServiceAccounts</span></span><br><span class="line">		<span class="keyword">switch</span> _, err := c.saLister.ServiceAccounts(ns.Name).Get(sa.Name); &#123;</span><br><span class="line">		<span class="keyword">case</span> err == <span class="literal">nil</span>:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">        <span class="comment">// 如果err是NotFound,则会在下面的逻辑中创建新的ServiceAccounts</span></span><br><span class="line">		<span class="keyword">case</span> apierrors.IsNotFound(err):</span><br><span class="line">		<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// this is only safe because we never read it and we always write it</span></span><br><span class="line">		<span class="comment">// TODO eliminate this once the fake client can handle creation without NS</span></span><br><span class="line">		sa.Namespace = ns.Name</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> _, err := c.client.CoreV1().ServiceAccounts(ns.Name).Create(ctx, &amp;sa, metav1.CreateOptions&#123;&#125;); err != <span class="literal">nil</span> &amp;&amp; !apierrors.IsAlreadyExists(err) &#123;</span><br><span class="line">			<span class="comment">// we can safely ignore terminating namespace errors</span></span><br><span class="line">			<span class="keyword">if</span> !apierrors.HasStatusCause(err, v1.NamespaceTerminatingCause) &#123;</span><br><span class="line">				createFailures = <span class="built_in">append</span>(createFailures, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> utilerrors.Flatten(utilerrors.NewAggregate(createFailures))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动入口</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/kube-controller-manager/app/core.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServiceAccountController</span><span class="params">(ctx context.Context, controllerContext ControllerContext)</span> <span class="params">(controller.Interface, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	sac, err := serviceaccountcontroller.NewServiceAccountsController(</span><br><span class="line">		controllerContext.InformerFactory.Core().V1().ServiceAccounts(),</span><br><span class="line">		controllerContext.InformerFactory.Core().V1().Namespaces(),</span><br><span class="line">		controllerContext.ClientBuilder.ClientOrDie(<span class="string">"service-account-controller"</span>),</span><br><span class="line">		serviceaccountcontroller.DefaultServiceAccountsControllerOptions(),</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, fmt.Errorf(<span class="string">"error creating ServiceAccount controller: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> sac.Run(ctx, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>当 Pod 使用 ServiceAccount 运行时，Kubernetes 会自动为该 ServiceAccount 创建一个与之关联的 Token。这个 Token 通常存储在 Pod 的文件系统中的 /var/run/secrets/kubernetes.io/serviceaccount/token 文件中。Pod 中的容器可以通过读取该文件来获取与 ServiceAccount 相关联的 Token。</p>
<p>Token 是一种用于身份验证的凭据，它可以用于与 Kubernetes API 服务器进行身份验证和授权操作。Pod 中的容器可以使用 Token 来与 Kubernetes API 服务器交互，例如获取或修改资源对象。</p>
<p>通过 ServiceAccount 和 Token 的组合，Kubernetes 提供了一种安全的身份验证和授权机制。Pod 可以使用与其关联的 ServiceAccount 的 Token 来证明其身份，并在需要访问受保护资源时进行授权。这种机制确保了集群中的各个组件和应用程序具有适当的访问权限，并提供了更细粒度的权限控制。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TokensControllerOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// TokenGenerator is the generator to use to create new tokens</span></span><br><span class="line">    <span class="comment">// GenerateToken生成一个令牌，用于标识给定的ServiceAccount</span></span><br><span class="line">	TokenGenerator serviceaccount.TokenGenerator</span><br><span class="line">	<span class="comment">// ServiceAccountResync is the time.Duration at which to fully re-list service accounts.</span></span><br><span class="line">	<span class="comment">// If zero, re-list will be delayed as long as possible</span></span><br><span class="line">	ServiceAccountResync time.Duration</span><br><span class="line">	<span class="comment">// SecretResync is the time.Duration at which to fully re-list secrets.</span></span><br><span class="line">	<span class="comment">// If zero, re-list will be delayed as long as possible</span></span><br><span class="line">	SecretResync time.Duration</span><br><span class="line">	<span class="comment">// This CA will be added in the secrets of service accounts</span></span><br><span class="line">	RootCA []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// MaxRetries controls the maximum number of times a particular key is retried before giving up</span></span><br><span class="line">	<span class="comment">// If zero, a default max is used</span></span><br><span class="line">	MaxRetries <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/controller/serviceaccount/tokens_controller.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTokensController</span><span class="params">(serviceAccounts informers.ServiceAccountInformer, secrets informers.SecretInformer, cl clientset.Interface, options TokensControllerOptions)</span> <span class="params">(*TokensController, error)</span></span> &#123;</span><br><span class="line">	maxRetries := options.MaxRetries</span><br><span class="line">	<span class="keyword">if</span> maxRetries == <span class="number">0</span> &#123;</span><br><span class="line">		maxRetries = <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e := &amp;TokensController&#123;</span><br><span class="line">		client: cl,</span><br><span class="line">		token:  options.TokenGenerator,</span><br><span class="line">		rootCA: options.RootCA,</span><br><span class="line"></span><br><span class="line">		syncServiceAccountQueue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"serviceaccount_tokens_service"</span>),</span><br><span class="line">		syncSecretQueue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"serviceaccount_tokens_secret"</span>),</span><br><span class="line"></span><br><span class="line">		maxRetries: maxRetries,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e.serviceAccounts = serviceAccounts.Lister()</span><br><span class="line">	e.serviceAccountSynced = serviceAccounts.Informer().HasSynced</span><br><span class="line">	serviceAccounts.Informer().AddEventHandlerWithResyncPeriod(</span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">            <span class="comment">// 加入syncServiceAccountQueue</span></span><br><span class="line">			AddFunc:    e.queueServiceAccountSync,</span><br><span class="line">			UpdateFunc: e.queueServiceAccountUpdateSync,</span><br><span class="line">			DeleteFunc: e.queueServiceAccountSync,</span><br><span class="line">		&#125;,</span><br><span class="line">		options.ServiceAccountResync,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	secretCache := secrets.Informer().GetIndexer()</span><br><span class="line">	e.updatedSecrets = cache.NewIntegerResourceVersionMutationCache(secretCache, secretCache, <span class="number">60</span>*time.Second, <span class="literal">true</span>)</span><br><span class="line">	e.secretSynced = secrets.Informer().HasSynced</span><br><span class="line">	secrets.Informer().AddEventHandlerWithResyncPeriod(</span><br><span class="line">		cache.FilteringResourceEventHandler&#123;</span><br><span class="line">			FilterFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">				<span class="keyword">switch</span> t := obj.(<span class="keyword">type</span>) &#123;</span><br><span class="line">				<span class="keyword">case</span> *v1.Secret:</span><br><span class="line">					<span class="keyword">return</span> t.Type == v1.SecretTypeServiceAccountToken</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					utilruntime.HandleError(fmt.Errorf(<span class="string">"object passed to %T that is not expected: %T"</span>, e, obj))</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">            <span class="comment">// 加入syncSecretQueue</span></span><br><span class="line">			Handler: cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">				AddFunc:    e.queueSecretSync,</span><br><span class="line">				UpdateFunc: e.queueSecretUpdateSync,</span><br><span class="line">				DeleteFunc: e.queueSecretSync,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		options.SecretResync,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> e, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *TokensController)</span> <span class="title">queueServiceAccountSync</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> serviceAccount, ok := obj.(*v1.ServiceAccount); ok &#123;</span><br><span class="line">		e.syncServiceAccountQueue.Add(makeServiceAccountKey(serviceAccount))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *TokensController)</span> <span class="title">queueServiceAccountUpdateSync</span><span class="params">(oldObj <span class="keyword">interface</span>&#123;&#125;, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> serviceAccount, ok := newObj.(*v1.ServiceAccount); ok &#123;</span><br><span class="line">		e.syncServiceAccountQueue.Add(makeServiceAccountKey(serviceAccount))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *TokensController)</span> <span class="title">queueSecretSync</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> secret, ok := obj.(*v1.Secret); ok &#123;</span><br><span class="line">		e.syncSecretQueue.Add(makeSecretQueueKey(secret))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *TokensController)</span> <span class="title">queueSecretUpdateSync</span><span class="params">(oldObj <span class="keyword">interface</span>&#123;&#125;, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> secret, ok := newObj.(*v1.Secret); ok &#123;</span><br><span class="line">		e.syncSecretQueue.Add(makeSecretQueueKey(secret))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run runs controller blocks until stopCh is closed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *TokensController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Shut down queues</span></span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> e.syncServiceAccountQueue.ShutDown()</span><br><span class="line">	<span class="keyword">defer</span> e.syncSecretQueue.ShutDown()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"tokens"</span>, ctx.Done(), e.serviceAccountSynced, e.secretSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.V(<span class="number">5</span>).Info(<span class="string">"Starting workers"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">        <span class="comment">// 启动了两个sync方法,syncServiceAccount,syncSecret</span></span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, e.syncServiceAccount, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, e.syncSecret, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">	logger.V(<span class="number">1</span>).Info(<span class="string">"Shutting down"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *TokensController)</span> <span class="title">syncServiceAccount</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	key, quit := e.syncServiceAccountQueue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> e.syncServiceAccountQueue.Done(key)</span><br><span class="line"></span><br><span class="line">	retry := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		e.retryOrForget(logger, e.syncServiceAccountQueue, key, retry)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取serviceAccountQueueKey</span></span><br><span class="line">    <span class="comment">// type serviceAccountQueueKey struct &#123;</span></span><br><span class="line">	<span class="comment">//     namespace string</span></span><br><span class="line">	<span class="comment">//     name      string</span></span><br><span class="line">	<span class="comment">//     uid       types.UID</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">	saInfo, err := parseServiceAccountKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Error(err, <span class="string">"Parsing service account key"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sa, err := e.getServiceAccount(saInfo.namespace, saInfo.name, saInfo.uid, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">		logger.Error(err, <span class="string">"Getting service account"</span>)</span><br><span class="line">		retry = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> sa == <span class="literal">nil</span>:</span><br><span class="line">		<span class="comment">// serviceaccount已经不存在，删除对应的token</span></span><br><span class="line">		logger.V(<span class="number">4</span>).Info(<span class="string">"Service account deleted, removing tokens"</span>, <span class="string">"namespace"</span>, saInfo.namespace, <span class="string">"serviceaccount"</span>, saInfo.name)</span><br><span class="line">		sa = &amp;v1.ServiceAccount&#123;ObjectMeta: metav1.ObjectMeta&#123;Namespace: saInfo.namespace, Name: saInfo.name, UID: saInfo.uid&#125;&#125;</span><br><span class="line">		retry, err = e.deleteTokens(sa)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Error(err, <span class="string">"Error deleting serviceaccount tokens"</span>, <span class="string">"namespace"</span>, saInfo.namespace, <span class="string">"serviceaccount"</span>, saInfo.name)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *TokensController)</span> <span class="title">syncSecret</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	key, quit := e.syncSecretQueue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> e.syncSecretQueue.Done(key)</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	<span class="comment">// Track whether or not we should retry this sync</span></span><br><span class="line">	retry := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		e.retryOrForget(logger, e.syncSecretQueue, key, retry)</span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// type secretQueueKey struct &#123;</span></span><br><span class="line">	<span class="comment">//     namespace string</span></span><br><span class="line">	<span class="comment">//     name      string</span></span><br><span class="line">	<span class="comment">//     uid       types.UID</span></span><br><span class="line">	<span class="comment">//     saName    string</span></span><br><span class="line">	<span class="comment">//     // optional, will be blank when syncing tokens missing the service account uid annotation</span></span><br><span class="line">	<span class="comment">//     saUID types.UID</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">	secretInfo, err := parseSecretQueueKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Error(err, <span class="string">"Parsing secret queue key"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 获取对应的Secret</span></span><br><span class="line">	secret, err := e.getSecret(secretInfo.namespace, secretInfo.name, secretInfo.uid, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">		logger.Error(err, <span class="string">"Getting secret"</span>)</span><br><span class="line">		retry = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> secret == <span class="literal">nil</span>:</span><br><span class="line">		<span class="comment">// If the service account exists</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> sa, saErr := e.getServiceAccount(secretInfo.namespace, secretInfo.saName, secretInfo.saUID, <span class="literal">false</span>); saErr == <span class="literal">nil</span> &amp;&amp; sa != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// secret no longer exists, so delete references to this secret from the service account</span></span><br><span class="line">            <span class="comment">// serviceaccount存在,secret不存在，删除对secret的引用</span></span><br><span class="line">			<span class="keyword">if</span> err := clientretry.RetryOnConflict(RemoveTokenBackoff, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">				<span class="keyword">return</span> e.removeSecretReference(secretInfo.namespace, secretInfo.saName, secretInfo.saUID, secretInfo.name)</span><br><span class="line">			&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				logger.Error(err, <span class="string">"Removing secret reference"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// Ensure service account exists</span></span><br><span class="line">        <span class="comment">// secret不为nil的情况</span></span><br><span class="line">		sa, saErr := e.getServiceAccount(secretInfo.namespace, secretInfo.saName, secretInfo.saUID, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> saErr != <span class="literal">nil</span>:</span><br><span class="line">			logger.Error(saErr, <span class="string">"Getting service account"</span>)</span><br><span class="line">			retry = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> sa == <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// Delete token</span></span><br><span class="line">            <span class="comment">// 如果serviceaccount为nil, 则删除对应的token</span></span><br><span class="line">			logger.V(<span class="number">4</span>).Info(<span class="string">"Service account does not exist, deleting token"</span>, <span class="string">"secret"</span>, klog.KRef(secretInfo.namespace, secretInfo.name))</span><br><span class="line">			<span class="keyword">if</span> retriable, err := e.deleteToken(secretInfo.namespace, secretInfo.name, secretInfo.uid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				logger.Error(err, <span class="string">"Deleting serviceaccount token"</span>, <span class="string">"secret"</span>, klog.KRef(secretInfo.namespace, secretInfo.name), <span class="string">"serviceAccount"</span>, klog.KRef(secretInfo.namespace, secretInfo.saName))</span><br><span class="line">				retry = retriable</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 更新token</span></span><br><span class="line">			<span class="keyword">if</span> retriable, err := e.generateTokenIfNeeded(logger, sa, secret); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				logger.Error(err, <span class="string">"Populating serviceaccount token"</span>, <span class="string">"secret"</span>, klog.KRef(secretInfo.namespace, secretInfo.name), <span class="string">"serviceAccount"</span>, klog.KRef(secretInfo.namespace, secretInfo.saName))</span><br><span class="line">				retry = retriable</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/serviceaccount/serviceaccounts_controller.go" target="_blank" rel="noopener">pkg/controller/serviceaccount/serviceaccounts_controller.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/cmd/kube-controller-manager/app/core.go" target="_blank" rel="noopener">cmd/kube-controller-manager/app/core.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/serviceaccount/tokens_controller.go" target="_blank" rel="noopener">pkg/controller/serviceaccount/tokens_controller.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之daemonset</title>
    <url>/2023/06/16/kube-controller%E4%B9%8Bdaemonset/</url>
    <content><![CDATA[<p><code>Kubernetes</code>中的<code>DaemonSet Controller</code>是负责管理<code>DaemonSet</code>资源的控制器，确保在集群中的每个节点上都运行指定数量的Pod副本。<br><code>DaemonSet Controller</code>是一种类型的控制器，用于在每个节点上运行一个<code>Pod</code>副本，以便在整个集群中覆盖所有节点。<br><code>DaemonSet</code>通常用于运行守护进程、日志收集器、监控代理等任务。</p>
<p>通过<code>DaemonSet Controller</code>，<code>Kubernetes</code>能够实现在整个集群中自动管理和部署<code>Pod</code>副本的能力，确保每个节点都运行所需的应用程序或服务。</p>
<hr>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/daemon/daemon_controller.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// BurstReplicas is a rate limiter for booting pods on a lot of pods.</span></span><br><span class="line">	<span class="comment">// The value of 250 is chosen b/c values that are too high can cause registry DoS issues.</span></span><br><span class="line">	BurstReplicas = <span class="number">250</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// StatusUpdateRetries limits the number of retries if sending a status update to API server fails.</span></span><br><span class="line">	StatusUpdateRetries = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// BackoffGCInterval is the time that has to pass before next iteration of backoff GC is run</span></span><br><span class="line">	BackoffGCInterval = <span class="number">1</span> * time.Minute</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义daemonset事件原因</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// SelectingAllReason 表示daemonset没有设置Selector</span></span><br><span class="line">	SelectingAllReason = <span class="string">"SelectingAll"</span></span><br><span class="line">	<span class="comment">// FailedPlacementReason 表示pod不能调度到对应的节点</span></span><br><span class="line">	FailedPlacementReason = <span class="string">"FailedPlacement"</span></span><br><span class="line">	<span class="comment">// FailedDaemonPodReason pod的状态是"Failed"</span></span><br><span class="line">	FailedDaemonPodReason = <span class="string">"FailedDaemonPod"</span></span><br><span class="line">	<span class="comment">// SucceededDaemonPodReason 成功拉取对应的pod</span></span><br><span class="line">	SucceededDaemonPodReason = <span class="string">"SucceededDaemonPod"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DaemonSetsController <span class="keyword">struct</span> &#123;</span><br><span class="line">	kubeClient clientset.Interface</span><br><span class="line"></span><br><span class="line">	eventBroadcaster record.EventBroadcaster</span><br><span class="line">	eventRecorder    record.EventRecorder</span><br><span class="line"></span><br><span class="line">	podControl controller.PodControlInterface</span><br><span class="line">	crControl  controller.ControllerRevisionControlInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// An dsc is temporarily suspended after creating/deleting these many replicas.</span></span><br><span class="line">	<span class="comment">// It resumes normal action after observing the watch events for them.</span></span><br><span class="line">    <span class="comment">// burstReplicas 默认值为 250 即每个 syncLoop 中创建或者删除的 pod 数最多为 250 个</span></span><br><span class="line">	burstReplicas <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// To allow injection of syncDaemonSet for testing.</span></span><br><span class="line">	syncHandler <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, dsKey <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line">	<span class="comment">// used for unit testing</span></span><br><span class="line">	enqueueDaemonSet <span class="function"><span class="keyword">func</span><span class="params">(ds *apps.DaemonSet)</span></span></span><br><span class="line">	<span class="comment">// A TTLCache of pod creates/deletes each ds expects to see</span></span><br><span class="line">	expectations controller.ControllerExpectationsInterface</span><br><span class="line">	<span class="comment">// dsLister can list/get daemonsets from the shared informer's store</span></span><br><span class="line">	dsLister appslisters.DaemonSetLister</span><br><span class="line">	<span class="comment">// dsStoreSynced returns true if the daemonset store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	dsStoreSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// historyLister get list/get history from the shared informers's store</span></span><br><span class="line">	historyLister appslisters.ControllerRevisionLister</span><br><span class="line">	<span class="comment">// historyStoreSynced returns true if the history store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	historyStoreSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// podLister get list/get pods from the shared informers's store</span></span><br><span class="line">	podLister corelisters.PodLister</span><br><span class="line">	<span class="comment">// podStoreSynced returns true if the pod store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	podStoreSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// nodeLister can list/get nodes from the shared informer's store</span></span><br><span class="line">	nodeLister corelisters.NodeLister</span><br><span class="line">	<span class="comment">// nodeStoreSynced returns true if the node store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	nodeStoreSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DaemonSet keys that need to be synced.</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line"></span><br><span class="line">	failedPodsBackoff *flowcontrol.Backoff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建DaemonSetController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDaemonSetsController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">	daemonSetInformer appsinformers.DaemonSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	historyInformer appsinformers.ControllerRevisionInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodeInformer coreinformers.NodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	kubeClient clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	failedPodsBackoff *flowcontrol.Backoff,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*DaemonSetsController, error)</span></span> &#123;</span><br><span class="line">	eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	dsc := &amp;DaemonSetsController&#123;</span><br><span class="line">		kubeClient:       kubeClient,</span><br><span class="line">		eventBroadcaster: eventBroadcaster,</span><br><span class="line">		eventRecorder:    eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"daemonset-controller"</span>&#125;),</span><br><span class="line">		podControl: controller.RealPodControl&#123;</span><br><span class="line">			KubeClient: kubeClient,</span><br><span class="line">			Recorder:   eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"daemonset-controller"</span>&#125;),</span><br><span class="line">		&#125;,</span><br><span class="line">		crControl: controller.RealControllerRevisionControl&#123;</span><br><span class="line">			KubeClient: kubeClient,</span><br><span class="line">		&#125;,</span><br><span class="line">		burstReplicas: BurstReplicas,</span><br><span class="line">		expectations:  controller.NewControllerExpectations(),</span><br><span class="line">		queue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"daemonset"</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// daemonSetInformer 监听daemonSet变化</span></span><br><span class="line">	daemonSetInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dsc.addDaemonset(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dsc.updateDaemonset(logger, oldObj, newObj)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dsc.deleteDaemonset(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	dsc.dsLister = daemonSetInformer.Lister()</span><br><span class="line">	dsc.dsStoreSynced = daemonSetInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">    <span class="comment">// historyInformer 监听history变化</span></span><br><span class="line">	historyInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dsc.addHistory(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dsc.updateHistory(logger, oldObj, newObj)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dsc.deleteHistory(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	dsc.historyLister = historyInformer.Lister()</span><br><span class="line">	dsc.historyStoreSynced = historyInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听pod事件creation/deletion. 我们监听pod事件的原因在于我们不想创建或删除更多的pod直到满足expectations.</span></span><br><span class="line">	podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dsc.addPod(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dsc.updatePod(logger, oldObj, newObj)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dsc.deletePod(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	dsc.podLister = podInformer.Lister()</span><br><span class="line">	dsc.podStoreSynced = podInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nodeInformer 监听node事件</span></span><br><span class="line">	nodeInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dsc.addNode(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dsc.updateNode(logger, oldObj, newObj)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	)</span><br><span class="line">	dsc.nodeStoreSynced = nodeInformer.Informer().HasSynced</span><br><span class="line">	dsc.nodeLister = nodeInformer.Lister()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置调谐函数</span></span><br><span class="line">	dsc.syncHandler = dsc.syncDaemonSet</span><br><span class="line">	dsc.enqueueDaemonSet = dsc.enqueue</span><br><span class="line"></span><br><span class="line">	dsc.failedPodsBackoff = failedPodsBackoff</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dsc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dsc *DaemonSetsController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	dsc.eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">	dsc.eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: dsc.kubeClient.CoreV1().Events(<span class="string">""</span>)&#125;)</span><br><span class="line">	<span class="keyword">defer</span> dsc.eventBroadcaster.Shutdown()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> dsc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.Info(<span class="string">"Starting daemon sets controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> logger.Info(<span class="string">"Shutting down daemon sets controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"daemon sets"</span>, ctx.Done(), dsc.podStoreSynced, dsc.nodeStoreSynced, dsc.historyStoreSynced, dsc.dsStoreSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, dsc.runWorker, time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> wait.Until(dsc.failedPodsBackoff.GC, BackoffGCInterval, ctx.Done())</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dsc *DaemonSetsController)</span> <span class="title">runWorker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> dsc.processNextWorkItem(ctx) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processNextWorkItem deals with one key off the queue.  It returns false when it's time to quit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dsc *DaemonSetsController)</span> <span class="title">processNextWorkItem</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	dsKey, quit := dsc.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> dsc.queue.Done(dsKey)</span><br><span class="line"></span><br><span class="line">	err := dsc.syncHandler(ctx, dsKey.(<span class="keyword">string</span>))</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		dsc.queue.Forget(dsKey)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	utilruntime.HandleError(fmt.Errorf(<span class="string">"%v failed with : %v"</span>, dsKey, err))</span><br><span class="line">	dsc.queue.AddRateLimited(dsKey)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调谐函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dsc *DaemonSetsController)</span> <span class="title">syncDaemonSet</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	startTime := dsc.failedPodsBackoff.Clock.Now()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		logger.V(<span class="number">4</span>).Info(<span class="string">"Finished syncing daemon set"</span>, <span class="string">"daemonset"</span>, key, <span class="string">"time"</span>, dsc.failedPodsBackoff.Clock.Now().Sub(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据workqueue中的数据解析出namespace和资源名称</span></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 获取对应的资源daemonset</span></span><br><span class="line">	ds, err := dsc.dsLister.DaemonSets(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">		logger.V(<span class="number">3</span>).Info(<span class="string">"Daemon set has been deleted"</span>, <span class="string">"daemonset"</span>, key)</span><br><span class="line">		dsc.expectations.DeleteExpectations(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unable to retrieve ds %v from store: %v"</span>, key, err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 获取所有的node节点</span></span><br><span class="line">	nodeList, err := dsc.nodeLister.List(labels.Everything())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't get list of nodes when syncing daemon set %#v: %v"</span>, ds, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	everything := metav1.LabelSelector&#123;&#125;</span><br><span class="line">    <span class="comment">// 判断daemonset有没有设置Selector, 如果没有设置则产生事件然后return</span></span><br><span class="line">	<span class="keyword">if</span> reflect.DeepEqual(ds.Spec.Selector, &amp;everything) &#123;</span><br><span class="line">		dsc.eventRecorder.Eventf(ds, v1.EventTypeWarning, SelectingAllReason, <span class="string">"This daemon set is selecting all pods. A non-empty selector is required."</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Don't process a daemon set until all its creations and deletions have been processed.</span></span><br><span class="line">	<span class="comment">// For example if daemon set foo asked for 3 new daemon pods in the previous call to manage,</span></span><br><span class="line">	<span class="comment">// then we do not want to call manage on foo until the daemon pods have been created.</span></span><br><span class="line">	dsKey, err := controller.KeyFunc(ds)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't get key for object %#v: %v"</span>, ds, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the DaemonSet is being deleted (either by foreground deletion or</span></span><br><span class="line">	<span class="comment">// orphan deletion), we cannot be sure if the DaemonSet history objects</span></span><br><span class="line">	<span class="comment">// it owned still exist -- those history objects can either be deleted</span></span><br><span class="line">	<span class="comment">// or orphaned. Garbage collector doesn't guarantee that it will delete</span></span><br><span class="line">	<span class="comment">// DaemonSet pods before deleting DaemonSet history objects, because</span></span><br><span class="line">	<span class="comment">// DaemonSet history doesn't own DaemonSet pods. We cannot reliably</span></span><br><span class="line">	<span class="comment">// calculate the status of a DaemonSet being deleted. Therefore, return</span></span><br><span class="line">	<span class="comment">// here without updating status for the DaemonSet being deleted.</span></span><br><span class="line">	<span class="keyword">if</span> ds.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Construct histories of the DaemonSet, and get the hash of current history</span></span><br><span class="line">	cur, old, err := dsc.constructHistory(ctx, ds)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to construct revisions of DaemonSet: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	hash := cur.Labels[apps.DefaultDaemonSetUniqueLabelKey]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过expectations机制判断daemonset有没有处理完</span></span><br><span class="line">	<span class="keyword">if</span> !dsc.expectations.SatisfiedExpectations(dsKey) &#123;</span><br><span class="line">        <span class="comment">// 没处理完只更新状态</span></span><br><span class="line">		<span class="comment">// Only update status. Don't raise observedGeneration since controller didn't process object of that generation.</span></span><br><span class="line">		<span class="keyword">return</span> dsc.updateDaemonSetStatus(ctx, ds, nodeList, hash, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = dsc.updateDaemonSet(ctx, ds, nodeList, hash, dsKey, old)</span><br><span class="line">	statusErr := dsc.updateDaemonSetStatus(ctx, ds, nodeList, hash, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span> &amp;&amp; statusErr != <span class="literal">nil</span>:</span><br><span class="line">		<span class="comment">// If there was an error, and we failed to update status,</span></span><br><span class="line">		<span class="comment">// log it and return the original error.</span></span><br><span class="line">		logger.Error(statusErr, <span class="string">"Failed to update status"</span>, <span class="string">"daemonSet"</span>, klog.KObj(ds))</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	<span class="keyword">case</span> statusErr != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> statusErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dsc *DaemonSetsController)</span> <span class="title">updateDaemonSet</span><span class="params">(ctx context.Context, ds *apps.DaemonSet, nodeList []*v1.Node, hash, key <span class="keyword">string</span>, old []*apps.ControllerRevision)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := dsc.manage(ctx, ds, nodeList, hash)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Process rolling updates if we're ready.</span></span><br><span class="line">    <span class="comment">// 满足expectations</span></span><br><span class="line">	<span class="keyword">if</span> dsc.expectations.SatisfiedExpectations(key) &#123;</span><br><span class="line">		<span class="keyword">switch</span> ds.Spec.UpdateStrategy.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> apps.OnDeleteDaemonSetStrategyType:</span><br><span class="line">		<span class="keyword">case</span> apps.RollingUpdateDaemonSetStrategyType:</span><br><span class="line">			err = dsc.rollingUpdate(ctx, ds, nodeList, hash)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = dsc.cleanupHistory(ctx, ds, old)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to clean up revisions of DaemonSet: %w"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/daemon/update.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dsc *DaemonSetsController)</span> <span class="title">rollingUpdate</span><span class="params">(ctx context.Context, ds *apps.DaemonSet, nodeList []*v1.Node, hash <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">    <span class="comment">// 返回一个字典，key为nodeName,值为列表，元素是对应node上需要创建的pod</span></span><br><span class="line">	nodeToDaemonPods, err := dsc.getNodesToDaemonPods(ctx, ds)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't get node to daemon pod mapping for daemon set %q: %v"</span>, ds.Name, err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// maxSurge允许的超出期望副本数的最大数量</span></span><br><span class="line">    <span class="comment">// maxUnavailable允许的不可用副本的最大数量</span></span><br><span class="line">	maxSurge, maxUnavailable, err := dsc.updatedDesiredNodeCounts(ctx, ds, nodeList, nodeToDaemonPods)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't get unavailable numbers: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	now := dsc.failedPodsBackoff.Clock.Now()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When not surging, we delete just enough pods to stay under the maxUnavailable limit, if any</span></span><br><span class="line">	<span class="comment">// are necessary, and let the core loop create new instances on those nodes.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Assumptions:</span></span><br><span class="line">	<span class="comment">// * Expect manage loop to allow no more than one pod per node</span></span><br><span class="line">	<span class="comment">// * Expect manage loop will create new pods</span></span><br><span class="line">	<span class="comment">// * Expect manage loop will handle failed pods</span></span><br><span class="line">	<span class="comment">// * Deleted pods do not count as unavailable so that updates make progress when nodes are down</span></span><br><span class="line">	<span class="comment">// Invariants:</span></span><br><span class="line">	<span class="comment">// * The number of new pods that are unavailable must be less than maxUnavailable</span></span><br><span class="line">	<span class="comment">// * A node with an available old pod is a candidate for deletion if it does not violate other invariants</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> maxSurge == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> numUnavailable <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">var</span> allowedReplacementPods []<span class="keyword">string</span></span><br><span class="line">		<span class="keyword">var</span> candidatePodsToDelete []<span class="keyword">string</span></span><br><span class="line">		<span class="keyword">for</span> nodeName, pods := <span class="keyword">range</span> nodeToDaemonPods &#123;</span><br><span class="line">            <span class="comment">//findUpdatedPodsOnNode函数检查给定节点上的非删除Pod，如果旧Pod和新Pod至多存在一个，则返回true；如果存在多个Pod，则返回false。</span></span><br><span class="line">            <span class="comment">// 在这种情况下，我们可以跳过处理特定节点，并让管理循环在下一次循环中处理多余的Pod。</span></span><br><span class="line">			newPod, oldPod, ok := findUpdatedPodsOnNode(ds, pods, hash)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="comment">// let the manage loop clean up this node, and treat it as an unavailable node</span></span><br><span class="line">				logger.V(<span class="number">3</span>).Info(<span class="string">"DaemonSet has excess pods on node, skipping to allow the core loop to process"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds), <span class="string">"node"</span>, klog.KRef(<span class="string">""</span>, nodeName))</span><br><span class="line">				numUnavailable++</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> oldPod == <span class="literal">nil</span> &amp;&amp; newPod == <span class="literal">nil</span>, oldPod != <span class="literal">nil</span> &amp;&amp; newPod != <span class="literal">nil</span>:</span><br><span class="line">				<span class="comment">// the manage loop will handle creating or deleting the appropriate pod, consider this unavailable</span></span><br><span class="line">				numUnavailable++</span><br><span class="line">			<span class="keyword">case</span> newPod != <span class="literal">nil</span>:</span><br><span class="line">				<span class="comment">// this pod is up to date, check its availability</span></span><br><span class="line">				<span class="keyword">if</span> !podutil.IsPodAvailable(newPod, ds.Spec.MinReadySeconds, metav1.Time&#123;Time: now&#125;) &#123;</span><br><span class="line">					<span class="comment">// an unavailable new pod is counted against maxUnavailable</span></span><br><span class="line">					numUnavailable++</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// this pod is old, it is an update candidate</span></span><br><span class="line">				<span class="keyword">switch</span> &#123;</span><br><span class="line">                <span class="comment">// 此pod状态不是Available，则加入allowedReplacementPods列表</span></span><br><span class="line">				<span class="keyword">case</span> !podutil.IsPodAvailable(oldPod, ds.Spec.MinReadySeconds, metav1.Time&#123;Time: now&#125;):</span><br><span class="line">					<span class="comment">// the old pod isn't available, so it needs to be replaced</span></span><br><span class="line">					logger.V(<span class="number">5</span>).Info(<span class="string">"DaemonSet pod on node is out of date and not available, allowing replacement"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds), <span class="string">"pod"</span>, klog.KObj(oldPod), <span class="string">"node"</span>, klog.KRef(<span class="string">""</span>, nodeName))</span><br><span class="line">					<span class="comment">// record the replacement</span></span><br><span class="line">					<span class="keyword">if</span> allowedReplacementPods == <span class="literal">nil</span> &#123;</span><br><span class="line">						allowedReplacementPods = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(nodeToDaemonPods))</span><br><span class="line">					&#125;</span><br><span class="line">					allowedReplacementPods = <span class="built_in">append</span>(allowedReplacementPods, oldPod.Name)</span><br><span class="line">				<span class="keyword">case</span> numUnavailable &gt;= maxUnavailable:</span><br><span class="line">					<span class="comment">// no point considering any other candidates</span></span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					logger.V(<span class="number">5</span>).Info(<span class="string">"DaemonSet pod on node is out of date, this is a candidate to replace"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds), <span class="string">"pod"</span>, klog.KObj(oldPod), <span class="string">"node"</span>, klog.KRef(<span class="string">""</span>, nodeName))</span><br><span class="line">					<span class="comment">// record the candidate</span></span><br><span class="line">					<span class="keyword">if</span> candidatePodsToDelete == <span class="literal">nil</span> &#123;</span><br><span class="line">						candidatePodsToDelete = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, maxUnavailable)</span><br><span class="line">					&#125;</span><br><span class="line">                    <span class="comment">// 记录需要被删除的pod</span></span><br><span class="line">					candidatePodsToDelete = <span class="built_in">append</span>(candidatePodsToDelete, oldPod.Name)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// use any of the candidates we can, including the allowedReplacemnntPods</span></span><br><span class="line">		logger.V(<span class="number">5</span>).Info(<span class="string">"DaemonSet allowing replacements"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds), <span class="string">"replacements"</span>, <span class="built_in">len</span>(allowedReplacementPods), <span class="string">"maxUnavailable"</span>, maxUnavailable, <span class="string">"numUnavailable"</span>, numUnavailable, <span class="string">"candidates"</span>, <span class="built_in">len</span>(candidatePodsToDelete))</span><br><span class="line">		remainingUnavailable := maxUnavailable - numUnavailable</span><br><span class="line">		<span class="keyword">if</span> remainingUnavailable &lt; <span class="number">0</span> &#123;</span><br><span class="line">			remainingUnavailable = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> max := <span class="built_in">len</span>(candidatePodsToDelete); remainingUnavailable &gt; max &#123;</span><br><span class="line">			remainingUnavailable = max</span><br><span class="line">		&#125;</span><br><span class="line">		oldPodsToDelete := <span class="built_in">append</span>(allowedReplacementPods, candidatePodsToDelete[:remainingUnavailable]...)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> dsc.syncNodes(ctx, ds, oldPodsToDelete, <span class="literal">nil</span>, hash)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When surging, we create new pods whenever an old pod is unavailable, and we can create up</span></span><br><span class="line">	<span class="comment">// to maxSurge extra pods</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Assumptions:</span></span><br><span class="line">	<span class="comment">// * Expect manage loop to allow no more than two pods per node, one old, one new</span></span><br><span class="line">	<span class="comment">// * Expect manage loop will create new pods if there are no pods on node</span></span><br><span class="line">	<span class="comment">// * Expect manage loop will handle failed pods</span></span><br><span class="line">	<span class="comment">// * Deleted pods do not count as unavailable so that updates make progress when nodes are down</span></span><br><span class="line">	<span class="comment">// Invariants:</span></span><br><span class="line">	<span class="comment">// * A node with an unavailable old pod is a candidate for immediate new pod creation</span></span><br><span class="line">	<span class="comment">// * An old available pod is deleted if a new pod is available</span></span><br><span class="line">	<span class="comment">// * No more than maxSurge new pods are created for old available pods at any one time</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">var</span> oldPodsToDelete []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> candidateNewNodes []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> allowedNewNodes []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> numSurge <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> nodeName, pods := <span class="keyword">range</span> nodeToDaemonPods &#123;</span><br><span class="line">		newPod, oldPod, ok := findUpdatedPodsOnNode(ds, pods, hash)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// let the manage loop clean up this node, and treat it as a surge node</span></span><br><span class="line">			logger.V(<span class="number">3</span>).Info(<span class="string">"DaemonSet has excess pods on node, skipping to allow the core loop to process"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds), <span class="string">"node"</span>, klog.KRef(<span class="string">""</span>, nodeName))</span><br><span class="line">			numSurge++</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> oldPod == <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// we don't need to do anything to this node, the manage loop will handle it</span></span><br><span class="line">		<span class="keyword">case</span> newPod == <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// this is a surge candidate</span></span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> !podutil.IsPodAvailable(oldPod, ds.Spec.MinReadySeconds, metav1.Time&#123;Time: now&#125;):</span><br><span class="line">				<span class="comment">// the old pod isn't available, allow it to become a replacement</span></span><br><span class="line">				logger.V(<span class="number">5</span>).Info(<span class="string">"Pod on node is out of date and not available, allowing replacement"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds), <span class="string">"pod"</span>, klog.KObj(oldPod), <span class="string">"node"</span>, klog.KRef(<span class="string">""</span>, nodeName))</span><br><span class="line">				<span class="comment">// record the replacement</span></span><br><span class="line">				<span class="keyword">if</span> allowedNewNodes == <span class="literal">nil</span> &#123;</span><br><span class="line">					allowedNewNodes = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(nodeToDaemonPods))</span><br><span class="line">				&#125;</span><br><span class="line">				allowedNewNodes = <span class="built_in">append</span>(allowedNewNodes, nodeName)</span><br><span class="line">			<span class="keyword">case</span> numSurge &gt;= maxSurge:</span><br><span class="line">				<span class="comment">// no point considering any other candidates</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				logger.V(<span class="number">5</span>).Info(<span class="string">"DaemonSet pod on node is out of date, this is a surge candidate"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds), <span class="string">"pod"</span>, klog.KObj(oldPod), <span class="string">"node"</span>, klog.KRef(<span class="string">""</span>, nodeName))</span><br><span class="line">				<span class="comment">// record the candidate</span></span><br><span class="line">				<span class="keyword">if</span> candidateNewNodes == <span class="literal">nil</span> &#123;</span><br><span class="line">					candidateNewNodes = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, maxSurge)</span><br><span class="line">				&#125;</span><br><span class="line">				candidateNewNodes = <span class="built_in">append</span>(candidateNewNodes, nodeName)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// we have already surged onto this node, determine our state</span></span><br><span class="line">			<span class="keyword">if</span> !podutil.IsPodAvailable(newPod, ds.Spec.MinReadySeconds, metav1.Time&#123;Time: now&#125;) &#123;</span><br><span class="line">				<span class="comment">// we're waiting to go available here</span></span><br><span class="line">				numSurge++</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// we're available, delete the old pod</span></span><br><span class="line">			logger.V(<span class="number">5</span>).Info(<span class="string">"DaemonSet pod on node is available, remove old pod"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds), <span class="string">"newPod"</span>, klog.KObj(newPod), <span class="string">"node"</span>, nodeName, <span class="string">"oldPod"</span>, klog.KObj(oldPod))</span><br><span class="line">			oldPodsToDelete = <span class="built_in">append</span>(oldPodsToDelete, oldPod.Name)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// use any of the candidates we can, including the allowedNewNodes</span></span><br><span class="line">	logger.V(<span class="number">5</span>).Info(<span class="string">"DaemonSet allowing replacements"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds), <span class="string">"replacements"</span>, <span class="built_in">len</span>(allowedNewNodes), <span class="string">"maxSurge"</span>, maxSurge, <span class="string">"numSurge"</span>, numSurge, <span class="string">"candidates"</span>, <span class="built_in">len</span>(candidateNewNodes))</span><br><span class="line">	remainingSurge := maxSurge - numSurge</span><br><span class="line">	<span class="keyword">if</span> remainingSurge &lt; <span class="number">0</span> &#123;</span><br><span class="line">		remainingSurge = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> max := <span class="built_in">len</span>(candidateNewNodes); remainingSurge &gt; max &#123;</span><br><span class="line">		remainingSurge = max</span><br><span class="line">	&#125;</span><br><span class="line">	newNodesToCreate := <span class="built_in">append</span>(allowedNewNodes, candidateNewNodes[:remainingSurge]...)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dsc.syncNodes(ctx, ds, oldPodsToDelete, newNodesToCreate, hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// pkg/controller/daemon/daemon_controller.go</span></span><br><span class="line"><span class="comment">// 在节点上删除或创建对应的pod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dsc *DaemonSetsController)</span> <span class="title">syncNodes</span><span class="params">(ctx context.Context, ds *apps.DaemonSet, podsToDelete, nodesNeedingDaemonPods []<span class="keyword">string</span>, hash <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// We need to set expectations before creating/deleting pods to avoid race conditions.</span></span><br><span class="line">    <span class="comment">// 在创建/删除pod前我们需要设置expections以避免竞态情况</span></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	dsKey, err := controller.KeyFunc(ds)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't get key for object %#v: %v"</span>, ds, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	createDiff := <span class="built_in">len</span>(nodesNeedingDaemonPods)</span><br><span class="line">	deleteDiff := <span class="built_in">len</span>(podsToDelete)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置最大创建数</span></span><br><span class="line">	<span class="keyword">if</span> createDiff &gt; dsc.burstReplicas &#123;</span><br><span class="line">		createDiff = dsc.burstReplicas</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//  设置最大删除数</span></span><br><span class="line">	<span class="keyword">if</span> deleteDiff &gt; dsc.burstReplicas &#123;</span><br><span class="line">		deleteDiff = dsc.burstReplicas</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置期望值</span></span><br><span class="line">	dsc.expectations.SetExpectations(dsKey, createDiff, deleteDiff)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// error channel to communicate back failures.  make the buffer big enough to avoid any blocking</span></span><br><span class="line">	errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, createDiff+deleteDiff)</span><br><span class="line"></span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Nodes needing daemon pods for daemon set, creating"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds), <span class="string">"needCount"</span>, nodesNeedingDaemonPods, <span class="string">"createCount"</span>, createDiff)</span><br><span class="line">	createWait := sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="comment">// If the returned error is not nil we have a parse error.</span></span><br><span class="line">	<span class="comment">// The controller handles this via the hash.</span></span><br><span class="line">	generation, err := util.GetTemplateGeneration(ds)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		generation = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	template := util.CreatePodTemplate(ds.Spec.Template, generation, hash)</span><br><span class="line">	<span class="comment">// Batch the pod creates. Batch sizes start at SlowStartInitialBatchSize</span></span><br><span class="line">	<span class="comment">// and double with each successful iteration in a kind of "slow start".</span></span><br><span class="line">	<span class="comment">// This handles attempts to start large numbers of pods that would</span></span><br><span class="line">	<span class="comment">// likely all fail with the same error. For example a project with a</span></span><br><span class="line">	<span class="comment">// low quota that attempts to create a large number of pods will be</span></span><br><span class="line">	<span class="comment">// prevented from spamming the API service with the pod create requests</span></span><br><span class="line">	<span class="comment">// after one of its pods fails.  Conveniently, this also prevents the</span></span><br><span class="line">	<span class="comment">// event spam that those failures would generate.</span></span><br><span class="line">	batchSize := integer.IntMin(createDiff, controller.SlowStartInitialBatchSize)</span><br><span class="line">	<span class="keyword">for</span> pos := <span class="number">0</span>; createDiff &gt; pos; batchSize, pos = integer.IntMin(<span class="number">2</span>*batchSize, createDiff-(pos+batchSize)), pos+batchSize &#123;</span><br><span class="line">		errorCount := <span class="built_in">len</span>(errCh)</span><br><span class="line">		createWait.Add(batchSize)</span><br><span class="line">		<span class="keyword">for</span> i := pos; i &lt; pos+batchSize; i++ &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ix <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">				<span class="keyword">defer</span> createWait.Done()</span><br><span class="line"></span><br><span class="line">				podTemplate := template.DeepCopy()</span><br><span class="line">				<span class="comment">// The pod's NodeAffinity will be updated to make sure the Pod is bound</span></span><br><span class="line">				<span class="comment">// to the target node by default scheduler. It is safe to do so because there</span></span><br><span class="line">				<span class="comment">// should be no conflicting node affinity with the target node.</span></span><br><span class="line">				podTemplate.Spec.Affinity = util.ReplaceDaemonSetPodNodeNameNodeAffinity(</span><br><span class="line">					podTemplate.Spec.Affinity, nodesNeedingDaemonPods[ix])</span><br><span class="line"></span><br><span class="line">				err := dsc.podControl.CreatePods(ctx, ds.Namespace, podTemplate,</span><br><span class="line">					ds, metav1.NewControllerRef(ds, controllerKind))</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> apierrors.HasStatusCause(err, v1.NamespaceTerminatingCause) &#123;</span><br><span class="line">						<span class="comment">// If the namespace is being torn down, we can safely ignore</span></span><br><span class="line">						<span class="comment">// this error since all subsequent creations will fail.</span></span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					logger.V(<span class="number">2</span>).Info(<span class="string">"Failed creation, decrementing expectations for daemon set"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds))</span><br><span class="line">					dsc.expectations.CreationObserved(dsKey)</span><br><span class="line">					errCh &lt;- err</span><br><span class="line">					utilruntime.HandleError(err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(i)</span><br><span class="line">		&#125;</span><br><span class="line">		createWait.Wait()</span><br><span class="line">		<span class="comment">// any skipped pods that we never attempted to start shouldn't be expected.</span></span><br><span class="line">		skippedPods := createDiff - (batchSize + pos)</span><br><span class="line">		<span class="keyword">if</span> errorCount &lt; <span class="built_in">len</span>(errCh) &amp;&amp; skippedPods &gt; <span class="number">0</span> &#123;</span><br><span class="line">			logger.V(<span class="number">2</span>).Info(<span class="string">"Slow-start failure. Skipping creation pods, decrementing expectations for daemon set"</span>, <span class="string">"skippedPods"</span>, skippedPods, <span class="string">"daemonset"</span>, klog.KObj(ds))</span><br><span class="line">			dsc.expectations.LowerExpectations(dsKey, skippedPods, <span class="number">0</span>)</span><br><span class="line">			<span class="comment">// The skipped pods will be retried later. The next controller resync will</span></span><br><span class="line">			<span class="comment">// retry the slow start process.</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Pods to delete for daemon set, deleting"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds), <span class="string">"toDeleteCount"</span>, podsToDelete, <span class="string">"deleteCount"</span>, deleteDiff)</span><br><span class="line">	deleteWait := sync.WaitGroup&#123;&#125;</span><br><span class="line">	deleteWait.Add(deleteDiff)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; deleteDiff; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ix <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> deleteWait.Done()</span><br><span class="line">			<span class="keyword">if</span> err := dsc.podControl.DeletePod(ctx, ds.Namespace, podsToDelete[ix], ds); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				dsc.expectations.DeletionObserved(dsKey)</span><br><span class="line">				<span class="keyword">if</span> !apierrors.IsNotFound(err) &#123;</span><br><span class="line">					logger.V(<span class="number">2</span>).Info(<span class="string">"Failed deletion, decremented expectations for daemon set"</span>, <span class="string">"daemonset"</span>, klog.KObj(ds))</span><br><span class="line">					errCh &lt;- err</span><br><span class="line">					utilruntime.HandleError(err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	deleteWait.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// collect errors if any for proper reporting/retry logic in the controller</span></span><br><span class="line">	errors := []error&#123;&#125;</span><br><span class="line">	<span class="built_in">close</span>(errCh)</span><br><span class="line">	<span class="keyword">for</span> err := <span class="keyword">range</span> errCh &#123;</span><br><span class="line">		errors = <span class="built_in">append</span>(errors, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> utilerrors.NewAggregate(errors)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/daemon/daemon_controller.go" target="_blank" rel="noopener">pkg/controller/daemon/daemon_controller.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/daemon/update.go" target="_blank" rel="noopener">pkg/controller/daemon/update.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之endpoint</title>
    <url>/2023/05/03/kube-controller%E4%B9%8Bendpoint/</url>
    <content><![CDATA[<p>在 <code>Kubernetes</code> 中，一个 <code>Endpoint</code> 代表一个网络地址（IP地址和端口,是实现实际服务的端点的集合,通常用于将服务的客户端请求路由到后端 Pod 的 IP 地址和端口上。</p>
<p><code>Endpoint</code> 可以手动创建，也可以由 <code>Kubernetes</code> 的 <code>service</code> 控制器自动创建和更新。当创建一个 <code>Service</code> 对象时，<code>Kubernetes</code> 会创建一个关联的 <code>Endpoint</code> 对象，自动添加 <code>Pod</code> 的 <code>I</code>P 地址和端口到 <code>Endpoint</code> 中。</p>
<p>当客户端通过 <code>Service</code> 访问后端 <code>Pod</code> 时，<code>Kubernetes</code> 会自动将客户端请求路由到后端 <code>Pod</code> 的 <code>IP</code> 地址和端口上。这种路由方式是通过 <code>iptables</code> 实现的，对于一个 <code>Service</code> 的每个端口，<code>Kubernetes</code> 会自动创建一条 <code>iptables</code> 规则将该端口上的请求转发到对应的 <code>Endpoint</code> 地址和端口上。</p>
<p>官方目前推荐使用<code>endpointslice</code>, 创建一个<code>service</code>会自动创建一个<code>endpoint</code>和<code>endpointSlice</code>.发现如果删除掉<code>endpoint</code>服务也能正常访问。</p>
<p>可以使用下面的<code>yaml</code>文件创建<code>Service</code>观察对应的<code>endpoint</code>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; ep.yaml &lt;&lt;EOF</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: ep</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: ep</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: ep</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: ep</span><br><span class="line">          image: hysyeah/my-curl:v1</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 80</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: ep</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: ep</span><br><span class="line">  ports:</span><br><span class="line">    - name: http</span><br><span class="line">      port: 8080</span><br><span class="line">      targetPort: 8080</span><br><span class="line">  type: NodePort</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>  <img src="https://img.hysyeah.top/2023/5/createep20230502202656.png" alt></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">I0503 15:23:44.009583  131717 round_trippers.go:463] POST apis/apps/v1/namespaces/default/deployments?fieldManager=kubectl-create&amp;fieldValidation=Strict</span><br><span class="line"></span><br><span class="line">deployment.apps/ep created</span><br><span class="line">I0503 15:23:44.016610  131717 round_trippers.go:463] POST api/v1/namespaces/default/services?fieldManager=kubectl-create&amp;fieldValidation=Strict</span><br><span class="line">service/ep created</span><br></pre></td></tr></table></figure>
<p>调用接口分别创建了<code>deployment</code>和<code>service</code>,假如关掉<code>kube-controller-manager</code>的话会发现<code>kubectl get ep</code>并不能看到对应的<code>Endpoint</code>,<code>Endpoint</code>是由<code>kube-controller-manager</code>创建的。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// pkg/apis/discovery/types.go</span></span><br><span class="line"><span class="comment">// Endpoint represents a single logical "backend" implementing a service.</span></span><br><span class="line"><span class="keyword">type</span> Endpoint <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// addresses of this endpoint. The contents of this field are interpreted</span></span><br><span class="line">	<span class="comment">// according to the corresponding EndpointSlice addressType field. Consumers</span></span><br><span class="line">	<span class="comment">// must handle different types of addresses in the context of their own</span></span><br><span class="line">	<span class="comment">// capabilities. This must contain at least one address but no more than</span></span><br><span class="line">	<span class="comment">// 100.</span></span><br><span class="line">	<span class="comment">// +listType=set</span></span><br><span class="line">	Addresses []<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// conditions contains information about the current status of the endpoint.</span></span><br><span class="line">	Conditions EndpointConditions</span><br><span class="line">	<span class="comment">// hostname of this endpoint. This field may be used by consumers of</span></span><br><span class="line">	<span class="comment">// endpoints to distinguish endpoints from each other (e.g. in DNS names).</span></span><br><span class="line">	<span class="comment">// Multiple endpoints which use the same hostname should be considered</span></span><br><span class="line">	<span class="comment">// fungible (e.g. multiple A values in DNS). Must pass DNS Label (RFC 1123)</span></span><br><span class="line">	<span class="comment">// validation.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Hostname *<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// targetRef is a reference to a Kubernetes object that represents this</span></span><br><span class="line">	<span class="comment">// endpoint.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	TargetRef *api.ObjectReference</span><br><span class="line">	<span class="comment">// deprecatedTopology is deprecated and only retained for round-trip</span></span><br><span class="line">	<span class="comment">// compatibility with v1beta1 Topology field.  When v1beta1 is removed, this</span></span><br><span class="line">	<span class="comment">// should be removed, too.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	DeprecatedTopology <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// nodeName represents the name of the Node hosting this endpoint. This can</span></span><br><span class="line">	<span class="comment">// be used to determine endpoints local to a Node.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	NodeName *<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// zone is the name of the Zone this endpoint exists in.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Zone *<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// hints contains information associated with how an endpoint should be</span></span><br><span class="line">	<span class="comment">// consumed.</span></span><br><span class="line">	<span class="comment">// +featureGate=TopologyAwareHints</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Hints *EndpointHints</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从代码中可以看该Controller通过Informer机制监听了三种资源</span></span><br><span class="line"><span class="comment">// Service</span></span><br><span class="line"><span class="comment">// Pod</span></span><br><span class="line"><span class="comment">// endpoint</span></span><br><span class="line"><span class="comment">// pkg/controller/endpoint/endpoints_controller.go</span></span><br><span class="line"><span class="comment">// NewEndpointController returns a new *Controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEndpointController</span><span class="params">(podInformer coreinformers.PodInformer, serviceInformer coreinformers.ServiceInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	endpointsInformer coreinformers.EndpointsInformer, client clientset.Interface, endpointUpdatesBatchPeriod time.Duration)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">	broadcaster := record.NewBroadcaster()</span><br><span class="line">	recorder := broadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"endpoint-controller"</span>&#125;)</span><br><span class="line"></span><br><span class="line">	e := &amp;Controller&#123;</span><br><span class="line">		client:           client,</span><br><span class="line">		queue:            workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"endpoint"</span>),</span><br><span class="line">		workerLoopPeriod: time.Second,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// onServiceUpdate,onServiceDelete都是执行入队操作</span></span><br><span class="line">	serviceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: e.onServiceUpdate,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			e.onServiceUpdate(cur)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: e.onServiceDelete,</span><br><span class="line">	&#125;)</span><br><span class="line">	e.serviceLister = serviceInformer.Lister()</span><br><span class="line">	e.servicesSynced = serviceInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc:    e.addPod,</span><br><span class="line">		UpdateFunc: e.updatePod,</span><br><span class="line">		DeleteFunc: e.deletePod,</span><br><span class="line">	&#125;)</span><br><span class="line">	e.podLister = podInformer.Lister()</span><br><span class="line">	e.podsSynced = podInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e.onEndpointsDelete将key(default/ep)入队</span></span><br><span class="line">	endpointsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		DeleteFunc: e.onEndpointsDelete,</span><br><span class="line">	&#125;)</span><br><span class="line">	e.endpointsLister = endpointsInformer.Lister()</span><br><span class="line">	e.endpointsSynced = endpointsInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	e.triggerTimeTracker = endpointutil.NewTriggerTimeTracker()</span><br><span class="line">	e.eventBroadcaster = broadcaster</span><br><span class="line">	e.eventRecorder = recorder</span><br><span class="line"></span><br><span class="line">	e.endpointUpdatesBatchPeriod = endpointUpdatesBatchPeriod</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Controller)</span> <span class="title">processNextWorkItem</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	eKey, quit := e.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> e.queue.Done(eKey)</span><br><span class="line">  <span class="comment">// 处理逻辑都在syncService中</span></span><br><span class="line">	err := e.syncService(ctx, eKey.(<span class="keyword">string</span>))</span><br><span class="line">	e.handleErr(err, eKey)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Controller)</span> <span class="title">syncService</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"Finished syncing service %q endpoints. (%v)"</span>, key, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过key获取资源的命名空间和名称</span></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 通过endpoint名称找到对应的service,这里endpoint与service应该是一一对应的</span></span><br><span class="line">	service, err := e.serviceLister.Services(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !errors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Delete the corresponding endpoint, as the service has been deleted.</span></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Please note that this will delete an endpoint when a</span></span><br><span class="line">		<span class="comment">// service is deleted. However, if we're down at the time when</span></span><br><span class="line">		<span class="comment">// the service is deleted, we will miss that deletion, so this</span></span><br><span class="line">		<span class="comment">// doesn't completely solve the problem. See #6877.</span></span><br><span class="line">    <span class="comment">// 当kube-controller-manager处于宕机状态时删除Service会导致Endpoint可能会一直存在</span></span><br><span class="line">		err = e.client.CoreV1().Endpoints(namespace).Delete(ctx, name, metav1.DeleteOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		e.triggerTimeTracker.DeleteService(namespace, name)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> service.Spec.Type == v1.ServiceTypeExternalName &#123;</span><br><span class="line">		<span class="comment">// services with Type ExternalName receive no endpoints from this controller;</span></span><br><span class="line">		<span class="comment">// Ref: https://issues.k8s.io/105986</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> service.Spec.Selector == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// services without a selector receive no endpoints from this controller;</span></span><br><span class="line">		<span class="comment">// these services will receive the endpoints that are created out-of-band via the REST API.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">5</span>).Infof(<span class="string">"About to update endpoints for service %q"</span>, key)</span><br><span class="line">  <span class="comment">// 通过Selector找到对应的Pod</span></span><br><span class="line">	pods, err := e.podLister.Pods(service.Namespace).List(labels.Set(service.Spec.Selector).AsSelectorPreValidated())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Since we're getting stuff from a local cache, it is</span></span><br><span class="line">		<span class="comment">// basically impossible to get this error.</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We call ComputeEndpointLastChangeTriggerTime here to make sure that the</span></span><br><span class="line">	<span class="comment">// state of the trigger time tracker gets updated even if the sync turns out</span></span><br><span class="line">	<span class="comment">// to be no-op and we don't update the endpoints object.</span></span><br><span class="line">	endpointsLastChangeTriggerTime := e.triggerTimeTracker.</span><br><span class="line">		ComputeEndpointLastChangeTriggerTime(namespace, service, pods)</span><br><span class="line"></span><br><span class="line">	subsets := []v1.EndpointSubset&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> totalReadyEps <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> totalNotReadyEps <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="keyword">if</span> !endpointutil.ShouldPodBeInEndpoints(pod, service.Spec.PublishNotReadyAddresses) &#123;</span><br><span class="line">			klog.V(<span class="number">5</span>).Infof(<span class="string">"Pod %s/%s is not included on endpoints for Service %s/%s"</span>, pod.Namespace, pod.Name, service.Namespace, service.Name)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ep, err := podToEndpointAddressForService(service, pod)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// this will happen, if the cluster runs with some nodes configured as dual stack and some as not</span></span><br><span class="line">			<span class="comment">// such as the case of an upgrade..</span></span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">"Failed to find endpoint for service:%s with ClusterIP:%s on pod:%s with error:%v"</span>, service.Name, service.Spec.ClusterIP, klog.KObj(pod), err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		epa := *ep</span><br><span class="line">		<span class="keyword">if</span> endpointutil.ShouldSetHostname(pod, service) &#123;</span><br><span class="line">			epa.Hostname = pod.Spec.Hostname</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Allow headless service not to have ports.</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(service.Spec.Ports) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> service.Spec.ClusterIP == api.ClusterIPNone &#123;</span><br><span class="line">				subsets, totalReadyEps, totalNotReadyEps = addEndpointSubset(subsets, pod, epa, <span class="literal">nil</span>, service.Spec.PublishNotReadyAddresses)</span><br><span class="line">				<span class="comment">// No need to repack subsets for headless service without ports.</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> service.Spec.Ports &#123;</span><br><span class="line">				servicePort := &amp;service.Spec.Ports[i]</span><br><span class="line">				portNum, err := podutil.FindPort(pod, servicePort)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					klog.V(<span class="number">4</span>).Infof(<span class="string">"Failed to find port for service %s/%s: %v"</span>, service.Namespace, service.Name, err)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				epp := endpointPortFromServicePort(servicePort, portNum)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">var</span> readyEps, notReadyEps <span class="keyword">int</span></span><br><span class="line">				subsets, readyEps, notReadyEps = addEndpointSubset(subsets, pod, epa, epp, service.Spec.PublishNotReadyAddresses)</span><br><span class="line">				totalReadyEps = totalReadyEps + readyEps</span><br><span class="line">				totalNotReadyEps = totalNotReadyEps + notReadyEps</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	subsets = endpoints.RepackSubsets(subsets)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// See if there's actually an update here.</span></span><br><span class="line">  <span class="comment">// 通过命名空间和资源名称找对应的Endpoint</span></span><br><span class="line">  <span class="comment">// 如果Endpoint存在则是一个更新操作</span></span><br><span class="line">	currentEndpoints, err := e.endpointsLister.Endpoints(service.Namespace).Get(service.Name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !errors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		currentEndpoints = &amp;v1.Endpoints&#123;</span><br><span class="line">			ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">				Name:   service.Name,</span><br><span class="line">				Labels: service.Labels,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示Endpoint不存在，需要创建新的EndPoint</span></span><br><span class="line">  <span class="comment">// 当删除Endpoint后createEndpoints = true</span></span><br><span class="line">  <span class="comment">// 当创建Service后(Endpoint创建之前)createEndpoints = true</span></span><br><span class="line">	createEndpoints := <span class="built_in">len</span>(currentEndpoints.ResourceVersion) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compare the sorted subsets and labels</span></span><br><span class="line">	<span class="comment">// Remove the HeadlessService label from the endpoints if it exists,</span></span><br><span class="line">	<span class="comment">// as this won't be set on the service itself</span></span><br><span class="line">	<span class="comment">// and will cause a false negative in this diff check.</span></span><br><span class="line">	<span class="comment">// But first check if it has that label to avoid expensive copies.</span></span><br><span class="line">	compareLabels := currentEndpoints.Labels</span><br><span class="line">	<span class="keyword">if</span> _, ok := currentEndpoints.Labels[v1.IsHeadlessService]; ok &#123;</span><br><span class="line">		compareLabels = utillabels.CloneAndRemoveLabel(currentEndpoints.Labels, v1.IsHeadlessService)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// When comparing the subsets, we ignore the difference in ResourceVersion of Pod to avoid unnecessary Endpoints</span></span><br><span class="line">	<span class="comment">// updates caused by Pod updates that we don't care, e.g. annotation update.</span></span><br><span class="line">  <span class="comment">// 不必更新Endpoint</span></span><br><span class="line">	<span class="keyword">if</span> !createEndpoints &amp;&amp;</span><br><span class="line">		endpointutil.EndpointSubsetsEqualIgnoreResourceVersion(currentEndpoints.Subsets, subsets) &amp;&amp;</span><br><span class="line">		apiequality.Semantic.DeepEqual(compareLabels, service.Labels) &amp;&amp;</span><br><span class="line">		capacityAnnotationSetCorrectly(currentEndpoints.Annotations, currentEndpoints.Subsets) &#123;</span><br><span class="line">		klog.V(<span class="number">5</span>).Infof(<span class="string">"endpoints are equal for %s/%s, skipping update"</span>, service.Namespace, service.Name)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// Endpoint发生变化，更新对应的字段</span></span><br><span class="line">	newEndpoints := currentEndpoints.DeepCopy()</span><br><span class="line">	newEndpoints.Subsets = subsets</span><br><span class="line">	newEndpoints.Labels = service.Labels</span><br><span class="line">	<span class="keyword">if</span> newEndpoints.Annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">		newEndpoints.Annotations = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !endpointsLastChangeTriggerTime.IsZero() &#123;</span><br><span class="line">		newEndpoints.Annotations[v1.EndpointsLastChangeTriggerTime] =</span><br><span class="line">			endpointsLastChangeTriggerTime.UTC().Format(time.RFC3339Nano)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// No new trigger time, clear the annotation.</span></span><br><span class="line">		<span class="built_in">delete</span>(newEndpoints.Annotations, v1.EndpointsLastChangeTriggerTime)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// subset的最大长度为1000,所以理论上一个service最多支持1000个pod</span></span><br><span class="line">  <span class="comment">// 大于1000则会发生截断</span></span><br><span class="line">	<span class="keyword">if</span> truncateEndpoints(newEndpoints) &#123;</span><br><span class="line">		newEndpoints.Annotations[v1.EndpointsOverCapacity] = truncated</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(newEndpoints.Annotations, v1.EndpointsOverCapacity)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> newEndpoints.Labels == <span class="literal">nil</span> &#123;</span><br><span class="line">		newEndpoints.Labels = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !helper.IsServiceIPSet(service) &#123;</span><br><span class="line">		newEndpoints.Labels = utillabels.CloneAndAddLabel(newEndpoints.Labels, v1.IsHeadlessService, <span class="string">""</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		newEndpoints.Labels = utillabels.CloneAndRemoveLabel(newEndpoints.Labels, v1.IsHeadlessService)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"Update endpoints for %v/%v, ready: %d not ready: %d"</span>, service.Namespace, service.Name, totalReadyEps, totalNotReadyEps)</span><br><span class="line">	<span class="keyword">if</span> createEndpoints &#123;</span><br><span class="line">		<span class="comment">// No previous endpoints, create them</span></span><br><span class="line">		_, err = e.client.CoreV1().Endpoints(service.Namespace).Create(ctx, newEndpoints, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Pre-existing</span></span><br><span class="line">		_, err = e.client.CoreV1().Endpoints(service.Namespace).Update(ctx, newEndpoints, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> createEndpoints &amp;&amp; errors.IsForbidden(err) &#123;</span><br><span class="line">			<span class="comment">// A request is forbidden primarily for two reasons:</span></span><br><span class="line">			<span class="comment">// 1. namespace is terminating, endpoint creation is not allowed by default.</span></span><br><span class="line">			<span class="comment">// 2. policy is misconfigured, in which case no service would function anywhere.</span></span><br><span class="line">			<span class="comment">// Given the frequency of 1, we log at a lower level.</span></span><br><span class="line">			klog.V(<span class="number">5</span>).Infof(<span class="string">"Forbidden from creating endpoints: %v"</span>, err)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// If the namespace is terminating, creates will continue to fail. Simply drop the item.</span></span><br><span class="line">			<span class="keyword">if</span> errors.HasStatusCause(err, v1.NamespaceTerminatingCause) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> createEndpoints &#123;</span><br><span class="line">			e.eventRecorder.Eventf(newEndpoints, v1.EventTypeWarning, <span class="string">"FailedToCreateEndpoint"</span>, <span class="string">"Failed to create endpoint for service %v/%v: %v"</span>, service.Namespace, service.Name, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			e.eventRecorder.Eventf(newEndpoints, v1.EventTypeWarning, <span class="string">"FailedToUpdateEndpoint"</span>, <span class="string">"Failed to update endpoint %v/%v: %v"</span>, service.Namespace, service.Name, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/endpoint/endpoints_controller.go" target="_blank" rel="noopener">pkg/controller/endpoint/endpoints_controller.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之deployment</title>
    <url>/2023/05/08/kube-controller%E4%B9%8Bdeployment/</url>
    <content><![CDATA[<p><code>Kubernetes</code>中的<code>Deployment Controller</code>是一个负责管理<code>Pod</code>副本集的控制器。它在<code>Kubernetes</code>集群中负责确保<code>Pod</code>的副本数始终符合用户指定的期望值。<code>Deployment Controller</code>能够对<code>Pod</code>进行滚动更新(默认的更新策略)，通过逐步替换<code>Pod</code>的方式更新应用程序，以确保服务的高可用性和零停机时间。<code>Deployment Controller</code>使用控制循环对目标状态和当前状态进行比较，并对任何不同之处进行调整，以确保集群中的<code>Pod</code>数始终符合用户指定的期望值。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DeploymentController启动入口</span></span><br><span class="line"><span class="comment">// cmd/kube-controller-manager/app/apps.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startDeploymentController</span><span class="params">(ctx context.Context, controllerContext ControllerContext)</span> <span class="params">(controller.Interface, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	dc, err := deployment.NewDeploymentController(</span><br><span class="line">		ctx,</span><br><span class="line">		controllerContext.InformerFactory.Apps().V1().Deployments(),</span><br><span class="line">		controllerContext.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">		controllerContext.InformerFactory.Core().V1().Pods(),</span><br><span class="line">		controllerContext.ClientBuilder.ClientOrDie(<span class="string">"deployment-controller"</span>),</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, fmt.Errorf(<span class="string">"error creating Deployment controller: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> dc.Run(ctx, <span class="keyword">int</span>(controllerContext.ComponentConfig.DeploymentController.ConcurrentDeploymentSyncs))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完成Controller注册</span></span><br><span class="line"><span class="comment">// cmd/kube-controller-manager/app/controllermanager.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">	controllers := <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All of the controllers must have unique names, or else we will explode.</span></span><br><span class="line">	register := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, fn InitFunc)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _, found := controllers[name]; found &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"controller name %q was registered twice"</span>, name))</span><br><span class="line">		&#125;</span><br><span class="line">		controllers[name] = fn</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	register(<span class="string">"deployment"</span>, startDeploymentController)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后会在Run方法中调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(ctx context.Context, c *config.CompletedConfig)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, startSATokenController InitFunc, initializersFunc ControllerInitializersFunc)</span></span> &#123;</span><br><span class="line">		controllerContext, err := CreateControllerContext(logger, c, rootClientBuilder, clientBuilder, ctx.Done())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Error(err, <span class="string">"Error building controller context"</span>)</span><br><span class="line">			klog.FlushAndExit(klog.ExitFlushTimeout, <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		controllerInitializers := initializersFunc(controllerContext.LoopMode)</span><br><span class="line">		<span class="keyword">if</span> err := StartControllers(ctx, controllerContext, startSATokenController, controllerInitializers, unsecuredMux, healthzHandler); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Error(err, <span class="string">"Error starting controllers"</span>)</span><br><span class="line">			klog.FlushAndExit(klog.ExitFlushTimeout, <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		controllerContext.InformerFactory.Start(stopCh)</span><br><span class="line">		controllerContext.ObjectOrMetadataInformerFactory.Start(stopCh)</span><br><span class="line">		<span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line"></span><br><span class="line">		&lt;-ctx.Done()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No leader election, run directly</span></span><br><span class="line">	<span class="keyword">if</span> !c.ComponentConfig.Generic.LeaderElection.LeaderElect &#123;</span><br><span class="line">		<span class="comment">// 启动NewControllerInitializers注册的controller</span></span><br><span class="line">		run(ctx, saTokenControllerInitFunc, NewControllerInitializers)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/deployment/deployment_controller.go</span></span><br><span class="line"><span class="comment">// 最大重试次数</span></span><br><span class="line"><span class="comment">// 采用公式(5ms*2^(retryNum-1))对消息进行重新入队</span></span><br><span class="line"><span class="comment">// 5ms, 10ms, 20ms, 40ms, 80ms, 160ms, 320ms, 640ms, 1.3s, 2.6s, 5.1s, 10.2s, 20.4s, 41s, 82s</span></span><br><span class="line"><span class="keyword">const</span> maxRetries = <span class="number">15</span></span><br><span class="line"><span class="keyword">type</span> DeploymentController <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// rsControl用于添加/删除ReplicaSets.</span></span><br><span class="line">	rsControl controller.RSControlInterface</span><br><span class="line">	client    clientset.Interface</span><br><span class="line"></span><br><span class="line">	eventBroadcaster record.EventBroadcaster</span><br><span class="line">	eventRecorder    record.EventRecorder</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To allow injection of syncDeployment for testing.</span></span><br><span class="line">    <span class="comment">// syncHandler默认为syncDeployment,测试时可进行替换</span></span><br><span class="line">	syncHandler <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, dKey <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line">	<span class="comment">// used for unit testing</span></span><br><span class="line">	enqueueDeployment <span class="function"><span class="keyword">func</span><span class="params">(deployment *apps.Deployment)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// dLister can list/get deployments from the shared informer's store</span></span><br><span class="line">	dLister appslisters.DeploymentLister</span><br><span class="line">	<span class="comment">// rsLister can list/get replica sets from the shared informer's store</span></span><br><span class="line">	rsLister appslisters.ReplicaSetLister</span><br><span class="line">	<span class="comment">// podLister can list/get pods from the shared informer's store</span></span><br><span class="line">	podLister corelisters.PodLister</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dListerSynced returns true if the Deployment store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	dListerSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// rsListerSynced returns true if the ReplicaSet store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	rsListerSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// podListerSynced returns true if the pod store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	podListerSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Deployments that need to be synced</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建DeploymentController</span></span><br><span class="line"><span class="comment">// 可以看到DeploymentController需要监听三种资源变化: Deployment, ReplicaSet, Pod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeploymentController</span><span class="params">(ctx context.Context, dInformer appsinformers.DeploymentInformer, rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, client clientset.Interface)</span> <span class="params">(*DeploymentController, error)</span></span> &#123;</span><br><span class="line">	eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	dc := &amp;DeploymentController&#123;</span><br><span class="line">		client:           client,</span><br><span class="line">		eventBroadcaster: eventBroadcaster,</span><br><span class="line">		eventRecorder:    eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"deployment-controller"</span>&#125;),</span><br><span class="line">		queue:            workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"deployment"</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	dc.rsControl = controller.RealRSControl&#123;</span><br><span class="line">		KubeClient: client,</span><br><span class="line">		Recorder:   dc.eventRecorder,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			<span class="comment">// 如果新建一个Deployment, 将key入队</span></span><br><span class="line">			dc.addDeployment(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dc.updateDeployment(logger, oldObj, newObj)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// This will enter the sync loop and no-op, because the deployment has been deleted from the store.</span></span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dc.deleteDeployment(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dc.addReplicaSet(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dc.updateReplicaSet(logger, oldObj, newObj)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dc.deleteReplicaSet(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			dc.deletePod(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置syncHandler为syncDeployment.</span></span><br><span class="line">	dc.syncHandler = dc.syncDeployment</span><br><span class="line">	dc.enqueueDeployment = dc.enqueue</span><br><span class="line"></span><br><span class="line">	dc.dLister = dInformer.Lister()</span><br><span class="line">	dc.rsLister = rsInformer.Lister()</span><br><span class="line">	dc.podLister = podInformer.Lister()</span><br><span class="line">	dc.dListerSynced = dInformer.Informer().HasSynced</span><br><span class="line">	dc.rsListerSynced = rsInformer.Informer().HasSynced</span><br><span class="line">	dc.podListerSynced = podInformer.Informer().HasSynced</span><br><span class="line">	<span class="keyword">return</span> dc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start events processing pipeline.</span></span><br><span class="line">	dc.eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">	dc.eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: dc.client.CoreV1().Events(<span class="string">""</span>)&#125;)</span><br><span class="line">	<span class="keyword">defer</span> dc.eventBroadcaster.Shutdown()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> dc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.Info(<span class="string">"Starting controller"</span>, <span class="string">"controller"</span>, <span class="string">"deployment"</span>)</span><br><span class="line">	<span class="keyword">defer</span> logger.Info(<span class="string">"Shutting down controller"</span>, <span class="string">"controller"</span>, <span class="string">"deployment"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"deployment"</span>, ctx.Done(), dc.dListerSynced, dc.rsListerSynced, dc.podListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, dc.worker, time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> dc.processNextWorkItem(ctx) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">processNextWorkItem</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 取出key,然后执行syncHandler,也就是syncDeployment</span></span><br><span class="line">	key, quit := dc.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> dc.queue.Done(key)</span><br><span class="line">	<span class="comment">// 执行调谐逻辑</span></span><br><span class="line">	err := dc.syncHandler(ctx, key.(<span class="keyword">string</span>))</span><br><span class="line">	dc.handleErr(ctx, err, key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeploymentController真正的处理逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">syncDeployment</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	<span class="comment">// 获取到资源的命名空间和名称</span></span><br><span class="line">	<span class="comment">// 假如是在命名空间default创建Deployment(ep),则key为default/ep</span></span><br><span class="line">	<span class="comment">// namespace=default,name=ep</span></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">"Failed to split meta namespace cache key"</span>, <span class="string">"cacheKey"</span>, key)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Started syncing deployment"</span>, <span class="string">"deployment"</span>, klog.KRef(namespace, name), <span class="string">"startTime"</span>, startTime)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		logger.V(<span class="number">4</span>).Info(<span class="string">"Finished syncing deployment"</span>, <span class="string">"deployment"</span>, klog.KRef(namespace, name), <span class="string">"duration"</span>, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从cache是获取deployment,如果不存在则直接退出</span></span><br><span class="line">	deployment, err := dc.dLister.Deployments(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		logger.V(<span class="number">2</span>).Info(<span class="string">"Deployment has been deleted"</span>, <span class="string">"deployment"</span>, klog.KRef(namespace, name))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Deep-copy otherwise we are mutating our cache.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Deep-copy only when needed.</span></span><br><span class="line">	d := deployment.DeepCopy()</span><br><span class="line"></span><br><span class="line">	everything := metav1.LabelSelector&#123;&#125;</span><br><span class="line">	<span class="comment">// 如果Deployment的Selector为空，生成警告事件</span></span><br><span class="line">	<span class="comment">// Selector不能为空(为空表示选择所有的pod)</span></span><br><span class="line">	<span class="keyword">if</span> reflect.DeepEqual(d.Spec.Selector, &amp;everything) &#123;</span><br><span class="line">		dc.eventRecorder.Eventf(d, v1.EventTypeWarning, <span class="string">"SelectingAll"</span>, <span class="string">"This deployment is selecting all pods. A non-empty selector is required."</span>)</span><br><span class="line">		<span class="keyword">if</span> d.Status.ObservedGeneration &lt; d.Generation &#123;</span><br><span class="line">			d.Status.ObservedGeneration = d.Generation</span><br><span class="line">			dc.client.AppsV1().Deployments(d.Namespace).UpdateStatus(ctx, d, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// List ReplicaSets owned by this Deployment, while reconciling ControllerRef</span></span><br><span class="line">	<span class="comment">// through adoption/orphaning.</span></span><br><span class="line">	<span class="comment">// 获取属于Deployment的ReplicaSet</span></span><br><span class="line">	rsList, err := dc.getReplicaSetsForDeployment(ctx, d)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回属于Deployment的pod,类型为map</span></span><br><span class="line">	<span class="comment">//map[ReplicaSet.UID][]*v1.Pod</span></span><br><span class="line">	podMap, err := dc.getPodMapForDeployment(d, rsList)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果DeletionTimestamp!=nil,表明Deployment已经被Delete</span></span><br><span class="line">	<span class="keyword">if</span> d.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.syncStatusOnly(ctx, d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update deployment conditions with an Unknown condition when pausing/resuming</span></span><br><span class="line">	<span class="comment">// a deployment. In this way, we can be sure that we won't timeout when a user</span></span><br><span class="line">	<span class="comment">// resumes a Deployment with a set progressDeadlineSeconds.</span></span><br><span class="line">	<span class="keyword">if</span> err = dc.checkPausedConditions(ctx, d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> d.Spec.Paused &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.sync(ctx, d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rollback is not re-entrant in case the underlying replica sets are updated with a new</span></span><br><span class="line">	<span class="comment">// revision so we should ensure that we won't proceed to update replica sets until we</span></span><br><span class="line">	<span class="comment">// make sure that the deployment has cleaned up its rollback spec in subsequent enqueues.</span></span><br><span class="line">	<span class="keyword">if</span> getRollbackTo(d) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.rollback(ctx, d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scalingEvent, err := dc.isScalingEvent(ctx, d, rsList)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> scalingEvent &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.sync(ctx, d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Deployment的默认升级策略是RollingUpdate</span></span><br><span class="line">	<span class="keyword">switch</span> d.Spec.Strategy.Type &#123;</span><br><span class="line">	<span class="keyword">case</span> apps.RecreateDeploymentStrategyType:</span><br><span class="line">		<span class="keyword">return</span> dc.rolloutRecreate(ctx, d, rsList, podMap)</span><br><span class="line">	<span class="keyword">case</span> apps.RollingUpdateDeploymentStrategyType:</span><br><span class="line">		<span class="keyword">return</span> dc.rolloutRolling(ctx, d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"unexpected deployment strategy type: %s"</span>, d.Spec.Strategy.Type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/deployment/rolling.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">rolloutRolling</span><span class="params">(ctx context.Context, d *apps.Deployment, rsList []*apps.ReplicaSet)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取最新的RS,和旧的RS</span></span><br><span class="line">	newRS, oldRSs, err := dc.getAllReplicaSetsAndSyncRevision(ctx, d, rsList, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	allRSs := <span class="built_in">append</span>(oldRSs, newRS)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scale up, if we can.</span></span><br><span class="line">	scaledUp, err := dc.reconcileNewReplicaSet(ctx, allRSs, newRS, d)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> scaledUp &#123;</span><br><span class="line">		<span class="comment">// Update DeploymentStatus</span></span><br><span class="line">		<span class="keyword">return</span> dc.syncRolloutStatus(ctx, allRSs, newRS, d)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scale down, if we can.</span></span><br><span class="line">	scaledDown, err := dc.reconcileOldReplicaSets(ctx, allRSs, controller.FilterActiveReplicaSets(oldRSs), newRS, d)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> scaledDown &#123;</span><br><span class="line">		<span class="comment">// Update DeploymentStatus</span></span><br><span class="line">		<span class="keyword">return</span> dc.syncRolloutStatus(ctx, allRSs, newRS, d)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> deploymentutil.DeploymentComplete(d, &amp;d.Status) &#123;</span><br><span class="line">		<span class="keyword">if</span> err := dc.cleanupDeployment(ctx, oldRSs, d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sync deployment status</span></span><br><span class="line">	<span class="keyword">return</span> dc.syncRolloutStatus(ctx, allRSs, newRS, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">reconcileNewReplicaSet</span><span class="params">(ctx context.Context, allRSs []*apps.ReplicaSet, newRS *apps.ReplicaSet, deployment *apps.Deployment)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果最新的RS副本数=deployment的副本数，则不进行更新</span></span><br><span class="line">	<span class="keyword">if</span> *(newRS.Spec.Replicas) == *(deployment.Spec.Replicas) &#123;</span><br><span class="line">		<span class="comment">// Scaling not required.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 减少pod数量</span></span><br><span class="line">	<span class="keyword">if</span> *(newRS.Spec.Replicas) &gt; *(deployment.Spec.Replicas) &#123;</span><br><span class="line">		<span class="comment">// Scale down.</span></span><br><span class="line">		scaled, _, err := dc.scaleReplicaSetAndRecordEvent(ctx, newRS, *(deployment.Spec.Replicas), deployment)</span><br><span class="line">		<span class="keyword">return</span> scaled, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算NewRS应该拥有的Replicas数目</span></span><br><span class="line">	newReplicasCount, err := deploymentutil.NewRSNewReplicas(deployment, allRSs, newRS)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	scaled, _, err := dc.scaleReplicaSetAndRecordEvent(ctx, newRS, newReplicasCount, deployment)</span><br><span class="line">	<span class="keyword">return</span> scaled, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">reconcileOldReplicaSets</span><span class="params">(ctx context.Context, allRSs []*apps.ReplicaSet, oldRSs []*apps.ReplicaSet, newRS *apps.ReplicaSet, deployment *apps.Deployment)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	oldPodsCount := deploymentutil.GetReplicaCountForReplicaSets(oldRSs)</span><br><span class="line">	<span class="keyword">if</span> oldPodsCount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Can't scale down further</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	allPodsCount := deploymentutil.GetReplicaCountForReplicaSets(allRSs)</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"New replica set"</span>, <span class="string">"replicaSet"</span>, klog.KObj(newRS), <span class="string">"availableReplicas"</span>, newRS.Status.AvailableReplicas)</span><br><span class="line">	maxUnavailable := deploymentutil.MaxUnavailable(*deployment)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if we can scale down. We can scale down in the following 2 cases:</span></span><br><span class="line">	<span class="comment">// * Some old replica sets have unhealthy replicas, we could safely scale down those unhealthy replicas since that won't further</span></span><br><span class="line">	<span class="comment">//  increase unavailability.</span></span><br><span class="line">	<span class="comment">// * New replica set has scaled up and it's replicas becomes ready, then we can scale down old replica sets in a further step.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// maxScaledDown := allPodsCount - minAvailable - newReplicaSetPodsUnavailable</span></span><br><span class="line">	<span class="comment">// take into account not only maxUnavailable and any surge pods that have been created, but also unavailable pods from</span></span><br><span class="line">	<span class="comment">// the newRS, so that the unavailable pods from the newRS would not make us scale down old replica sets in a further</span></span><br><span class="line">	<span class="comment">// step(that will increase unavailability).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Concrete example:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// * 10 replicas</span></span><br><span class="line">	<span class="comment">// * 2 maxUnavailable (absolute number, not percent)</span></span><br><span class="line">	<span class="comment">// * 3 maxSurge (absolute number, not percent)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// case 1:</span></span><br><span class="line">	<span class="comment">// * Deployment is updated, newRS is created with 3 replicas, oldRS is scaled down to 8, and newRS is scaled up to 5.</span></span><br><span class="line">	<span class="comment">// * The new replica set pods crashloop and never become available.</span></span><br><span class="line">	<span class="comment">// * allPodsCount is 13. minAvailable is 8. newRSPodsUnavailable is 5.</span></span><br><span class="line">	<span class="comment">// * A node fails and causes one of the oldRS pods to become unavailable. However, 13 - 8 - 5 = 0, so the oldRS won't be scaled down.</span></span><br><span class="line">	<span class="comment">// * The user notices the crashloop and does kubectl rollout undo to rollback.</span></span><br><span class="line">	<span class="comment">// * newRSPodsUnavailable is 1, since we rolled back to the good replica set, so maxScaledDown = 13 - 8 - 1 = 4. 4 of the crashlooping pods will be scaled down.</span></span><br><span class="line">	<span class="comment">// * The total number of pods will then be 9 and the newRS can be scaled up to 10.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// case 2:</span></span><br><span class="line">	<span class="comment">// Same example, but pushing a new pod template instead of rolling back (aka "roll over"):</span></span><br><span class="line">	<span class="comment">// * The new replica set created must start with 0 replicas because allPodsCount is already at 13.</span></span><br><span class="line">	<span class="comment">// * However, newRSPodsUnavailable would also be 0, so the 2 old replica sets could be scaled down by 5 (13 - 8 - 0), which would then</span></span><br><span class="line">	<span class="comment">// allow the new replica set to be scaled up by 5.</span></span><br><span class="line">	minAvailable := *(deployment.Spec.Replicas) - maxUnavailable</span><br><span class="line">	newRSUnavailablePodCount := *(newRS.Spec.Replicas) - newRS.Status.AvailableReplicas</span><br><span class="line">	maxScaledDown := allPodsCount - minAvailable - newRSUnavailablePodCount</span><br><span class="line">	<span class="keyword">if</span> maxScaledDown &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clean up unhealthy replicas first, otherwise unhealthy replicas will block deployment</span></span><br><span class="line">	<span class="comment">// and cause timeout. See https://github.com/kubernetes/kubernetes/issues/16737</span></span><br><span class="line">	oldRSs, cleanupCount, err := dc.cleanupUnhealthyReplicas(ctx, oldRSs, deployment, maxScaledDown)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Cleaned up unhealthy replicas from old RSes"</span>, <span class="string">"count"</span>, cleanupCount)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scale down old replica sets, need check maxUnavailable to ensure we can scale down</span></span><br><span class="line">	allRSs = <span class="built_in">append</span>(oldRSs, newRS)</span><br><span class="line">	scaledDownCount, err := dc.scaleDownOldReplicaSetsForRollingUpdate(ctx, allRSs, oldRSs, deployment)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Scaled down old RSes"</span>, <span class="string">"deployment"</span>, klog.KObj(deployment), <span class="string">"count"</span>, scaledDownCount)</span><br><span class="line"></span><br><span class="line">	totalScaledDown := cleanupCount + scaledDownCount</span><br><span class="line">	<span class="keyword">return</span> totalScaledDown &gt; <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/cmd/kube-controller-manager/app/apps.go" target="_blank" rel="noopener">cmd/kube-controller-manager/app/apps.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/deployment/deployment_controller.go" target="_blank" rel="noopener">pkg/controller/deployment/deployment_controller.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/deployment/rolling.go" target="_blank" rel="noopener">pkg/controller/deployment/rolling.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之history</title>
    <url>/2023/06/25/kube-controller%E4%B9%8Bhistory/</url>
    <content><![CDATA[<h5 id="ControllerRevision"><a href="#ControllerRevision" class="headerlink" title="ControllerRevision"></a>ControllerRevision</h5><p><code>ControllerRevision</code> 实现了一个不可变的状态数据快照。客户端负责序列化和反序列化包含其内部状态的对象<br>一旦成功创建了 <code>ControllerRevision</code>，就不能对其进行更新,但是可以被删除。<code>APIServer</code>会拒绝所有试图修改 <code>Data</code> 字段的请求。<br><code>ControllerRevision</code>主要被 <code>DaemonSet</code> 和 <code>StatefulSet</code> 控制器用于更新和回滚。而且这个对象是<code>beta</code>的，在未来可能会发生变化，<br>客户端不应依赖其稳定性。因此<code>ControllerRevision</code>主要在内部控制器内使用。</p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/api/apps/v1/types.go</span></span><br><span class="line"><span class="keyword">type</span> ControllerRevision <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">	<span class="comment">// Standard object's metadata.</span></span><br><span class="line">	metav1.ObjectMeta <span class="string">`json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Data is the serialized representation of the state.</span></span><br><span class="line">	Data runtime.RawExtension <span class="string">`json:"data,omitempty" protobuf:"bytes,2,opt,name=data"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Revision indicates the revision of the state represented by Data.</span></span><br><span class="line">	Revision <span class="keyword">int64</span> <span class="string">`json:"revision" protobuf:"varint,3,opt,name=revision"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/controller/history/controller_history.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerRevision</span><span class="params">(parent metav1.Object,</span></span></span><br><span class="line"><span class="function"><span class="params">	parentKind schema.GroupVersionKind,</span></span></span><br><span class="line"><span class="function"><span class="params">	templateLabels <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	data runtime.RawExtension,</span></span></span><br><span class="line"><span class="function"><span class="params">	revision <span class="keyword">int64</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	collisionCount *<span class="keyword">int32</span>)</span> <span class="params">(*apps.ControllerRevision, error)</span></span> &#123;</span><br><span class="line">	labelMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> templateLabels &#123;</span><br><span class="line">		labelMap[k] = v</span><br><span class="line">	&#125;</span><br><span class="line">	cr := &amp;apps.ControllerRevision&#123;</span><br><span class="line">		ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">			Labels:          labelMap,</span><br><span class="line">            <span class="comment">// 设置OwnerReferences</span></span><br><span class="line">			OwnerReferences: []metav1.OwnerReference&#123;*metav1.NewControllerRef(parent, parentKind)&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		Data:     data,</span><br><span class="line">		Revision: revision,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 返回cr.Data的hash</span></span><br><span class="line">	hash := HashControllerRevision(cr, collisionCount)</span><br><span class="line">    <span class="comment">// 设置cr.Name</span></span><br><span class="line">	cr.Name = ControllerRevisionName(parent.GetName(), hash)</span><br><span class="line">	cr.Labels[ControllerRevisionHashLabel] = hash</span><br><span class="line">	<span class="keyword">return</span> cr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/controller/history/controller_history.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ControllerRevisionName</span><span class="params">(prefix <span class="keyword">string</span>, hash <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(prefix) &gt; <span class="number">223</span> &#123;</span><br><span class="line">		prefix = prefix[:<span class="number">223</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s-%s"</span>, prefix, hash)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> realHistory <span class="keyword">struct</span> &#123;</span><br><span class="line">	client clientset.Interface</span><br><span class="line">	lister appslisters.ControllerRevisionLister</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHistory</span><span class="params">(client clientset.Interface, lister appslisters.ControllerRevisionLister)</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;realHistory&#123;client, lister&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回ControllerRevision列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rh *realHistory)</span> <span class="title">ListControllerRevisions</span><span class="params">(parent metav1.Object, selector labels.Selector)</span> <span class="params">([]*apps.ControllerRevision, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// List all revisions in the namespace that match the selector</span></span><br><span class="line">	history, err := rh.lister.ControllerRevisions(parent.GetNamespace()).List(selector)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> owned []*apps.ControllerRevision</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> history &#123;</span><br><span class="line">		ref := metav1.GetControllerOfNoCopy(history[i])</span><br><span class="line">		<span class="keyword">if</span> ref == <span class="literal">nil</span> ControllerRevisions|| ref.UID == parent.GetUID() &#123;</span><br><span class="line">			owned = <span class="built_in">append</span>(owned, history[i])</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> owned, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ControllerRevision</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rh *realHistory)</span> <span class="title">CreateControllerRevision</span><span class="params">(parent metav1.Object, revision *apps.ControllerRevision, collisionCount *<span class="keyword">int32</span>)</span> <span class="params">(*apps.ControllerRevision, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> collisionCount ControllerRevisions== <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"collisionCount should not be nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clone the input</span></span><br><span class="line">	clone := revision.DeepCopy()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Continue to attempt to create the revision updating the name with a new hash on each iteration</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		hash := HashControllerRevision(revision, collisionCount)</span><br><span class="line">		<span class="comment">// Update the revisions name</span></span><br><span class="line">		clone.Name = ControllerRevisionName(parent.GetName(), hash)</span><br><span class="line">		ns := parent.GetNamespace()</span><br><span class="line">		created, err := rh.client.AppsV1().ControllerRevisions(ns).Create(context.TODO(), clone, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">if</span> errors.IsAlreadyExists(err) &#123;</span><br><span class="line">			exists, err := rh.client.AppsV1().ControllerRevisions(ns).Get(context.TODO(), clone.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> bytes.Equal(exists.Data.Raw, clone.Data.Raw) &#123;</span><br><span class="line">				<span class="keyword">return</span> exists, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			*collisionCount++</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> created, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新ControllerRevision,Data字段不能更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rh *realHistory)</span> <span class="title">UpdateControllerRevision</span><span class="params">(revision *apps.ControllerRevision, newRevision <span class="keyword">int64</span>)</span> <span class="params">(*apps.ControllerRevision, error)</span></span> &#123;</span><br><span class="line">	clone := revision.DeepCopy()</span><br><span class="line">	err := retry.RetryOnConflict(retry.DefaultBackoff, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> clone.Revision == newRevision &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		clone.Revision = newRevision</span><br><span class="line">		updated, updateErr := rh.client.AppsV1().ControllerRevisions(clone.Namespace).Update(context.TODO(), clone, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">if</span> updateErr == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> updated != <span class="literal">nil</span> &#123;</span><br><span class="line">			clone = updated</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> updated, err := rh.lister.ControllerRevisions(clone.Namespace).Get(clone.Name); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// make a copy so we don't mutate the shared cache</span></span><br><span class="line">			clone = updated.DeepCopy()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> updateErr</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> clone, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除ControllerRevision</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rh *realHistory)</span> <span class="title">DeleteControllerRevision</span><span class="params">(revision *apps.ControllerRevision)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rh.client.AppsV1().ControllerRevisions(revision.Namespace).Delete(context.TODO(), revision.Name, metav1.DeleteOptions&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/controller/statefulset/stateful_set_control.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRevision</span><span class="params">(set *apps.StatefulSet, revision <span class="keyword">int64</span>, collisionCount *<span class="keyword">int32</span>)</span> <span class="params">(*apps.ControllerRevision, error)</span></span> &#123;</span><br><span class="line">	patch, err := getPatch(set)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	cr, err := history.NewControllerRevision(set,</span><br><span class="line">		controllerKind,</span><br><span class="line">		set.Spec.Template.Labels,</span><br><span class="line">		runtime.RawExtension&#123;Raw: patch&#125;,</span><br><span class="line">		revision,</span><br><span class="line">		collisionCount)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> cr.ObjectMeta.Annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">		cr.ObjectMeta.Annotations = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> set.Annotations &#123;</span><br><span class="line">		cr.ObjectMeta.Annotations[key] = value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *defaultStatefulSetControl)</span> <span class="title">getStatefulSetRevisions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	set *apps.StatefulSet,</span></span></span><br><span class="line"><span class="function"><span class="params">	revisions []*apps.ControllerRevision)</span> <span class="params">(*apps.ControllerRevision, *apps.ControllerRevision, <span class="keyword">int32</span>, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	updateRevision, err := newRevision(set, nextRevision(revisions), &amp;collisionCount)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>严格来说<code>ControllerRevision history controller</code>并不是一个真正的控制器，只是提供了创建<code>ControlllerRevison</code>和对<code>ControllerRevision</code>操作的一些方法，可以给其它的控制器使用，比如<code>StatefulSet</code>。</p>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/staging/src/k8s.io/api/apps/v1/types.go" target="_blank" rel="noopener">staging/src/k8s.io/api/apps/v1/types.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/history/controller_history.go" target="_blank" rel="noopener">pkg/controller/history/controller_history.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/statefulset/stateful_set_control.go" target="_blank" rel="noopener">pkg/controller/statefulset/stateful_set_control.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之job</title>
    <url>/2023/06/21/kube-controller%E4%B9%8Bjob/</url>
    <content><![CDATA[<h5 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h5><p>在<code>k8s</code>中，<code>Job</code>是用于运行批处理或单次任务的资源。它代表了一个任务或一组并行任务，直到成功完成。<code>Job</code>通常用于数据处理、备份或其他需要执行一次或定期执行的任务<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/" target="_blank" rel="noopener">CronJob</a>。</p>
<p>以下是<code>k8s</code>中Job的一些关键特性和特点：</p>
<ol>
<li><p>执行：<code>Job</code>确保任务成功完成后才将其标记为“完成”。每个任务都会执行直到完成，可以是一个单独的<code>Pod</code>或一组并行的<code>Pod</code>。</p>
</li>
<li><p><code>Pod</code>创建：<code>Job</code>创建一个或多个<code>Pod</code>来执行任务。这些<code>Pod</code>由<code>Job</code>控制器自动管理。</p>
</li>
<li><p>任务并行性：<code>Job</code>可以配置为并行运行任务，可以通过指定并行<code>Pod</code>的数量或定义具有多个工作器的工作队列来实现。</p>
</li>
<li><p>重启策略：<code>Job</code>具有重启策略，用于确定任务失败或<code>Pod</code>终止时的处理方式。重启策略可以设置为“从不重启”、“仅在失败时重启”或“总是重启”。</p>
</li>
<li><p>任务完成条件：<code>Job</code>具有完成条件，定义了何时认为<code>Job</code>成功完成。完成条件可以基于成功完成的任务数量或用户指定的其他条件。</p>
</li>
</ol>
<ol>
<li>清理：<code>Job</code>可以配置为在任务完成后清理已完成的<code>Pod</code>。这样可以确保在Job完成后不会留下未释放的资源。</li>
</ol>
<p><code>Job</code>提供了在<code>k8s</code>中执行批处理和一次性任务的方式。它们是执行非交互式工作负载的基本构建块，可以与其他<code>k8s</code>资源（例如持久卷、配置映射和机密）结合使用，执行复杂的任务。</p>
<p>详细信息可查看<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/" target="_blank" rel="noopener">官方文档</a></p>
<hr>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/job/job_controller.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// DefaultJobBackOff is the default backoff period. Exported for tests.</span></span><br><span class="line">	DefaultJobBackOff = <span class="number">10</span> * time.Second</span><br><span class="line">	<span class="comment">// MaxJobBackOff is the max backoff period. Exported for tests.</span></span><br><span class="line">	MaxJobBackOff = <span class="number">360</span> * time.Second</span><br><span class="line">	<span class="comment">// MaxUncountedPods is the maximum size the slices in</span></span><br><span class="line">	<span class="comment">// .status.uncountedTerminatedPods should have to keep their representation</span></span><br><span class="line">	<span class="comment">// roughly below 20 KB. Exported for tests</span></span><br><span class="line">	MaxUncountedPods = <span class="number">500</span></span><br><span class="line">	<span class="comment">// MaxPodCreateDeletePerSync is the maximum number of pods that can be</span></span><br><span class="line">	<span class="comment">// created or deleted in a single sync call. Exported for tests.</span></span><br><span class="line">	MaxPodCreateDeletePerSync = <span class="number">500</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	kubeClient clientset.Interface</span><br><span class="line">	podControl controller.PodControlInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To allow injection of the following for testing.</span></span><br><span class="line">	updateStatusHandler <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, job *batch.Job)</span> <span class="params">(*batch.Job, error)</span></span></span><br><span class="line">	patchJobHandler     <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, job *batch.Job, patch []<span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line">	syncHandler         <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, jobKey <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line">	<span class="comment">// podStoreSynced returns true if the pod store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">    <span class="comment">// 判断是否至少出现一次全量同步</span></span><br><span class="line">	podStoreSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// jobStoreSynced returns true if the job store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	jobStoreSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A TTLCache of pod creates/deletes each rc expects to see</span></span><br><span class="line">	expectations controller.ControllerExpectationsInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// finalizerExpectations tracks the Pod UIDs for which the controller</span></span><br><span class="line">	<span class="comment">// expects to observe the tracking finalizer removed.</span></span><br><span class="line">	finalizerExpectations *uidTrackingExpectations</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A store of jobs</span></span><br><span class="line">	jobLister batchv1listers.JobLister</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A store of pods, populated by the podController</span></span><br><span class="line">	podStore corelisters.PodLister</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Jobs that need to be updated</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Orphan deleted pods that still have a Job tracking finalizer to be removed</span></span><br><span class="line">	orphanQueue workqueue.RateLimitingInterface</span><br><span class="line"></span><br><span class="line">	broadcaster record.EventBroadcaster</span><br><span class="line">	recorder    record.EventRecorder</span><br><span class="line"></span><br><span class="line">	podUpdateBatchPeriod time.Duration</span><br><span class="line"></span><br><span class="line">	clock clock.WithTicker</span><br><span class="line"></span><br><span class="line">	backoffRecordStore *backoffStore</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(podInformer coreinformers.PodInformer, jobInformer batchinformers.JobInformer, kubeClient clientset.Interface)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> newControllerWithClock(podInformer, jobInformer, kubeClient, &amp;clock.RealClock&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newControllerWithClock</span><span class="params">(podInformer coreinformers.PodInformer, jobInformer batchinformers.JobInformer, kubeClient clientset.Interface, clock clock.WithTicker)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">	eventBroadcaster := record.NewBroadcaster()</span><br><span class="line"></span><br><span class="line">	jm := &amp;Controller&#123;</span><br><span class="line">		kubeClient: kubeClient,</span><br><span class="line">		podControl: controller.RealPodControl&#123;</span><br><span class="line">			KubeClient: kubeClient,</span><br><span class="line">			Recorder:   eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"job-controller"</span>&#125;),</span><br><span class="line">		&#125;,</span><br><span class="line">		expectations:          controller.NewControllerExpectations(),</span><br><span class="line">		finalizerExpectations: newUIDTrackingExpectations(),</span><br><span class="line">		queue:                 workqueue.NewRateLimitingQueueWithDelayingInterface(workqueue.NewDelayingQueueWithCustomClock(clock, <span class="string">"job"</span>), workqueue.NewItemExponentialFailureRateLimiter(DefaultJobBackOff, MaxJobBackOff)),</span><br><span class="line">		orphanQueue:           workqueue.NewRateLimitingQueueWithDelayingInterface(workqueue.NewDelayingQueueWithCustomClock(clock, <span class="string">"job_orphan_pod"</span>), workqueue.NewItemExponentialFailureRateLimiter(DefaultJobBackOff, MaxJobBackOff)),</span><br><span class="line">		broadcaster:           eventBroadcaster,</span><br><span class="line">		recorder:              eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"job-controller"</span>&#125;),</span><br><span class="line">		clock:                 clock,</span><br><span class="line">		backoffRecordStore:    newBackoffRecordStore(),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> feature.DefaultFeatureGate.Enabled(features.JobReadyPods) &#123;</span><br><span class="line">		jm.podUpdateBatchPeriod = podUpdateBatchPeriod</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jobInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			jm.enqueueController(obj, <span class="literal">true</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: jm.updateJob,</span><br><span class="line">		DeleteFunc: jm.deleteJob,</span><br><span class="line">	&#125;)</span><br><span class="line">	jm.jobLister = jobInformer.Lister()</span><br><span class="line">	jm.jobStoreSynced = jobInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc:    jm.addPod,</span><br><span class="line">		UpdateFunc: jm.updatePod,</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			jm.deletePod(obj, <span class="literal">true</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	jm.podStore = podInformer.Lister()</span><br><span class="line">	jm.podStoreSynced = podInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向apiserver更新job的状态</span></span><br><span class="line">	jm.updateStatusHandler = jm.updateJobStatus</span><br><span class="line">    <span class="comment">// 设置对应的Handler函数</span></span><br><span class="line">	<span class="comment">// 对job进行patch操作</span></span><br><span class="line">	jm.patchJobHandler = jm.patchJob</span><br><span class="line">	<span class="comment">// 调谐函数</span></span><br><span class="line">	jm.syncHandler = jm.syncJob</span><br><span class="line"></span><br><span class="line">	metrics.Register()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> jm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syncJob will sync the job with the given key if it has had its expectations fulfilled, meaning</span></span><br><span class="line"><span class="comment">// it did not expect to see any more of its pods created or deleted. This function is not meant to be invoked</span></span><br><span class="line"><span class="comment">// concurrently with the same key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *Controller)</span> <span class="title">syncJob</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="params">(rErr error)</span></span> &#123;</span><br><span class="line">	startTime := jm.clock.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"Finished syncing job %q (%v)"</span>, key, jm.clock.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	ns, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ns) == <span class="number">0</span> || <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid job key %q: either namespace or name is missing"</span>, key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取对应的Job</span></span><br><span class="line">	sharedJob, err := jm.jobLister.Jobs(ns).Get(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="comment">// 如果Job不存在，说明Job已经被删除</span></span><br><span class="line">			<span class="comment">// 删除对应的expectations</span></span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"Job has been deleted: %v"</span>, key)</span><br><span class="line">			jm.expectations.DeleteExpectations(key)</span><br><span class="line">			jm.finalizerExpectations.deleteExpectations(key)</span><br><span class="line"></span><br><span class="line">			err := jm.backoffRecordStore.removeBackoffRecord(key)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// re-syncing here as the record has to be removed for finished/deleted jobs</span></span><br><span class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">"error removing backoff record %w"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// make a copy so we don't mutate the shared cache</span></span><br><span class="line">	job := *sharedJob.DeepCopy()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if job was finished previously, we don't want to redo the termination</span></span><br><span class="line">	<span class="keyword">if</span> IsJobFinished(&amp;job) &#123;</span><br><span class="line">		<span class="comment">// 从backoff缓存中删除</span></span><br><span class="line">		err := jm.backoffRecordStore.removeBackoffRecord(key)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// re-syncing here as the record has to be removed for finished/deleted jobs</span></span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"error removing backoff record %w"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 目前有两种CompletionMode: 1. NonIndexed(default),2. Indexed</span></span><br><span class="line">	<span class="comment">// NonIndexed: 当完成的pod数量=.spec.completions表示此job已经完成，每个pod都是一样的</span></span><br><span class="line">	<span class="comment">// Indexed: Job关联了一个completon index(0-.spec.completions-1),当每个index上都有</span></span><br><span class="line">	<span class="comment">// 一个completed pod,表示此job已完成</span></span><br><span class="line">	<span class="comment">// 当CompletionMod=“Indexed",必须指定.spec.completions,.spec.parallelism必须&lt;=100000</span></span><br><span class="line">	<span class="comment">// pod名称$(job-name)-$(index)-$(random-string)</span></span><br><span class="line">	<span class="comment">// pod hostname:$(job-name)-$(index)</span></span><br><span class="line">	<span class="keyword">if</span> job.Spec.CompletionMode != <span class="literal">nil</span> &amp;&amp; *job.Spec.CompletionMode != batch.NonIndexedCompletion &amp;&amp; *job.Spec.CompletionMode != batch.IndexedCompletion &#123;</span><br><span class="line">		jm.recorder.Event(&amp;job, v1.EventTypeWarning, <span class="string">"UnknownCompletionMode"</span>, <span class="string">"Skipped Job sync because completion mode is unknown"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取CompletionMode</span></span><br><span class="line">	completionMode := getCompletionMode(&amp;job)</span><br><span class="line">	action := metrics.JobSyncActionReconciling</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		result := <span class="string">"success"</span></span><br><span class="line">		<span class="keyword">if</span> rErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			result = <span class="string">"error"</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		metrics.JobSyncDurationSeconds.WithLabelValues(completionMode, result, action).Observe(jm.clock.Since(startTime).Seconds())</span><br><span class="line">		metrics.JobSyncNum.WithLabelValues(completionMode, result, action).Inc()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// UncountedTerminatedPods 记录terminated状态但是job controller并没有记录的pod的UID</span></span><br><span class="line">	<span class="keyword">if</span> job.Status.UncountedTerminatedPods == <span class="literal">nil</span> &#123;</span><br><span class="line">		job.Status.UncountedTerminatedPods = &amp;batch.UncountedTerminatedPods&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	uncounted := newUncountedTerminatedPods(*job.Status.UncountedTerminatedPods)</span><br><span class="line">	expectedRmFinalizers := jm.finalizerExpectations.getExpectedUIDs(key)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check the expectations of the job before counting active pods, otherwise a new pod can sneak in</span></span><br><span class="line">	<span class="comment">// and update the expectations after we've retrieved active pods from the store. If a new pod enters</span></span><br><span class="line">	<span class="comment">// the store after we've checked the expectation, the job sync is just deferred till the next relist.</span></span><br><span class="line">	satisfiedExpectations := jm.expectations.SatisfiedExpectations(key)</span><br><span class="line"></span><br><span class="line">	pods, err := jm.getPodsForJob(ctx, &amp;job)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// activePod p.Status.Phase != v1.PodSucceeded &amp;&amp; p.Status.Phase!=v1.PodFailed &amp;&amp; p.DeletionTimestamp==nil</span></span><br><span class="line">	activePods := controller.FilterActivePods(pods)</span><br><span class="line">	active := <span class="keyword">int32</span>(<span class="built_in">len</span>(activePods))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回未记录的最近成功和失败的pod</span></span><br><span class="line">	newSucceededPods, newFailedPods := getNewFinishedPods(&amp;job, pods, uncounted, expectedRmFinalizers)</span><br><span class="line">	<span class="comment">// 更新成功的pod数量</span></span><br><span class="line">	succeeded := job.Status.Succeeded + <span class="keyword">int32</span>(<span class="built_in">len</span>(newSucceededPods)) + <span class="keyword">int32</span>(<span class="built_in">len</span>(uncounted.succeeded))</span><br><span class="line">	<span class="comment">// 更新失败的pod数量</span></span><br><span class="line">	failed := job.Status.Failed + <span class="keyword">int32</span>(<span class="built_in">len</span>(newFailedPods)) + <span class="keyword">int32</span>(<span class="built_in">len</span>(uncounted.failed))</span><br><span class="line">	<span class="keyword">var</span> ready *<span class="keyword">int32</span></span><br><span class="line">	<span class="keyword">if</span> feature.DefaultFeatureGate.Enabled(features.JobReadyPods) &#123;</span><br><span class="line">		ready = pointer.Int32(countReadyPods(activePods))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Job first start. Set StartTime only if the job is not in the suspended state.</span></span><br><span class="line">	<span class="keyword">if</span> job.Status.StartTime == <span class="literal">nil</span> &amp;&amp; !jobSuspended(&amp;job) &#123;</span><br><span class="line">		now := metav1.NewTime(jm.clock.Now())</span><br><span class="line">		job.Status.StartTime = &amp;now</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newBackoffInfo := jm.backoffRecordStore.newBackoffRecord(jm.clock, key, newSucceededPods, newFailedPods)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> manageJobErr error</span><br><span class="line">	<span class="keyword">var</span> finishedCondition *batch.JobCondition</span><br><span class="line"></span><br><span class="line">	jobHasNewFailure := failed &gt; job.Status.Failed</span><br><span class="line">	<span class="comment">// new failures happen when status does not reflect the failures and active</span></span><br><span class="line">	<span class="comment">// is different than parallelism, otherwise the previous controller loop</span></span><br><span class="line">	<span class="comment">// failed updating status so even if we pick up failure it is not a new one</span></span><br><span class="line">	exceedsBackoffLimit := jobHasNewFailure &amp;&amp; (active != *job.Spec.Parallelism) &amp;&amp;</span><br><span class="line">		(failed &gt; *job.Spec.BackoffLimit)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> feature.DefaultFeatureGate.Enabled(features.JobPodFailurePolicy) &#123;</span><br><span class="line">		<span class="keyword">if</span> failureTargetCondition := findConditionByType(job.Status.Conditions, batch.JobFailureTarget); failureTargetCondition != <span class="literal">nil</span> &#123;</span><br><span class="line">			finishedCondition = newFailedConditionForFailureTarget(failureTargetCondition, jm.clock.Now())</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> failJobMessage := getFailJobMessage(&amp;job, pods); failJobMessage != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Prepare the interim FailureTarget condition to record the failure message before the finalizers (allowing removal of the pods) are removed.</span></span><br><span class="line">			finishedCondition = newCondition(batch.JobFailureTarget, v1.ConditionTrue, jobConditionReasonPodFailurePolicy, *failJobMessage, jm.clock.Now())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> finishedCondition == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> exceedsBackoffLimit || pastBackoffLimitOnFailure(&amp;job, pods) &#123;</span><br><span class="line">			<span class="comment">// check if the number of pod restart exceeds backoff (for restart OnFailure only)</span></span><br><span class="line">			<span class="comment">// OR if the number of failed jobs increased since the last syncJob</span></span><br><span class="line">			finishedCondition = newCondition(batch.JobFailed, v1.ConditionTrue, <span class="string">"BackoffLimitExceeded"</span>, <span class="string">"Job has reached the specified backoff limit"</span>, jm.clock.Now())</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> jm.pastActiveDeadline(&amp;job) &#123;</span><br><span class="line">			finishedCondition = newCondition(batch.JobFailed, v1.ConditionTrue, <span class="string">"DeadlineExceeded"</span>, <span class="string">"Job was active longer than specified deadline"</span>, jm.clock.Now())</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> job.Spec.ActiveDeadlineSeconds != <span class="literal">nil</span> &amp;&amp; !jobSuspended(&amp;job) &#123;</span><br><span class="line">			syncDuration := time.Duration(*job.Spec.ActiveDeadlineSeconds)*time.Second - jm.clock.Since(job.Status.StartTime.Time)</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">"Job has activeDeadlineSeconds configuration. Will sync this job again"</span>, <span class="string">"job"</span>, key, <span class="string">"nextSyncIn"</span>, syncDuration)</span><br><span class="line">			jm.queue.AddAfter(key, syncDuration)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> prevSucceededIndexes, succeededIndexes orderedIntervals</span><br><span class="line">	<span class="comment">// 如果是IndexedJob,统计成功的indexes</span></span><br><span class="line">	<span class="keyword">if</span> isIndexedJob(&amp;job) &#123;</span><br><span class="line">		prevSucceededIndexes, succeededIndexes = calculateSucceededIndexes(&amp;job, pods)</span><br><span class="line">		succeeded = <span class="keyword">int32</span>(succeededIndexes.total())</span><br><span class="line">	&#125;</span><br><span class="line">	suspendCondChanged := <span class="literal">false</span></span><br><span class="line">	<span class="comment">// Remove active pods if Job failed.</span></span><br><span class="line">	<span class="keyword">if</span> finishedCondition != <span class="literal">nil</span> &#123;</span><br><span class="line">		deleted, err := jm.deleteActivePods(ctx, &amp;job, activePods)</span><br><span class="line">		<span class="keyword">if</span> deleted != active || !satisfiedExpectations &#123;</span><br><span class="line">			<span class="comment">// Can't declare the Job as finished yet, as there might be remaining</span></span><br><span class="line">			<span class="comment">// pod finalizers or pods that are not in the informer's cache yet.</span></span><br><span class="line">			finishedCondition = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		active -= deleted</span><br><span class="line">		manageJobErr = err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		manageJobCalled := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> satisfiedExpectations &amp;&amp; job.DeletionTimestamp == <span class="literal">nil</span> &#123;</span><br><span class="line">			active, action, manageJobErr = jm.manageJob(ctx, &amp;job, activePods, succeeded, succeededIndexes, newBackoffInfo)</span><br><span class="line">			manageJobCalled = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		complete := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> job.Spec.Completions == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// This type of job is complete when any pod exits with success.</span></span><br><span class="line">			<span class="comment">// Each pod is capable of</span></span><br><span class="line">			<span class="comment">// determining whether or not the entire Job is done.  Subsequent pods are</span></span><br><span class="line">			<span class="comment">// not expected to fail, but if they do, the failure is ignored.  Once any</span></span><br><span class="line">			<span class="comment">// pod succeeds, the controller waits for remaining pods to finish, and</span></span><br><span class="line">			<span class="comment">// then the job is complete.</span></span><br><span class="line">			complete = succeeded &gt; <span class="number">0</span> &amp;&amp; active == <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Job specifies a number of completions.  This type of job signals</span></span><br><span class="line">			<span class="comment">// success by having that number of successes.  Since we do not</span></span><br><span class="line">			<span class="comment">// start more pods than there are remaining completions, there should</span></span><br><span class="line">			<span class="comment">// not be any remaining active pods once this count is reached.</span></span><br><span class="line">			complete = succeeded &gt;= *job.Spec.Completions &amp;&amp; active == <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> complete &#123;</span><br><span class="line">			finishedCondition = newCondition(batch.JobComplete, v1.ConditionTrue, <span class="string">""</span>, <span class="string">""</span>, jm.clock.Now())</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> manageJobCalled &#123;</span><br><span class="line">			<span class="comment">// Update the conditions / emit events only if manageJob was called in</span></span><br><span class="line">			<span class="comment">// this syncJob. Otherwise wait for the right syncJob call to make</span></span><br><span class="line">			<span class="comment">// updates.</span></span><br><span class="line">			<span class="keyword">if</span> job.Spec.Suspend != <span class="literal">nil</span> &amp;&amp; *job.Spec.Suspend &#123;</span><br><span class="line">				<span class="comment">// Job can be in the suspended state only if it is NOT completed.</span></span><br><span class="line">				<span class="keyword">var</span> isUpdated <span class="keyword">bool</span></span><br><span class="line">				job.Status.Conditions, isUpdated = ensureJobConditionStatus(job.Status.Conditions, batch.JobSuspended, v1.ConditionTrue, <span class="string">"JobSuspended"</span>, <span class="string">"Job suspended"</span>, jm.clock.Now())</span><br><span class="line">				<span class="keyword">if</span> isUpdated &#123;</span><br><span class="line">					suspendCondChanged = <span class="literal">true</span></span><br><span class="line">					jm.recorder.Event(&amp;job, v1.EventTypeNormal, <span class="string">"Suspended"</span>, <span class="string">"Job suspended"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Job not suspended.</span></span><br><span class="line">				<span class="keyword">var</span> isUpdated <span class="keyword">bool</span></span><br><span class="line">				job.Status.Conditions, isUpdated = ensureJobConditionStatus(job.Status.Conditions, batch.JobSuspended, v1.ConditionFalse, <span class="string">"JobResumed"</span>, <span class="string">"Job resumed"</span>, jm.clock.Now())</span><br><span class="line">				<span class="keyword">if</span> isUpdated &#123;</span><br><span class="line">					suspendCondChanged = <span class="literal">true</span></span><br><span class="line">					jm.recorder.Event(&amp;job, v1.EventTypeNormal, <span class="string">"Resumed"</span>, <span class="string">"Job resumed"</span>)</span><br><span class="line">					<span class="comment">// Resumed jobs will always reset StartTime to current time. This is</span></span><br><span class="line">					<span class="comment">// done because the ActiveDeadlineSeconds timer shouldn't go off</span></span><br><span class="line">					<span class="comment">// whilst the Job is still suspended and resetting StartTime is</span></span><br><span class="line">					<span class="comment">// consistent with resuming a Job created in the suspended state.</span></span><br><span class="line">					<span class="comment">// (ActiveDeadlineSeconds is interpreted as the number of seconds a</span></span><br><span class="line">					<span class="comment">// Job is continuously active.)</span></span><br><span class="line">					now := metav1.NewTime(jm.clock.Now())</span><br><span class="line">					job.Status.StartTime = &amp;now</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	needsStatusUpdate := suspendCondChanged || active != job.Status.Active || !equalReady(ready, job.Status.Ready)</span><br><span class="line">	job.Status.Active = active</span><br><span class="line">	job.Status.Ready = ready</span><br><span class="line">	err = jm.trackJobStatusAndRemoveFinalizers(ctx, &amp;job, pods, prevSucceededIndexes, *uncounted, expectedRmFinalizers, finishedCondition, needsStatusUpdate, newBackoffInfo)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> apierrors.IsConflict(err) &#123;</span><br><span class="line">			<span class="comment">// we probably have a stale informer cache</span></span><br><span class="line">			<span class="comment">// so don't return an error to avoid backoff</span></span><br><span class="line">			jm.enqueueController(&amp;job, <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"tracking status: %w"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断Job是否已经完成</span></span><br><span class="line">	jobFinished := IsJobFinished(&amp;job)</span><br><span class="line">	<span class="keyword">if</span> jobHasNewFailure &amp;&amp; !jobFinished &#123;</span><br><span class="line">		<span class="comment">// returning an error will re-enqueue Job after the backoff period</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed pod(s) detected for job key %q"</span>, key)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> manageJobErr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/controller/controller_utils.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsJobFinished</span><span class="params">(j *batch.Job)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> j.Status.Conditions &#123;</span><br><span class="line">		<span class="keyword">if</span> (c.Type == batch.JobComplete || c.Type == batch.JobFailed) &amp;&amp; c.Status == v1.ConditionTrue &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/job/job_controller.go" target="_blank" rel="noopener">pkg/controller/job/job_controller.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/controller_utils.go" target="_blank" rel="noopener">pkg/controller/controller_utils.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之endpointslice</title>
    <url>/2023/05/07/kube-controller%E4%B9%8Bendpointslice/</url>
    <content><![CDATA[<p><code>Kubernetes EndpointSlice</code>是在<code>Kubernetes 1.16</code>版本中引入的一种资源，它提供了一种更有效的方式来表示<code>Kubernetes</code>服务的网络端点。</p>
<p><code>EndpointSlice</code>为现有的<code>Endpoints</code>资源提供了一种替代方案，对于具有大量网络端点的非常大型服务，<code>Endpoints</code>资源可能会成为性能瓶颈。 <code>EndpointSlice</code>将服务的网络端点分成更小、更易管理的块，每个块由单独的<code>EndpointSlice</code>资源表示。</p>
<p>每个<code>EndpointSlice</code>包含有关服务的一部分端点的信息，包括它们的IP地址、端口和附加的元数据，例如拓扑信息。这使得<code>Kubernetes</code>更容易有效地管理和更新服务的网络端点。</p>
<p><code>EndpointSlice</code>还支持其他功能，例如支持多协议服务和支持加权负载平衡，这些功能在原始的<code>Endpoints</code>资源中不可用。</p>
<p>与 <code>Endpoints</code> 的比较<br>原来的 <code>Endpoints API</code> 提供了在 <code>Kubernetes</code> 中跟踪网络端点的一种简单而直接的方法。随着 <code>Kubernetes</code> 集群和服务逐渐开始为更多的后端 <code>Pod</code> 处理和发送请求， 原来的 <code>API</code> 的局限性变得越来越明显。最明显的是那些因为要处理大量网络端点而带来的挑战。</p>
<p>由于任一 <code>Service</code> 的所有网络端点都保存在同一个 <code>Endpoints</code> 对象中，这些 <code>Endpoints</code> 对象可能变得非常巨大。对于保持稳定的服务（长时间使用同一组端点），影响不太明显； 即便如此，<code>Kubernetes</code> 的一些使用场景也没有得到很好的服务。</p>
<p>当某 <code>Service</code>存在很多后端端点并且该工作负载频繁扩缩或上线新更改时，对该 <code>Service</code> 的单个 <code>Endpoints</code> 对象的每次更新都意味着（在控制平面内以及在节点和 API 服务器之间）<code>Kubernetes</code> 集群组件之间会出现大量流量。 这种额外的流量在 <code>CPU</code> 使用方面也有开销。</p>
<p>使用 <code>EndpointSlices</code> 时，添加或移除单个 <code>Pod</code> 对于正监视变更的客户端会触发相同数量的更新， 但这些更新消息的大小在大规模场景下要小得多。</p>
<p><code>EndpointSlices</code> 还支持围绕双栈网络和拓扑感知路由等新功能的创新。</p>
<hr>
<p>可以使用下面的<code>yaml</code>文件创建<code>Service</code>观察对应的<code>EndpointSlice</code>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; ep.yaml &lt;&lt;EOF</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: ep</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: ep</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: ep</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: ep</span><br><span class="line">          image: hysyeah/my-curl:v1</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 80</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: ep</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: ep</span><br><span class="line">  ports:</span><br><span class="line">    - name: http</span><br><span class="line">      port: 8080</span><br><span class="line">      targetPort: 8080</span><br><span class="line">  type: NodePort</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes git:(master) k get svc --show-labels</span><br><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE    LABELS</span><br><span class="line">ep           NodePort    10.96.112.72     &lt;none&gt;        8080:30143/TCP   23h    &lt;none&gt;</span><br><span class="line">➜  kubernetes git:(master) k get endpointslice --show-labels</span><br><span class="line">NAME           ADDRESSTYPE   PORTS     ENDPOINTS        AGE    LABELS</span><br><span class="line">ep-rsnnk       IPv4          8080      10.244.0.183     23h    endpointslice.kubernetes.io/managed-by=endpointslice-controller.k8s.io,kubernetes.io/service-name=ep</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/api/discovery/v1/types.go</span></span><br><span class="line"><span class="comment">// EndpointSlice represents a subset of the endpoints that implement a service.</span></span><br><span class="line"><span class="comment">// For a given service there may be multiple EndpointSlice objects, selected by</span></span><br><span class="line"><span class="comment">// labels, which must be joined to produce the full set of endpoints.</span></span><br><span class="line"><span class="comment">// EndpointSlice表示实现服务的一部分端点。对于给定的服务，可能会有多个EndpointSlice对象，</span></span><br><span class="line"><span class="comment">// 通过标签进行选择，必须将它们合并以产生完整的端点集。</span></span><br><span class="line"><span class="keyword">type</span> EndpointSlice <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Standard object's metadata.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	metav1.ObjectMeta <span class="string">`json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// addressType specifies the type of address carried by this EndpointSlice.</span></span><br><span class="line">	<span class="comment">// All addresses in this slice must be the same type. This field is</span></span><br><span class="line">	<span class="comment">// immutable after creation. The following address types are currently</span></span><br><span class="line">	<span class="comment">// supported:</span></span><br><span class="line">	<span class="comment">// * IPv4: Represents an IPv4 Address.</span></span><br><span class="line">	<span class="comment">// * IPv6: Represents an IPv6 Address.</span></span><br><span class="line">	<span class="comment">// * FQDN: Represents a Fully Qualified Domain Name.</span></span><br><span class="line">	AddressType AddressType <span class="string">`json:"addressType" protobuf:"bytes,4,rep,name=addressType"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// endpoints is a list of unique endpoints in this slice. Each slice may</span></span><br><span class="line">	<span class="comment">// include a maximum of 1000 endpoints.</span></span><br><span class="line">	<span class="comment">// +listType=atomic</span></span><br><span class="line">	Endpoints []Endpoint <span class="string">`json:"endpoints" protobuf:"bytes,2,rep,name=endpoints"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ports specifies the list of network ports exposed by each endpoint in</span></span><br><span class="line">	<span class="comment">// this slice. Each port must have a unique name. When ports is empty, it</span></span><br><span class="line">	<span class="comment">// indicates that there are no defined ports. When a port is defined with a</span></span><br><span class="line">	<span class="comment">// nil port value, it indicates "all ports". Each slice may include a</span></span><br><span class="line">	<span class="comment">// maximum of 100 ports.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	<span class="comment">// +listType=atomic</span></span><br><span class="line">	Ports []EndpointPort <span class="string">`json:"ports" protobuf:"bytes,3,rep,name=ports"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/controller/endpointslice/endpointslice_controller.go</span></span><br><span class="line"><span class="comment">// 与endpoint_controller有一点区别，endpointslice监听了node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	serviceInformer coreinformers.ServiceInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodeInformer coreinformers.NodeInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	endpointSliceInformer discoveryinformers.EndpointSliceInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	maxEndpointsPerSlice <span class="keyword">int32</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	client clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	endpointUpdatesBatchPeriod time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">	broadcaster := record.NewBroadcaster()</span><br><span class="line">	recorder := broadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"endpoint-slice-controller"</span>&#125;)</span><br><span class="line"></span><br><span class="line">	endpointslicemetrics.RegisterMetrics()</span><br><span class="line"></span><br><span class="line">	c := &amp;Controller&#123;</span><br><span class="line">		client: client,</span><br><span class="line">		<span class="comment">// This is similar to the DefaultControllerRateLimiter, just with a</span></span><br><span class="line">		<span class="comment">// significantly higher default backoff (1s vs 5ms). This controller</span></span><br><span class="line">		<span class="comment">// processes events that can require significant EndpointSlice changes,</span></span><br><span class="line">		<span class="comment">// such as an update to a Service or Deployment. A more significant</span></span><br><span class="line">		<span class="comment">// rate limit back off here helps ensure that the Controller does not</span></span><br><span class="line">		<span class="comment">// overwhelm the API Server.</span></span><br><span class="line">		queue: workqueue.NewNamedRateLimitingQueue(workqueue.NewMaxOfRateLimiter(</span><br><span class="line">			workqueue.NewItemExponentialFailureRateLimiter(defaultSyncBackOff, maxSyncBackOff),</span><br><span class="line">			<span class="comment">// 10 qps, 100 bucket size. This is only for retry speed and its</span></span><br><span class="line">			<span class="comment">// only the overall factor (not per item).</span></span><br><span class="line">			&amp;workqueue.BucketRateLimiter&#123;Limiter: rate.NewLimiter(rate.Limit(<span class="number">10</span>), <span class="number">100</span>)&#125;,</span><br><span class="line">		), <span class="string">"endpoint_slice"</span>),</span><br><span class="line">		workerLoopPeriod: time.Second,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	serviceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: c.onServiceUpdate,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			c.onServiceUpdate(cur)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: c.onServiceDelete,</span><br><span class="line">	&#125;)</span><br><span class="line">	c.serviceLister = serviceInformer.Lister()</span><br><span class="line">	c.servicesSynced = serviceInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc:    c.addPod,</span><br><span class="line">		UpdateFunc: c.updatePod,</span><br><span class="line">		DeleteFunc: c.deletePod,</span><br><span class="line">	&#125;)</span><br><span class="line">	c.podLister = podInformer.Lister()</span><br><span class="line">	c.podsSynced = podInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	c.nodeLister = nodeInformer.Lister()</span><br><span class="line">	c.nodesSynced = nodeInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	endpointSliceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc:    c.onEndpointSliceAdd,</span><br><span class="line">		UpdateFunc: c.onEndpointSliceUpdate,</span><br><span class="line">		DeleteFunc: c.onEndpointSliceDelete,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	c.endpointSliceLister = endpointSliceInformer.Lister()</span><br><span class="line">	c.endpointSlicesSynced = endpointSliceInformer.Informer().HasSynced</span><br><span class="line">	c.endpointSliceTracker = endpointsliceutil.NewEndpointSliceTracker()</span><br><span class="line"></span><br><span class="line">	c.maxEndpointsPerSlice = maxEndpointsPerSlice</span><br><span class="line"></span><br><span class="line">	c.triggerTimeTracker = endpointutil.NewTriggerTimeTracker()</span><br><span class="line"></span><br><span class="line">	c.eventBroadcaster = broadcaster</span><br><span class="line">	c.eventRecorder = recorder</span><br><span class="line"></span><br><span class="line">	c.endpointUpdatesBatchPeriod = endpointUpdatesBatchPeriod</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.TopologyAwareHints) &#123;</span><br><span class="line">		nodeInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc:    c.addNode,</span><br><span class="line">			UpdateFunc: c.updateNode,</span><br><span class="line">			DeleteFunc: c.deleteNode,</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		c.topologyCache = topologycache.NewTopologyCache()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.reconciler = &amp;reconciler&#123;</span><br><span class="line">		client:               c.client,</span><br><span class="line">		nodeLister:           c.nodeLister,</span><br><span class="line">		maxEndpointsPerSlice: c.maxEndpointsPerSlice,</span><br><span class="line">		endpointSliceTracker: c.endpointSliceTracker,</span><br><span class="line">		metricsCache:         endpointslicemetrics.NewCache(maxEndpointsPerSlice),</span><br><span class="line">		topologyCache:        c.topologyCache,</span><br><span class="line">		eventRecorder:        c.eventRecorder,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>syncService</code>是循环处理函数，从<code>workqueue</code>中取<code>key</code>然后进行处理</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/endpointslice/endpointslice_controller.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">syncService</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"Finished syncing service %q endpoint slices. (%v)"</span>, key, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	service, err := c.serviceLister.Services(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !apierrors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		c.triggerTimeTracker.DeleteService(namespace, name)</span><br><span class="line">		c.reconciler.deleteService(namespace, name)</span><br><span class="line">		c.endpointSliceTracker.DeleteService(namespace, name)</span><br><span class="line">		<span class="comment">// The service has been deleted, return nil so that it won't be retried.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> service.Spec.Type == v1.ServiceTypeExternalName &#123;</span><br><span class="line">		<span class="comment">// services with Type ExternalName receive no endpoints from this controller;</span></span><br><span class="line">		<span class="comment">// Ref: https://issues.k8s.io/105986</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> service.Spec.Selector == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// services without a selector receive no endpoint slices from this controller;</span></span><br><span class="line">		<span class="comment">// these services will receive endpoint slices that are created out-of-band via the REST API.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">5</span>).Infof(<span class="string">"About to update endpoint slices for service %q"</span>, key)</span><br><span class="line"></span><br><span class="line">	podLabelSelector := labels.Set(service.Spec.Selector).AsSelectorPreValidated()</span><br><span class="line">	pods, err := c.podLister.Pods(service.Namespace).List(podLabelSelector)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Since we're getting stuff from a local cache, it is basically</span></span><br><span class="line">		<span class="comment">// impossible to get this error.</span></span><br><span class="line">		c.eventRecorder.Eventf(service, v1.EventTypeWarning, <span class="string">"FailedToListPods"</span>,</span><br><span class="line">			<span class="string">"Error listing Pods for Service %s/%s: %v"</span>, service.Namespace, service.Name, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	esLabelSelector := labels.Set(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		discovery.LabelServiceName: service.Name,</span><br><span class="line">		discovery.LabelManagedBy:   controllerName,</span><br><span class="line">	&#125;).AsSelectorPreValidated()</span><br><span class="line">	endpointSlices, err := c.endpointSliceLister.EndpointSlices(service.Namespace).List(esLabelSelector)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Since we're getting stuff from a local cache, it is basically</span></span><br><span class="line">		<span class="comment">// impossible to get this error.</span></span><br><span class="line">		c.eventRecorder.Eventf(service, v1.EventTypeWarning, <span class="string">"FailedToListEndpointSlices"</span>,</span><br><span class="line">			<span class="string">"Error listing Endpoint Slices for Service %s/%s: %v"</span>, service.Namespace, service.Name, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Drop EndpointSlices that have been marked for deletion to prevent the controller from getting stuck.</span></span><br><span class="line">	endpointSlices = dropEndpointSlicesPendingDeletion(endpointSlices)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.endpointSliceTracker.StaleSlices(service, endpointSlices) &#123;</span><br><span class="line">		<span class="keyword">return</span> endpointsliceutil.NewStaleInformerCache(<span class="string">"EndpointSlice informer cache is out of date"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We call ComputeEndpointLastChangeTriggerTime here to make sure that the</span></span><br><span class="line">	<span class="comment">// state of the trigger time tracker gets updated even if the sync turns out</span></span><br><span class="line">	<span class="comment">// to be no-op and we don't update the EndpointSlice objects.</span></span><br><span class="line">	lastChangeTriggerTime := c.triggerTimeTracker.</span><br><span class="line">		ComputeEndpointLastChangeTriggerTime(namespace, service, pods)</span><br><span class="line"></span><br><span class="line">	err = c.reconciler.reconcile(service, pods, endpointSlices, lastChangeTriggerTime)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.eventRecorder.Eventf(service, v1.EventTypeWarning, <span class="string">"FailedToUpdateEndpointSlices"</span>,</span><br><span class="line">			<span class="string">"Error updating Endpoint Slices for Service %s/%s: %v"</span>, service.Namespace, service.Name, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reconcile takes a set of pods currently matching a service selector and</span></span><br><span class="line"><span class="comment">// compares them with the endpoints already present in any existing endpoint</span></span><br><span class="line"><span class="comment">// slices for the given service. It creates, updates, or deletes endpoint slices</span></span><br><span class="line"><span class="comment">// to ensure the desired set of pods are represented by endpoint slices.</span></span><br><span class="line"><span class="comment">// pkg/controller/endpointslice/reconciler.go</span></span><br><span class="line"><span class="comment">// 参数为service及匹配service selector的pods,已经存在的endpointslice</span></span><br><span class="line"><span class="comment">// 作用:创建，更新或删除endpointslice,确保endpointslice能匹配所有预期的pod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *reconciler)</span> <span class="title">reconcile</span><span class="params">(service *corev1.Service, pods []*corev1.Pod, existingSlices []*discovery.EndpointSlice, triggerTime time.Time)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	slicesToDelete := []*discovery.EndpointSlice&#123;&#125;                                    <span class="comment">// slices that are no longer  matching any address the service has</span></span><br><span class="line">	errs := []error&#123;&#125;                                                                 <span class="comment">// all errors generated in the process of reconciling</span></span><br><span class="line">	slicesByAddressType := <span class="built_in">make</span>(<span class="keyword">map</span>[discovery.AddressType][]*discovery.EndpointSlice) <span class="comment">// slices by address type</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// addresses that this service supports [o(1) find]</span></span><br><span class="line">    <span class="comment">// 获得server支持的AddressesTypes,serviceSupportedAddressesTypes是一个map实现的set</span></span><br><span class="line">    <span class="comment">// * IPv4: Represents an IPv4 Address.</span></span><br><span class="line">	<span class="comment">// * IPv6: Represents an IPv6 Address.</span></span><br><span class="line">	<span class="comment">// * FQDN: Represents a Fully Qualified Domain Name.</span></span><br><span class="line">	serviceSupportedAddressesTypes := getAddressTypesForService(service)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// loop through slices identifying their address type.</span></span><br><span class="line">	<span class="comment">// slices that no longer match address type supported by services</span></span><br><span class="line">	<span class="comment">// go to delete, other slices goes to the reconciler machinery</span></span><br><span class="line">	<span class="comment">// for further adjustment</span></span><br><span class="line">	<span class="keyword">for</span> _, existingSlice := <span class="keyword">range</span> existingSlices &#123;</span><br><span class="line">		<span class="comment">// service no longer supports that address type, add it to deleted slices</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := serviceSupportedAddressesTypes[existingSlice.AddressType]; !ok &#123;</span><br><span class="line">			<span class="keyword">if</span> r.topologyCache != <span class="literal">nil</span> &#123;</span><br><span class="line">				svcKey, err := serviceControllerKey(existingSlice)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					klog.Warningf(<span class="string">"Couldn't get key to remove EndpointSlice from topology cache %+v: %v"</span>, existingSlice, err)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					r.topologyCache.RemoveHints(svcKey, existingSlice.AddressType)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 如果是这个Service不支持的AddressType则加入删除列表</span></span><br><span class="line">			slicesToDelete = <span class="built_in">append</span>(slicesToDelete, existingSlice)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// add list if it is not on our map</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := slicesByAddressType[existingSlice.AddressType]; !ok &#123;</span><br><span class="line">			slicesByAddressType[existingSlice.AddressType] = <span class="built_in">make</span>([]*discovery.EndpointSlice, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		slicesByAddressType[existingSlice.AddressType] = <span class="built_in">append</span>(slicesByAddressType[existingSlice.AddressType], existingSlice)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// reconcile for existing.</span></span><br><span class="line">	<span class="keyword">for</span> addressType := <span class="keyword">range</span> serviceSupportedAddressesTypes &#123;</span><br><span class="line">		existingSlices := slicesByAddressType[addressType]</span><br><span class="line">        <span class="comment">// 对不同的AddressType进行调谐</span></span><br><span class="line">		err := r.reconcileByAddressType(service, pods, existingSlices, triggerTime, addressType)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// delete those which are of addressType that is no longer supported</span></span><br><span class="line">	<span class="comment">// by the service</span></span><br><span class="line">	<span class="keyword">for</span> _, sliceToDelete := <span class="keyword">range</span> slicesToDelete &#123;</span><br><span class="line">		err := r.client.DiscoveryV1().EndpointSlices(service.Namespace).Delete(context.TODO(), sliceToDelete.Name, metav1.DeleteOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs = <span class="built_in">append</span>(errs, fmt.Errorf(<span class="string">"error deleting %s EndpointSlice for Service %s/%s: %w"</span>, sliceToDelete.Name, service.Namespace, service.Name, err))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r.endpointSliceTracker.ExpectDeletion(sliceToDelete)</span><br><span class="line">			metrics.EndpointSliceChanges.WithLabelValues(<span class="string">"delete"</span>).Inc()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reconcileByAddressType takes a set of pods currently matching a service selector and</span></span><br><span class="line"><span class="comment">// compares them with the endpoints already present in any existing endpoint</span></span><br><span class="line"><span class="comment">// slices (by address type) for the given service. It creates, updates, or deletes endpoint slices</span></span><br><span class="line"><span class="comment">// to ensure the desired set of pods are represented by endpoint slices.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *reconciler)</span> <span class="title">reconcileByAddressType</span><span class="params">(service *corev1.Service, pods []*corev1.Pod, existingSlices []*discovery.EndpointSlice, triggerTime time.Time, addressType discovery.AddressType)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	errs := []error&#123;&#125;</span><br><span class="line"></span><br><span class="line">	slicesToCreate := []*discovery.EndpointSlice&#123;&#125;</span><br><span class="line">	slicesToUpdate := []*discovery.EndpointSlice&#123;&#125;</span><br><span class="line">	slicesToDelete := []*discovery.EndpointSlice&#123;&#125;</span><br><span class="line">	events := []*topologycache.EventBuilder&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build data structures for existing state.</span></span><br><span class="line">	existingSlicesByPortMap := <span class="keyword">map</span>[endpointutil.PortMapKey][]*discovery.EndpointSlice&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, existingSlice := <span class="keyword">range</span> existingSlices &#123;</span><br><span class="line">		<span class="keyword">if</span> ownedBy(existingSlice, service) &#123;</span><br><span class="line">			epHash := endpointutil.NewPortMapKey(existingSlice.Ports)</span><br><span class="line">			existingSlicesByPortMap[epHash] = <span class="built_in">append</span>(existingSlicesByPortMap[epHash], existingSlice)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			slicesToDelete = <span class="built_in">append</span>(slicesToDelete, existingSlice)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build data structures for desired state.</span></span><br><span class="line">	desiredMetaByPortMap := <span class="keyword">map</span>[endpointutil.PortMapKey]*endpointMeta&#123;&#125;</span><br><span class="line">	desiredEndpointsByPortMap := <span class="keyword">map</span>[endpointutil.PortMapKey]endpointsliceutil.EndpointSet&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="keyword">if</span> !endpointutil.ShouldPodBeInEndpoints(pod, <span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		endpointPorts := getEndpointPorts(service, pod)</span><br><span class="line">		epHash := endpointutil.NewPortMapKey(endpointPorts)</span><br><span class="line">		<span class="keyword">if</span> _, ok := desiredEndpointsByPortMap[epHash]; !ok &#123;</span><br><span class="line">			desiredEndpointsByPortMap[epHash] = endpointsliceutil.EndpointSet&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> _, ok := desiredMetaByPortMap[epHash]; !ok &#123;</span><br><span class="line">			desiredMetaByPortMap[epHash] = &amp;endpointMeta&#123;</span><br><span class="line">				addressType: addressType,</span><br><span class="line">				ports:       endpointPorts,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		node, err := r.nodeLister.Get(pod.Spec.NodeName)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// we are getting the information from the local informer,</span></span><br><span class="line">			<span class="comment">// an error different than IsNotFound should not happen</span></span><br><span class="line">			<span class="keyword">if</span> !errors.IsNotFound(err) &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// If the Node specified by the Pod doesn't exist we want to requeue the Service so we</span></span><br><span class="line">			<span class="comment">// retry later, but also update the EndpointSlice without the problematic Pod.</span></span><br><span class="line">			<span class="comment">// Theoretically, the pod Garbage Collector will remove the Pod, but we want to avoid</span></span><br><span class="line">			<span class="comment">// situations where a reference from a Pod to a missing node can leave the EndpointSlice</span></span><br><span class="line">			<span class="comment">// stuck forever.</span></span><br><span class="line">			<span class="comment">// On the other side, if the service.Spec.PublishNotReadyAddresses is set we just add the</span></span><br><span class="line">			<span class="comment">// Pod, since the user is explicitly indicating that the Pod address should be published.</span></span><br><span class="line">			<span class="keyword">if</span> !service.Spec.PublishNotReadyAddresses &#123;</span><br><span class="line">				klog.Warningf(<span class="string">"skipping Pod %s for Service %s/%s: Node %s Not Found"</span>, pod.Name, service.Namespace, service.Name, pod.Spec.NodeName)</span><br><span class="line">				errs = <span class="built_in">append</span>(errs, fmt.Errorf(<span class="string">"skipping Pod %s for Service %s/%s: Node %s Not Found"</span>, pod.Name, service.Namespace, service.Name, pod.Spec.NodeName))</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		endpoint := podToEndpoint(pod, node, service, addressType)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(endpoint.Addresses) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			desiredEndpointsByPortMap[epHash].Insert(&amp;endpoint)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spMetrics := metrics.NewServicePortCache()</span><br><span class="line">	totalAdded := <span class="number">0</span></span><br><span class="line">	totalRemoved := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Determine changes necessary for each group of slices by port map.</span></span><br><span class="line">	<span class="keyword">for</span> portMap, desiredEndpoints := <span class="keyword">range</span> desiredEndpointsByPortMap &#123;</span><br><span class="line">		numEndpoints := <span class="built_in">len</span>(desiredEndpoints)</span><br><span class="line">		pmSlicesToCreate, pmSlicesToUpdate, pmSlicesToDelete, added, removed := r.reconcileByPortMapping(</span><br><span class="line">			service, existingSlicesByPortMap[portMap], desiredEndpoints, desiredMetaByPortMap[portMap])</span><br><span class="line"></span><br><span class="line">		totalAdded += added</span><br><span class="line">		totalRemoved += removed</span><br><span class="line"></span><br><span class="line">		spMetrics.Set(portMap, metrics.EfficiencyInfo&#123;</span><br><span class="line">			Endpoints: numEndpoints,</span><br><span class="line">			Slices:    <span class="built_in">len</span>(existingSlicesByPortMap[portMap]) + <span class="built_in">len</span>(pmSlicesToCreate) - <span class="built_in">len</span>(pmSlicesToDelete),</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		slicesToCreate = <span class="built_in">append</span>(slicesToCreate, pmSlicesToCreate...)</span><br><span class="line">		slicesToUpdate = <span class="built_in">append</span>(slicesToUpdate, pmSlicesToUpdate...)</span><br><span class="line">		slicesToDelete = <span class="built_in">append</span>(slicesToDelete, pmSlicesToDelete...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If there are unique sets of ports that are no longer desired, mark</span></span><br><span class="line">	<span class="comment">// the corresponding endpoint slices for deletion.</span></span><br><span class="line">	<span class="keyword">for</span> portMap, existingSlices := <span class="keyword">range</span> existingSlicesByPortMap &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := desiredEndpointsByPortMap[portMap]; !ok &#123;</span><br><span class="line">			slicesToDelete = <span class="built_in">append</span>(slicesToDelete, existingSlices...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When no endpoint slices would usually exist, we need to add a placeholder.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(existingSlices) == <span class="built_in">len</span>(slicesToDelete) &amp;&amp; <span class="built_in">len</span>(slicesToCreate) &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// Check for existing placeholder slice outside of the core control flow</span></span><br><span class="line">		placeholderSlice := newEndpointSlice(service, &amp;endpointMeta&#123;ports: []discovery.EndpointPort&#123;&#125;, addressType: addressType&#125;)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(slicesToDelete) == <span class="number">1</span> &amp;&amp; placeholderSliceCompare.DeepEqual(slicesToDelete[<span class="number">0</span>], placeholderSlice) &#123;</span><br><span class="line">			<span class="comment">// We are about to unnecessarily delete/recreate the placeholder, remove it now.</span></span><br><span class="line">			slicesToDelete = slicesToDelete[:<span class="number">0</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			slicesToCreate = <span class="built_in">append</span>(slicesToCreate, placeholderSlice)</span><br><span class="line">		&#125;</span><br><span class="line">		spMetrics.Set(endpointutil.NewPortMapKey(placeholderSlice.Ports), metrics.EfficiencyInfo&#123;</span><br><span class="line">			Endpoints: <span class="number">0</span>,</span><br><span class="line">			Slices:    <span class="number">1</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	metrics.EndpointsAddedPerSync.WithLabelValues().Observe(<span class="keyword">float64</span>(totalAdded))</span><br><span class="line">	metrics.EndpointsRemovedPerSync.WithLabelValues().Observe(<span class="keyword">float64</span>(totalRemoved))</span><br><span class="line"></span><br><span class="line">	serviceNN := types.NamespacedName&#123;Name: service.Name, Namespace: service.Namespace&#125;</span><br><span class="line">	r.metricsCache.UpdateServicePortCache(serviceNN, spMetrics)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Topology hints are assigned per address type. This means it is</span></span><br><span class="line">	<span class="comment">// theoretically possible for endpoints of one address type to be assigned</span></span><br><span class="line">	<span class="comment">// hints while another endpoints of another address type are not.</span></span><br><span class="line">	si := &amp;topologycache.SliceInfo&#123;</span><br><span class="line">		ServiceKey:  fmt.Sprintf(<span class="string">"%s/%s"</span>, service.Namespace, service.Name),</span><br><span class="line">		AddressType: addressType,</span><br><span class="line">		ToCreate:    slicesToCreate,</span><br><span class="line">		ToUpdate:    slicesToUpdate,</span><br><span class="line">		Unchanged:   unchangedSlices(existingSlices, slicesToUpdate, slicesToDelete),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> r.topologyCache != <span class="literal">nil</span> &amp;&amp; hintsEnabled(service.Annotations) &#123;</span><br><span class="line">		slicesToCreate, slicesToUpdate, events = r.topologyCache.AddHints(si)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.topologyCache != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> r.topologyCache.HasPopulatedHints(si.ServiceKey) &#123;</span><br><span class="line">				klog.InfoS(<span class="string">"TopologyAwareHints annotation has changed, removing hints"</span>, <span class="string">"serviceKey"</span>, si.ServiceKey, <span class="string">"addressType"</span>, si.AddressType)</span><br><span class="line">				events = <span class="built_in">append</span>(events, &amp;topologycache.EventBuilder&#123;</span><br><span class="line">					EventType: corev1.EventTypeWarning,</span><br><span class="line">					Reason:    <span class="string">"TopologyAwareHintsDisabled"</span>,</span><br><span class="line">					Message:   topologycache.FormatWithAddressType(topologycache.TopologyAwareHintsDisabled, si.AddressType),</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			r.topologyCache.RemoveHints(si.ServiceKey, addressType)</span><br><span class="line">		&#125;</span><br><span class="line">		slicesToCreate, slicesToUpdate = topologycache.RemoveHintsFromSlices(si)</span><br><span class="line">	&#125;</span><br><span class="line">	err := r.finalize(service, slicesToCreate, slicesToUpdate, slicesToDelete, triggerTime)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, event := <span class="keyword">range</span> events &#123;</span><br><span class="line">		r.eventRecorder.Event(service, event.EventType, event.Reason, event.Message)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>为了管理服务的<code>EndpointSlices</code>分发，<code>Kubernetes</code>维护了一个名为<code>TopologyCache</code>的<code>EndpointSlices</code>缓存。<code>TopologyCache</code>跟踪服务所有<code>EndpointSlices</code>的状态，并允许<code>Kubernetes</code>快速、高效地将流量路由到适当的端点。</p>
<p><code>TopologyCache</code>是由服务控制器提供的端点拓扑信息构建的。控制器根据标签和选择器确定服务端点的拓扑，并生成一组基于拓扑信息的<code>EndpointSlices</code>，并使用新的<code>EndpointSlices</code>更新<code>TopologyCache</code>。</p>
<hr>
<p>REF:<br>1.<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之namespace</title>
    <url>/2023/05/11/kube-controller%E4%B9%8Bnamespace/</url>
    <content><![CDATA[<p><code>Kubernetes Namespace Controller</code>是<code>Kubernetes</code>中的一个控制器，负责管理<code>Kubernetes</code>中的命名空间。命名空间是<code>Kubernetes</code>资源的一个逻辑分组，用于将资源隔离在不同的命名空间中，从而实现更好的资源管理和隔离。</p>
<p><code>Namespace Controller</code>主要负责以下任务：<br>在删除命名空间时，确保所有在该命名空间中创建的资源都被正确地清理和回收。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动函数</span></span><br><span class="line"><span class="comment">// cmd/kube-controller-manager/app/core.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNamespaceController</span><span class="params">(ctx context.Context, controllerContext ControllerContext)</span> <span class="params">(controller.Interface, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// the namespace cleanup controller is very chatty.  It makes lots of discovery calls and then it makes lots of delete calls</span></span><br><span class="line">	<span class="comment">// the ratelimiter negatively affects its speed.  Deleting 100 total items in a namespace (that's only a few of each resource</span></span><br><span class="line">	<span class="comment">// including events), takes ~10 seconds by default.</span></span><br><span class="line">	nsKubeconfig := controllerContext.ClientBuilder.ConfigOrDie(<span class="string">"namespace-controller"</span>)</span><br><span class="line">	nsKubeconfig.QPS *= <span class="number">20</span></span><br><span class="line">	nsKubeconfig.Burst *= <span class="number">100</span></span><br><span class="line">	namespaceKubeClient := clientset.NewForConfigOrDie(nsKubeconfig)</span><br><span class="line">	<span class="keyword">return</span> startModifiedNamespaceController(ctx, controllerContext, namespaceKubeClient, nsKubeconfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startModifiedNamespaceController</span><span class="params">(ctx context.Context, controllerContext ControllerContext, namespaceKubeClient clientset.Interface, nsKubeconfig *restclient.Config)</span> <span class="params">(controller.Interface, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	metadataClient, err := metadata.NewForConfig(nsKubeconfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	discoverResourcesFn := namespaceKubeClient.Discovery().ServerPreferredNamespacedResources</span><br><span class="line"></span><br><span class="line">	namespaceController := namespacecontroller.NewNamespaceController(</span><br><span class="line">		ctx,</span><br><span class="line">		namespaceKubeClient,</span><br><span class="line">		metadataClient,</span><br><span class="line">		discoverResourcesFn,</span><br><span class="line">		controllerContext.InformerFactory.Core().V1().Namespaces(),</span><br><span class="line">		controllerContext.ComponentConfig.NamespaceController.NamespaceSyncPeriod.Duration,</span><br><span class="line">		v1.FinalizerKubernetes,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">go</span> namespaceController.Run(ctx, <span class="keyword">int</span>(controllerContext.ComponentConfig.NamespaceController.ConcurrentNamespaceSyncs))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/namespace/namespace_controller.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// namespaceDeletionGracePeriod is the time period to wait before processing a received namespace event.</span></span><br><span class="line">	<span class="comment">// This allows time for the following to occur:</span></span><br><span class="line">	<span class="comment">// * lifecycle admission plugins on HA apiservers to also observe a namespace</span></span><br><span class="line">	<span class="comment">//   deletion and prevent new objects from being created in the terminating namespace</span></span><br><span class="line">	<span class="comment">// * non-leader etcd servers to observe last-minute object creations in a namespace</span></span><br><span class="line">	<span class="comment">//   so this controller's cleanup can actually clean up all objects</span></span><br><span class="line">    <span class="comment">// 延迟入队时间</span></span><br><span class="line">	namespaceDeletionGracePeriod = <span class="number">5</span> * time.Second</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NamespaceController is responsible for performing actions dependent upon a namespace phase</span></span><br><span class="line"><span class="keyword">type</span> NamespaceController <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// lister that can list namespaces from a shared cache</span></span><br><span class="line">	lister corelisters.NamespaceLister</span><br><span class="line">	<span class="comment">// returns true when the namespace cache is ready</span></span><br><span class="line">	listerSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// namespaces that have been queued up for processing by workers</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line">	<span class="comment">// helper to delete all resources in the namespace when the namespace is deleted.</span></span><br><span class="line">	namespacedResourcesDeleter deletion.NamespacedResourcesDeleterInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamespaceController creates a new NamespaceController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamespaceController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">	kubeClient clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	metadataClient metadata.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	discoverResourcesFn <span class="keyword">func</span>()</span> <span class="params">([]*metav1.APIResourceList, error)</span>,</span></span><br><span class="line">	namespaceInformer coreinformers.NamespaceInformer,</span><br><span class="line">	resyncPeriod time.Duration,</span><br><span class="line">	finalizerToken v1.FinalizerName) *NamespaceController &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create the controller so we can inject the enqueue function</span></span><br><span class="line">	namespaceController := &amp;NamespaceController&#123;</span><br><span class="line">		queue:                      workqueue.NewNamedRateLimitingQueue(nsControllerRateLimiter(), <span class="string">"namespace"</span>),</span><br><span class="line">		namespacedResourcesDeleter: deletion.NewNamespacedResourcesDeleter(ctx, kubeClient.CoreV1().Namespaces(), metadataClient, kubeClient.CoreV1(), discoverResourcesFn, finalizerToken),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// configure the namespace informer event handlers</span></span><br><span class="line">	namespaceInformer.Informer().AddEventHandlerWithResyncPeriod(</span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">				namespace := obj.(*v1.Namespace)</span><br><span class="line">				namespaceController.enqueueNamespace(namespace)</span><br><span class="line">			&#125;,</span><br><span class="line">			UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">				namespace := newObj.(*v1.Namespace)</span><br><span class="line">				namespaceController.enqueueNamespace(namespace)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		resyncPeriod,</span><br><span class="line">	)</span><br><span class="line">	namespaceController.lister = namespaceInformer.Lister()</span><br><span class="line">	namespaceController.listerSynced = namespaceInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> namespaceController</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">enqueueNamespace</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	key, err := controller.KeyFunc(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Couldn't get key for object %+v: %v"</span>, obj, err))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	namespace := obj.(*v1.Namespace)</span><br><span class="line">	<span class="comment">// don't queue if we aren't deleted</span></span><br><span class="line">    <span class="comment">// !! 只有删除操作才会入队，所以说NamespaceController只处理删除操作</span></span><br><span class="line">	<span class="keyword">if</span> namespace.DeletionTimestamp == <span class="literal">nil</span> || namespace.DeletionTimestamp.IsZero() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// delay processing namespace events to allow HA api servers to observe namespace deletion,</span></span><br><span class="line">	<span class="comment">// and HA etcd servers to observe last minute object creations inside the namespace</span></span><br><span class="line">	nm.queue.AddAfter(key, namespaceDeletionGracePeriod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> nm.queue.ShutDown()</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.Info(<span class="string">"Starting namespace controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> logger.Info(<span class="string">"Shutting down namespace controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"namespace"</span>, ctx.Done(), nm.listerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.V(<span class="number">5</span>).Info(<span class="string">"Starting workers of namespace controller"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, nm.worker, time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// workFunc 返回值是一个bool, 表明有队列是否被关闭</span></span><br><span class="line">	workFunc := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="comment">// 从队列中获取一个key, 如果队列已经关闭，直接退出</span></span><br><span class="line">		key, quit := nm.queue.Get()</span><br><span class="line">		<span class="keyword">if</span> quit &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> nm.queue.Done(key)</span><br><span class="line"></span><br><span class="line">		err := nm.syncNamespaceFromKey(ctx, key.(<span class="keyword">string</span>))</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// no error, forget this entry and return</span></span><br><span class="line">			nm.queue.Forget(key)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ok=true,表明资源未完全清除完</span></span><br><span class="line">        <span class="comment">// 这里会有一个延迟入队,等待资源被清除</span></span><br><span class="line">		<span class="keyword">if</span> estimate, ok := err.(*deletion.ResourcesRemainingError); ok &#123;</span><br><span class="line">			t := estimate.Estimate/<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">			klog.FromContext(ctx).V(<span class="number">4</span>).Info(<span class="string">"Content remaining in namespace"</span>, <span class="string">"namespace"</span>, key, <span class="string">"waitSeconds"</span>, t)</span><br><span class="line">			nm.queue.AddAfter(key, time.Duration(t)*time.Second)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// rather than wait for a full resync, re-add the namespace to the queue to be processed</span></span><br><span class="line">            <span class="comment">// 其它错误，直接重新入队</span></span><br><span class="line">			nm.queue.AddRateLimited(key)</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"deletion of namespace %v failed: %v"</span>, key, err))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		quit := workFunc(ctx)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 队列已关闭</span></span><br><span class="line">		<span class="keyword">if</span> quit &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syncNamespaceFromKey looks for a namespace with the specified key in its store and synchronizes it</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">syncNamespaceFromKey</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		logger.V(<span class="number">4</span>).Info(<span class="string">"Finished syncing namespace"</span>, <span class="string">"namespace"</span>, key, <span class="string">"duration"</span>, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	namespace, err := nm.lister.Get(key)</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		logger.Info(<span class="string">"Namespace has been deleted"</span>, <span class="string">"namespace"</span>, key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"Unable to retrieve namespace %v from store: %v"</span>, key, err))</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nm.namespacedResourcesDeleter.Delete(ctx, namespace.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/namespace/deletion/namespaced_resources_deleter.go</span></span><br><span class="line"><span class="comment">// Delete deletes all resources in the given namespace.</span></span><br><span class="line"><span class="comment">// Before deleting resources:</span></span><br><span class="line"><span class="comment">//   - It ensures that deletion timestamp is set on the</span></span><br><span class="line"><span class="comment">//     namespace (does nothing if deletion timestamp is missing).</span></span><br><span class="line"><span class="comment">//   - Verifies that the namespace is in the "terminating" phase</span></span><br><span class="line"><span class="comment">//     (updates the namespace phase if it is not yet marked terminating)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// After deleting the resources:</span></span><br><span class="line"><span class="comment">// * It removes finalizer token from the given namespace.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns an error if any of those steps fail.</span></span><br><span class="line"><span class="comment">// Returns ResourcesRemainingError if it deleted some resources but needs</span></span><br><span class="line"><span class="comment">// to wait for them to go away.</span></span><br><span class="line"><span class="comment">// Caller is expected to keep calling this until it succeeds.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *namespacedResourcesDeleter)</span> <span class="title">Delete</span><span class="params">(ctx context.Context, nsName <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Multiple controllers may edit a namespace during termination</span></span><br><span class="line">	<span class="comment">// first get the latest state of the namespace before proceeding</span></span><br><span class="line">	<span class="comment">// if the namespace was deleted already, don't do anything</span></span><br><span class="line">	namespace, err := d.nsClient.Get(context.TODO(), nsName, metav1.GetOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> namespace.DeletionTimestamp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.FromContext(ctx).V(<span class="number">5</span>).Info(<span class="string">"Namespace controller - syncNamespace"</span>, <span class="string">"namespace"</span>, namespace.Name, <span class="string">"finalizerToken"</span>, d.finalizerToken)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ensure that the status is up to date on the namespace</span></span><br><span class="line">	<span class="comment">// if we get a not found error, we assume the namespace is truly gone</span></span><br><span class="line">	namespace, err = d.retryOnConflictError(namespace, d.updateNamespaceStatusFunc)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the latest view of the namespace asserts that namespace is no longer deleting..</span></span><br><span class="line">	<span class="keyword">if</span> namespace.DeletionTimestamp.IsZero() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return if it is already finalized.</span></span><br><span class="line">    <span class="comment">// 如果len(Spec.Finalizers)==0, return</span></span><br><span class="line">	<span class="keyword">if</span> finalized(namespace) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// there may still be content for us to remove</span></span><br><span class="line">	estimate, err := d.deleteAllContent(ctx, namespace)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有资源未删除</span></span><br><span class="line">	<span class="keyword">if</span> estimate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;ResourcesRemainingError&#123;estimate&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we have removed content, so mark it finalized by us</span></span><br><span class="line">	_, err = d.retryOnConflictError(namespace, d.finalizeNamespace)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// in normal practice, this should not be possible, but if a deployment is running</span></span><br><span class="line">		<span class="comment">// two controllers to do namespace deletion that share a common finalizer token it's</span></span><br><span class="line">		<span class="comment">// possible that a not found could occur since the other controller would have finished the delete.</span></span><br><span class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用dynamic client删除命名空间下的所有资源</span></span><br><span class="line"><span class="comment">// 返回一个时间(估计资源删除需要的时间)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *namespacedResourcesDeleter)</span> <span class="title">deleteAllContent</span><span class="params">(ctx context.Context, ns *v1.Namespace)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	namespace := ns.Name</span><br><span class="line">	namespaceDeletedAt := *ns.DeletionTimestamp</span><br><span class="line">	<span class="keyword">var</span> errs []error</span><br><span class="line">	conditionUpdater := namespaceConditionUpdater&#123;&#125;</span><br><span class="line">	estimate := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"namespace controller - deleteAllContent"</span>, <span class="string">"namespace"</span>, namespace)</span><br><span class="line"></span><br><span class="line">	resources, err := d.discoverResourcesFn()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// discovery errors are not fatal.  We often have some set of resources we can operate against even if we don't have a complete list</span></span><br><span class="line">		errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">		conditionUpdater.ProcessDiscoverResourcesErr(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// TODO(sttts): get rid of opCache and pass the verbs (especially "deletecollection") down into the deleter</span></span><br><span class="line">	deletableResources := discovery.FilteredBy(discovery.SupportsAllVerbs&#123;Verbs: []<span class="keyword">string</span>&#123;<span class="string">"delete"</span>&#125;&#125;, resources)</span><br><span class="line">	groupVersionResources, err := discovery.GroupVersionResources(deletableResources)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// discovery errors are not fatal.  We often have some set of resources we can operate against even if we don't have a complete list</span></span><br><span class="line">		errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">		conditionUpdater.ProcessGroupVersionErr(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	numRemainingTotals := allGVRDeletionMetadata&#123;</span><br><span class="line">		gvrToNumRemaining:        <span class="keyword">map</span>[schema.GroupVersionResource]<span class="keyword">int</span>&#123;&#125;,</span><br><span class="line">		finalizersToNumRemaining: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> gvr := <span class="keyword">range</span> groupVersionResources &#123;</span><br><span class="line">		gvrDeletionMetadata, err := d.deleteAllContentForGroupVersionResource(ctx, gvr, namespace, namespaceDeletedAt)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// If there is an error, hold on to it but proceed with all the remaining</span></span><br><span class="line">			<span class="comment">// groupVersionResources.</span></span><br><span class="line">			errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">			conditionUpdater.ProcessDeleteContentErr(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> gvrDeletionMetadata.finalizerEstimateSeconds &gt; estimate &#123;</span><br><span class="line">			estimate = gvrDeletionMetadata.finalizerEstimateSeconds</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> gvrDeletionMetadata.numRemaining &gt; <span class="number">0</span> &#123;</span><br><span class="line">			numRemainingTotals.gvrToNumRemaining[gvr] = gvrDeletionMetadata.numRemaining</span><br><span class="line">			<span class="keyword">for</span> finalizer, numRemaining := <span class="keyword">range</span> gvrDeletionMetadata.finalizersToNumRemaining &#123;</span><br><span class="line">				<span class="keyword">if</span> numRemaining == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				numRemainingTotals.finalizersToNumRemaining[finalizer] = numRemainingTotals.finalizersToNumRemaining[finalizer] + numRemaining</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	conditionUpdater.ProcessContentTotals(numRemainingTotals)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we always want to update the conditions because if we have set a condition to "it worked" after it was previously, "it didn't work",</span></span><br><span class="line">	<span class="comment">// we need to reflect that information.  Recall that additional finalizers can be set on namespaces, so this finalizer may clear itself and</span></span><br><span class="line">	<span class="comment">// NOT remove the resource instance.</span></span><br><span class="line">	<span class="keyword">if</span> hasChanged := conditionUpdater.Update(ns); hasChanged &#123;</span><br><span class="line">		<span class="keyword">if</span> _, err = d.nsClient.UpdateStatus(context.TODO(), ns, metav1.UpdateOptions&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"couldn't update status condition for namespace %q: %v"</span>, namespace, err))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if len(errs)==0, NewAggregate returns nil.</span></span><br><span class="line">	err = utilerrors.NewAggregate(errs)</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"namespace controller - deleteAllContent"</span>, <span class="string">"namespace"</span>, namespace, <span class="string">"estimate"</span>, estimate, <span class="string">"err"</span>, err)</span><br><span class="line">	<span class="keyword">return</span> estimate, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br><code>NamespaceController</code>相对比较简单，只有一个删除的调谐操作。</p>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/cmd/kube-controller-manager/app/core.go" target="_blank" rel="noopener">cmd/kube-controller-manager/app/core.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/namespace/namespace_controller.go" target="_blank" rel="noopener">pkg/controller/namespace/namespace_controller.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/namespace/deletion/namespaced_resources_deleter.go" target="_blank" rel="noopener">pkg/controller/namespace/deletion/namespaced_resources_deleter.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之hpa</title>
    <url>/2023/06/14/kube-controller%E4%B9%8Bhpa/</url>
    <content><![CDATA[<h5 id="HPA"><a href="#HPA" class="headerlink" title="HPA"></a>HPA</h5><p><code>HPA</code>全称<code>HorizontalPodAutoscaler</code>,<code>pod</code>水平自动扩缩。在 <code>Kubernetes</code> 中，<code>HorizontalPodAutoscaler</code> 自动更新工作负载资源 （例如 <code>Deployment</code> 或者 <code>StatefulSet</code>）， 目的是自动扩缩工作负载以满足需求。</p>
<p>水平扩缩意味着对增加的负载的响应是部署更多的<code>Pod</code>。 这与 “垂直（Vertical）” 扩缩不同，对于 <code>Kubernetes</code>， 垂直扩缩意味着将更多资源（例如：内存或 CPU）分配给已经为工作负载运行的 <code>Pod</code>。</p>
<p>如果负载减少，并且 <code>Pod</code> 的数量高于配置的最小值， <code>HorizontalPodAutoscaler</code> 会指示工作负载资源（<code>Deployment</code>、<code>StatefulSet</code> 或其他类似资源）缩减。</p>
<p>水平 Pod 自动扩缩不适用于无法扩缩的对象（例如：<code>DaemonSet</code>。）</p>
<p><code>HorizontalPodAutoscaler</code> 被实现为 <code>Kubernetes API</code> 资源和控制器。</p>
<p>在 <code>Kubernetes</code> 控制平面内运行的水平 <code>Pod</code> 自动扩缩控制器会定期调整其目标（例如：<code>Deployment</code>）的所需规模，以匹配观察到的指标， 例如，平均 <code>CPU</code> 利用率、平均内存利用率或你指定的任何其他自定义指标。</p>
<p><code>HorizontalPodAutoscaler</code>从<code>Metrics Server</code>中获得对应的资源指标，然后根据这些指标计算扩缩容比例。<br><code>HorizontalPodAutoscaler</code> 控制器访问支持扩缩的相应工作负载资源（例如：Deployment,StatefulSet,ReplicaSet) 这些资源每个都有一个名为 scale 的子资源，该接口允许你动态设置副本的数量。</p>
<h5 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h5><p>Pod 水平自动扩缩控制器根据当前指标和期望指标来计算扩缩比例。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">期望副本数 = ceil[当前副本数 * (当前指标 / 期望指标)]</span><br></pre></td></tr></table></figure></p>
<p>例如，如果当前指标值为 200m，而期望值为 100m，则副本数将加倍， 因为 200.0 / 100.0 == 2.0 如果当前值为 50m，则副本数将减半， 因为 50.0 / 100.0 == 0.5。如果比率足够接近 1.0（在全局可配置的容差范围内，默认为 0.1）， 则控制平面会跳过扩缩操作。</p>
<p>详细信息可查看<a href="https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/#algorithm-details" target="_blank" rel="noopener">文档</a></p>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/podautoscaler/horizontal.go</span></span><br><span class="line"><span class="comment">// HorizontalController, 可以看到HorizontalController</span></span><br><span class="line"><span class="comment">// 包含了hpaLister,podLister,</span></span><br><span class="line"><span class="keyword">type</span> HorizontalController <span class="keyword">struct</span> &#123;</span><br><span class="line">	scaleNamespacer scaleclient.ScalesGetter</span><br><span class="line">	hpaNamespacer   autoscalingclient.HorizontalPodAutoscalersGetter</span><br><span class="line">	mapper          apimeta.RESTMapper</span><br><span class="line"></span><br><span class="line">	replicaCalc   *ReplicaCalculator</span><br><span class="line">	eventRecorder record.EventRecorder</span><br><span class="line"></span><br><span class="line">	downscaleStabilisationWindow time.Duration</span><br><span class="line"></span><br><span class="line">	monitor monitor.Monitor</span><br><span class="line"></span><br><span class="line">	<span class="comment">// hpaLister is able to list/get HPAs from the shared cache from the informer passed in to</span></span><br><span class="line">	<span class="comment">// NewHorizontalController.</span></span><br><span class="line">	hpaLister       autoscalinglisters.HorizontalPodAutoscalerLister</span><br><span class="line">	hpaListerSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// podLister is able to list/get Pods from the shared cache from the informer passed in to</span></span><br><span class="line">	<span class="comment">// NewHorizontalController.</span></span><br><span class="line">	podLister       corelisters.PodLister</span><br><span class="line">	podListerSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Controllers that need to be synced</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Latest unstabilized recommendations for each autoscaler.</span></span><br><span class="line">	recommendations     <span class="keyword">map</span>[<span class="keyword">string</span>][]timestampedRecommendation</span><br><span class="line">	recommendationsLock sync.Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Latest autoscaler events</span></span><br><span class="line">	scaleUpEvents       <span class="keyword">map</span>[<span class="keyword">string</span>][]timestampedScaleEvent</span><br><span class="line">	scaleUpEventsLock   sync.RWMutex</span><br><span class="line">	scaleDownEvents     <span class="keyword">map</span>[<span class="keyword">string</span>][]timestampedScaleEvent</span><br><span class="line">	scaleDownEventsLock sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Storage of HPAs and their selectors.</span></span><br><span class="line">	hpaSelectors    *selectors.BiMultimap</span><br><span class="line">	hpaSelectorsMux sync.Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// feature gates</span></span><br><span class="line">	containerResourceMetricsEnabled <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HorizontalController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHorizontalController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	evtNamespacer v1core.EventsGetter,</span></span></span><br><span class="line"><span class="function"><span class="params">	scaleNamespacer scaleclient.ScalesGetter,</span></span></span><br><span class="line"><span class="function"><span class="params">	hpaNamespacer autoscalingclient.HorizontalPodAutoscalersGetter,</span></span></span><br><span class="line"><span class="function"><span class="params">	mapper apimeta.RESTMapper,</span></span></span><br><span class="line"><span class="function"><span class="params">	metricsClient metricsclient.MetricsClient,</span></span></span><br><span class="line"><span class="function"><span class="params">	hpaInformer autoscalinginformers.HorizontalPodAutoscalerInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	resyncPeriod time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">	downscaleStabilisationWindow time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">	tolerance <span class="keyword">float64</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cpuInitializationPeriod,</span></span></span><br><span class="line"><span class="function"><span class="params">	delayOfInitialReadinessStatus time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">	containerResourceMetricsEnabled <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> *<span class="title">HorizontalController</span></span> &#123;</span><br><span class="line">	broadcaster := record.NewBroadcaster()</span><br><span class="line">	broadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">	broadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: evtNamespacer.Events(<span class="string">""</span>)&#125;)</span><br><span class="line">	recorder := broadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"horizontal-pod-autoscaler"</span>&#125;)</span><br><span class="line"></span><br><span class="line">	hpaController := &amp;HorizontalController&#123;</span><br><span class="line">		eventRecorder:                   recorder,</span><br><span class="line">		scaleNamespacer:                 scaleNamespacer,</span><br><span class="line">		hpaNamespacer:                   hpaNamespacer,</span><br><span class="line">		downscaleStabilisationWindow:    downscaleStabilisationWindow,</span><br><span class="line">		monitor:                         monitor.New(),</span><br><span class="line">		queue:                           workqueue.NewNamedRateLimitingQueue(NewDefaultHPARateLimiter(resyncPeriod), <span class="string">"horizontalpodautoscaler"</span>),</span><br><span class="line">		mapper:                          mapper,</span><br><span class="line">		recommendations:                 <span class="keyword">map</span>[<span class="keyword">string</span>][]timestampedRecommendation&#123;&#125;,</span><br><span class="line">		recommendationsLock:             sync.Mutex&#123;&#125;,</span><br><span class="line">		scaleUpEvents:                   <span class="keyword">map</span>[<span class="keyword">string</span>][]timestampedScaleEvent&#123;&#125;,</span><br><span class="line">		scaleUpEventsLock:               sync.RWMutex&#123;&#125;,</span><br><span class="line">		scaleDownEvents:                 <span class="keyword">map</span>[<span class="keyword">string</span>][]timestampedScaleEvent&#123;&#125;,</span><br><span class="line">		scaleDownEventsLock:             sync.RWMutex&#123;&#125;,</span><br><span class="line">		hpaSelectors:                    selectors.NewBiMultimap(),</span><br><span class="line">		containerResourceMetricsEnabled: containerResourceMetricsEnabled,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听了资源hpa变化，并进行入队操作</span></span><br><span class="line">	hpaInformer.Informer().AddEventHandlerWithResyncPeriod(</span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc:    hpaController.enqueueHPA,</span><br><span class="line">			UpdateFunc: hpaController.updateHPA,</span><br><span class="line">			DeleteFunc: hpaController.deleteHPA,</span><br><span class="line">		&#125;,</span><br><span class="line">		resyncPeriod,</span><br><span class="line">	)</span><br><span class="line">	hpaController.hpaLister = hpaInformer.Lister()</span><br><span class="line">	hpaController.hpaListerSynced = hpaInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	hpaController.podLister = podInformer.Lister()</span><br><span class="line">	hpaController.podListerSynced = podInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于计算副本数,ReplicaCalculator实现了几个方法用于副本的计算</span></span><br><span class="line">	replicaCalc := NewReplicaCalculator(</span><br><span class="line">		metricsClient,</span><br><span class="line">		hpaController.podLister,</span><br><span class="line">		tolerance,</span><br><span class="line">		cpuInitializationPeriod,</span><br><span class="line">		delayOfInitialReadinessStatus,</span><br><span class="line">	)</span><br><span class="line">	hpaController.replicaCalc = replicaCalc</span><br><span class="line"></span><br><span class="line">	monitor.Register()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hpaController</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *HorizontalController)</span> <span class="title">processNextWorkItem</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	key, quit := a.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> a.queue.Done(key)</span><br><span class="line"></span><br><span class="line">	deleted, err := a.reconcileKey(ctx, key.(<span class="keyword">string</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Add request processing HPA to queue with resyncPeriod delay.</span></span><br><span class="line">	<span class="comment">// Requests are always added to queue with resyncPeriod delay. If there's already request</span></span><br><span class="line">	<span class="comment">// for the HPA in the queue then a new request is always dropped. Requests spend resyncPeriod</span></span><br><span class="line">	<span class="comment">// in queue so HPAs are processed every resyncPeriod.</span></span><br><span class="line">	<span class="comment">// Request is added here just in case last resync didn't insert request into the queue. This</span></span><br><span class="line">	<span class="comment">// happens quite often because there is race condition between adding request after resyncPeriod</span></span><br><span class="line">	<span class="comment">// and removing them from queue. Request can be added by resync before previous request is</span></span><br><span class="line">	<span class="comment">// removed from queue. If we didn't add request here then in this case one request would be dropped</span></span><br><span class="line">	<span class="comment">// and HPA would processed after 2 x resyncPeriod.</span></span><br><span class="line">	<span class="keyword">if</span> !deleted &#123;</span><br><span class="line">		a.queue.AddRateLimited(key)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *HorizontalController)</span> <span class="title">reconcileKey</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="params">(deleted <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取hpa</span></span><br><span class="line">	hpa, err := a.hpaLister.HorizontalPodAutoscalers(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> k8serrors.IsNotFound(err) &#123;</span><br><span class="line">		logger.Info(<span class="string">"Horizontal Pod Autoscaler has been deleted"</span>, <span class="string">"HPA"</span>, klog.KRef(namespace, name))</span><br><span class="line"></span><br><span class="line">		a.recommendationsLock.Lock()</span><br><span class="line">		<span class="built_in">delete</span>(a.recommendations, key)</span><br><span class="line">		a.recommendationsLock.Unlock()</span><br><span class="line"></span><br><span class="line">		a.scaleUpEventsLock.Lock()</span><br><span class="line">		<span class="built_in">delete</span>(a.scaleUpEvents, key)</span><br><span class="line">		a.scaleUpEventsLock.Unlock()</span><br><span class="line"></span><br><span class="line">		a.scaleDownEventsLock.Lock()</span><br><span class="line">		<span class="built_in">delete</span>(a.scaleDownEvents, key)</span><br><span class="line">		a.scaleDownEventsLock.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, a.reconcileAutoscaler(ctx, hpa, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 真正进行调谐的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *HorizontalController)</span> <span class="title">reconcileAutoscaler</span><span class="params">(ctx context.Context, hpaShared *autoscalingv2.HorizontalPodAutoscaler, key <span class="keyword">string</span>)</span> <span class="params">(retErr error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// actionLabel is used to report which actions this reconciliation has taken.</span></span><br><span class="line">	actionLabel := monitor.ActionLabelNone</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		errorLabel := monitor.ErrorLabelNone</span><br><span class="line">		<span class="keyword">if</span> retErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// In case of error, set "internal" as default.</span></span><br><span class="line">			errorLabel = monitor.ErrorLabelInternal</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> errors.Is(retErr, errSpec) &#123;</span><br><span class="line">			errorLabel = monitor.ErrorLabelSpec</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		a.monitor.ObserveReconciliationResult(actionLabel, errorLabel, time.Since(start))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// make a copy so that we never mutate the shared informer cache (conversion can mutate the object)</span></span><br><span class="line">	hpa := hpaShared.DeepCopy()</span><br><span class="line">	hpaStatusOriginal := hpa.Status.DeepCopy()</span><br><span class="line"></span><br><span class="line">	reference := fmt.Sprintf(<span class="string">"%s/%s/%s"</span>, hpa.Spec.ScaleTargetRef.Kind, hpa.Namespace, hpa.Spec.ScaleTargetRef.Name)</span><br><span class="line"></span><br><span class="line">	targetGV, err := schema.ParseGroupVersion(hpa.Spec.ScaleTargetRef.APIVersion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		a.eventRecorder.Event(hpa, v1.EventTypeWarning, <span class="string">"FailedGetScale"</span>, err.Error())</span><br><span class="line">		setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionFalse, <span class="string">"FailedGetScale"</span>, <span class="string">"the HPA controller was unable to get the target's current scale: %v"</span>, err)</span><br><span class="line">		<span class="keyword">if</span> err := a.updateStatusIfNeeded(ctx, hpaStatusOriginal, hpa); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid API version in scale target reference: %v%w"</span>, err, errSpec)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	targetGK := schema.GroupKind&#123;</span><br><span class="line">		Group: targetGV.Group,</span><br><span class="line">		Kind:  hpa.Spec.ScaleTargetRef.Kind,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// RESTMappings 返回提供的组和资源类型的所有资源映射</span></span><br><span class="line">	mappings, err := a.mapper.RESTMappings(targetGK)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		a.eventRecorder.Event(hpa, v1.EventTypeWarning, <span class="string">"FailedGetScale"</span>, err.Error())</span><br><span class="line">		setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionFalse, <span class="string">"FailedGetScale"</span>, <span class="string">"the HPA controller was unable to get the target's current scale: %v"</span>, err)</span><br><span class="line">		<span class="keyword">if</span> err := a.updateStatusIfNeeded(ctx, hpaStatusOriginal, hpa); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unable to determine resource for scale target reference: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取hpa引用的资源的子资源scale</span></span><br><span class="line">	scale, targetGR, err := a.scaleForResourceMappings(ctx, hpa.Namespace, hpa.Spec.ScaleTargetRef.Name, mappings)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		a.eventRecorder.Event(hpa, v1.EventTypeWarning, <span class="string">"FailedGetScale"</span>, err.Error())</span><br><span class="line">		setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionFalse, <span class="string">"FailedGetScale"</span>, <span class="string">"the HPA controller was unable to get the target's current scale: %v"</span>, err)</span><br><span class="line">		<span class="keyword">if</span> err := a.updateStatusIfNeeded(ctx, hpaStatusOriginal, hpa); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to query scale subresource for %s: %v"</span>, reference, err)</span><br><span class="line">	&#125;</span><br><span class="line">	setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionTrue, <span class="string">"SucceededGetScale"</span>, <span class="string">"the HPA controller was able to get the target's current scale"</span>)</span><br><span class="line">    <span class="comment">// 当前复本数</span></span><br><span class="line">	currentReplicas := scale.Spec.Replicas</span><br><span class="line">	a.recordInitialRecommendation(currentReplicas, key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		metricStatuses        []autoscalingv2.MetricStatus</span><br><span class="line">		metricDesiredReplicas <span class="keyword">int32</span></span><br><span class="line">		metricName            <span class="keyword">string</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望的副本数</span></span><br><span class="line">	desiredReplicas := <span class="keyword">int32</span>(<span class="number">0</span>)</span><br><span class="line">	rescaleReason := <span class="string">""</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> minReplicas <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置MinReplicas</span></span><br><span class="line">	<span class="keyword">if</span> hpa.Spec.MinReplicas != <span class="literal">nil</span> &#123;</span><br><span class="line">		minReplicas = *hpa.Spec.MinReplicas</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Default value</span></span><br><span class="line">		minReplicas = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rescale := <span class="literal">true</span></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scale的副本数为0和minReplicas!=0,不进行Autoscaling(为什么还需要minReplicas这个条件)</span></span><br><span class="line">	<span class="keyword">if</span> scale.Spec.Replicas == <span class="number">0</span> &amp;&amp; minReplicas != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Autoscaling is disabled for this resource</span></span><br><span class="line">		desiredReplicas = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 不进行扩缩容操作</span></span><br><span class="line">		rescale = <span class="literal">false</span></span><br><span class="line">		setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, <span class="string">"ScalingDisabled"</span>, <span class="string">"scaling is disabled since the replica count of the target is zero"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> currentReplicas &gt; hpa.Spec.MaxReplicas &#123;</span><br><span class="line">        <span class="comment">// 如果当前副本数大于hpa MaxReplicas, 则期望副本数等于hpa.Spec.MaxReplicas</span></span><br><span class="line">		rescaleReason = <span class="string">"Current number of replicas above Spec.MaxReplicas"</span></span><br><span class="line">		desiredReplicas = hpa.Spec.MaxReplicas</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> currentReplicas &lt; minReplicas &#123;</span><br><span class="line">        <span class="comment">// 如果当前副本数小于hpa MinReplicas, 则期望副本数等于hpa.Spec.MinReplicas</span></span><br><span class="line">		rescaleReason = <span class="string">"Current number of replicas below Spec.MinReplicas"</span></span><br><span class="line">		desiredReplicas = minReplicas</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> metricTimestamp time.Time</span><br><span class="line">        <span class="comment">// 根据资源指标计算metricDesiredReplicas</span></span><br><span class="line">        <span class="comment">// hpa的算法就在computeReplicasForMetrics里</span></span><br><span class="line">		metricDesiredReplicas, metricName, metricStatuses, metricTimestamp, err = a.computeReplicasForMetrics(ctx, hpa, scale, hpa.Spec.Metrics)</span><br><span class="line">		<span class="comment">// computeReplicasForMetrics may return both non-zero metricDesiredReplicas and an error.</span></span><br><span class="line">		<span class="comment">// That means some metrics still work and HPA should perform scaling based on them.</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; metricDesiredReplicas == <span class="number">-1</span> &#123;</span><br><span class="line">			a.setCurrentReplicasInStatus(hpa, currentReplicas)</span><br><span class="line">			<span class="keyword">if</span> err := a.updateStatusIfNeeded(ctx, hpaStatusOriginal, hpa); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				utilruntime.HandleError(err)</span><br><span class="line">			&#125;</span><br><span class="line">			a.eventRecorder.Event(hpa, v1.EventTypeWarning, <span class="string">"FailedComputeMetricsReplicas"</span>, err.Error())</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to compute desired number of replicas based on listed metrics for %s: %v"</span>, reference, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// We proceed to scaling, but return this error from reconcileAutoscaler() finally.</span></span><br><span class="line">			retErr = err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		logger.V(<span class="number">4</span>).Info(<span class="string">"Proposing desired replicas"</span>,</span><br><span class="line">			<span class="string">"desiredReplicas"</span>, metricDesiredReplicas,</span><br><span class="line">			<span class="string">"metric"</span>, metricName,</span><br><span class="line">			<span class="string">"timestamp"</span>, metricTimestamp,</span><br><span class="line">			<span class="string">"scaleTarget"</span>, reference)</span><br><span class="line"></span><br><span class="line">		rescaleMetric := <span class="string">""</span></span><br><span class="line">		<span class="keyword">if</span> metricDesiredReplicas &gt; desiredReplicas &#123;</span><br><span class="line">			desiredReplicas = metricDesiredReplicas</span><br><span class="line">			rescaleMetric = metricName</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> desiredReplicas &gt; currentReplicas &#123;</span><br><span class="line">			rescaleReason = fmt.Sprintf(<span class="string">"%s above target"</span>, rescaleMetric)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> desiredReplicas &lt; currentReplicas &#123;</span><br><span class="line">			rescaleReason = <span class="string">"All metrics below target"</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> hpa.Spec.Behavior == <span class="literal">nil</span> &#123;</span><br><span class="line">			desiredReplicas = a.normalizeDesiredReplicas(hpa, key, currentReplicas, desiredReplicas, minReplicas)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			desiredReplicas = a.normalizeDesiredReplicasWithBehaviors(hpa, key, currentReplicas, desiredReplicas, minReplicas)</span><br><span class="line">		&#125;</span><br><span class="line">		rescale = desiredReplicas != currentReplicas</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rescale &#123;</span><br><span class="line">        <span class="comment">// 设置scale.Spec.Replicas</span></span><br><span class="line">		scale.Spec.Replicas = desiredReplicas</span><br><span class="line">        <span class="comment">// 调用接口更新scale</span></span><br><span class="line">		_, err = a.scaleNamespacer.Scales(hpa.Namespace).Update(ctx, targetGR, scale, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			a.eventRecorder.Eventf(hpa, v1.EventTypeWarning, <span class="string">"FailedRescale"</span>, <span class="string">"New size: %d; reason: %s; error: %v"</span>, desiredReplicas, rescaleReason, err.Error())</span><br><span class="line">			setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionFalse, <span class="string">"FailedUpdateScale"</span>, <span class="string">"the HPA controller was unable to update the target scale: %v"</span>, err)</span><br><span class="line">			a.setCurrentReplicasInStatus(hpa, currentReplicas)</span><br><span class="line">			<span class="keyword">if</span> err := a.updateStatusIfNeeded(ctx, hpaStatusOriginal, hpa); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				utilruntime.HandleError(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to rescale %s: %v"</span>, reference, err)</span><br><span class="line">		&#125;</span><br><span class="line">		setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionTrue, <span class="string">"SucceededRescale"</span>, <span class="string">"the HPA controller was able to update the target scale to %d"</span>, desiredReplicas)</span><br><span class="line">		a.eventRecorder.Eventf(hpa, v1.EventTypeNormal, <span class="string">"SuccessfulRescale"</span>, <span class="string">"New size: %d; reason: %s"</span>, desiredReplicas, rescaleReason)</span><br><span class="line">		a.storeScaleEvent(hpa.Spec.Behavior, key, currentReplicas, desiredReplicas)</span><br><span class="line">		logger.Info(<span class="string">"Successfully rescaled"</span>,</span><br><span class="line">			<span class="string">"HPA"</span>, klog.KObj(hpa),</span><br><span class="line">			<span class="string">"currentReplicas"</span>, currentReplicas,</span><br><span class="line">			<span class="string">"desiredReplicas"</span>, desiredReplicas,</span><br><span class="line">			<span class="string">"reason"</span>, rescaleReason)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> desiredReplicas &gt; currentReplicas &#123;</span><br><span class="line">			actionLabel = monitor.ActionLabelScaleUp</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			actionLabel = monitor.ActionLabelScaleDown</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		logger.V(<span class="number">4</span>).Info(<span class="string">"Decided not to scale"</span>,</span><br><span class="line">			<span class="string">"scaleTarget"</span>, reference,</span><br><span class="line">			<span class="string">"desiredReplicas"</span>, desiredReplicas,</span><br><span class="line">			<span class="string">"lastScaleTime"</span>, hpa.Status.LastScaleTime)</span><br><span class="line">		desiredReplicas = currentReplicas</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	a.setStatus(hpa, currentReplicas, desiredReplicas, metricStatuses, rescale)</span><br><span class="line"></span><br><span class="line">	err = a.updateStatusIfNeeded(ctx, hpaStatusOriginal, hpa)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// we can overwrite retErr in this case because it's an internal error.</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retErr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据HPA中的metric spec计算期望副本数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *HorizontalController)</span> <span class="title">computeReplicasForMetrics</span><span class="params">(ctx context.Context, hpa *autoscalingv2.HorizontalPodAutoscaler, scale *autoscalingv1.Scale,</span></span></span><br><span class="line"><span class="function"><span class="params">	metricSpecs []autoscalingv2.MetricSpec)</span> <span class="params">(replicas <span class="keyword">int32</span>, metric <span class="keyword">string</span>, statuses []autoscalingv2.MetricStatus, timestamp time.Time, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	selector, err := a.validateAndParseSelector(hpa, scale.Status.Selector)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="string">""</span>, <span class="literal">nil</span>, time.Time&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	specReplicas := scale.Spec.Replicas</span><br><span class="line">	statusReplicas := scale.Status.Replicas</span><br><span class="line">	statuses = <span class="built_in">make</span>([]autoscalingv2.MetricStatus, <span class="built_in">len</span>(metricSpecs))</span><br><span class="line"></span><br><span class="line">	invalidMetricsCount := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> invalidMetricError error</span><br><span class="line">	<span class="keyword">var</span> invalidMetricCondition autoscalingv2.HorizontalPodAutoscalerCondition</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历metricSpecs,分别计算期望副本数，取最大值</span></span><br><span class="line">	<span class="keyword">for</span> i, metricSpec := <span class="keyword">range</span> metricSpecs &#123;</span><br><span class="line">		replicaCountProposal, metricNameProposal, timestampProposal, condition, err := a.computeReplicasForMetric(ctx, hpa, metricSpec, specReplicas, statusReplicas, selector, &amp;statuses[i])</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> invalidMetricsCount &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				invalidMetricCondition = condition</span><br><span class="line">				invalidMetricError = err</span><br><span class="line">			&#125;</span><br><span class="line">			invalidMetricsCount++</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> replicas == <span class="number">0</span> || replicaCountProposal &gt; replicas &#123;</span><br><span class="line">			timestamp = timestampProposal</span><br><span class="line">			replicas = replicaCountProposal</span><br><span class="line">			metric = metricNameProposal</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> invalidMetricError != <span class="literal">nil</span> &#123;</span><br><span class="line">		invalidMetricError = fmt.Errorf(<span class="string">"invalid metrics (%v invalid out of %v), first error is: %v"</span>, invalidMetricsCount, <span class="built_in">len</span>(metricSpecs), invalidMetricError)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If all metrics are invalid or some are invalid and we would scale down,</span></span><br><span class="line">	<span class="comment">// return an error and set the condition of the hpa based on the first invalid metric.</span></span><br><span class="line">	<span class="comment">// Otherwise set the condition as scaling active as we're going to scale</span></span><br><span class="line">	<span class="keyword">if</span> invalidMetricsCount &gt;= <span class="built_in">len</span>(metricSpecs) || (invalidMetricsCount &gt; <span class="number">0</span> &amp;&amp; replicas &lt; specReplicas) &#123;</span><br><span class="line">		setCondition(hpa, invalidMetricCondition.Type, invalidMetricCondition.Status, invalidMetricCondition.Reason, invalidMetricCondition.Message)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="string">""</span>, statuses, time.Time&#123;&#125;, invalidMetricError</span><br><span class="line">	&#125;</span><br><span class="line">	setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionTrue, <span class="string">"ValidMetricFound"</span>, <span class="string">"the HPA was able to successfully calculate a replica count from %s"</span>, metric)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> replicas, metric, statuses, timestamp, invalidMetricError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *HorizontalController)</span> <span class="title">computeReplicasForMetric</span><span class="params">(ctx context.Context, hpa *autoscalingv2.HorizontalPodAutoscaler, spec autoscalingv2.MetricSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">	specReplicas, statusReplicas <span class="keyword">int32</span>, selector labels.Selector, status *autoscalingv2.MetricStatus)</span> <span class="params">(replicaCountProposal <span class="keyword">int32</span>, metricNameProposal <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	timestampProposal time.Time, condition autoscalingv2.HorizontalPodAutoscalerCondition, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// actionLabel is used to report which actions this reconciliation has taken.</span></span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		actionLabel := monitor.ActionLabelNone</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> replicaCountProposal &gt; hpa.Status.CurrentReplicas:</span><br><span class="line">			actionLabel = monitor.ActionLabelScaleUp</span><br><span class="line">		<span class="keyword">case</span> replicaCountProposal &lt; hpa.Status.CurrentReplicas:</span><br><span class="line">			actionLabel = monitor.ActionLabelScaleDown</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		errorLabel := monitor.ErrorLabelNone</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// In case of error, set "internal" as default.</span></span><br><span class="line">			errorLabel = monitor.ErrorLabelInternal</span><br><span class="line">			actionLabel = monitor.ActionLabelNone</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> errors.Is(err, errSpec) &#123;</span><br><span class="line">			errorLabel = monitor.ErrorLabelSpec</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		a.monitor.ObserveMetricComputationResult(actionLabel, errorLabel, time.Since(start), spec.Type)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的类型分别计算期望副本数</span></span><br><span class="line">	<span class="keyword">switch</span> spec.Type &#123;</span><br><span class="line">	<span class="keyword">case</span> autoscalingv2.ObjectMetricSourceType:</span><br><span class="line">		metricSelector, err := metav1.LabelSelectorAsSelector(spec.Object.Metric.Selector)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			condition := a.getUnableComputeReplicaCountCondition(hpa, <span class="string">"FailedGetObjectMetric"</span>, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="string">""</span>, time.Time&#123;&#125;, condition, fmt.Errorf(<span class="string">"failed to get object metric value: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		replicaCountProposal, timestampProposal, metricNameProposal, condition, err = a.computeStatusForObjectMetric(specReplicas, statusReplicas, spec, hpa, selector, status, metricSelector)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="string">""</span>, time.Time&#123;&#125;, condition, fmt.Errorf(<span class="string">"failed to get object metric value: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> autoscalingv2.PodsMetricSourceType:</span><br><span class="line">		metricSelector, err := metav1.LabelSelectorAsSelector(spec.Pods.Metric.Selector)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			condition := a.getUnableComputeReplicaCountCondition(hpa, <span class="string">"FailedGetPodsMetric"</span>, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="string">""</span>, time.Time&#123;&#125;, condition, fmt.Errorf(<span class="string">"failed to get pods metric value: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		replicaCountProposal, timestampProposal, metricNameProposal, condition, err = a.computeStatusForPodsMetric(specReplicas, spec, hpa, selector, status, metricSelector)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="string">""</span>, time.Time&#123;&#125;, condition, fmt.Errorf(<span class="string">"failed to get pods metric value: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> autoscalingv2.ResourceMetricSourceType:</span><br><span class="line">		replicaCountProposal, timestampProposal, metricNameProposal, condition, err = a.computeStatusForResourceMetric(ctx, specReplicas, spec, hpa, selector, status)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="string">""</span>, time.Time&#123;&#125;, condition, fmt.Errorf(<span class="string">"failed to get %s resource metric value: %v"</span>, spec.Resource.Name, err)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> autoscalingv2.ContainerResourceMetricSourceType:</span><br><span class="line">		<span class="keyword">if</span> !a.containerResourceMetricsEnabled &#123;</span><br><span class="line">			<span class="comment">// If the container resource metrics feature is disabled but the object has the one,</span></span><br><span class="line">			<span class="comment">// that means the user enabled the feature once,</span></span><br><span class="line">			<span class="comment">// created some HPAs with the container resource metrics, and disabled it finally.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="string">""</span>, time.Time&#123;&#125;, condition, fmt.Errorf(<span class="string">"ContainerResource metric type is not supported: disabled by the feature gate"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		replicaCountProposal, timestampProposal, metricNameProposal, condition, err = a.computeStatusForContainerResourceMetric(ctx, specReplicas, spec, hpa, selector, status)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="string">""</span>, time.Time&#123;&#125;, condition, fmt.Errorf(<span class="string">"failed to get %s container metric value: %v"</span>, spec.ContainerResource.Container, err)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> autoscalingv2.ExternalMetricSourceType:</span><br><span class="line">		replicaCountProposal, timestampProposal, metricNameProposal, condition, err = a.computeStatusForExternalMetric(specReplicas, statusReplicas, spec, hpa, selector, status)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="string">""</span>, time.Time&#123;&#125;, condition, fmt.Errorf(<span class="string">"failed to get %s external metric value: %v"</span>, spec.External.Metric.Name, err)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// It shouldn't reach here as invalid metric source type is filtered out in the api-server's validation.</span></span><br><span class="line">		err = fmt.Errorf(<span class="string">"unknown metric source type %q%w"</span>, <span class="keyword">string</span>(spec.Type), errSpec)</span><br><span class="line">		condition := a.getUnableComputeReplicaCountCondition(hpa, <span class="string">"InvalidMetricSourceType"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="string">""</span>, time.Time&#123;&#125;, condition, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> replicaCountProposal, metricNameProposal, timestampProposal, autoscalingv2.HorizontalPodAutoscalerCondition&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Metric类型</span></span><br><span class="line"><span class="comment">// staging/src/k8s.io/api/autoscaling/v2/types.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// ObjectMetricSourceType is a metric describing a kubernetes object</span></span><br><span class="line">	<span class="comment">// (for example, hits-per-second on an Ingress object).</span></span><br><span class="line">	ObjectMetricSourceType MetricSourceType = <span class="string">"Object"</span></span><br><span class="line">	<span class="comment">// PodsMetricSourceType is a metric describing each pod in the current scale</span></span><br><span class="line">	<span class="comment">// target (for example, transactions-processed-per-second).  The values</span></span><br><span class="line">	<span class="comment">// will be averaged together before being compared to the target value.</span></span><br><span class="line">	PodsMetricSourceType MetricSourceType = <span class="string">"Pods"</span></span><br><span class="line">	<span class="comment">// ResourceMetricSourceType is a resource metric known to Kubernetes, as</span></span><br><span class="line">	<span class="comment">// specified in requests and limits, describing each pod in the current</span></span><br><span class="line">	<span class="comment">// scale target (e.g. CPU or memory).  Such metrics are built in to</span></span><br><span class="line">	<span class="comment">// Kubernetes, and have special scaling options on top of those available</span></span><br><span class="line">	<span class="comment">// to normal per-pod metrics (the "pods" source).</span></span><br><span class="line">	ResourceMetricSourceType MetricSourceType = <span class="string">"Resource"</span></span><br><span class="line">	<span class="comment">// ContainerResourceMetricSourceType is a resource metric known to Kubernetes, as</span></span><br><span class="line">	<span class="comment">// specified in requests and limits, describing a single container in each pod in the current</span></span><br><span class="line">	<span class="comment">// scale target (e.g. CPU or memory).  Such metrics are built in to</span></span><br><span class="line">	<span class="comment">// Kubernetes, and have special scaling options on top of those available</span></span><br><span class="line">	<span class="comment">// to normal per-pod metrics (the "pods" source).</span></span><br><span class="line">	ContainerResourceMetricSourceType MetricSourceType = <span class="string">"ContainerResource"</span></span><br><span class="line">	<span class="comment">// ExternalMetricSourceType is a global metric that is not associated</span></span><br><span class="line">	<span class="comment">// with any Kubernetes object. It allows autoscaling based on information</span></span><br><span class="line">	<span class="comment">// coming from components running outside of cluster</span></span><br><span class="line">	<span class="comment">// (for example length of queue in cloud messaging service, or</span></span><br><span class="line">	<span class="comment">// QPS from loadbalancer running outside of cluster).</span></span><br><span class="line">	ExternalMetricSourceType MetricSourceType = <span class="string">"External"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/" target="_blank" rel="noopener">horizontal-pod-autoscale/</a><br>2.<a href="https://github.com/kubernetes-sigs/custom-metrics-apiserver" target="_blank" rel="noopener">编写自定义指标适配器</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/staging/src/k8s.io/api/autoscaling/v2/types.go" target="_blank" rel="noopener">staging/src/k8s.io/api/autoscaling/v2/types.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/podautoscaler/horizontal.go" target="_blank" rel="noopener">pkg/controller/podautoscaler/horizontal.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之podgc</title>
    <url>/2023/05/12/kube-controller%E4%B9%8Bpodgc/</url>
    <content><![CDATA[<p><code>podgc controller</code>负责对<code>pod</code>进行垃圾回收。</p>
<ul>
<li>如果Terminated状态的数量大于terminatedPodThreshold,删除部分Terminated状态的pod</li>
<li>删除不再服务的node上的pod</li>
<li>删除孤儿pod(一个pod绑定到了一个不存在的Node)</li>
<li>删除Terminating状态且未被调度到某一Node上的pod</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/kube-controller-manager/app/core.go</span></span><br><span class="line"><span class="comment">// 启动入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startPodGCController</span><span class="params">(ctx context.Context, controllerContext ControllerContext)</span> <span class="params">(controller.Interface, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> podgc.NewPodGC(</span><br><span class="line">		ctx,</span><br><span class="line">		controllerContext.ClientBuilder.ClientOrDie(<span class="string">"pod-garbage-collector"</span>),</span><br><span class="line">		controllerContext.InformerFactory.Core().V1().Pods(),</span><br><span class="line">		controllerContext.InformerFactory.Core().V1().Nodes(),</span><br><span class="line">		<span class="keyword">int</span>(controllerContext.ComponentConfig.PodGCController.TerminatedPodGCThreshold),</span><br><span class="line">	).Run(ctx)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/podgc/gc_controller.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// gcCheckPeriod defines frequency of running main controller loop</span></span><br><span class="line">	gcCheckPeriod = <span class="number">20</span> * time.Second</span><br><span class="line">	<span class="comment">// quarantineTime defines how long Orphaned GC waits for nodes to show up</span></span><br><span class="line">	<span class="comment">// in an informer before issuing a GET call to check if they are truly gone</span></span><br><span class="line">	<span class="comment">// 隔离时间，延迟入队时间，在quarantineTime秒后会再次判断node是否真正的消失</span></span><br><span class="line">	<span class="comment">// 可以避免一些node短暂离开的情况</span></span><br><span class="line">	quarantineTime = <span class="number">40</span> * time.Second</span><br><span class="line"></span><br><span class="line">	<span class="comment">// field manager used to add pod failure condition and change the pod phase</span></span><br><span class="line">	fieldManager = <span class="string">"PodGC"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PodGCController <span class="keyword">struct</span> &#123;</span><br><span class="line">	kubeClient clientset.Interface</span><br><span class="line"></span><br><span class="line">	podLister        corelisters.PodLister</span><br><span class="line">	podListerSynced  cache.InformerSynced</span><br><span class="line">	nodeLister       corelisters.NodeLister</span><br><span class="line">	nodeListerSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	nodeQueue workqueue.DelayingInterface</span><br><span class="line"></span><br><span class="line">	terminatedPodThreshold <span class="keyword">int</span></span><br><span class="line">	gcCheckPeriod          time.Duration</span><br><span class="line">	quarantineTime         time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Register prometheus metrics</span></span><br><span class="line">	RegisterMetrics()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPodGC</span><span class="params">(ctx context.Context, kubeClient clientset.Interface, podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodeInformer coreinformers.NodeInformer, terminatedPodThreshold <span class="keyword">int</span>)</span> *<span class="title">PodGCController</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewPodGCInternal(ctx, kubeClient, podInformer, nodeInformer, terminatedPodThreshold, gcCheckPeriod, quarantineTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function is only intended for integration tests</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPodGCInternal</span><span class="params">(ctx context.Context, kubeClient clientset.Interface, podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodeInformer coreinformers.NodeInformer, terminatedPodThreshold <span class="keyword">int</span>, gcCheckPeriod, quarantineTime time.Duration)</span> *<span class="title">PodGCController</span></span> &#123;</span><br><span class="line">	gcc := &amp;PodGCController&#123;</span><br><span class="line">		kubeClient:             kubeClient,</span><br><span class="line">		terminatedPodThreshold: terminatedPodThreshold,</span><br><span class="line">		podLister:              podInformer.Lister(),</span><br><span class="line">		podListerSynced:        podInformer.Informer().HasSynced,</span><br><span class="line">		nodeLister:             nodeInformer.Lister(),</span><br><span class="line">		nodeListerSynced:       nodeInformer.Informer().HasSynced,</span><br><span class="line">		nodeQueue:              workqueue.NewNamedDelayingQueue(<span class="string">"orphaned_pods_nodes"</span>),</span><br><span class="line">		gcCheckPeriod:          gcCheckPeriod,</span><br><span class="line">		quarantineTime:         quarantineTime,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> gcc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">Run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	klog.Infof(<span class="string">"Starting GC controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> gcc.nodeQueue.ShutDown()</span><br><span class="line">	<span class="keyword">defer</span> klog.Infof(<span class="string">"Shutting down GC controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"GC"</span>, ctx.Done(), gcc.podListerSynced, gcc.nodeListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> wait.UntilWithContext(ctx, gcc.gc, gcc.gcCheckPeriod)</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gc</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 返回indexer中的所有pod</span></span><br><span class="line">	pods, err := gcc.podLister.List(labels.Everything())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">"Error while listing all pods: %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	nodes, err := gcc.nodeLister.List(labels.Everything())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">"Error while listing all nodes: %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// terminatedPodThreshold 系统中可以存在Terminated状态pod的数量</span></span><br><span class="line">	<span class="keyword">if</span> gcc.terminatedPodThreshold &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 删除部分Terminated状态的pod</span></span><br><span class="line">		gcc.gcTerminated(ctx, pods)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 删除不再服务的node上的pod</span></span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.NodeOutOfServiceVolumeDetach) &#123;</span><br><span class="line">		gcc.gcTerminating(ctx, pods)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 删除孤儿pod(一个pod绑定到了一个不存在的Node)</span></span><br><span class="line">	gcc.gcOrphaned(ctx, pods, nodes)</span><br><span class="line">	<span class="comment">// 删除Terminating状态且未被调度到某一Node上的pod</span></span><br><span class="line">	<span class="comment">// 什么情况下会产生这种pod?? 将创建没来得及被调度就被删除了</span></span><br><span class="line">	gcc.gcUnscheduledTerminating(ctx, pods)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPodTerminated</span><span class="params">(pod *v1.Pod)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> phase := pod.Status.Phase; phase != v1.PodPending &amp;&amp; phase != v1.PodRunning &amp;&amp; phase != v1.PodUnknown &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isPodTerminating returns true if the pod is terminating.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPodTerminating</span><span class="params">(pod *v1.Pod)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pod.ObjectMeta.DeletionTimestamp != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcTerminating</span><span class="params">(ctx context.Context, pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">4</span>).Info(<span class="string">"GC'ing terminating pods that are on out-of-service nodes"</span>)</span><br><span class="line">	terminatingPods := []*v1.Pod&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="keyword">if</span> isPodTerminating(pod) &#123;</span><br><span class="line">			<span class="comment">// 获取pod所在的node</span></span><br><span class="line">			node, err := gcc.nodeLister.Get(pod.Spec.NodeName)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.Errorf(<span class="string">"failed to get node %s : %s"</span>, pod.Spec.NodeName, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Add this pod to terminatingPods list only if the following conditions are met:</span></span><br><span class="line">			<span class="comment">// 1. Node is not ready.</span></span><br><span class="line">			<span class="comment">// 2. Node has `node.kubernetes.io/out-of-service` taint.</span></span><br><span class="line">			<span class="comment">// 判断Node是否是Ready,Node是否包含node.kubernetes.io/out-of-service</span></span><br><span class="line">			<span class="comment">// 同时满足这两个条件，则加入terminatingPods列表</span></span><br><span class="line">			<span class="keyword">if</span> !nodeutil.IsNodeReady(node) &amp;&amp; taints.TaintKeyExists(node.Spec.Taints, v1.TaintNodeOutOfService) &#123;</span><br><span class="line">				klog.V(<span class="number">4</span>).Infof(<span class="string">"garbage collecting pod %s that is terminating. Phase [%v]"</span>, pod.Name, pod.Status.Phase)</span><br><span class="line">				terminatingPods = <span class="built_in">append</span>(terminatingPods, pod)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	deleteCount := <span class="built_in">len</span>(terminatingPods)</span><br><span class="line">	<span class="keyword">if</span> deleteCount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"Garbage collecting %v pods that are terminating on node tainted with node.kubernetes.io/out-of-service"</span>, deleteCount)</span><br><span class="line">	<span class="comment">// sort only when necessary</span></span><br><span class="line">	sort.Sort(byEvictionAndCreationTimestamp(terminatingPods))</span><br><span class="line">	<span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line">	<span class="comment">// 删除terminatingPods</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; deleteCount; i++ &#123;</span><br><span class="line">		wait.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wait.Done()</span><br><span class="line">			deletingPodsTotal.WithLabelValues().Inc()</span><br><span class="line">			<span class="keyword">if</span> err := gcc.markFailedAndDeletePod(ctx, pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// ignore not founds</span></span><br><span class="line">				utilruntime.HandleError(err)</span><br><span class="line">				deletingPodsErrorTotal.WithLabelValues().Inc()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(terminatingPods[i])</span><br><span class="line">	&#125;</span><br><span class="line">	wait.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcTerminated</span><span class="params">(ctx context.Context, pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">	terminatedPods := []*v1.Pod&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="keyword">if</span> isPodTerminated(pod) &#123;</span><br><span class="line">			terminatedPods = <span class="built_in">append</span>(terminatedPods, pod)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	terminatedPodCount := <span class="built_in">len</span>(terminatedPods)</span><br><span class="line">	deleteCount := terminatedPodCount - gcc.terminatedPodThreshold</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> deleteCount &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.InfoS(<span class="string">"Garbage collecting pods"</span>, <span class="string">"numPods"</span>, deleteCount)</span><br><span class="line">	<span class="comment">// sort only when necessary</span></span><br><span class="line">	sort.Sort(byEvictionAndCreationTimestamp(terminatedPods))</span><br><span class="line">	<span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; deleteCount; i++ &#123;</span><br><span class="line">		wait.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wait.Done()</span><br><span class="line">			<span class="keyword">if</span> err := gcc.markFailedAndDeletePod(ctx, pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// ignore not founds</span></span><br><span class="line">				<span class="keyword">defer</span> utilruntime.HandleError(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(terminatedPods[i])</span><br><span class="line">	&#125;</span><br><span class="line">	wait.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcOrphaned deletes pods that are bound to nodes that don't exist.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcOrphaned</span><span class="params">(ctx context.Context, pods []*v1.Pod, nodes []*v1.Node)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"GC'ing orphaned"</span>)</span><br><span class="line">	existingNodeNames := sets.NewString()</span><br><span class="line">	<span class="comment">// 获取存在的NodeName</span></span><br><span class="line">	<span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">		existingNodeNames.Insert(node.Name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Add newly found unknown nodes to quarantine</span></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="comment">// pod的nodeName不为空且nodeName不存在于existingNodeNames</span></span><br><span class="line">		<span class="comment">// 将NodeName入队，延迟时间为quarantineTime</span></span><br><span class="line">		<span class="keyword">if</span> pod.Spec.NodeName != <span class="string">""</span> &amp;&amp; !existingNodeNames.Has(pod.Spec.NodeName) &#123;</span><br><span class="line">			gcc.nodeQueue.AddAfter(pod.Spec.NodeName, gcc.quarantineTime)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Check if nodes are still missing after quarantine period</span></span><br><span class="line">	<span class="comment">// 在隔离期时间过后检查node是否存在</span></span><br><span class="line">	deletedNodesNames, quit := gcc.discoverDeletedNodes(ctx, existingNodeNames)</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 删除孤儿Pod</span></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="comment">// pod.Spec.NodeName 不在已删除的node集合，说明不是孤儿Pod</span></span><br><span class="line">		<span class="keyword">if</span> !deletedNodesNames.Has(pod.Spec.NodeName) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">2</span>).InfoS(<span class="string">"Found orphaned Pod assigned to the Node, deleting."</span>, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"node"</span>, pod.Spec.NodeName)</span><br><span class="line">		condition := corev1apply.PodCondition().</span><br><span class="line">			WithType(v1.DisruptionTarget).</span><br><span class="line">			WithStatus(v1.ConditionTrue).</span><br><span class="line">			WithReason(<span class="string">"DeletionByPodGC"</span>).</span><br><span class="line">			WithMessage(<span class="string">"PodGC: node no longer exists"</span>).</span><br><span class="line">			WithLastTransitionTime(metav1.Now())</span><br><span class="line">		<span class="keyword">if</span> err := gcc.markFailedAndDeletePodWithCondition(ctx, pod, condition); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.InfoS(<span class="string">"Forced deletion of orphaned Pod succeeded"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">discoverDeletedNodes</span><span class="params">(ctx context.Context, existingNodeNames sets.String)</span> <span class="params">(sets.String, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	deletedNodesNames := sets.NewString()</span><br><span class="line">	<span class="keyword">for</span> gcc.nodeQueue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		item, quit := gcc.nodeQueue.Get()</span><br><span class="line">		<span class="keyword">if</span> quit &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		nodeName := item.(<span class="keyword">string</span>)</span><br><span class="line">		<span class="keyword">if</span> !existingNodeNames.Has(nodeName) &#123;</span><br><span class="line">			exists, err := gcc.checkIfNodeExists(ctx, nodeName)</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Error while getting node"</span>, <span class="string">"node"</span>, klog.KRef(<span class="string">""</span>, nodeName))</span><br><span class="line">				<span class="comment">// Node will be added back to the queue in the subsequent loop if still needed</span></span><br><span class="line">			<span class="keyword">case</span> !exists:</span><br><span class="line">				deletedNodesNames.Insert(nodeName)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		gcc.nodeQueue.Done(item)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> deletedNodesNames, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">checkIfNodeExists</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	_, fetchErr := gcc.kubeClient.CoreV1().Nodes().Get(ctx, name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(fetchErr) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fetchErr == <span class="literal">nil</span>, fetchErr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcUnscheduledTerminating deletes pods that are terminating and haven't been scheduled to a particular node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">gcUnscheduledTerminating</span><span class="params">(ctx context.Context, pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"GC'ing unscheduled pods which are terminating."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="comment">// 未被删除或已经调度到node</span></span><br><span class="line">		<span class="keyword">if</span> pod.DeletionTimestamp == <span class="literal">nil</span> || <span class="built_in">len</span>(pod.Spec.NodeName) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">2</span>).InfoS(<span class="string">"Found unscheduled terminating Pod not assigned to any Node, deleting."</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">		<span class="keyword">if</span> err := gcc.markFailedAndDeletePod(ctx, pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.InfoS(<span class="string">"Forced deletion of unscheduled terminating Pod succeeded"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// byEvictionAndCreationTimestamp sorts a list by Evicted status and then creation timestamp,</span></span><br><span class="line"><span class="comment">// using their names as a tie breaker.</span></span><br><span class="line"><span class="comment">// Evicted pods will be deleted first to avoid impact on terminated pods created by controllers.</span></span><br><span class="line"><span class="keyword">type</span> byEvictionAndCreationTimestamp []*v1.Pod</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byEvictionAndCreationTimestamp)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(o) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byEvictionAndCreationTimestamp)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; o[i], o[j] = o[j], o[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o byEvictionAndCreationTimestamp)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	iEvicted, jEvicted := eviction.PodIsEvicted(o[i].Status), eviction.PodIsEvicted(o[j].Status)</span><br><span class="line">	<span class="comment">// Evicted pod is smaller</span></span><br><span class="line">	<span class="keyword">if</span> iEvicted != jEvicted &#123;</span><br><span class="line">		<span class="keyword">return</span> iEvicted</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> o[i].CreationTimestamp.Equal(&amp;o[j].CreationTimestamp) &#123;</span><br><span class="line">		<span class="keyword">return</span> o[i].Name &lt; o[j].Name</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o[i].CreationTimestamp.Before(&amp;o[j].CreationTimestamp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">markFailedAndDeletePod</span><span class="params">(ctx context.Context, pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> gcc.markFailedAndDeletePodWithCondition(ctx, pod, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gcc *PodGCController)</span> <span class="title">markFailedAndDeletePodWithCondition</span><span class="params">(ctx context.Context, pod *v1.Pod, condition *corev1apply.PodConditionApplyConfiguration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	klog.InfoS(<span class="string">"PodGC is force deleting Pod"</span>, <span class="string">"pod"</span>, klog.KRef(pod.Namespace, pod.Name))</span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.PodDisruptionConditions) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Mark the pod as failed - this is especially important in case the pod</span></span><br><span class="line">		<span class="comment">// is orphaned, in which case the pod would remain in the Running phase</span></span><br><span class="line">		<span class="comment">// forever as there is no kubelet running to change the phase.</span></span><br><span class="line">		<span class="keyword">if</span> pod.Status.Phase != v1.PodSucceeded &amp;&amp; pod.Status.Phase != v1.PodFailed &#123;</span><br><span class="line">			podApply := corev1apply.Pod(pod.Name, pod.Namespace).WithStatus(corev1apply.PodStatus())</span><br><span class="line">			<span class="comment">// we don't need to extract the pod apply configuration and can send</span></span><br><span class="line">			<span class="comment">// only phase and the DisruptionTarget condition as PodGC would not</span></span><br><span class="line">			<span class="comment">// own other fields. If the DisruptionTarget condition is owned by</span></span><br><span class="line">			<span class="comment">// PodGC it means that it is in the Failed phase, so sending the</span></span><br><span class="line">			<span class="comment">// condition will not be re-attempted.</span></span><br><span class="line">			podApply.Status.WithPhase(v1.PodFailed)</span><br><span class="line">			<span class="keyword">if</span> condition != <span class="literal">nil</span> &#123;</span><br><span class="line">				podApply.Status.WithConditions(condition)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> _, err := gcc.kubeClient.CoreV1().Pods(pod.Namespace).ApplyStatus(ctx, podApply, metav1.ApplyOptions&#123;FieldManager: fieldManager, Force: <span class="literal">true</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gcc.kubeClient.CoreV1().Pods(pod.Namespace).Delete(ctx, pod.Name, *metav1.NewDeleteOptions(<span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/tree/release-1.27/cmd/kube-controller-manager/app/core.go" target="_blank" rel="noopener">cmd/kube-controller-manager/app/core.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/tree/release-1.27/pkg/controller/podgc/gc_controller.go" target="_blank" rel="noopener">pkg/controller/podgc/gc_controller.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之resource-quota</title>
    <url>/2023/06/15/kube-controller%E4%B9%8Bresource-quota/</url>
    <content><![CDATA[<p>在 <code>Kubernetes</code> 中，<code>ResourceQuota</code>（资源配额）是一种机制，用于对命名空间中的资源使用进行限制和控制。它可以帮助管理员在 <code>Kubernetes</code> 集群中实施资源管理策略，确保不同的命名空间或用户不会滥用资源或超出预定的限制。</p>
<p><code>ResourceQuota</code> 控制器是 <code>Kubernetes</code> 中的一部分，它负责监控和执行 <code>ResourceQuota</code> 对象的策略。控制器会定期检查每个命名空间的资源使用情况，并与 <code>ResourceQuota</code> 对象中定义的限制进行比较。如果某个命名空间的资源使用超出了限制，控制器将采取相应的措施来限制该命名空间的资源使用。</p>
<p>通过 <code>ResourceQuota</code>，管理员可以限制每个命名空间的 CPU、内存、存储等资源的使用量。它还可以限制 Pod、服务、配置映射等对象的数量。通过定义适当的 <code>ResourceQuota</code>对象，管理员可以确保资源在集群中得到合理的分配和使用。</p>
<p>在 <code>Kubernetes</code> 源码中，<code>ResourceQuota</code> 控制器的实现可以在 <code>pkg/controller/resourcequota</code> 目录下找到。该目录中的文件包含了 <code>ResourceQuota</code> 控制器的业务逻辑和处理逻辑。</p>
<hr>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/resourcequota/resource_quota_controller.go</span></span><br><span class="line"><span class="comment">// Controller is responsible for tracking quota usage status in the system</span></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Must have authority to list all resources in the system, and update quota status</span></span><br><span class="line">	rqClient corev1client.ResourceQuotasGetter</span><br><span class="line">	<span class="comment">// A lister/getter of resource quota objects</span></span><br><span class="line">	rqLister corelisters.ResourceQuotaLister</span><br><span class="line">	<span class="comment">// A list of functions that return true when their caches have synced</span></span><br><span class="line">	informerSyncedFuncs []cache.InformerSynced</span><br><span class="line">	<span class="comment">// ResourceQuota objects that need to be synchronized</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line">	<span class="comment">// missingUsageQueue holds objects that are missing the initial usage information</span></span><br><span class="line">	missingUsageQueue workqueue.RateLimitingInterface</span><br><span class="line">	<span class="comment">// To allow injection of syncUsage for testing.</span></span><br><span class="line">	syncHandler <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line">	<span class="comment">// function that controls full recalculation of quota usage</span></span><br><span class="line">	resyncPeriod controller.ResyncPeriodFunc</span><br><span class="line">	<span class="comment">// knows how to calculate usage</span></span><br><span class="line">	registry quota.Registry</span><br><span class="line">	<span class="comment">// knows how to monitor all the resources tracked by quota and trigger replenishment</span></span><br><span class="line">	quotaMonitor *QuotaMonitor</span><br><span class="line">	<span class="comment">// controls the workers that process quotas</span></span><br><span class="line">	<span class="comment">// this lock is acquired to control write access to the monitors and ensures that all</span></span><br><span class="line">	<span class="comment">// monitors are synced before the controller can process quotas.</span></span><br><span class="line">	workerLock sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewController creates a quota controller with specified options</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(ctx context.Context, options *ControllerOptions)</span> <span class="params">(*Controller, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// build the resource quota controller</span></span><br><span class="line">	rq := &amp;Controller&#123;</span><br><span class="line">		rqClient:            options.QuotaClient,</span><br><span class="line">		rqLister:            options.ResourceQuotaInformer.Lister(),</span><br><span class="line">		informerSyncedFuncs: []cache.InformerSynced&#123;options.ResourceQuotaInformer.Informer().HasSynced&#125;,</span><br><span class="line">		queue:               workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"resourcequota_primary"</span>),</span><br><span class="line">		missingUsageQueue:   workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"resourcequota_priority"</span>),</span><br><span class="line">		resyncPeriod:        options.ResyncPeriod,</span><br><span class="line">		registry:            options.Registry,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// set the synchronization handler</span></span><br><span class="line">	rq.syncHandler = rq.syncResourceQuotaFromKey</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">	options.ResourceQuotaInformer.Informer().AddEventHandlerWithResyncPeriod(</span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">				rq.addQuota(logger, obj)</span><br><span class="line">			&#125;,</span><br><span class="line">			UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">				<span class="comment">// 我们只</span></span><br><span class="line">				oldResourceQuota := old.(*v1.ResourceQuota)</span><br><span class="line">				curResourceQuota := cur.(*v1.ResourceQuota)</span><br><span class="line">				<span class="keyword">if</span> quota.Equals(oldResourceQuota.Spec.Hard, curResourceQuota.Spec.Hard) &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				rq.addQuota(logger, curResourceQuota)</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="comment">// This will enter the sync loop and no-op, because the controller has been deleted from the store.</span></span><br><span class="line">			<span class="comment">// Note that deleting a controller immediately after scaling it to 0 will not work. The recommended</span></span><br><span class="line">			<span class="comment">// way of achieving this is by performing a `stop` operation on the controller.</span></span><br><span class="line">            <span class="comment">// 进入sync loop但是不做任何操作，因为controller已经被删除了</span></span><br><span class="line">			DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">				rq.enqueueResourceQuota(logger, obj)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		rq.resyncPeriod(),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> options.DiscoveryFunc != <span class="literal">nil</span> &#123;</span><br><span class="line">		qm := &amp;QuotaMonitor&#123;</span><br><span class="line">			informersStarted:  options.InformersStarted,</span><br><span class="line">			informerFactory:   options.InformerFactory,</span><br><span class="line">			ignoredResources:  options.IgnoredResourcesFunc(),</span><br><span class="line">			resourceChanges:   workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"resource_quota_controller_resource_changes"</span>),</span><br><span class="line">			resyncPeriod:      options.ReplenishmentResyncPeriod,</span><br><span class="line">			replenishmentFunc: rq.replenishQuota,</span><br><span class="line">			registry:          rq.registry,</span><br><span class="line">			updateFilter:      options.UpdateFilter,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rq.quotaMonitor = qm</span><br><span class="line"></span><br><span class="line">		<span class="comment">// do initial quota monitor setup.  If we have a discovery failure here, it's ok. We'll discover more resources when a later sync happens.</span></span><br><span class="line">        <span class="comment">// 用于获取可以进行配额限制的资源列表</span></span><br><span class="line">		resources, err := GetQuotableResources(options.DiscoveryFunc)</span><br><span class="line">		<span class="keyword">if</span> discovery.IsGroupDiscoveryFailedError(err) &#123;</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"initial discovery check failure, continuing and counting on future sync update: %v"</span>, err))</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err = qm.SyncMonitors(ctx, resources); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"initial monitor sync has error: %v"</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// only start quota once all informers synced</span></span><br><span class="line">		rq.informerSyncedFuncs = <span class="built_in">append</span>(rq.informerSyncedFuncs, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> qm.IsSynced(ctx)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rq, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ControllerOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Must have authority to list all quotas, and update quota status</span></span><br><span class="line">	QuotaClient corev1client.ResourceQuotasGetter</span><br><span class="line">	<span class="comment">// Shared informer for resource quotas</span></span><br><span class="line">	ResourceQuotaInformer coreinformers.ResourceQuotaInformer</span><br><span class="line">	<span class="comment">// Controls full recalculation of quota usage</span></span><br><span class="line">	ResyncPeriod controller.ResyncPeriodFunc</span><br><span class="line">	<span class="comment">// Maintains evaluators that know how to calculate usage for group resource</span></span><br><span class="line">	Registry quota.Registry</span><br><span class="line">	<span class="comment">// Discover list of supported resources on the server.</span></span><br><span class="line">	DiscoveryFunc NamespacedResourcesFunc</span><br><span class="line">	<span class="comment">// A function that returns the list of resources to ignore</span></span><br><span class="line">	IgnoredResourcesFunc <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">map</span>[<span class="title">schema</span>.<span class="title">GroupResource</span>]<span class="title">struct</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">// InformersStarted knows if informers were started.</span></span><br><span class="line">	InformersStarted &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// InformerFactory interfaces with informers.</span></span><br><span class="line">	InformerFactory informerfactory.InformerFactory</span><br><span class="line">	<span class="comment">// Controls full resync of objects monitored for replenishment.</span></span><br><span class="line">	ReplenishmentResyncPeriod controller.ResyncPeriodFunc</span><br><span class="line">	<span class="comment">// Filters update events so we only enqueue the ones where we know quota will change</span></span><br><span class="line">	UpdateFilter UpdateFilter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syncHandler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rq *Controller)</span> <span class="title">syncResourceQuotaFromKey</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger = klog.LoggerWithValues(logger, <span class="string">"key"</span>, key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		logger.V(<span class="number">4</span>).Info(<span class="string">"Finished syncing resource quota"</span>, <span class="string">"key"</span>, key, <span class="string">"duration"</span>, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	resourceQuota, err := rq.rqLister.ResourceQuotas(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		logger.Info(<span class="string">"Resource quota has been deleted"</span>, <span class="string">"key"</span>, key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Error(err, <span class="string">"Unable to retrieve resource quota from store"</span>, <span class="string">"key"</span>, key)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rq.syncResourceQuota(ctx, resourceQuota)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// syncResourceQuota runs a complete sync of resource quota status across all known kinds</span></span><br><span class="line"><span class="comment">// 计算资源使用率并向api-serever上报</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rq *Controller)</span> <span class="title">syncResourceQuota</span><span class="params">(ctx context.Context, resourceQuota *v1.ResourceQuota)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// quota is dirty if any part of spec hard limits differs from the status hard limits</span></span><br><span class="line">	statusLimitsDirty := !apiequality.Semantic.DeepEqual(resourceQuota.Spec.Hard, resourceQuota.Status.Hard)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dirty tracks if the usage status differs from the previous sync,</span></span><br><span class="line">	<span class="comment">// if so, we send a new usage with latest status</span></span><br><span class="line">	<span class="comment">// if this is our first sync, it will be dirty by default, since we need track usage</span></span><br><span class="line">	dirty := statusLimitsDirty || resourceQuota.Status.Hard == <span class="literal">nil</span> || resourceQuota.Status.Used == <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	used := v1.ResourceList&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> resourceQuota.Status.Used != <span class="literal">nil</span> &#123;</span><br><span class="line">		used = quota.Add(v1.ResourceList&#123;&#125;, resourceQuota.Status.Used)</span><br><span class="line">	&#125;</span><br><span class="line">	hardLimits := quota.Add(v1.ResourceList&#123;&#125;, resourceQuota.Spec.Hard)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> errs []error</span><br><span class="line"></span><br><span class="line">	newUsage, err := quota.CalculateUsage(resourceQuota.Namespace, resourceQuota.Spec.Scopes, hardLimits, rq.registry, resourceQuota.Spec.ScopeSelector)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// if err is non-nil, remember it to return, but continue updating status with any resources in newUsage</span></span><br><span class="line">		errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> newUsage &#123;</span><br><span class="line">		used[key] = value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ensure set of used values match those that have hard constraints</span></span><br><span class="line">	hardResources := quota.ResourceNames(hardLimits)</span><br><span class="line">	used = quota.Mask(used, hardResources)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a usage object that is based on the quota resource version that will handle updates</span></span><br><span class="line">	<span class="comment">// by default, we preserve the past usage observation, and set hard to the current spec</span></span><br><span class="line">	usage := resourceQuota.DeepCopy()</span><br><span class="line">	usage.Status = v1.ResourceQuotaStatus&#123;</span><br><span class="line">		Hard: hardLimits,</span><br><span class="line">		Used: used,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dirty = dirty || !quota.Equals(usage.Status.Used, resourceQuota.Status.Used)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// there was a change observed by this controller that requires we update quota</span></span><br><span class="line">	<span class="keyword">if</span> dirty &#123;</span><br><span class="line">		_, err = rq.rqClient.ResourceQuotas(usage.Namespace).UpdateStatus(ctx, usage, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errs = <span class="built_in">append</span>(errs, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:</p>
<p>1.<a href="https://kubernetes.io/zh-cn/docs/concepts/policy/resource-quotas" target="_blank" rel="noopener">resource-quotas</a><br>2.<a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/quota-api-object" target="_blank" rel="noopener">quota-api-object</a><br>3.<a href="https://github.com/kubernetes/design-proposals-archive/blob/main/resource-management/admission_control_resource_quota.md" target="_blank" rel="noopener">admission_control_resource_quota</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/resourcequota/resource_quota_controller.go" target="_blank" rel="noopener">pkg/controller/resourcequota/resource_quota_controller.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之replicaset</title>
    <url>/2023/05/10/kube-controller%E4%B9%8Breplicaset/</url>
    <content><![CDATA[<p><code>ReplicaSet</code>维护一组<code>Pod</code>并使<code>Pod</code>数量和状态达到预期的状态。<code>Deployment</code>就是基于<code>ReplicaSet</code>的一层封装，官方并不建议直接使用<code>ReplicaSet</code>,而是使用<code>Deployment</code>。</p>
<p>使用下面的yaml创建对应的RS.<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">guestbook</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">php-redis</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">hysyeah/my-curl:v1</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplicaSetController <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// GroupVersionKind indicates the controller type.</span></span><br><span class="line">	<span class="comment">// Different instances of this struct may handle different GVKs.</span></span><br><span class="line">	<span class="comment">// For example, this struct can be used (with adapters) to handle ReplicationController.</span></span><br><span class="line">	schema.GroupVersionKind</span><br><span class="line"></span><br><span class="line">	kubeClient clientset.Interface</span><br><span class="line">	podControl controller.PodControlInterface</span><br><span class="line"></span><br><span class="line">	eventBroadcaster record.EventBroadcaster</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A ReplicaSet is temporarily suspended after creating/deleting these many replicas.</span></span><br><span class="line">	<span class="comment">// It resumes normal action after observing the watch events for them.</span></span><br><span class="line">	burstReplicas <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// To allow injection of syncReplicaSet for testing.</span></span><br><span class="line">	syncHandler <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, rsKey <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// A TTLCache of pod creates/deletes each rc expects to see.</span></span><br><span class="line">	expectations *controller.UIDTrackingControllerExpectations</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A store of ReplicaSets, populated by the shared informer passed to NewReplicaSetController</span></span><br><span class="line">	rsLister appslisters.ReplicaSetLister</span><br><span class="line">	<span class="comment">// rsListerSynced returns true if the pod store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	rsListerSynced cache.InformerSynced</span><br><span class="line">	rsIndexer      cache.Indexer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A store of pods, populated by the shared informer passed to NewReplicaSetController</span></span><br><span class="line">	podLister corelisters.PodLister</span><br><span class="line">	<span class="comment">// podListerSynced returns true if the pod store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	podListerSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Controllers that need to be synced</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReplicaSetController</span><span class="params">(logger klog.Logger, rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, kubeClient clientset.Interface, burstReplicas <span class="keyword">int</span>)</span> *<span class="title">ReplicaSetController</span></span> &#123;</span><br><span class="line">	eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">	<span class="keyword">if</span> err := metrics.Register(legacyregistry.Register); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Error(err, <span class="string">"unable to register metrics"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NewBaseController(rsInformer, podInformer, kubeClient, burstReplicas,</span><br><span class="line">		apps.SchemeGroupVersion.WithKind(<span class="string">"ReplicaSet"</span>),</span><br><span class="line">		<span class="string">"replicaset_controller"</span>,</span><br><span class="line">		<span class="string">"replicaset"</span>,</span><br><span class="line">		controller.RealPodControl&#123;</span><br><span class="line">			KubeClient: kubeClient,</span><br><span class="line">			Recorder:   eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"replicaset-controller"</span>&#125;),</span><br><span class="line">		&#125;,</span><br><span class="line">		eventBroadcaster,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个ReplicaSetController</span></span><br><span class="line"><span class="comment">// 监听ReplicaSet和Pod变化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBaseController</span><span class="params">(rsInformer appsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, kubeClient clientset.Interface, burstReplicas <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	gvk schema.GroupVersionKind, metricOwnerName, queueName <span class="keyword">string</span>, podControl controller.PodControlInterface, eventBroadcaster record.EventBroadcaster)</span> *<span class="title">ReplicaSetController</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	rsc := &amp;ReplicaSetController&#123;</span><br><span class="line">		GroupVersionKind: gvk,</span><br><span class="line">		kubeClient:       kubeClient,</span><br><span class="line">		podControl:       podControl,</span><br><span class="line">		eventBroadcaster: eventBroadcaster,</span><br><span class="line">		burstReplicas:    burstReplicas,</span><br><span class="line">		expectations:     controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectations()),</span><br><span class="line">		queue:            workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), queueName),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc:    rsc.addRS,</span><br><span class="line">		UpdateFunc: rsc.updateRS,</span><br><span class="line">		DeleteFunc: rsc.deleteRS,</span><br><span class="line">	&#125;)</span><br><span class="line">	rsInformer.Informer().AddIndexers(cache.Indexers&#123;</span><br><span class="line">		controllerUIDIndex: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">			rs, ok := obj.(*apps.ReplicaSet)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			controllerRef := metav1.GetControllerOf(rs)</span><br><span class="line">			<span class="keyword">if</span> controllerRef == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> []<span class="keyword">string</span>&#123;<span class="keyword">string</span>(controllerRef.UID)&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	rsc.rsIndexer = rsInformer.Informer().GetIndexer()</span><br><span class="line">	rsc.rsLister = rsInformer.Lister()</span><br><span class="line">	rsc.rsListerSynced = rsInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: rsc.addPod,</span><br><span class="line">		<span class="comment">// This invokes the ReplicaSet for every pod change, eg: host assignment. Though this might seem like</span></span><br><span class="line">		<span class="comment">// overkill the most frequent pod update is status, and the associated ReplicaSet will only list from</span></span><br><span class="line">		<span class="comment">// local storage, so it should be ok.</span></span><br><span class="line">		UpdateFunc: rsc.updatePod,</span><br><span class="line">		DeleteFunc: rsc.deletePod,</span><br><span class="line">	&#125;)</span><br><span class="line">	rsc.podLister = podInformer.Lister()</span><br><span class="line">	rsc.podListerSynced = podInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	rsc.syncHandler = rsc.syncReplicaSet</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rsc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run begins watching and syncing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start events processing pipeline.</span></span><br><span class="line">	rsc.eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">	rsc.eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: rsc.kubeClient.CoreV1().Events(<span class="string">""</span>)&#125;)</span><br><span class="line">	<span class="keyword">defer</span> rsc.eventBroadcaster.Shutdown()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> rsc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	controllerName := strings.ToLower(rsc.Kind)</span><br><span class="line">	klog.FromContext(ctx).Info(<span class="string">"Starting controller"</span>, <span class="string">"name"</span>, controllerName)</span><br><span class="line">	<span class="keyword">defer</span> klog.FromContext(ctx).Info(<span class="string">"Shutting down controller"</span>, <span class="string">"name"</span>, controllerName)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(rsc.Kind, ctx.Done(), rsc.podListerSynced, rsc.rsListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, rsc.worker, time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> rsc.processNextWorkItem(ctx) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">processNextWorkItem</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	key, quit := rsc.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> rsc.queue.Done(key)</span><br><span class="line"></span><br><span class="line">	err := rsc.syncHandler(ctx, key.(<span class="keyword">string</span>))</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果未发生错误,结束重试</span></span><br><span class="line">		rsc.queue.Forget(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	utilruntime.HandleError(fmt.Errorf(<span class="string">"sync %q failed with %v"</span>, key, err))</span><br><span class="line">    <span class="comment">// 发生错误则重新入队</span></span><br><span class="line">	rsc.queue.AddRateLimited(key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syncHandler函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">syncReplicaSet</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">    <span class="comment">// 记录此次syncReplicaSet耗时</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		klog.FromContext(ctx).V(<span class="number">4</span>).Info(<span class="string">"Finished syncing"</span>, <span class="string">"kind"</span>, rsc.Kind, <span class="string">"key"</span>, key, <span class="string">"duration"</span>, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 获取对应的RS</span></span><br><span class="line">	rs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">		klog.FromContext(ctx).V(<span class="number">4</span>).Info(<span class="string">"deleted"</span>, <span class="string">"kind"</span>, rsc.Kind, <span class="string">"key"</span>, key)</span><br><span class="line">		rsc.expectations.DeleteExpectations(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要Sync</span></span><br><span class="line">	rsNeedsSync := rsc.expectations.SatisfiedExpectations(key)</span><br><span class="line">	selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"error converting pod selector to selector for rs %v/%v: %v"</span>, namespace, name, err))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里会获取RS对应命名空间下的所有pod</span></span><br><span class="line">    <span class="comment">// 这是一个优化项,将下面的FilterActivePods合并为一步</span></span><br><span class="line">	allPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 返回所有Active Pod</span></span><br><span class="line">	filteredPods := controller.FilterActivePods(allPods)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> filteredPods are pointing to objects from cache - if you need to</span></span><br><span class="line">	<span class="comment">// modify them, you need to copy it first.</span></span><br><span class="line">    <span class="comment">// 新建的RS第一次调谐，filterdPod为nil</span></span><br><span class="line">	filteredPods, err = rsc.claimPods(ctx, rs, selector, filteredPods)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> manageReplicasErr error</span><br><span class="line">	<span class="keyword">if</span> rsNeedsSync &amp;&amp; rs.DeletionTimestamp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 操作pod</span></span><br><span class="line">		manageReplicasErr = rsc.manageReplicas(ctx, filteredPods, rs)</span><br><span class="line">	&#125;</span><br><span class="line">	rs = rs.DeepCopy()</span><br><span class="line">	newStatus := calculateStatus(rs, filteredPods, manageReplicasErr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Always updates status as pods come up or die.</span></span><br><span class="line">	updatedRS, err := updateReplicaSetStatus(klog.FromContext(ctx), rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Multiple things could lead to this update failing. Requeuing the replica set ensures</span></span><br><span class="line">		<span class="comment">// Returning an error causes a requeue without forcing a hotloop</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Resync the ReplicaSet after MinReadySeconds as a last line of defense to guard against clock-skew.</span></span><br><span class="line">	<span class="keyword">if</span> manageReplicasErr == <span class="literal">nil</span> &amp;&amp; updatedRS.Spec.MinReadySeconds &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">		updatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &amp;&amp;</span><br><span class="line">		updatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) &#123;</span><br><span class="line">		rsc.queue.AddAfter(key, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> manageReplicasErr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">claimPods</span><span class="params">(ctx context.Context, rs *apps.ReplicaSet, selector labels.Selector, filteredPods []*v1.Pod)</span> <span class="params">([]*v1.Pod, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// If any adoptions are attempted, we should first recheck for deletion with</span></span><br><span class="line">	<span class="comment">// an uncached quorum read sometime after listing Pods (see #42639).</span></span><br><span class="line">	canAdoptFunc := controller.RecheckDeletionTimestamp(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="params">(metav1.Object, error)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 获取最新的RS</span></span><br><span class="line">        <span class="comment">// 如果fresh.UID和rs.UID不相等. 说明rs不是最新的，直接返回error</span></span><br><span class="line">		fresh, err := rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace).Get(ctx, rs.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> fresh.UID != rs.UID &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"original %v %v/%v is gone: got uid %v, wanted %v"</span>, rsc.Kind, rs.Namespace, rs.Name, fresh.UID, rs.UID)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fresh, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">    <span class="comment">// 返回PodControllerRefManager</span></span><br><span class="line">    <span class="comment">// PodControllerRefManager实现了对Pod管理的一些方法</span></span><br><span class="line">	cm := controller.NewPodControllerRefManager(rsc.podControl, rs, selector, rsc.GroupVersionKind, canAdoptFunc)</span><br><span class="line">    <span class="comment">// 认领RS拥有的Pod</span></span><br><span class="line">	<span class="keyword">return</span> cm.ClaimPods(ctx, filteredPods)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 认领RS所拥有的Pod</span></span><br><span class="line"><span class="comment">// 如果selector匹配,收养orphans pod</span></span><br><span class="line"><span class="comment">// 如果selector不再匹配,释放对应的pod</span></span><br><span class="line"><span class="comment">// 如果error返回为nil,则表示本次调谐成功或者不需要调谐</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *PodControllerRefManager)</span> <span class="title">ClaimPods</span><span class="params">(ctx context.Context, pods []*v1.Pod, filters ...<span class="keyword">func</span>(*v1.Pod)</span> <span class="title">bool</span>) <span class="params">([]*v1.Pod, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> claimed []*v1.Pod</span><br><span class="line">	<span class="keyword">var</span> errlist []error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断pod.Labels和rs.Selector是否匹配</span></span><br><span class="line">	match := <span class="function"><span class="keyword">func</span><span class="params">(obj metav1.Object)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		pod := obj.(*v1.Pod)</span><br><span class="line">		<span class="comment">// Check selector first so filters only run on potentially matching Pods.</span></span><br><span class="line">		<span class="keyword">if</span> !m.Selector.Matches(labels.Set(pod.Labels)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, filter := <span class="keyword">range</span> filters &#123;</span><br><span class="line">			<span class="keyword">if</span> !filter(pod) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 收养一个pod</span></span><br><span class="line">    <span class="comment">// 如果某个 Pod 没有 OwnerReference 或者其 OwnerReference 不是一个控制器， </span></span><br><span class="line">    <span class="comment">// 且其匹配到某 ReplicaSet 的选择算符，则该 Pod 立即被此 ReplicaSet 获得。</span></span><br><span class="line">	adopt := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, obj metav1.Object)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> m.AdoptPod(ctx, obj.(*v1.Pod))</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果不再匹配则释放对应的pod</span></span><br><span class="line">	release := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, obj metav1.Object)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> m.ReleasePod(ctx, obj.(*v1.Pod))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		ok, err := m.ClaimObject(ctx, pod, match, adopt, release)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			errlist = <span class="built_in">append</span>(errlist, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			claimed = <span class="built_in">append</span>(claimed, pod)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果是新建的RS第一次调谐,claimed为nil</span></span><br><span class="line">	<span class="keyword">return</span> claimed, utilerrors.NewAggregate(errlist)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对replicas进行操作</span></span><br><span class="line"><span class="comment">// 不能直接对&lt;filteredPods&gt;进行修改</span></span><br><span class="line"><span class="comment">// 因为这个过程可能失败，失败后需要重新入队</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">manageReplicas</span><span class="params">(ctx context.Context, filteredPods []*v1.Pod, rs *apps.ReplicaSet)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 新建的RS,len(filteredPods)=0</span></span><br><span class="line">    <span class="comment">// 如果replicas=3,则diff=-3</span></span><br><span class="line">    diff := <span class="built_in">len</span>(filteredPods) - <span class="keyword">int</span>(*(rs.Spec.Replicas))</span><br><span class="line">    <span class="comment">// rsKey = default/frontend</span></span><br><span class="line">	rsKey, err := controller.KeyFunc(rs)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"couldn't get key for %v %#v: %v"</span>, rsc.Kind, rs, err))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// diff&lt;0,说明需要增加pod</span></span><br><span class="line">	<span class="keyword">if</span> diff &lt; <span class="number">0</span> &#123;</span><br><span class="line">		diff *= <span class="number">-1</span></span><br><span class="line">		<span class="keyword">if</span> diff &gt; rsc.burstReplicas &#123;</span><br><span class="line">			diff = rsc.burstReplicas</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Track UIDs of creates just like deletes. The problem currently</span></span><br><span class="line">		<span class="comment">// is we'd need to wait on the result of a create to record the pod's</span></span><br><span class="line">		<span class="comment">// UID, which would require locking *across* the create, which will turn</span></span><br><span class="line">		<span class="comment">// into a performance bottleneck. We should generate a UID for the pod</span></span><br><span class="line">		<span class="comment">// beforehand and store it via ExpectCreations.</span></span><br><span class="line">        <span class="comment">// 向Controller注册最的Expection</span></span><br><span class="line">		rsc.expectations.ExpectCreations(rsKey, diff)</span><br><span class="line">		klog.FromContext(ctx).V(<span class="number">2</span>).Info(<span class="string">"Too few replicas"</span>, <span class="string">"replicaSet"</span>, klog.KObj(rs), <span class="string">"need"</span>, *(rs.Spec.Replicas), <span class="string">"creating"</span>, diff)</span><br><span class="line">		<span class="comment">// Batch the pod creates. Batch sizes start at SlowStartInitialBatchSize</span></span><br><span class="line">		<span class="comment">// and double with each successful iteration in a kind of "slow start".</span></span><br><span class="line">		<span class="comment">// This handles attempts to start large numbers of pods that would</span></span><br><span class="line">		<span class="comment">// likely all fail with the same error. For example a project with a</span></span><br><span class="line">		<span class="comment">// low quota that attempts to create a large number of pods will be</span></span><br><span class="line">		<span class="comment">// prevented from spamming the API service with the pod create requests</span></span><br><span class="line">		<span class="comment">// after one of its pods fails.  Conveniently, this also prevents the</span></span><br><span class="line">		<span class="comment">// event spam that those failures would generate.</span></span><br><span class="line">		successfulCreations, err := slowStartBatch(diff, controller.SlowStartInitialBatchSize, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="comment">// 调用接口创建pod</span></span><br><span class="line">			err := rsc.podControl.CreatePods(ctx, rs.Namespace, &amp;rs.Spec.Template, rs, metav1.NewControllerRef(rs, rsc.GroupVersionKind))</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> apierrors.HasStatusCause(err, v1.NamespaceTerminatingCause) &#123;</span><br><span class="line">					<span class="comment">// if the namespace is being terminated, we don't have to do</span></span><br><span class="line">					<span class="comment">// anything because any creation will fail</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Any skipped pods that we never attempted to start shouldn't be expected.</span></span><br><span class="line">		<span class="comment">// The skipped pods will be retried later. The next controller resync will</span></span><br><span class="line">		<span class="comment">// retry the slow start process.</span></span><br><span class="line">		<span class="keyword">if</span> skippedPods := diff - successfulCreations; skippedPods &gt; <span class="number">0</span> &#123;</span><br><span class="line">			klog.FromContext(ctx).V(<span class="number">2</span>).Info(<span class="string">"Slow-start failure. Skipping creation of pods, decrementing expectations"</span>, <span class="string">"podsSkipped"</span>, skippedPods, <span class="string">"kind"</span>, rsc.Kind, <span class="string">"replicaSet"</span>, klog.KObj(rs))</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; skippedPods; i++ &#123;</span><br><span class="line">				<span class="comment">// Decrement the expected number of creates because the informer won't observe this pod</span></span><br><span class="line">				rsc.expectations.CreationObserved(rsKey)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> diff &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> diff &gt; rsc.burstReplicas &#123;</span><br><span class="line">			diff = rsc.burstReplicas</span><br><span class="line">		&#125;</span><br><span class="line">		klog.FromContext(ctx).V(<span class="number">2</span>).Info(<span class="string">"Too many replicas"</span>, <span class="string">"replicaSet"</span>, klog.KObj(rs), <span class="string">"need"</span>, *(rs.Spec.Replicas), <span class="string">"deleting"</span>, diff)</span><br><span class="line"></span><br><span class="line">		relatedPods, err := rsc.getIndirectlyRelatedPods(klog.FromContext(ctx), rs)</span><br><span class="line">		utilruntime.HandleError(err)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Choose which Pods to delete, preferring those in earlier phases of startup.</span></span><br><span class="line">		podsToDelete := getPodsToDelete(filteredPods, relatedPods, diff)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Snapshot the UIDs (ns/name) of the pods we're expecting to see</span></span><br><span class="line">		<span class="comment">// deleted, so we know to record their expectations exactly once either</span></span><br><span class="line">		<span class="comment">// when we see it as an update of the deletion timestamp, or as a delete.</span></span><br><span class="line">		<span class="comment">// Note that if the labels on a pod/rs change in a way that the pod gets</span></span><br><span class="line">		<span class="comment">// orphaned, the rs will only wake up after the expectations have</span></span><br><span class="line">		<span class="comment">// expired even if other pods are deleted.</span></span><br><span class="line">		rsc.expectations.ExpectDeletions(rsKey, getPodKeys(podsToDelete))</span><br><span class="line"></span><br><span class="line">		errCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, diff)</span><br><span class="line">		<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">		wg.Add(diff)</span><br><span class="line">		<span class="keyword">for</span> _, pod := <span class="keyword">range</span> podsToDelete &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(targetPod *v1.Pod)</span></span> &#123;</span><br><span class="line">				<span class="keyword">defer</span> wg.Done()</span><br><span class="line">                <span class="comment">// 删除多余的pod</span></span><br><span class="line">				<span class="keyword">if</span> err := rsc.podControl.DeletePod(ctx, rs.Namespace, targetPod.Name, rs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="comment">// Decrement the expected number of deletes because the informer won't observe this deletion</span></span><br><span class="line">					podKey := controller.PodKey(targetPod)</span><br><span class="line">					rsc.expectations.DeletionObserved(rsKey, podKey)</span><br><span class="line">					<span class="keyword">if</span> !apierrors.IsNotFound(err) &#123;</span><br><span class="line">						klog.FromContext(ctx).V(<span class="number">2</span>).Info(<span class="string">"Failed to delete pod, decremented expectations"</span>, <span class="string">"pod"</span>, podKey, <span class="string">"kind"</span>, rsc.Kind, <span class="string">"replicaSet"</span>, klog.KObj(rs))</span><br><span class="line">						errCh &lt;- err</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(pod)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> err := &lt;-errCh:</span><br><span class="line">			<span class="comment">// all errors have been reported before and they're likely to be the same, so we'll only return the first one we hit.</span></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/replicaset/replica_set.go" target="_blank" rel="noopener">pkg/controller/replicaset/replica_set.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/controller_ref_manager.go" target="_blank" rel="noopener">pkg/controller/controller_ref_manager.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之ttl</title>
    <url>/2023/06/17/kube-controller%E4%B9%8Bttl/</url>
    <content><![CDATA[<p>在<code>k8s</code>中<code>TTLController</code>负责根据集群大小在<code>Node</code>上设置<code>ttl annotations</code>。<code>TTL annotations</code>告诉<code>kubelet</code>在重新请求<code>APISerever</code>之前<br>可以缓存资源对象(比如: secrets,configmap)多长时间。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/ttl/ttl_controller.go</span></span><br><span class="line"><span class="comment">// Controller sets ttl annotations on nodes, based on cluster size.</span></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	kubeClient clientset.Interface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓存集群节点信息</span></span><br><span class="line">	nodeStore listers.NodeLister</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Nodes that need to be synced.</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Returns true if all underlying informers are synced.</span></span><br><span class="line">	hasSynced <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line">	lock sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 集群节点大小</span></span><br><span class="line">	nodeCount <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 期望的TTL</span></span><br><span class="line">	desiredTTLSeconds <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示目前所处的集群规模大小</span></span><br><span class="line">    <span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line">    <span class="comment">// boundaryStep  --&gt; 节点范围  --&gt; desiredTTLSeconds</span></span><br><span class="line">    <span class="comment">// 0 --&gt; [0,100]     0</span></span><br><span class="line">    <span class="comment">// 1 --&gt; [90, 500]   15</span></span><br><span class="line">    <span class="comment">// 2 --&gt; [450, 100]  30</span></span><br><span class="line">    <span class="comment">// 3 --&gt; [900, 2000] 60</span></span><br><span class="line">    <span class="comment">// 4 --&gt; [1800, ~]   300</span></span><br><span class="line">	boundaryStep <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTTLController creates a new TTLController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTTLController</span><span class="params">(ctx context.Context, nodeInformer informers.NodeInformer, kubeClient clientset.Interface)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">	ttlc := &amp;Controller&#123;</span><br><span class="line">		kubeClient: kubeClient,</span><br><span class="line">		queue:      workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"ttlcontroller"</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	nodeInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			ttlc.addNode(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			ttlc.updateNode(logger, old, newObj)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: ttlc.deleteNode,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	ttlc.nodeStore = listers.NewNodeLister(nodeInformer.Informer().GetIndexer())</span><br><span class="line">	ttlc.hasSynced = nodeInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ttlc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ttlBoundary <span class="keyword">struct</span> &#123;</span><br><span class="line">	sizeMin    <span class="keyword">int</span></span><br><span class="line">	sizeMax    <span class="keyword">int</span></span><br><span class="line">	ttlSeconds <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了不同节点范围的集群下的TTL</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ttlBoundaries = []ttlBoundary&#123;</span><br><span class="line">		&#123;sizeMin: <span class="number">0</span>, sizeMax: <span class="number">100</span>, ttlSeconds: <span class="number">0</span>&#125;,</span><br><span class="line">		&#123;sizeMin: <span class="number">90</span>, sizeMax: <span class="number">500</span>, ttlSeconds: <span class="number">15</span>&#125;,</span><br><span class="line">		&#123;sizeMin: <span class="number">450</span>, sizeMax: <span class="number">1000</span>, ttlSeconds: <span class="number">30</span>&#125;,</span><br><span class="line">		&#123;sizeMin: <span class="number">900</span>, sizeMax: <span class="number">2000</span>, ttlSeconds: <span class="number">60</span>&#125;,</span><br><span class="line">		&#123;sizeMin: <span class="number">1800</span>, sizeMax: math.MaxInt32, ttlSeconds: <span class="number">300</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run begins watching and syncing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ttlc *Controller)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> ttlc.queue.ShutDown()</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.Info(<span class="string">"Starting TTL controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> logger.Info(<span class="string">"Shutting down TTL controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"TTL"</span>, ctx.Done(), ttlc.hasSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, ttlc.worker, time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ttlc *Controller)</span> <span class="title">addNode</span><span class="params">(logger klog.Logger, obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	node, ok := obj.(*v1.Node)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"unexpected object type: %v"</span>, obj))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ttlc.lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> ttlc.lock.Unlock()</span><br><span class="line">        <span class="comment">// 集群节点数加1</span></span><br><span class="line">		ttlc.nodeCount++</span><br><span class="line">		<span class="keyword">if</span> ttlc.nodeCount &gt; ttlBoundaries[ttlc.boundaryStep].sizeMax &#123;</span><br><span class="line">            <span class="comment">// 超过当前规模的最大值，则加1进入下一规模，ttlSeconds相应的也会增加</span></span><br><span class="line">			ttlc.boundaryStep++</span><br><span class="line">			ttlc.desiredTTLSeconds = ttlBoundaries[ttlc.boundaryStep].ttlSeconds</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">	ttlc.enqueueNode(logger, node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ttlc *Controller)</span> <span class="title">updateNode</span><span class="params">(logger klog.Logger, _, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	node, ok := newObj.(*v1.Node)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"unexpected object type: %v"</span>, newObj))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Processing all updates of nodes guarantees that we will update</span></span><br><span class="line">	<span class="comment">// the ttl annotation, when cluster size changes.</span></span><br><span class="line">	<span class="comment">// We are relying on the fact that Kubelet is updating node status</span></span><br><span class="line">	<span class="comment">// every 10s (or generally every X seconds), which means that whenever</span></span><br><span class="line">	<span class="comment">// required, its ttl annotation should be updated within that period.</span></span><br><span class="line">	ttlc.enqueueNode(logger, node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ttlc *Controller)</span> <span class="title">deleteNode</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	_, ok := obj.(*v1.Node)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		tombstone, ok := obj.(cache.DeletedFinalStateUnknown)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"unexpected object type: %v"</span>, obj))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		_, ok = tombstone.Obj.(*v1.Node)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"unexpected object types: %v"</span>, obj))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ttlc.lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> ttlc.lock.Unlock()</span><br><span class="line">        <span class="comment">// 节点减1</span></span><br><span class="line">		ttlc.nodeCount--</span><br><span class="line">		<span class="keyword">if</span> ttlc.nodeCount &lt; ttlBoundaries[ttlc.boundaryStep].sizeMin &#123;</span><br><span class="line">            <span class="comment">// 如果小于当前规模的最小值，则减1进入回到上一规模，ttlSeconds相应的也会减小</span></span><br><span class="line">			ttlc.boundaryStep--</span><br><span class="line">			ttlc.desiredTTLSeconds = ttlBoundaries[ttlc.boundaryStep].ttlSeconds</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// 这里我们不再对节点进行处理，因为节点已经不存在了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ttlc *Controller)</span> <span class="title">enqueueNode</span><span class="params">(logger klog.Logger, node *v1.Node)</span></span> &#123;</span><br><span class="line">	key, err := controller.KeyFunc(node)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Error(<span class="literal">nil</span>, <span class="string">"Couldn't get key for object"</span>, <span class="string">"object"</span>, klog.KObj(node))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ttlc.queue.Add(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ttlc *Controller)</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> ttlc.processItem(ctx) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ttlc *Controller)</span> <span class="title">processItem</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	key, quit := ttlc.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> ttlc.queue.Done(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是调谐函数</span></span><br><span class="line">	err := ttlc.updateNodeIfNeeded(ctx, key.(<span class="keyword">string</span>))</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		ttlc.queue.Forget(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ttlc.queue.AddRateLimited(key)</span><br><span class="line">	utilruntime.HandleError(err)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ttlc *Controller)</span> <span class="title">getDesiredTTLSeconds</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ttlc.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> ttlc.lock.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> ttlc.desiredTTLSeconds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntFromAnnotation</span><span class="params">(ctx context.Context, node *v1.Node, annotationKey <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node.Annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	annotationValue, ok := node.Annotations[annotationKey]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	intValue, err := strconv.Atoi(annotationValue)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger := klog.FromContext(ctx)</span><br><span class="line">		logger.Info(<span class="string">"Could not convert the value with annotation key for the node"</span>, <span class="string">"annotationValue"</span>,</span><br><span class="line">			annotationValue, <span class="string">"annotationKey"</span>, annotationKey, <span class="string">"node"</span>, klog.KObj(node))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> intValue, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setIntAnnotation</span><span class="params">(node *v1.Node, annotationKey <span class="keyword">string</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node.Annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">		node.Annotations = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	node.Annotations[annotationKey] = strconv.Itoa(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ttlc *Controller)</span> <span class="title">patchNodeWithAnnotation</span><span class="params">(ctx context.Context, node *v1.Node, annotationKey <span class="keyword">string</span>, value <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	oldData, err := json.Marshal(node)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	setIntAnnotation(node, annotationKey, value)</span><br><span class="line">	newData, err := json.Marshal(node)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	patchBytes, err := strategicpatch.CreateTwoWayMergePatch(oldData, newData, &amp;v1.Node&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = ttlc.kubeClient.CoreV1().Nodes().Patch(ctx, node.Name, types.StrategicMergePatchType, patchBytes, metav1.PatchOptions&#123;&#125;)</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.V(<span class="number">2</span>).Info(<span class="string">"Failed to change ttl annotation for node"</span>, <span class="string">"node"</span>, klog.KObj(node), <span class="string">"err"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	logger.V(<span class="number">2</span>).Info(<span class="string">"Changed ttl annotation"</span>, <span class="string">"node"</span>, klog.KObj(node), <span class="string">"TTL"</span>, time.Duration(value)*time.Second)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ttlc *Controller)</span> <span class="title">updateNodeIfNeeded</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	node, err := ttlc.nodeStore.Get(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 预期的TTL</span></span><br><span class="line">	desiredTTL := ttlc.getDesiredTTLSeconds()</span><br><span class="line">    <span class="comment">// 当前的TTL</span></span><br><span class="line">	currentTTL, ok := getIntFromAnnotation(ctx, node, v1.ObjectTTLAnnotationKey)</span><br><span class="line">	<span class="keyword">if</span> ok &amp;&amp; currentTTL == desiredTTL &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新TTL</span></span><br><span class="line">	<span class="keyword">return</span> ttlc.patchNodeWithAnnotation(ctx, node.DeepCopy(), v1.ObjectTTLAnnotationKey, desiredTTL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/ttl/ttl_controller.go" target="_blank" rel="noopener">pkg/controller/ttl/ttl_controller.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之resourceclaim</title>
    <url>/2023/06/18/kube-controller%E4%B9%8Bresourceclaim/</url>
    <content><![CDATA[<h5 id="动态资源分配"><a href="#动态资源分配" class="headerlink" title="动态资源分配"></a>动态资源分配</h5><p>动态资源分配是一个用于在 Pod 之间和 Pod 内部容器之间请求和共享资源的新 API。 它是对为通用资源所提供的持久卷 API 的泛化。第三方资源驱动程序负责跟踪和分配资源。 不同类型的资源支持用任意参数进行定义和初始化.</p>
<p>resource.k8s.io/v1alpha2 API 组提供四种新类型：</p>
<p>ResourceClass<br>定义由哪个资源驱动程序处理某种资源，并为其提供通用参数。 集群管理员在安装资源驱动程序时创建 ResourceClass。<br>ResourceClaim<br>定义工作负载所需的特定资源实例。 由用户创建（手动管理生命周期，可以在不同的 Pod 之间共享）， 或者由控制平面基于 ResourceClaimTemplate 为特定 Pod 创建 （自动管理生命周期，通常仅由一个 Pod 使用）。<br>ResourceClaimTemplate<br>定义用于创建 ResourceClaim 的 spec 和一些元数据。 部署工作负载时由用户创建。<br>PodSchedulingContext<br>供控制平面和资源驱动程序内部使用， 在需要为 Pod 分配 ResourceClaim 时协调 Pod 调度。<br>ResourceClass 和 ResourceClaim 的参数存储在单独的对象中， 通常使用安装资源驱动程序时创建的 CRD 所定义的类型。</p>
<p>core/v1 的 PodSpec 在新的 resourceClaims 字段中定义 Pod 所需的 ResourceClaim。 该列表中的条目引用 ResourceClaim 或 ResourceClaimTemplate。 当引用 ResourceClaim 时，使用此 PodSpec 的所有 Pod （例如 Deployment 或 StatefulSet 中的 Pod）共享相同的 ResourceClaim 实例。 引用 ResourceClaimTemplate 时，每个 Pod 都有自己的实例。</p>
<p>容器资源的 resources.claims 列表定义容器可以访问的资源实例， 从而可以实现在一个或多个容器之间共享资源。</p>
<p>下面是一个虚构的资源驱动程序的示例。 该示例将为此 Pod 创建两个 ResourceClaim 对象，每个容器都可以访问其中一个。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">piVersion:</span> <span class="string">resource.k8s.io/v1alpha2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ResourceClass</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">resource.example.com</span></span><br><span class="line"><span class="attr">driverName:</span> <span class="string">resource-driver.example.com</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">cats.resource.example.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClaimParameters</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">large-black-cat-claim-parameters</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">black</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">large</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">resource.k8s.io/v1alpha2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ResourceClaimTemplate</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">large-black-cat-claim-template</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">resourceClassName:</span> <span class="string">resource.example.com</span></span><br><span class="line">    <span class="attr">parametersRef:</span></span><br><span class="line">      <span class="attr">apiGroup:</span> <span class="string">cats.resource.example.com</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">ClaimParameters</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">large-black-cat-claim-parameters</span></span><br><span class="line"><span class="string">–--</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-with-cats</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">container0</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ubuntu:20.04</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["sleep",</span> <span class="string">"9999"</span><span class="string">]</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">claims:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cat-0</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">container1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ubuntu:20.04</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["sleep",</span> <span class="string">"9999"</span><span class="string">]</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">claims:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cat-1</span></span><br><span class="line">  <span class="attr">resourceClaims:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cat-0</span></span><br><span class="line">    <span class="attr">source:</span></span><br><span class="line">      <span class="attr">resourceClaimTemplateName:</span> <span class="string">large-black-cat-claim-template</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cat-1</span></span><br><span class="line">    <span class="attr">source:</span></span><br><span class="line">      <span class="attr">resourceClaimTemplateName:</span> <span class="string">large-black-cat-claim-template</span></span><br></pre></td></tr></table></figure>
<h5 id="resourceClaim"><a href="#resourceClaim" class="headerlink" title="resourceClaim"></a>resourceClaim</h5><p><code>resourceClaim Controller</code>的作用就是根据<code>pod spec</code>中的<code>ResourceClaimTemplates</code>创建对应的<code>ResourceClaims</code>。</p>
<h5 id="resourceClaim源码分析"><a href="#resourceClaim源码分析" class="headerlink" title="resourceClaim源码分析"></a>resourceClaim源码分析</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// pkg/controller/resourceclaim/controller.go</span></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// kubeClient is the kube API client used to communicate with the API</span></span><br><span class="line">	<span class="comment">// server.</span></span><br><span class="line">	kubeClient clientset.Interface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// claimLister is the shared ResourceClaim lister used to fetch and store ResourceClaim</span></span><br><span class="line">	<span class="comment">// objects from the API server. It is shared with other controllers and</span></span><br><span class="line">	<span class="comment">// therefore the ResourceClaim objects in its store should be treated as immutable.</span></span><br><span class="line">	claimLister  resourcev1alpha2listers.ResourceClaimLister</span><br><span class="line">	claimsSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// podLister is the shared Pod lister used to fetch Pod</span></span><br><span class="line">	<span class="comment">// objects from the API server. It is shared with other controllers and</span></span><br><span class="line">	<span class="comment">// therefore the Pod objects in its store should be treated as immutable.</span></span><br><span class="line">	podLister v1listers.PodLister</span><br><span class="line">	podSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// templateLister is the shared ResourceClaimTemplate lister used to</span></span><br><span class="line">	<span class="comment">// fetch template objects from the API server. It is shared with other</span></span><br><span class="line">	<span class="comment">// controllers and therefore the objects in its store should be treated</span></span><br><span class="line">	<span class="comment">// as immutable.</span></span><br><span class="line">	templateLister  resourcev1alpha2listers.ResourceClaimTemplateLister</span><br><span class="line">	templatesSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// podIndexer has the common PodResourceClaim indexer indexer installed To</span></span><br><span class="line">	<span class="comment">// limit iteration over pods to those of interest.</span></span><br><span class="line">	podIndexer cache.Indexer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// recorder is used to record events in the API server</span></span><br><span class="line">	recorder record.EventRecorder</span><br><span class="line"></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The deletedObjects cache keeps track of Pods for which we know that</span></span><br><span class="line">	<span class="comment">// they have existed and have been removed. For those we can be sure</span></span><br><span class="line">	<span class="comment">// that a ReservedFor entry needs to be removed.</span></span><br><span class="line">	deletedObjects *uidCache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建resourceClaim Controller</span></span><br><span class="line"><span class="comment">// resourceClaim为pod和resourceClaim添加事件监听</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	kubeClient clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	podInformer v1informers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	claimInformer resourcev1alpha2informers.ResourceClaimInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	templateInformer resourcev1alpha2informers.ResourceClaimTemplateInformer)</span> <span class="params">(*Controller, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ec := &amp;Controller&#123;</span><br><span class="line">		kubeClient:      kubeClient,</span><br><span class="line">		podLister:       podInformer.Lister(),</span><br><span class="line">		podIndexer:      podInformer.Informer().GetIndexer(),</span><br><span class="line">		podSynced:       podInformer.Informer().HasSynced,</span><br><span class="line">		claimLister:     claimInformer.Lister(),</span><br><span class="line">		claimsSynced:    claimInformer.Informer().HasSynced,</span><br><span class="line">		templateLister:  templateInformer.Lister(),</span><br><span class="line">		templatesSynced: templateInformer.Informer().HasSynced,</span><br><span class="line">		queue:           workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"resource_claim"</span>),</span><br><span class="line">		deletedObjects:  newUIDCache(maxUIDCacheEntries),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	metrics.RegisterMetrics()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err := podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			ec.enqueuePod(obj, <span class="literal">false</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, updated <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			ec.enqueuePod(updated, <span class="literal">false</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			ec.enqueuePod(obj, <span class="literal">true</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, err := claimInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: ec.onResourceClaimAddOrUpdate,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, updated <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			ec.onResourceClaimAddOrUpdate(updated)</span><br><span class="line">		&#125;,</span><br><span class="line">		DeleteFunc: ec.onResourceClaimDelete,</span><br><span class="line">	&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := ec.podIndexer.AddIndexers(cache.Indexers&#123;podResourceClaimIndex: podResourceClaimIndexFunc&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"could not initialize ResourceClaim controller: %w"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ec, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ec *Controller)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> ec.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.Info(<span class="string">"Starting ephemeral volume controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> logger.Info(<span class="string">"Shutting down ephemeral volume controller"</span>)</span><br><span class="line"></span><br><span class="line">	eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">	eventBroadcaster.StartLogging(klog.Infof)</span><br><span class="line">	eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: ec.kubeClient.CoreV1().Events(<span class="string">""</span>)&#125;)</span><br><span class="line">	ec.recorder = eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"resource_claim"</span>&#125;)</span><br><span class="line">	<span class="keyword">defer</span> eventBroadcaster.Shutdown()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"ephemeral"</span>, ctx.Done(), ec.podSynced, ec.claimsSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, ec.runWorker, time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ec *Controller)</span> <span class="title">runWorker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> ec.processNextWorkItem(ctx) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ec *Controller)</span> <span class="title">processNextWorkItem</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	key, shutdown := ec.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> shutdown &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> ec.queue.Done(key)</span><br><span class="line"></span><br><span class="line">	err := ec.syncHandler(ctx, key.(<span class="keyword">string</span>))</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		ec.queue.Forget(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	runtime.HandleError(fmt.Errorf(<span class="string">"%v failed with: %v"</span>, key, err))</span><br><span class="line">	ec.queue.AddRateLimited(key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syncHandler is invoked for each work item which might need to be processed.</span></span><br><span class="line"><span class="comment">// If an error is returned from this function, the item will be requeued.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ec *Controller)</span> <span class="title">syncHandler</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	sep := strings.Index(key, <span class="string">":"</span>)</span><br><span class="line">	<span class="keyword">if</span> sep &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unexpected key: %s"</span>, key)</span><br><span class="line">	&#125;</span><br><span class="line">	prefix, object := key[<span class="number">0</span>:sep+<span class="number">1</span>], key[sep+<span class="number">1</span>:]</span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(object)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 通过prefix判断是pod事件还是resourceClaim事件，从而调用不同的处理函数</span></span><br><span class="line">	<span class="keyword">switch</span> prefix &#123;</span><br><span class="line">	<span class="keyword">case</span> podKeyPrefix:</span><br><span class="line">		<span class="keyword">return</span> ec.syncPod(ctx, namespace, name)</span><br><span class="line">	<span class="keyword">case</span> claimKeyPrefix:</span><br><span class="line">		<span class="keyword">return</span> ec.syncClaim(ctx, namespace, name)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unexpected key prefix: %s"</span>, prefix)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ec *Controller)</span> <span class="title">syncPod</span><span class="params">(ctx context.Context, namespace, name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	logger := klog.LoggerWithValues(klog.FromContext(ctx), <span class="string">"pod"</span>, klog.KRef(namespace, name))</span><br><span class="line">	ctx = klog.NewContext(ctx, logger)</span><br><span class="line">	pod, err := ec.podLister.Pods(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">			logger.V(<span class="number">5</span>).Info(<span class="string">"nothing to do for pod, it is gone"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ignore pods which are already getting deleted.</span></span><br><span class="line">	<span class="keyword">if</span> pod.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.V(<span class="number">5</span>).Info(<span class="string">"nothing to do for pod, it is marked for deletion"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, podClaim := <span class="keyword">range</span> pod.Spec.ResourceClaims &#123;</span><br><span class="line">		<span class="keyword">if</span> err := ec.handleClaim(ctx, pod, podClaim); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ec.recorder != <span class="literal">nil</span> &#123;</span><br><span class="line">				ec.recorder.Event(pod, v1.EventTypeWarning, <span class="string">"FailedResourceClaimCreation"</span>, fmt.Sprintf(<span class="string">"PodResourceClaim %s: %v"</span>, podClaim.Name, err))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"pod %s/%s, PodResourceClaim %s: %v"</span>, namespace, name, podClaim.Name, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ec *Controller)</span> <span class="title">syncClaim</span><span class="params">(ctx context.Context, namespace, name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	logger := klog.LoggerWithValues(klog.FromContext(ctx), <span class="string">"PVC"</span>, klog.KRef(namespace, name))</span><br><span class="line">	ctx = klog.NewContext(ctx, logger)</span><br><span class="line">	claim, err := ec.claimLister.ResourceClaims(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">			logger.V(<span class="number">5</span>).Info(<span class="string">"nothing to do for claim, it is gone"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if the ReservedFor entries are all still valid.</span></span><br><span class="line">	valid := <span class="built_in">make</span>([]resourcev1alpha2.ResourceClaimConsumerReference, <span class="number">0</span>, <span class="built_in">len</span>(claim.Status.ReservedFor))</span><br><span class="line">	<span class="keyword">for</span> _, reservedFor := <span class="keyword">range</span> claim.Status.ReservedFor &#123;</span><br><span class="line">		<span class="keyword">if</span> reservedFor.APIGroup == <span class="string">""</span> &amp;&amp;</span><br><span class="line">			reservedFor.Resource == <span class="string">"pods"</span> &#123;</span><br><span class="line">			<span class="comment">// A pod falls into one of three categories:</span></span><br><span class="line">			<span class="comment">// - we have it in our cache -&gt; don't remove it until we are told that it got removed</span></span><br><span class="line">			<span class="comment">// - we don't have it in our cache anymore, but we have seen it before -&gt; it was deleted, remove it</span></span><br><span class="line">			<span class="comment">// - not in our cache, not seen -&gt; double-check with API server before removal</span></span><br><span class="line"></span><br><span class="line">			keepEntry := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tracking deleted pods in the LRU cache is an</span></span><br><span class="line">			<span class="comment">// optimization. Without this cache, the code would</span></span><br><span class="line">			<span class="comment">// have to do the API call below for every deleted pod</span></span><br><span class="line">			<span class="comment">// to ensure that the pod really doesn't exist. With</span></span><br><span class="line">			<span class="comment">// the cache, most of the time the pod will be recorded</span></span><br><span class="line">			<span class="comment">// as deleted and the API call can be avoided.</span></span><br><span class="line">			<span class="keyword">if</span> ec.deletedObjects.Has(reservedFor.UID) &#123;</span><br><span class="line">				<span class="comment">// We know that the pod was deleted. This is</span></span><br><span class="line">				<span class="comment">// easy to check and thus is done first.</span></span><br><span class="line">				keepEntry = <span class="literal">false</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				pod, err := ec.podLister.Pods(claim.Namespace).Get(reservedFor.Name)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.IsNotFound(err) &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> pod == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="comment">// We might not have it in our informer cache</span></span><br><span class="line">					<span class="comment">// yet. Removing the pod while the scheduler is</span></span><br><span class="line">					<span class="comment">// scheduling it would be bad. We have to be</span></span><br><span class="line">					<span class="comment">// absolutely sure and thus have to check with</span></span><br><span class="line">					<span class="comment">// the API server.</span></span><br><span class="line">					pod, err := ec.kubeClient.CoreV1().Pods(claim.Namespace).Get(ctx, reservedFor.Name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.IsNotFound(err) &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> pod == <span class="literal">nil</span> || pod.UID != reservedFor.UID &#123;</span><br><span class="line">						keepEntry = <span class="literal">false</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> pod.UID != reservedFor.UID &#123;</span><br><span class="line">					<span class="comment">// Pod exists, but is a different incarnation under the same name.</span></span><br><span class="line">					keepEntry = <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> keepEntry &#123;</span><br><span class="line">				valid = <span class="built_in">append</span>(valid, reservedFor)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> support generic object lookup</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"unsupported ReservedFor entry: %v"</span>, reservedFor)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(valid) &lt; <span class="built_in">len</span>(claim.Status.ReservedFor) &#123;</span><br><span class="line">		<span class="comment">// TODO (#113700): patch</span></span><br><span class="line">		claim := claim.DeepCopy()</span><br><span class="line">		claim.Status.ReservedFor = valid</span><br><span class="line">		_, err := ec.kubeClient.ResourceV1alpha2().ResourceClaims(claim.Namespace).UpdateStatus(ctx, claim, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/dynamic-resource-allocation/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/dynamic-resource-allocation/</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/resourceclaim/controller.go" target="_blank" rel="noopener">pkg/controller/resourceclaim/controller.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之storageversion</title>
    <url>/2023/07/30/kube-controller%E4%B9%8Bstorageversion/</url>
    <content><![CDATA[<h3 id="Lease-storageVersion"><a href="#Lease-storageVersion" class="headerlink" title="Lease, storageVersion"></a>Lease, storageVersion</h3><p><code>Lease</code>(租约)租约提供了一种机制来锁定共享资源并协调集合成员之间的活动，<code>Kubernetes</code> 也使用 <code>Lease</code> 确保在任何给定时间某个组件只有一个实例在运行。 这在高可用配置中由 <code>kube-controller-manager</code> 和 <code>kube-scheduler</code> 等控制平面组件进行使用， 这些组件只应有一个实例激活运行，而其他实例待机。</p>
<p><code>StorageVersion</code> 是一种内部版本资源，记录了 <code>APIServerID</code>和其所支持的对象版本。</p>
<p>当<code>Lease</code>被删除时，说明<code>API Server</code>实例发生了变化，所以对象支持的版本也有可能<br>发生变化，所以需要对<code>storageVersion</code>作相应的处理。</p>
<p>所以<code>storageversiongc</code>的作用就是当<code>API Server</code>发生时更新<code>storageversion</code>中记录<code>API Server</code>支持的版本。<br>当<code>storageversion</code>发生变化时，也会查询<code>lease</code>信息从而更新<code>storageversion</code></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/api/apiserverinternal/v1alpha1/types.go</span></span><br><span class="line"><span class="keyword">type</span> StorageVersion <span class="keyword">struct</span> &#123;</span><br><span class="line">    metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">    <span class="comment">// The name is &lt;group&gt;.&lt;resource&gt;.</span></span><br><span class="line">    metav1.ObjectMeta <span class="string">`json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spec is an empty spec. It is here to comply with Kubernetes API style.</span></span><br><span class="line">    Spec StorageVersionSpec <span class="string">`json:"spec" protobuf:"bytes,2,opt,name=spec"`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// API server instances report the version they can decode and the version they</span></span><br><span class="line">    <span class="comment">// encode objects to when persisting objects in the backend.</span></span><br><span class="line">    Status StorageVersionStatus <span class="string">`json:"status" protobuf:"bytes,3,opt,name=status"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StorageVersionSpec <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// API server instances report the versions they can decode and the version they</span></span><br><span class="line"><span class="comment">// encode objects to when persisting objects in the backend.</span></span><br><span class="line"><span class="keyword">type</span> StorageVersionStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// The reported versions per API server instance.</span></span><br><span class="line">    <span class="comment">// +optional</span></span><br><span class="line">    <span class="comment">// +listType=map</span></span><br><span class="line">    <span class="comment">// +listMapKey=apiServerID</span></span><br><span class="line">    StorageVersions []ServerStorageVersion <span class="string">`json:"storageVersions,omitempty" protobuf:"bytes,1,opt,name=storageVersions"`</span></span><br><span class="line">    <span class="comment">// If all API server instances agree on the same encoding storage version,</span></span><br><span class="line">    <span class="comment">// then this field is set to that version. Otherwise this field is left empty.</span></span><br><span class="line">    <span class="comment">// API servers should finish updating its storageVersionStatus entry before</span></span><br><span class="line">    <span class="comment">// serving write operations, so that this field will be in sync with the reality.</span></span><br><span class="line">    <span class="comment">// +optional</span></span><br><span class="line">    CommonEncodingVersion *<span class="keyword">string</span> <span class="string">`json:"commonEncodingVersion,omitempty" protobuf:"bytes,2,opt,name=commonEncodingVersion"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The latest available observations of the storageVersion's state.</span></span><br><span class="line">    <span class="comment">// +optional</span></span><br><span class="line">    <span class="comment">// +listType=map</span></span><br><span class="line">    <span class="comment">// +listMapKey=type</span></span><br><span class="line">    Conditions []StorageVersionCondition    <span class="string">`json:"conditions,omitempty" protobuf:"bytes,3,opt,name=conditions"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An API server instance reports the version it can decode and the version it</span></span><br><span class="line"><span class="comment">// encodes objects to when persisting objects in the backend.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServerStorageVersion 记录了API server实例可以decode/encode的版本</span></span><br><span class="line"><span class="keyword">type</span> ServerStorageVersion <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// The ID of the reporting API server.</span></span><br><span class="line">    APIServerID <span class="keyword">string</span> <span class="string">`json:"apiServerID,omitempty" protobuf:"bytes,1,opt,name=apiServerID"`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当对象进行持久化时API Server采用EncodingVersion对对象进行编码</span></span><br><span class="line">    EncodingVersion <span class="keyword">string</span> <span class="string">`json:"encodingVersion,omitempty" protobuf:"bytes,2,opt,name=encodingVersion"`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// API server可以解码的版本， encodingVersion必须在decodableVersions中</span></span><br><span class="line">    <span class="comment">// +listType=set</span></span><br><span class="line">    DecodableVersions []<span class="keyword">string</span> <span class="string">`json:"decodableVersions,omitempty" protobuf:"bytes,3,opt,name=decodableVersions"`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// API Serever可以处理的version,DecodableVersions必须包含所有的ServedVersions</span></span><br><span class="line">    <span class="comment">// +listType=set</span></span><br><span class="line">    ServedVersions []<span class="keyword">string</span> <span class="string">`json:"servedVersions,omitempty" protobuf:"bytes,4,opt,name=servedVersions"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.go</span></span><br><span class="line"><span class="comment">// 启动时会创建对应的storageversion</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c completedConfig)</span> <span class="title">NewWithDelegate</span><span class="params">(delegationTarget genericapiserver.DelegationTarget)</span> <span class="params">(*APIAggregator, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Technically an apiserver only needs to update storage version once during bootstrap.</span></span><br><span class="line">    <span class="comment">// Reconcile StorageVersion objects every 10 minutes will help in the case that the</span></span><br><span class="line">    <span class="comment">// StorageVersion objects get accidentally modified/deleted by a different agent. In that</span></span><br><span class="line">    <span class="comment">// case, the reconciliation ensures future storage migration still works. If nothing gets</span></span><br><span class="line">    <span class="comment">// changed, the reconciliation update is a noop and gets short-circuited by the apiserver,</span></span><br><span class="line">    <span class="comment">// therefore won't change the resource version and trigger storage migration.</span></span><br><span class="line"><span class="keyword">go</span> wait.PollImmediateUntil(<span class="number">10</span>*time.Minute, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// All apiservers (aggregator-apiserver, kube-apiserver, apiextensions-apiserver)</span></span><br><span class="line">    <span class="comment">// share the same generic apiserver config. The same StorageVersion manager is used</span></span><br><span class="line">    <span class="comment">// to register all built-in resources when the generic apiservers install APIs.</span></span><br><span class="line">    s.GenericAPIServer.StorageVersionManager.UpdateStorageVersions(hookContext.LoopbackClientConfig, s.GenericAPIServer.APIServerID, c.GenericConfig.MergedResourceConfig)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;, hookContext.StopCh)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/storageversiongc/gc_controller.go</span></span><br><span class="line"><span class="comment">// 可以看出Controller会监听两种资源对象,lease, storageversion</span></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">    kubeclientset kubernetes.Interface</span><br><span class="line"></span><br><span class="line">    leaseLister coordlisters.LeaseLister</span><br><span class="line">    leasesSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">    storageVersionSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">    leaseQueue workqueue.RateLimitingInterface</span><br><span class="line">    storageVersionQueue workqueue.  RateLimitingInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStorageVersionGC creates a new Controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStorageVersionGC</span><span class="params">(ctx context.Context, clientset kubernetes.Interface, leaseInformer coordinformers.LeaseInformer, storageVersionInformer apiserverinternalinformers.StorageVersionInformer)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">c := &amp;Controller&#123;</span><br><span class="line">    kubeclientset: clientset,</span><br><span class="line">    leaseLister: leaseInformer.Lister(),</span><br><span class="line">    leasesSynced: leaseInformer.Informer().HasSynced,</span><br><span class="line">    storageVersionSynced: storageVersionInformer.Informer().HasSynced,</span><br><span class="line">    leaseQueue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"storage_version_garbage_collector_leases"</span>),</span><br><span class="line">    storageVersionQueue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"storage_version_garbage_collector_storageversions"</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    logger := klog.FromContext(ctx)</span><br><span class="line">    leaseInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">    <span class="comment">// 这里只监听lease删除的事件</span></span><br><span class="line">    <span class="comment">// lease删除了说明API Server发生了变化，这很好理解</span></span><br><span class="line">    <span class="comment">// 但为什么不监听Create事件呢？</span></span><br><span class="line">    <span class="comment">// 因为一个实例在启动的过程中会创建对应StorageVersion</span></span><br><span class="line">    DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        c.onDeleteLease(logger, obj)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// use the default resync period from the informer</span></span><br><span class="line">    storageVersionInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            c.onAddStorageVersion(logger, obj)</span><br><span class="line">        &#125;,</span><br><span class="line">        UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            c.onUpdateStorageVersion(logger, old, newObj)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run starts one worker.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">Run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    logger := klog.FromContext(ctx)</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">    <span class="keyword">defer</span> c.leaseQueue.ShutDown()</span><br><span class="line">    <span class="keyword">defer</span> c.storageVersionQueue.ShutDown()</span><br><span class="line">    <span class="keyword">defer</span> logger.Info(<span class="string">"Shutting down storage version garbage collector"</span>)</span><br><span class="line"></span><br><span class="line">    logger.Info(<span class="string">"Starting storage version garbage collector"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !cache.WaitForCacheSync(ctx.Done(), c.leasesSynced, c.storageVersionSynced) &#123;</span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">"timed out waiting for caches to sync"</span>))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identity lease deletion and storageversion update don't happen too often. Start one</span></span><br><span class="line"><span class="comment">// worker for each of them.</span></span><br><span class="line"><span class="comment">// runLeaseWorker handles legit identity lease deletion, while runStorageVersionWorker</span></span><br><span class="line"><span class="comment">// handles storageversion creation/update with non-existing id. The latter should rarely</span></span><br><span class="line"><span class="comment">// happen. It's okay for the two workers to conflict on update.</span></span><br><span class="line"><span class="keyword">go</span> wait.UntilWithContext(ctx, c.runLeaseWorker, time.Second)</span><br><span class="line"><span class="keyword">go</span> wait.UntilWithContext(ctx, c.runStorageVersionWorker, time.Second)</span><br><span class="line"></span><br><span class="line">    &lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">runLeaseWorker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> c.processNextLease(ctx) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">processNextLease</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">key, quit := c.leaseQueue.Get()</span><br><span class="line">    <span class="keyword">if</span> quit &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> c.leaseQueue.Done(key)</span><br><span class="line"></span><br><span class="line">    err := c.processDeletedLease(ctx, key.(<span class="keyword">string</span>))</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.leaseQueue.Forget(key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">"lease %v failed with: %v"</span>, key, err))</span><br><span class="line">    c.leaseQueue.AddRateLimited(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">runStorageVersionWorker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> c.processNextStorageVersion(ctx) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">processNextStorageVersion</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    key, quit := c.storageVersionQueue.Get()</span><br><span class="line">    <span class="keyword">if</span> quit &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> c.storageVersionQueue.Done(key)</span><br><span class="line"></span><br><span class="line">    err := c.syncStorageVersion(ctx, key.(<span class="keyword">string</span>))</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.storageVersionQueue.Forget(key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">"storage version %v failed with:     %v"</span>, key, err))</span><br><span class="line">    c.storageVersionQueue.AddRateLimited(key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理删除lease时的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">processDeletedLease</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := c.kubeclientset.CoordinationV1().Leases(metav1.NamespaceSystem).Get(ctx, name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">    <span class="comment">// lease没有被删除，不需要做任何事</span></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除IsNotFound的错误外，直接return</span></span><br><span class="line">    <span class="keyword">if</span> !apierrors.IsNotFound(err) &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取所有的storageversion对象，只有当删除lease时才会触发，所以调用频率不高</span></span><br><span class="line">    storageVersionList, err := c.kubeclientset.InternalV1alpha1().StorageVersions().List(ctx, metav1.ListOptions&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> errors []error</span><br><span class="line">    <span class="keyword">for</span> _, sv := <span class="keyword">range</span> storageVersionList.Items &#123;</span><br><span class="line">    <span class="keyword">var</span> serverStorageVersions []apiserverinternalv1alpha1.  ServerStorageVersion</span><br><span class="line">    hasStaleRecord := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> _, ssv := <span class="keyword">range</span> sv.Status.StorageVersions &#123;</span><br><span class="line">        <span class="comment">// 如果ssv.APIServerID == name, 则应该被删除</span></span><br><span class="line">        <span class="comment">// 因为此时APIServerID已经不是原来的实例了,则原有实例支持的version需要更新</span></span><br><span class="line">        <span class="keyword">if</span> ssv.APIServerID == name &#123;</span><br><span class="line">            hasStaleRecord = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        serverStorageVersions = <span class="built_in">append</span>(serverStorageVersions, ssv)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !hasStaleRecord &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := c.updateOrDeleteStorageVersion(ctx, &amp;sv,  serverStorageVersions); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        errors = <span class="built_in">append</span>(errors, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> utilerrors.NewAggregate(errors)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">syncStorageVersion</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    sv, err := c.kubeclientset.InternalV1alpha1().StorageVersions().Get(ctx, name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">    <span class="comment">// The problematic storage version that was added/updated recently is gone.</span></span><br><span class="line">    <span class="comment">// Nothing we need to do here.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hasInvalidID := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> serverStorageVersions []apiserverinternalv1alpha1.  ServerStorageVersion</span><br><span class="line">    <span class="comment">// 遍历所有的StorageVersions</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> sv.Status.StorageVersions &#123;</span><br><span class="line">        <span class="comment">// 根据APIServerID获取对应的lease</span></span><br><span class="line">        lease, err := c.kubeclientset.CoordinationV1().Leases(metav1.   NamespaceSystem).Get(ctx, v.APIServerID, metav1.GetOptions&#123;&#125;)</span><br><span class="line">        <span class="comment">// 如找不到对应的APIServer则需要更新serverStorageVersions</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> || lease == <span class="literal">nil</span> || lease.Labels == <span class="literal">nil</span> ||</span><br><span class="line">        lease.Labels[controlplane.IdentityLeaseComponentLabelKey] !=    controlplane.KubeAPIServer &#123;</span><br><span class="line">        <span class="comment">// We cannot find a corresponding identity lease from apiserver as  well.</span></span><br><span class="line">        <span class="comment">// We need to clean up this storage version.</span></span><br><span class="line">         hasInvalidID = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverStorageVersions = <span class="built_in">append</span>(serverStorageVersions, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !hasInvalidID &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.updateOrDeleteStorageVersion(ctx, sv, serverStorageVersions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">updateOrDeleteStorageVersion</span><span class="params">(ctx context.Context, sv *apiserverinternalv1alpha1.StorageVersion, serverStorageVersions []apiserverinternalv1alpha1.ServerStorageVersion)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(serverStorageVersions) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.kubeclientset.InternalV1alpha1().StorageVersions().Delete(</span><br><span class="line">        ctx, sv.Name, metav1.DeleteOptions&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">    sv.Status.StorageVersions = serverStorageVersions</span><br><span class="line">    storageversion.SetCommonEncodingVersion(sv)</span><br><span class="line">    _, err := c.kubeclientset.InternalV1alpha1().StorageVersions().UpdateStatus(ctx, sv, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:</p>
<ol>
<li><a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/leases/" target="_blank" rel="noopener">Lease</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/blob/v1.27.4/staging/src/k8s.io/api/apiserverinternal/v1alpha1/types.go" target="_blank" rel="noopener">staging/src/k8s.io/api/apiserverinternal/v1alpha1/types.go</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/tree/v1.27.4/staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.go" target="_blank" rel="noopener">staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.go</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/tree/v1.27.4/pkg/controller/storageversiongc/gc_controller.go" target="_blank" rel="noopener">pkg/controller/storageversiongc/gc_controller.go</a></li>
</ol>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet之imagegc-manager</title>
    <url>/2023/05/18/kubelet%E4%B9%8Bimagegc-manager/</url>
    <content><![CDATA[<p><code>imagegc-manager</code>负责管理容器镜像生命周期。当磁盘的使用率达到所设置的值时会将没有使用的镜像给删除掉。</p>
<p><code>kubelet</code>通过如下的的参数来设置<code>ImageGC</code>策略：</p>
<ul>
<li>ImageGCHighThresholdPercent：触发gc的阈值，超过该值将会执行gc，当值为100时，不启动gc</li>
<li>ImageGCLowThresholdPercent：低于这个值不会进行gc</li>
<li>ImageMinimumGCAge：最短GC年龄（即距离首次被探测到的间隔），小于该阈值时不会被gc</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/kubelet.go</span></span><br><span class="line">imageGCPolicy := images.ImageGCPolicy&#123;</span><br><span class="line">	MinAge:               kubeCfg.ImageMinimumGCAge.Duration,</span><br><span class="line">	HighThresholdPercent: <span class="keyword">int</span>(kubeCfg.ImageGCHighThresholdPercent),</span><br><span class="line">	LowThresholdPercent:  <span class="keyword">int</span>(kubeCfg.ImageGCLowThresholdPercent),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// pkg/kubelet/images/types.go</span></span><br><span class="line"><span class="comment">// 定义了镜像拉取时的一些错误类型</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// ErrImagePullBackOff - Container image pull failed, kubelet is backing off image pull</span></span><br><span class="line">	ErrImagePullBackOff = errors.New(<span class="string">"ImagePullBackOff"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ErrImageInspect - Unable to inspect image</span></span><br><span class="line">	ErrImageInspect = errors.New(<span class="string">"ImageInspectError"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ErrImagePull - General image pull error</span></span><br><span class="line">	ErrImagePull = errors.New(<span class="string">"ErrImagePull"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ErrImageNeverPull - Required Image is absent on host and PullPolicy is NeverPullImage</span></span><br><span class="line">    <span class="comment">// 镜像拉取策略为Never且镜像不存在对应的节点上</span></span><br><span class="line">	ErrImageNeverPull = errors.New(<span class="string">"ErrImageNeverPull"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ErrInvalidImageName - Unable to parse the image name.</span></span><br><span class="line">	ErrInvalidImageName = errors.New(<span class="string">"InvalidImageName"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageManager provides an interface to manage the lifecycle of images.</span></span><br><span class="line"><span class="comment">// Implementations of this interface are expected to deal with pulling (downloading),</span></span><br><span class="line"><span class="comment">// managing, and deleting container images.</span></span><br><span class="line"><span class="comment">// Implementations are expected to abstract the underlying runtimes.</span></span><br><span class="line"><span class="comment">// Implementations are expected to be thread safe.</span></span><br><span class="line"><span class="keyword">type</span> ImageManager <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 判断镜像是否被使用</span></span><br><span class="line">	EnsureImageExists(ctx context.Context, pod *v1.Pod, container *v1.Container, pullSecrets []v1.Secret, podSandboxConfig *runtimeapi.PodSandboxConfig) (<span class="keyword">string</span>, <span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// pkg/kubelet/images/puller.go</span></span><br><span class="line"><span class="keyword">type</span> pullResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	imageRef     <span class="keyword">string</span></span><br><span class="line">	err          error</span><br><span class="line">	pullDuration time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> imagePuller <span class="keyword">interface</span> &#123;</span><br><span class="line">	pullImage(context.Context, kubecontainer.ImageSpec, []v1.Secret, <span class="keyword">chan</span>&lt;- pullResult, *runtimeapi.PodSandboxConfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保parallelImagePuller,serialImagePuller都实现了imagePuller接口</span></span><br><span class="line"><span class="keyword">var</span> _, _ imagePuller = &amp;parallelImagePuller&#123;&#125;, &amp;serialImagePuller&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过channel实现并行拉取镜像</span></span><br><span class="line"><span class="keyword">type</span> parallelImagePuller <span class="keyword">struct</span> &#123;</span><br><span class="line">	imageService kubecontainer.ImageService</span><br><span class="line">	tokens       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newParallelImagePuller</span><span class="params">(imageService kubecontainer.ImageService, maxParallelImagePulls *<span class="keyword">int32</span>)</span> <span class="title">imagePuller</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> maxParallelImagePulls == <span class="literal">nil</span> || *maxParallelImagePulls &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;parallelImagePuller&#123;imageService, <span class="literal">nil</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;parallelImagePuller&#123;imageService, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, *maxParallelImagePulls)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pip *parallelImagePuller)</span> <span class="title">pullImage</span><span class="params">(ctx context.Context, spec kubecontainer.ImageSpec, pullSecrets []v1.Secret, pullChan <span class="keyword">chan</span>&lt;- pullResult, podSandboxConfig *runtimeapi.PodSandboxConfig)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果pip.tokens不为nil</span></span><br><span class="line">		<span class="keyword">if</span> pip.tokens != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 发送数据到pip.tokens,如果channel已满则会阻塞</span></span><br><span class="line">            <span class="comment">// 否则往下走拉取镜像</span></span><br><span class="line">			pip.tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            <span class="comment">// 从channel读取数据，释放一个空位</span></span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-pip.tokens &#125;()</span><br><span class="line">		&#125;</span><br><span class="line">		startTime := time.Now()</span><br><span class="line">		imageRef, err := pip.imageService.PullImage(ctx, spec, pullSecrets, podSandboxConfig)</span><br><span class="line">		pullChan &lt;- pullResult&#123;</span><br><span class="line">			imageRef:     imageRef,</span><br><span class="line">			err:          err,</span><br><span class="line">			pullDuration: time.Since(startTime),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Maximum number of image pull requests than can be queued.</span></span><br><span class="line"><span class="comment">// 最大请求排队数，如果超过了这个数则会发生阻塞</span></span><br><span class="line"><span class="keyword">const</span> maxImagePullRequests = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> serialImagePuller <span class="keyword">struct</span> &#123;</span><br><span class="line">	imageService kubecontainer.ImageService</span><br><span class="line">	pullRequests <span class="keyword">chan</span> *imagePullRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSerialImagePuller</span><span class="params">(imageService kubecontainer.ImageService)</span> <span class="title">imagePuller</span></span> &#123;</span><br><span class="line">	imagePuller := &amp;serialImagePuller&#123;imageService, <span class="built_in">make</span>(<span class="keyword">chan</span> *imagePullRequest, maxImagePullRequests)&#125;</span><br><span class="line">    <span class="comment">// 启动一个协程不断的从pullRequest通道中获取数据并串行拉取镜像</span></span><br><span class="line">	<span class="keyword">go</span> wait.Until(imagePuller.processImagePullRequests, time.Second, wait.NeverStop)</span><br><span class="line">	<span class="keyword">return</span> imagePuller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> imagePullRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	ctx              context.Context</span><br><span class="line">	spec             kubecontainer.ImageSpec</span><br><span class="line">	pullSecrets      []v1.Secret</span><br><span class="line">	pullChan         <span class="keyword">chan</span>&lt;- pullResult</span><br><span class="line">	podSandboxConfig *runtimeapi.PodSandboxConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这方法会在EnsureImageExists中调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sip *serialImagePuller)</span> <span class="title">pullImage</span><span class="params">(ctx context.Context, spec kubecontainer.ImageSpec, pullSecrets []v1.Secret, pullChan <span class="keyword">chan</span>&lt;- pullResult, podSandboxConfig *runtimeapi.PodSandboxConfig)</span></span> &#123;</span><br><span class="line">	sip.pullRequests &lt;- &amp;imagePullRequest&#123;</span><br><span class="line">		ctx:              ctx,</span><br><span class="line">		spec:             spec,</span><br><span class="line">		pullSecrets:      pullSecrets,</span><br><span class="line">		pullChan:         pullChan,</span><br><span class="line">		podSandboxConfig: podSandboxConfig,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sip *serialImagePuller)</span> <span class="title">processImagePullRequests</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> pullRequest := <span class="keyword">range</span> sip.pullRequests &#123;</span><br><span class="line">		startTime := time.Now()</span><br><span class="line">		imageRef, err := sip.imageService.PullImage(pullRequest.ctx, pullRequest.spec, pullRequest.pullSecrets, pullRequest.podSandboxConfig)</span><br><span class="line">		pullRequest.pullChan &lt;- pullResult&#123;</span><br><span class="line">			imageRef:     imageRef,</span><br><span class="line">			err:          err,</span><br><span class="line">			pullDuration: time.Since(startTime),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/images/image_manager.go</span></span><br><span class="line"><span class="keyword">type</span> ImagePodPullingTimeRecorder <span class="keyword">interface</span> &#123;</span><br><span class="line">	RecordImageStartedPulling(podUID types.UID)</span><br><span class="line">	RecordImageFinishedPulling(podUID types.UID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// imageManager provides the functionalities for image pulling.</span></span><br><span class="line"><span class="keyword">type</span> imageManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	recorder     record.EventRecorder</span><br><span class="line">	imageService kubecontainer.ImageService</span><br><span class="line">	backOff      *flowcontrol.Backoff</span><br><span class="line">	<span class="comment">// It will check the presence of the image, and report the 'image pulling', image pulled' events correspondingly.</span></span><br><span class="line">	puller imagePuller</span><br><span class="line"></span><br><span class="line">	podPullingTimeRecorder ImagePodPullingTimeRecorder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保imageManager实现了ImageManager接口</span></span><br><span class="line"><span class="keyword">var</span> _ ImageManager = &amp;imageManager&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewImageManager instantiates a new ImageManager object.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImageManager</span><span class="params">(recorder record.EventRecorder, imageService kubecontainer.ImageService, imageBackOff *flowcontrol.Backoff, serialized <span class="keyword">bool</span>, maxParallelImagePulls *<span class="keyword">int32</span>, qps <span class="keyword">float32</span>, burst <span class="keyword">int</span>, podPullingTimeRecorder ImagePodPullingTimeRecorder)</span> <span class="title">ImageManager</span></span> &#123;</span><br><span class="line">	imageService = throttleImagePulling(imageService, qps, burst)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> puller imagePuller</span><br><span class="line">    <span class="comment">// 判断使用哪种镜像拉取策略(串行或并行)</span></span><br><span class="line">	<span class="keyword">if</span> serialized &#123;</span><br><span class="line">		puller = newSerialImagePuller(imageService)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		puller = newParallelImagePuller(imageService, maxParallelImagePulls)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;imageManager&#123;</span><br><span class="line">		recorder:               recorder,</span><br><span class="line">		imageService:           imageService,</span><br><span class="line">		backOff:                imageBackOff,</span><br><span class="line">		puller:                 puller,</span><br><span class="line">		podPullingTimeRecorder: podPullingTimeRecorder,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shouldPullImage returns whether we should pull an image according to</span></span><br><span class="line"><span class="comment">// the presence and pull policy of the image.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldPullImage</span><span class="params">(container *v1.Container, imagePresent <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> container.ImagePullPolicy == v1.PullNever &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> container.ImagePullPolicy == v1.PullAlways ||</span><br><span class="line">		(container.ImagePullPolicy == v1.PullIfNotPresent &amp;&amp; (!imagePresent)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// records an event using ref, event msg.  log to glog using prefix, msg, logFn</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *imageManager)</span> <span class="title">logIt</span><span class="params">(ref *v1.ObjectReference, eventtype, event, prefix, msg <span class="keyword">string</span>, logFn <span class="keyword">func</span>(args ...<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ref != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.recorder.Event(ref, eventtype, event, msg)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		logFn(fmt.Sprint(prefix, <span class="string">" "</span>, msg))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EnsureImageExists pulls the image for the specified pod and container, and returns</span></span><br><span class="line"><span class="comment">// (imageRef, error message, error).</span></span><br><span class="line"><span class="comment">// 为pod和container拉取指定的镜像</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *imageManager)</span> <span class="title">EnsureImageExists</span><span class="params">(ctx context.Context, pod *v1.Pod, container *v1.Container, pullSecrets []v1.Secret, podSandboxConfig *runtimeapi.PodSandboxConfig)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	logPrefix := fmt.Sprintf(<span class="string">"%s/%s/%s"</span>, pod.Namespace, pod.Name, container.Image)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回*v1.ObjectReference,指向container(如果这个container属于这个pod)</span></span><br><span class="line">	ref, err := kubecontainer.GenerateContainerRef(pod, container)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">"Couldn't make a ref to pod"</span>, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"containerName"</span>, container.Name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果镜像不包含tag和摘要,为这个镜像设置默认的tag, latest</span></span><br><span class="line">	image, err := applyDefaultImageTag(container.Image)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"Failed to apply default image tag %q: %v"</span>, container.Image, err)</span><br><span class="line">		m.logIt(ref, v1.EventTypeWarning, events.FailedToInspectImage, logPrefix, msg, klog.Warning)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, msg, ErrInvalidImageName</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器注解</span></span><br><span class="line">	<span class="keyword">var</span> podAnnotations []kubecontainer.Annotation</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> pod.GetAnnotations() &#123;</span><br><span class="line">		podAnnotations = <span class="built_in">append</span>(podAnnotations, kubecontainer.Annotation&#123;</span><br><span class="line">			Name:  k,</span><br><span class="line">			Value: v,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spec := kubecontainer.ImageSpec&#123;</span><br><span class="line">		Image:       image,</span><br><span class="line">		Annotations: podAnnotations,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 返回镜像ID或digest,如果不存在则返回("", nil)</span></span><br><span class="line">	imageRef, err := m.imageService.GetImageRef(ctx, spec)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"Failed to inspect image %q: %v"</span>, container.Image, err)</span><br><span class="line">		m.logIt(ref, v1.EventTypeWarning, events.FailedToInspectImage, logPrefix, msg, klog.Warning)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, msg, ErrImageInspect</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// present为true,表示镜像已存在</span></span><br><span class="line">	present := imageRef != <span class="string">""</span></span><br><span class="line">	<span class="keyword">if</span> !shouldPullImage(container, present) &#123;</span><br><span class="line">		<span class="keyword">if</span> present &#123;</span><br><span class="line">			msg := fmt.Sprintf(<span class="string">"Container image %q already present on machine"</span>, container.Image)</span><br><span class="line">			m.logIt(ref, v1.EventTypeNormal, events.PulledImage, logPrefix, msg, klog.Info)</span><br><span class="line">			<span class="keyword">return</span> imageRef, <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"Container image %q is not present with pull policy of Never"</span>, container.Image)</span><br><span class="line">		m.logIt(ref, v1.EventTypeWarning, events.ErrImageNeverPullPolicy, logPrefix, msg, klog.Warning)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, msg, ErrImageNeverPull</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	backOffKey := fmt.Sprintf(<span class="string">"%s_%s"</span>, pod.UID, container.Image)</span><br><span class="line">	<span class="keyword">if</span> m.backOff.IsInBackOffSinceUpdate(backOffKey, m.backOff.Clock.Now()) &#123;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">"Back-off pulling image %q"</span>, container.Image)</span><br><span class="line">		m.logIt(ref, v1.EventTypeNormal, events.BackOffPullImage, logPrefix, msg, klog.Info)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, msg, ErrImagePullBackOff</span><br><span class="line">	&#125;</span><br><span class="line">	m.podPullingTimeRecorder.RecordImageStartedPulling(pod.UID)</span><br><span class="line">	m.logIt(ref, v1.EventTypeNormal, events.PullingImage, logPrefix, fmt.Sprintf(<span class="string">"Pulling image %q"</span>, container.Image), klog.Info)</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	pullChan := <span class="built_in">make</span>(<span class="keyword">chan</span> pullResult)</span><br><span class="line">    <span class="comment">// 拉取镜像</span></span><br><span class="line">	m.puller.pullImage(ctx, spec, pullSecrets, pullChan, podSandboxConfig)</span><br><span class="line">	imagePullResult := &lt;-pullChan</span><br><span class="line">	<span class="keyword">if</span> imagePullResult.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.logIt(ref, v1.EventTypeWarning, events.FailedToPullImage, logPrefix, fmt.Sprintf(<span class="string">"Failed to pull image %q: %v"</span>, container.Image, imagePullResult.err), klog.Warning)</span><br><span class="line">		m.backOff.Next(backOffKey, m.backOff.Clock.Now())</span><br><span class="line"></span><br><span class="line">		msg, err := evalCRIPullErr(container, imagePullResult.err)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, msg, err</span><br><span class="line">	&#125;</span><br><span class="line">	m.podPullingTimeRecorder.RecordImageFinishedPulling(pod.UID)</span><br><span class="line">	m.logIt(ref, v1.EventTypeNormal, events.PulledImage, logPrefix, fmt.Sprintf(<span class="string">"Successfully pulled image %q in %v (%v including waiting)"</span>,</span><br><span class="line">		container.Image, imagePullResult.pullDuration.Truncate(time.Millisecond), time.Since(startTime).Truncate(time.Millisecond)), klog.Info)</span><br><span class="line">	m.backOff.GC()</span><br><span class="line">	<span class="keyword">return</span> imagePullResult.imageRef, <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/images/image_gc_manager.go</span></span><br><span class="line"><span class="comment">// 定义了ImageGCManager要实现的方法</span></span><br><span class="line"><span class="keyword">type</span> ImageGCManager <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Applies the garbage collection policy. Errors include being unable to free</span></span><br><span class="line">	<span class="comment">// enough space as per the garbage collection policy.</span></span><br><span class="line">	GarbageCollect(ctx context.Context) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start async garbage collection of images.</span></span><br><span class="line">	Start()</span><br><span class="line"></span><br><span class="line">	GetImageList() ([]container.Image, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delete all unused images.</span></span><br><span class="line">	DeleteUnusedImages(ctx context.Context) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ImageGCPolicy <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Any usage above this threshold will always trigger garbage collection.</span></span><br><span class="line">	<span class="comment">// This is the highest usage we will allow.</span></span><br><span class="line">    <span class="comment">// 超过高水位总会解发gc</span></span><br><span class="line">	HighThresholdPercent <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Any usage below this threshold will never trigger garbage collection.</span></span><br><span class="line">	<span class="comment">// This is the lowest threshold we will try to garbage collect to.</span></span><br><span class="line">	LowThresholdPercent <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Minimum age at which an image can be garbage collected.</span></span><br><span class="line">	MinAge time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> realImageGCManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Container runtime</span></span><br><span class="line">	runtime container.Runtime</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Records of images and their use.</span></span><br><span class="line">	imageRecords     <span class="keyword">map</span>[<span class="keyword">string</span>]*imageRecord</span><br><span class="line">	imageRecordsLock sync.Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The image garbage collection policy in use.</span></span><br><span class="line">	policy ImageGCPolicy</span><br><span class="line"></span><br><span class="line">	<span class="comment">// statsProvider provides stats used during image garbage collection.</span></span><br><span class="line">	statsProvider StatsProvider</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Recorder for Kubernetes events.</span></span><br><span class="line">	recorder record.EventRecorder</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reference to this node.</span></span><br><span class="line">	nodeRef *v1.ObjectReference</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Track initialization</span></span><br><span class="line">	initialized <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// imageCache is the cache of latest image list.</span></span><br><span class="line">	imageCache imageCache</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sandbox image exempted from GC</span></span><br><span class="line">	sandboxImage <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// tracer for recording spans</span></span><br><span class="line">	tracer trace.Tracer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// imageCache实现了set和get方法</span></span><br><span class="line"><span class="keyword">type</span> imageCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// sync.Mutex is the mutex protects the image cache.</span></span><br><span class="line">	sync.Mutex</span><br><span class="line">	<span class="comment">// images is the image cache.</span></span><br><span class="line">	images []container.Image</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *imageCache)</span> <span class="title">set</span><span class="params">(images []container.Image)</span></span> &#123;</span><br><span class="line">	i.Lock()</span><br><span class="line">	<span class="keyword">defer</span> i.Unlock()</span><br><span class="line">	<span class="comment">// The image list needs to be sorted when it gets read and used in</span></span><br><span class="line">	<span class="comment">// setNodeStatusImages. We sort the list on write instead of on read,</span></span><br><span class="line">	<span class="comment">// because the image cache is more often read than written</span></span><br><span class="line">	sort.Sort(sliceutils.ByImageSize(images))</span><br><span class="line">	i.images = images</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *imageCache)</span> <span class="title">get</span><span class="params">()</span> []<span class="title">container</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">	i.Lock()</span><br><span class="line">	<span class="keyword">defer</span> i.Unlock()</span><br><span class="line">	<span class="keyword">return</span> i.images</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录追踪的镜像的一些信息</span></span><br><span class="line"><span class="keyword">type</span> imageRecord <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Time when this image was first detected.</span></span><br><span class="line">	firstDetected time.Time</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Time when we last saw this image being used.</span></span><br><span class="line">	lastUsed time.Time</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Size of the image in bytes.</span></span><br><span class="line">	size <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pinned status of the image</span></span><br><span class="line">	pinned <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ImageGCManager</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewImageGCManager</span><span class="params">(runtime container.Runtime, statsProvider StatsProvider, recorder record.EventRecorder, nodeRef *v1.ObjectReference, policy ImageGCPolicy, sandboxImage <span class="keyword">string</span>, tracerProvider trace.TracerProvider)</span> <span class="params">(ImageGCManager, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 对策略的一些判断</span></span><br><span class="line">	<span class="keyword">if</span> policy.HighThresholdPercent &lt; <span class="number">0</span> || policy.HighThresholdPercent &gt; <span class="number">100</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid HighThresholdPercent %d, must be in range [0-100]"</span>, policy.HighThresholdPercent)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> policy.LowThresholdPercent &lt; <span class="number">0</span> || policy.LowThresholdPercent &gt; <span class="number">100</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"invalid LowThresholdPercent %d, must be in range [0-100]"</span>, policy.LowThresholdPercent)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> policy.LowThresholdPercent &gt; policy.HighThresholdPercent &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"LowThresholdPercent %d can not be higher than HighThresholdPercent %d"</span>, policy.LowThresholdPercent, policy.HighThresholdPercent)</span><br><span class="line">	&#125;</span><br><span class="line">	tracer := tracerProvider.Tracer(instrumentationScope)</span><br><span class="line">	im := &amp;realImageGCManager&#123;</span><br><span class="line">		runtime:       runtime,</span><br><span class="line">		policy:        policy,</span><br><span class="line">		imageRecords:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*imageRecord),</span><br><span class="line">		statsProvider: statsProvider,</span><br><span class="line">		recorder:      recorder,</span><br><span class="line">		nodeRef:       nodeRef,</span><br><span class="line">		initialized:   <span class="literal">false</span>,</span><br><span class="line">		sandboxImage:  sandboxImage,</span><br><span class="line">		tracer:        tracer,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> im, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(im *realImageGCManager)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">    <span class="comment">// 5分钟执行一次detectImages</span></span><br><span class="line">	<span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// Initial detection make detected time "unknown" in the past.</span></span><br><span class="line">		<span class="keyword">var</span> ts time.Time</span><br><span class="line">		<span class="keyword">if</span> im.initialized &#123;</span><br><span class="line">			ts = time.Now()</span><br><span class="line">		&#125;</span><br><span class="line">		_, err := im.detectImages(ctx, ts)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.InfoS(<span class="string">"Failed to monitor images"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			im.initialized = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="number">5</span>*time.Minute, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start a goroutine periodically updates image cache.</span></span><br><span class="line">    <span class="comment">// 每30s更新下imageCache</span></span><br><span class="line">	<span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 获取镜像列表</span></span><br><span class="line">		images, err := im.runtime.ListImages(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.InfoS(<span class="string">"Failed to update image list"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			im.imageCache.set(images)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="number">30</span>*time.Second, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(im *realImageGCManager)</span> <span class="title">detectImages</span><span class="params">(ctx context.Context, detectTime time.Time)</span> <span class="params">(sets.String, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个集合记录正在使用中的镜像</span></span><br><span class="line">	imagesInUse := sets.NewString()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Always consider the container runtime pod sandbox image in use</span></span><br><span class="line">	<span class="comment">// sandboxImage永远被认为在使用中</span></span><br><span class="line">	imageRef, err := im.runtime.GetImageRef(ctx, container.ImageSpec&#123;Image: im.sandboxImage&#125;)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; imageRef != <span class="string">""</span> &#123;</span><br><span class="line">		imagesInUse.Insert(imageRef)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取当前节点上的所有镜像</span></span><br><span class="line">	images, err := im.runtime.ListImages(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> imagesInUse, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回pod列表</span></span><br><span class="line">	pods, err := im.runtime.GetPods(ctx, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> imagesInUse, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make a set of images in use by containers.</span></span><br><span class="line">	<span class="comment">// 遍历pod中的container将镜像ID添加到集合中</span></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="keyword">for</span> _, container := <span class="keyword">range</span> pod.Containers &#123;</span><br><span class="line">			klog.V(<span class="number">5</span>).InfoS(<span class="string">"Container uses image"</span>, <span class="string">"pod"</span>, klog.KRef(pod.Namespace, pod.Name), <span class="string">"containerName"</span>, container.Name, <span class="string">"containerImage"</span>, container.Image, <span class="string">"imageID"</span>, container.ImageID)</span><br><span class="line">			imagesInUse.Insert(container.ImageID)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add new images and record those being used.</span></span><br><span class="line">	now := time.Now()</span><br><span class="line">	currentImages := sets.NewString()</span><br><span class="line">	im.imageRecordsLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> im.imageRecordsLock.Unlock()</span><br><span class="line">	<span class="comment">// 遍历当前节点上的所有镜像</span></span><br><span class="line">	<span class="keyword">for</span> _, image := <span class="keyword">range</span> images &#123;</span><br><span class="line">		klog.V(<span class="number">5</span>).InfoS(<span class="string">"Adding image ID to currentImages"</span>, <span class="string">"imageID"</span>, image.ID)</span><br><span class="line">		currentImages.Insert(image.ID)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// New image, set it as detected now.</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := im.imageRecords[image.ID]; !ok &#123;</span><br><span class="line">			<span class="comment">// 镜像不存在imageRecords中</span></span><br><span class="line">			klog.V(<span class="number">5</span>).InfoS(<span class="string">"Image ID is new"</span>, <span class="string">"imageID"</span>, image.ID)</span><br><span class="line">			im.imageRecords[image.ID] = &amp;imageRecord&#123;</span><br><span class="line">				firstDetected: detectTime,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set last used time to now if the image is being used.</span></span><br><span class="line">		<span class="keyword">if</span> isImageUsed(image.ID, imagesInUse) &#123;</span><br><span class="line">			klog.V(<span class="number">5</span>).InfoS(<span class="string">"Setting Image ID lastUsed"</span>, <span class="string">"imageID"</span>, image.ID, <span class="string">"lastUsed"</span>, now)</span><br><span class="line">			im.imageRecords[image.ID].lastUsed = now</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">5</span>).InfoS(<span class="string">"Image ID has size"</span>, <span class="string">"imageID"</span>, image.ID, <span class="string">"size"</span>, image.Size)</span><br><span class="line">		im.imageRecords[image.ID].size = image.Size</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">5</span>).InfoS(<span class="string">"Image ID is pinned"</span>, <span class="string">"imageID"</span>, image.ID, <span class="string">"pinned"</span>, image.Pinned)</span><br><span class="line">		im.imageRecords[image.ID].pinned = image.Pinned</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remove old images from our records.</span></span><br><span class="line">	<span class="keyword">for</span> image := <span class="keyword">range</span> im.imageRecords &#123;</span><br><span class="line">		<span class="keyword">if</span> !currentImages.Has(image) &#123;</span><br><span class="line">			klog.V(<span class="number">5</span>).InfoS(<span class="string">"Image ID is no longer present; removing from imageRecords"</span>, <span class="string">"imageID"</span>, image)</span><br><span class="line">			<span class="comment">// 如果一个不存在这个节点的镜像列表</span></span><br><span class="line">			<span class="built_in">delete</span>(im.imageRecords, image)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> imagesInUse, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会在StartGarbageCollection中被调用，每5分钟执行一次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(im *realImageGCManager)</span> <span class="title">GarbageCollect</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ctx, otelSpan := im.tracer.Start(ctx, <span class="string">"Images/GarbageCollect"</span>)</span><br><span class="line">	<span class="keyword">defer</span> otelSpan.End()</span><br><span class="line">	<span class="comment">// Get disk usage on disk holding images.</span></span><br><span class="line">	fsStats, err := im.statsProvider.ImageFsStats(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> capacity, available <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> fsStats.CapacityBytes != <span class="literal">nil</span> &#123;</span><br><span class="line">		capacity = <span class="keyword">int64</span>(*fsStats.CapacityBytes)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fsStats.AvailableBytes != <span class="literal">nil</span> &#123;</span><br><span class="line">		available = <span class="keyword">int64</span>(*fsStats.AvailableBytes)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> available &gt; capacity &#123;</span><br><span class="line">		klog.InfoS(<span class="string">"Availability is larger than capacity"</span>, <span class="string">"available"</span>, available, <span class="string">"capacity"</span>, capacity)</span><br><span class="line">		available = capacity</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check valid capacity.</span></span><br><span class="line">	<span class="keyword">if</span> capacity == <span class="number">0</span> &#123;</span><br><span class="line">		err := goerrors.New(<span class="string">"invalid capacity 0 on image filesystem"</span>)</span><br><span class="line">		im.recorder.Eventf(im.nodeRef, v1.EventTypeWarning, events.InvalidDiskCapacity, err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If over the max threshold, free enough to place us at the lower threshold.</span></span><br><span class="line">	usagePercent := <span class="number">100</span> - <span class="keyword">int</span>(available*<span class="number">100</span>/capacity)</span><br><span class="line">	<span class="keyword">if</span> usagePercent &gt;= im.policy.HighThresholdPercent &#123;</span><br><span class="line">		amountToFree := capacity*<span class="keyword">int64</span>(<span class="number">100</span>-im.policy.LowThresholdPercent)/<span class="number">100</span> - available</span><br><span class="line">		klog.InfoS(<span class="string">"Disk usage on image filesystem is over the high threshold, trying to free bytes down to the low threshold"</span>, <span class="string">"usage"</span>, usagePercent, <span class="string">"highThreshold"</span>, im.policy.HighThresholdPercent, <span class="string">"amountToFree"</span>, amountToFree, <span class="string">"lowThreshold"</span>, im.policy.LowThresholdPercent)</span><br><span class="line">        <span class="comment">// 删除不使用的镜像</span></span><br><span class="line">		freed, err := im.freeSpace(ctx, amountToFree, time.Now())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> freed &lt; amountToFree &#123;</span><br><span class="line">			err := fmt.Errorf(<span class="string">"Failed to garbage collect required amount of images. Attempted to free %d bytes, but only found %d bytes eligible to free."</span>, amountToFree, freed)</span><br><span class="line">			im.recorder.Eventf(im.nodeRef, v1.EventTypeWarning, events.FreeDiskSpaceFailed, err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(im *realImageGCManager)</span> <span class="title">freeSpace</span><span class="params">(ctx context.Context, bytesToFree <span class="keyword">int64</span>, freeTime time.Time)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	imagesInUse, err := im.detectImages(ctx, freeTime)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	im.imageRecordsLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> im.imageRecordsLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get all images in eviction order.</span></span><br><span class="line">	images := <span class="built_in">make</span>([]evictionInfo, <span class="number">0</span>, <span class="built_in">len</span>(im.imageRecords))</span><br><span class="line">	<span class="keyword">for</span> image, record := <span class="keyword">range</span> im.imageRecords &#123;</span><br><span class="line">		<span class="keyword">if</span> isImageUsed(image, imagesInUse) &#123;</span><br><span class="line">			klog.V(<span class="number">5</span>).InfoS(<span class="string">"Image ID is being used"</span>, <span class="string">"imageID"</span>, image)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Check if image is pinned, prevent garbage collection</span></span><br><span class="line">		<span class="keyword">if</span> record.pinned &#123;</span><br><span class="line">			klog.V(<span class="number">5</span>).InfoS(<span class="string">"Image is pinned, skipping garbage collection"</span>, <span class="string">"imageID"</span>, image)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		images = <span class="built_in">append</span>(images, evictionInfo&#123;</span><br><span class="line">			id:          image,</span><br><span class="line">			imageRecord: *record,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(byLastUsedAndDetected(images))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delete unused images until we've freed up enough space.</span></span><br><span class="line">	<span class="keyword">var</span> deletionErrors []error</span><br><span class="line">	spaceFreed := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, image := <span class="keyword">range</span> images &#123;</span><br><span class="line">		klog.V(<span class="number">5</span>).InfoS(<span class="string">"Evaluating image ID for possible garbage collection"</span>, <span class="string">"imageID"</span>, image.id)</span><br><span class="line">		<span class="comment">// Images that are currently in used were given a newer lastUsed.</span></span><br><span class="line">		<span class="keyword">if</span> image.lastUsed.Equal(freeTime) || image.lastUsed.After(freeTime) &#123;</span><br><span class="line">			klog.V(<span class="number">5</span>).InfoS(<span class="string">"Image ID was used too recently, not eligible for garbage collection"</span>, <span class="string">"imageID"</span>, image.id, <span class="string">"lastUsed"</span>, image.lastUsed, <span class="string">"freeTime"</span>, freeTime)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Avoid garbage collect the image if the image is not old enough.</span></span><br><span class="line">		<span class="comment">// In such a case, the image may have just been pulled down, and will be used by a container right away.</span></span><br><span class="line">		<span class="comment">// 如果镜像加入缓存的时间 &lt; im.policy.MinAge,则不会对镜像进行回收</span></span><br><span class="line">		<span class="keyword">if</span> freeTime.Sub(image.firstDetected) &lt; im.policy.MinAge &#123;</span><br><span class="line">			klog.V(<span class="number">5</span>).InfoS(<span class="string">"Image ID's age is less than the policy's minAge, not eligible for garbage collection"</span>, <span class="string">"imageID"</span>, image.id, <span class="string">"age"</span>, freeTime.Sub(image.firstDetected), <span class="string">"minAge"</span>, im.policy.MinAge)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Remove image. Continue despite errors.</span></span><br><span class="line">		klog.InfoS(<span class="string">"Removing image to free bytes"</span>, <span class="string">"imageID"</span>, image.id, <span class="string">"size"</span>, image.size)</span><br><span class="line">		err := im.runtime.RemoveImage(ctx, container.ImageSpec&#123;Image: image.id&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			deletionErrors = <span class="built_in">append</span>(deletionErrors, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">delete</span>(im.imageRecords, image.id)</span><br><span class="line">		spaceFreed += image.size</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> spaceFreed &gt;= bytesToFree &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(deletionErrors) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> spaceFreed, fmt.Errorf(<span class="string">"wanted to free %d bytes, but freed %d bytes space with errors in image deletion: %v"</span>, bytesToFree, spaceFreed, errors.NewAggregate(deletionErrors))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> spaceFreed, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cmd/kubelet/app/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAndInitKubelet</span><span class="params">(kubeServer *options.KubeletServer,</span></span></span><br><span class="line"><span class="function"><span class="params">	kubeDeps *kubelet.Dependencies,</span></span></span><br><span class="line"><span class="function"><span class="params">	hostname <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	hostnameOverridden <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodeName types.NodeName,</span></span></span><br><span class="line"><span class="function"><span class="params">	nodeIPs []net.IP)</span> <span class="params">(k kubelet.Bootstrap, err error)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        k.StartGarbageCollection()</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">StartGarbageCollection</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> kl.kubeletConfiguration.ImageGCHighThresholdPercent == <span class="number">100</span> &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).InfoS(<span class="string">"ImageGCHighThresholdPercent is set 100, Disable image GC"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ctx := context.Background()</span><br><span class="line">		<span class="keyword">if</span> err := kl.imageManager.GarbageCollect(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> prevImageGCFailed &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Image garbage collection failed multiple times in a row"</span>)</span><br><span class="line">				<span class="comment">// Only create an event for repeated failures</span></span><br><span class="line">				kl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.ImageGCFailed, err.Error())</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Image garbage collection failed once. Stats initialization may not have completed yet"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			prevImageGCFailed = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> vLevel klog.Level = <span class="number">4</span></span><br><span class="line">			<span class="keyword">if</span> prevImageGCFailed &#123;</span><br><span class="line">				vLevel = <span class="number">1</span></span><br><span class="line">				prevImageGCFailed = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			klog.V(vLevel).InfoS(<span class="string">"Image garbage collection succeeded"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, ImageGCPeriod, wait.NeverStop)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/images/types.go" target="_blank" rel="noopener">pkg/kubelet/images/types.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/images/image_gc_manager.go" target="_blank" rel="noopener">pkg/kubelet/images/image_gc_manager.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/images/image_manager.go" target="_blank" rel="noopener">pkg/kubelet/images/image_manager.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/images/puller.go" target="_blank" rel="noopener">pkg/kubelet/images/puller.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubelet</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之statefulset</title>
    <url>/2023/07/15/kube-controller%E4%B9%8Bstatefulset/</url>
    <content><![CDATA[<h5 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h5><p>StatefulSet 是用来管理有状态应用的工作负载 API 对象。</p>
<p>StatefulSet 用来管理某 Pod 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。</p>
<p>和 Deployment 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</p>
<p>如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 尽管 StatefulSet 中的单个 Pod 仍可能出现故障， 但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。</p>
<h5 id="使用-StatefulSet"><a href="#使用-StatefulSet" class="headerlink" title="使用 StatefulSet"></a>使用 StatefulSet</h5><p>StatefulSet 对于需要满足以下一个或多个需求的应用程序很有价值：</p>
<ul>
<li>稳定的、唯一的网络标识符。</li>
<li>稳定的、持久的存储。</li>
<li>有序的、优雅的部署和扩缩。</li>
<li>有序的、自动的滚动更新。<br>在上面描述中，“稳定的”意味着 Pod 调度或重调度的整个过程是有持久性的。 如果应用程序不需要任何稳定的标识符或有序的部署、删除或扩缩， 则应该使用由一组无状态的副本控制器提供的工作负载来部署应用程序，比如 Deployment 或者 ReplicaSet 可能更适用于你的无状态应用部署需要。</li>
</ul>
<h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><p>给定 Pod 的存储必须由 PersistentVolume Provisioner 基于所请求的 storage class 来制备，或者由管理员预先制备。<br>删除或者扩缩 StatefulSet 并不会删除它关联的存储卷。 这样做是为了保证数据安全，它通常比自动清除 StatefulSet 所有相关的资源更有价值。<br>StatefulSet 当前需要无头服务来负责 Pod 的网络标识。你需要负责创建此服务。<br>当删除一个 StatefulSet 时，该 StatefulSet 不提供任何终止 Pod 的保证。 为了实现 StatefulSet 中的 Pod 可以有序且体面地终止，可以在删除之前将 StatefulSet 缩容到 0。<br>在默认 Pod 管理策略(OrderedReady) 时使用滚动更新， 可能进入需要人工干预才能修复的损坏状态。</p>
<p>以上来自<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">官方文档</a></p>
<hr>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/statefulset/stateful_set.go</span></span><br><span class="line"><span class="keyword">type</span> StatefulSetController <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// client interface</span></span><br><span class="line">	kubeClient clientset.Interface</span><br><span class="line">	<span class="comment">// control returns an interface capable of syncing a stateful set.</span></span><br><span class="line">	<span class="comment">// Abstracted out for testing.</span></span><br><span class="line">	control StatefulSetControlInterface</span><br><span class="line">	<span class="comment">// podControl is used for patching pods.</span></span><br><span class="line">	podControl controller.PodControlInterface</span><br><span class="line">	<span class="comment">// podLister is able to list/get pods from a shared informer's store</span></span><br><span class="line">	podLister corelisters.PodLister</span><br><span class="line">	<span class="comment">// podListerSynced returns true if the pod shared informer has synced at least once</span></span><br><span class="line">	podListerSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// setLister is able to list/get stateful sets from a shared informer's store</span></span><br><span class="line">	setLister appslisters.StatefulSetLister</span><br><span class="line">	<span class="comment">// setListerSynced returns true if the stateful set shared informer has synced at least once</span></span><br><span class="line">	setListerSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// pvcListerSynced returns true if the pvc shared informer has synced at least once</span></span><br><span class="line">	pvcListerSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// revListerSynced returns true if the rev shared informer has synced at least once</span></span><br><span class="line">	revListerSynced cache.InformerSynced</span><br><span class="line">	<span class="comment">// StatefulSets that need to be synced.</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line">	<span class="comment">// eventBroadcaster is the core of event processing pipeline.</span></span><br><span class="line">	eventBroadcaster record.EventBroadcaster</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/statefulset/stateful_set_control.go</span></span><br><span class="line"><span class="comment">// 定义了StatefulSet操作的一些方法</span></span><br><span class="line"><span class="keyword">type</span> StatefulSetControlInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// UpdateStatefulSet implements the control logic for Pod creation, update, and deletion, and</span></span><br><span class="line">	<span class="comment">// persistent volume creation, update, and deletion.</span></span><br><span class="line">	<span class="comment">// If an implementation returns a non-nil error, the invocation will be retried using a rate-limited strategy.</span></span><br><span class="line">	<span class="comment">// Implementors should sink any errors that they do not wish to trigger a retry, and they may feel free to</span></span><br><span class="line">	<span class="comment">// exit exceptionally at any point provided they wish the update to be re-run at a later point in time.</span></span><br><span class="line">    <span class="comment">// 实现Pod和pv的创建，更新，删除操作</span></span><br><span class="line">	UpdateStatefulSet(ctx context.Context, set *apps.StatefulSet, pods []*v1.Pod) (*apps.StatefulSetStatus, error)</span><br><span class="line">	<span class="comment">// ListRevisions returns a array of the ControllerRevisions that represent the revisions of set. If the returned</span></span><br><span class="line">	<span class="comment">// error is nil, the returns slice of ControllerRevisions is valid.</span></span><br><span class="line">	ListRevisions(set *apps.StatefulSet) ([]*apps.ControllerRevision, error)</span><br><span class="line">	<span class="comment">// AdoptOrphanRevisions adopts any orphaned ControllerRevisions that match set's Selector. If all adoptions are</span></span><br><span class="line">	<span class="comment">// successful the returned error is nil.</span></span><br><span class="line">	AdoptOrphanRevisions(set *apps.StatefulSet, revisions []*apps.ControllerRevision) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ControllerRevision 实现了一个不可变的状态数据快照。客户端负责序列化和反序列化包含其内部状态的对象</span></span><br><span class="line"><span class="comment">// 一旦成功创建了 ControllerRevision，就不能对其进行更新,但是可以被删除。API 服务器会拒绝所有试图修改 Data 字段的请求</span></span><br><span class="line"><span class="comment">// 主要被 DaemonSet 和 StatefulSet 控制器用于更新和回滚</span></span><br><span class="line"><span class="comment">// vendor/k8s.io/api/apps/v1/types.go</span></span><br><span class="line"><span class="keyword">type</span> ControllerRevision <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line"></span><br><span class="line">	metav1.ObjectMeta <span class="string">`json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Data is the serialized representation of the state.</span></span><br><span class="line">	Data runtime.RawExtension <span class="string">`json:"data,omitempty" protobuf:"bytes,2,opt,name=data"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Revision indicates the revision of the state represented by Data.</span></span><br><span class="line">	Revision <span class="keyword">int64</span> <span class="string">`json:"revision" protobuf:"varint,3,opt,name=revision"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/statefulset/stateful_set.go</span></span><br><span class="line"><span class="comment">// 新建一个StatefulSet Controller</span></span><br><span class="line"><span class="comment">// 都是一样的操作，设置EventHandler,初始化队列等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStatefulSetController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">	podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	setInformer appsinformers.StatefulSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	pvcInformer coreinformers.PersistentVolumeClaimInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	revInformer appsinformers.ControllerRevisionInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">	kubeClient clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> *<span class="title">StatefulSetController</span></span> &#123;</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">	recorder := eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"statefulset-controller"</span>&#125;)</span><br><span class="line">	ssc := &amp;StatefulSetController&#123;</span><br><span class="line">		kubeClient: kubeClient,</span><br><span class="line">		control: NewDefaultStatefulSetControl(</span><br><span class="line">			NewStatefulPodControl(</span><br><span class="line">				kubeClient,</span><br><span class="line">				podInformer.Lister(),</span><br><span class="line">				pvcInformer.Lister(),</span><br><span class="line">				recorder),</span><br><span class="line">			NewRealStatefulSetStatusUpdater(kubeClient, setInformer.Lister()),</span><br><span class="line">			history.NewHistory(kubeClient, revInformer.Lister()),</span><br><span class="line">			recorder,</span><br><span class="line">		),</span><br><span class="line">		pvcListerSynced: pvcInformer.Informer().HasSynced,</span><br><span class="line">		revListerSynced: revInformer.Informer().HasSynced,</span><br><span class="line">		queue:           workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"statefulset"</span>),</span><br><span class="line">		podControl:      controller.RealPodControl&#123;KubeClient: kubeClient, Recorder: recorder&#125;,</span><br><span class="line"></span><br><span class="line">		eventBroadcaster: eventBroadcaster,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		<span class="comment">// lookup the statefulset and enqueue</span></span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			ssc.addPod(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// lookup current and old statefulset if labels changed</span></span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			ssc.updatePod(logger, oldObj, newObj)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// lookup statefulset accounting for deletion tombstones</span></span><br><span class="line">		DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			ssc.deletePod(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	ssc.podLister = podInformer.Lister()</span><br><span class="line">	ssc.podListerSynced = podInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	setInformer.Informer().AddEventHandler(</span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc: ssc.enqueueStatefulSet,</span><br><span class="line">			UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">				oldPS := old.(*apps.StatefulSet)</span><br><span class="line">				curPS := cur.(*apps.StatefulSet)</span><br><span class="line">				<span class="keyword">if</span> oldPS.Status.Replicas != curPS.Status.Replicas &#123;</span><br><span class="line">					logger.V(<span class="number">4</span>).Info(<span class="string">"Observed updated replica count for StatefulSet"</span>, <span class="string">"statefulSet"</span>, klog.KObj(curPS), <span class="string">"oldReplicas"</span>, oldPS.Status.Replicas, <span class="string">"newReplicas"</span>, curPS.Status.Replicas)</span><br><span class="line">				&#125;</span><br><span class="line">				ssc.enqueueStatefulSet(cur)</span><br><span class="line">			&#125;,</span><br><span class="line">			DeleteFunc: ssc.enqueueStatefulSet,</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line">	ssc.setLister = setInformer.Lister()</span><br><span class="line">	ssc.setListerSynced = setInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Watch volumes</span></span><br><span class="line">	<span class="keyword">return</span> ssc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run runs the statefulset controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start events processing pipeline.</span></span><br><span class="line">	ssc.eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">	ssc.eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: ssc.kubeClient.CoreV1().Events(<span class="string">""</span>)&#125;)</span><br><span class="line">	<span class="keyword">defer</span> ssc.eventBroadcaster.Shutdown()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> ssc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.Info(<span class="string">"Starting stateful set controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> logger.Info(<span class="string">"Shutting down statefulset controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"stateful set"</span>, ctx.Done(), ssc.podListerSynced, ssc.setListerSynced, ssc.pvcListerSynced, ssc.revListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, ssc.worker, time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start events processing pipeline.</span></span><br><span class="line">	ssc.eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">	ssc.eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: ssc.kubeClient.CoreV1().Events(<span class="string">""</span>)&#125;)</span><br><span class="line">	<span class="keyword">defer</span> ssc.eventBroadcaster.Shutdown()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> ssc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.Info(<span class="string">"Starting stateful set controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> logger.Info(<span class="string">"Shutting down statefulset controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"stateful set"</span>, ctx.Done(), ssc.podListerSynced, ssc.setListerSynced, ssc.pvcListerSynced, ssc.revListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, ssc.worker, time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> ssc.processNextWorkItem(ctx) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">processNextWorkItem</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	key, quit := ssc.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> ssc.queue.Done(key)</span><br><span class="line">	<span class="comment">// 调谐函数ssc.sync,所以我们主要的分析集中在sync函数</span></span><br><span class="line">	<span class="keyword">if</span> err := ssc.sync(ctx, key.(<span class="keyword">string</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"error syncing StatefulSet %v, requeuing: %v"</span>, key.(<span class="keyword">string</span>), err))</span><br><span class="line">		ssc.queue.AddRateLimited(key)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ssc.queue.Forget(key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StatefulSet的调谐函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">sync</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		logger.V(<span class="number">4</span>).Info(<span class="string">"Finished syncing statefulset"</span>, <span class="string">"key"</span>, key, <span class="string">"time"</span>, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 通过队列中的key取出命名空间和资源名称</span></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取StatefulSet</span></span><br><span class="line">	set, err := ssc.setLister.StatefulSets(namespace).Get(name)</span><br><span class="line">	<span class="comment">// 如果已经删除了则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		logger.Info(<span class="string">"StatefulSet has been deleted"</span>, <span class="string">"key"</span>, key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 其它错误</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"unable to retrieve StatefulSet %v from store: %v"</span>, key, err))</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取selector</span></span><br><span class="line">	selector, err := metav1.LabelSelectorAsSelector(set.Spec.Selector)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"error converting StatefulSet %v selector: %v"</span>, key, err))</span><br><span class="line">		<span class="comment">// This is a non-transient error, so don't retry.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 收养孤儿ControllerRevisions</span></span><br><span class="line">	<span class="keyword">if</span> err := ssc.adoptOrphanRevisions(ctx, set); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过sts和selector获取对应的pod</span></span><br><span class="line">	pods, err := ssc.getPodsForStatefulSet(ctx, set, selector)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 逻辑操作</span></span><br><span class="line">	<span class="keyword">return</span> ssc.syncStatefulSet(ctx, set, pods)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 收养孤儿ControllerRevisions</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">adoptOrphanRevisions</span><span class="params">(ctx context.Context, set *apps.StatefulSet)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取sts的ControllerRevision列表</span></span><br><span class="line">	revisions, err := ssc.control.ListRevisions(set)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	orphanRevisions := <span class="built_in">make</span>([]*apps.ControllerRevision, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> revisions &#123;</span><br><span class="line">		<span class="comment">// 获取OwnerReference</span></span><br><span class="line">		<span class="keyword">if</span> metav1.GetControllerOf(revisions[i]) == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// OwnerReference为空</span></span><br><span class="line">			orphanRevisions = <span class="built_in">append</span>(orphanRevisions, revisions[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 存在孤儿ControllerRevisions</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(orphanRevisions) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 判断是否能收养，再进行一次check</span></span><br><span class="line">		canAdoptErr := ssc.canAdoptFunc(ctx, set)(ctx)</span><br><span class="line">		<span class="keyword">if</span> canAdoptErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"can't adopt ControllerRevisions: %v"</span>, canAdoptErr)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ssc.control.AdoptOrphanRevisions(set, orphanRevisions)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">syncStatefulSet</span><span class="params">(ctx context.Context, set *apps.StatefulSet, pods []*v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Syncing StatefulSet with pods"</span>, <span class="string">"statefulSet"</span>, klog.KObj(set), <span class="string">"pods"</span>, <span class="built_in">len</span>(pods))</span><br><span class="line">	<span class="keyword">var</span> status *apps.StatefulSetStatus</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	status, err = ssc.control.UpdateStatefulSet(ctx, set, pods)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Successfully synced StatefulSet"</span>, <span class="string">"statefulSet"</span>, klog.KObj(set))</span><br><span class="line">	<span class="comment">// One more sync to handle the clock skew. This is also helping in requeuing right after status update</span></span><br><span class="line">	<span class="keyword">if</span> set.Spec.MinReadySeconds &gt; <span class="number">0</span> &amp;&amp; status != <span class="literal">nil</span> &amp;&amp; status.AvailableReplicas != *set.Spec.Replicas &#123;</span><br><span class="line">		ssc.enqueueSSAfter(set, time.Duration(set.Spec.MinReadySeconds)*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sts调谐的核心逻辑，默认采用[monotonic update strategy],扩容按照一定的顺序进行，只有当所有pod都Ready了才会创建后面的Pod,</span></span><br><span class="line"><span class="comment">// 缩容是如扩容是不一样的顺序(比如扩容是1-&gt;2-&gt;3,缩容则是3-&gt;2-&gt;1)</span></span><br><span class="line"><span class="comment">// 如果采用的是[burst strategy]则没有这么多的限制，Pod将会被迅速创建和删除，并且没有特定的顺序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *defaultStatefulSetControl)</span> <span class="title">UpdateStatefulSet</span><span class="params">(ctx context.Context, set *apps.StatefulSet, pods []*v1.Pod)</span> <span class="params">(*apps.StatefulSetStatus, error)</span></span> &#123;</span><br><span class="line">	set = set.DeepCopy() <span class="comment">// set is modified when a new revision is created in performUpdate. Make a copy now to avoid mutation errors.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取所有的Revisions</span></span><br><span class="line">	revisions, err := ssc.ListRevisions(set)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对revisions进行排序</span></span><br><span class="line">	history.SortControllerRevisions(revisions)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	currentRevision, updateRevision, status, err := ssc.performUpdate(ctx, set, pods, revisions)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, utilerrors.NewAggregate([]error&#123;err, ssc.truncateHistory(set, pods, revisions, currentRevision, updateRevision)&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// maintain the set's revision history limit</span></span><br><span class="line">	<span class="comment">// history保持一定的长度以避免占用过多的资源</span></span><br><span class="line">	<span class="keyword">return</span> status, ssc.truncateHistory(set, pods, revisions, currentRevision, updateRevision)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *defaultStatefulSetControl)</span> <span class="title">performUpdate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context, set *apps.StatefulSet, pods []*v1.Pod, revisions []*apps.ControllerRevision)</span> <span class="params">(*apps.ControllerRevision, *apps.ControllerRevision, *apps.StatefulSetStatus, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> currentStatus *apps.StatefulSetStatus</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	<span class="comment">// get the current, and update revisions</span></span><br><span class="line">	currentRevision, updateRevision, collisionCount, err := ssc.getStatefulSetRevisions(set, revisions)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> currentRevision, updateRevision, currentStatus, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行更新逻辑并返回获取状态</span></span><br><span class="line">	currentStatus, err = ssc.updateStatefulSet(ctx, set, currentRevision, updateRevision, collisionCount, pods)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; currentStatus == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> currentRevision, updateRevision, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// make sure to update the latest status even if there is an error with non-nil currentStatus</span></span><br><span class="line">	statusErr := ssc.updateStatefulSetStatus(ctx, set, currentStatus)</span><br><span class="line">	<span class="keyword">if</span> statusErr == <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.V(<span class="number">4</span>).Info(<span class="string">"Updated status"</span>, <span class="string">"statefulSet"</span>, klog.KObj(set),</span><br><span class="line">			<span class="string">"replicas"</span>, currentStatus.Replicas,</span><br><span class="line">			<span class="string">"readyReplicas"</span>, currentStatus.ReadyReplicas,</span><br><span class="line">			<span class="string">"currentReplicas"</span>, currentStatus.CurrentReplicas,</span><br><span class="line">			<span class="string">"updatedReplicas"</span>, currentStatus.UpdatedReplicas)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span> &amp;&amp; statusErr != <span class="literal">nil</span>:</span><br><span class="line">		klog.ErrorS(statusErr, <span class="string">"Could not update status"</span>, <span class="string">"statefulSet"</span>, klog.KObj(set))</span><br><span class="line">		<span class="keyword">return</span> currentRevision, updateRevision, currentStatus, err</span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> currentRevision, updateRevision, currentStatus, err</span><br><span class="line">	<span class="keyword">case</span> statusErr != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> currentRevision, updateRevision, currentStatus, statusErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"StatefulSet revisions"</span>, <span class="string">"statefulSet"</span>, klog.KObj(set),</span><br><span class="line">		<span class="string">"currentRevision"</span>, currentStatus.CurrentRevision,</span><br><span class="line">		<span class="string">"updateRevision"</span>, currentStatus.UpdateRevision)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> currentRevision, updateRevision, currentStatus, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/statefulset/stateful_set_control.go</span></span><br><span class="line"><span class="comment">// StatefulSet控制器最核心逻辑。updateStatefulSet以特定的顺序creates,updates,deletes statefulset中的pod</span></span><br><span class="line"><span class="comment">// 以达到预期的状态。</span></span><br><span class="line"><span class="comment">// 如果更新策略为RollingUpdateStatefulSetStrategyType,sts中的所有pod必须在sts.Status.CurrentRevision中</span></span><br><span class="line"><span class="comment">// 如果更新策略为OnDeleteStatefulSetStrategyType,目标状态对sts中的pod的revision没有任何意义</span></span><br><span class="line"><span class="comment">// 如果更新策略为PartitionStatefulSetStrategyType所有pod ordinal低于UpdateStrategy.Partition.Ordinal必须存在</span></span><br><span class="line"><span class="comment">// 于Status.CurrentRevision,其余的pod必须在Status.UpdateRevision.</span></span><br><span class="line"><span class="comment">// 返回值：error=nil,说明StatefulSetStatus是有效的，更新必须记录。如果error!=nil,进行重试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *defaultStatefulSetControl)</span> <span class="title">updateStatefulSet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">	set *apps.StatefulSet,</span></span></span><br><span class="line"><span class="function"><span class="params">	currentRevision *apps.ControllerRevision,</span></span></span><br><span class="line"><span class="function"><span class="params">	updateRevision *apps.ControllerRevision,</span></span></span><br><span class="line"><span class="function"><span class="params">	collisionCount <span class="keyword">int32</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	pods []*v1.Pod)</span> <span class="params">(*apps.StatefulSetStatus, error)</span></span> &#123;</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新sts Revision并返回currentSet</span></span><br><span class="line">	currentSet, err := ApplyRevision(set, currentRevision)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新sts Revision并返回updateSet</span></span><br><span class="line">	updateSet, err := ApplyRevision(set, updateRevision)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回的状态，设置对应的值</span></span><br><span class="line">	status := apps.StatefulSetStatus&#123;&#125;</span><br><span class="line">	status.ObservedGeneration = set.Generation</span><br><span class="line">	status.CurrentRevision = currentRevision.Name</span><br><span class="line">	status.UpdateRevision = updateRevision.Name</span><br><span class="line">	status.CollisionCount = <span class="built_in">new</span>(<span class="keyword">int32</span>)</span><br><span class="line">	*status.CollisionCount = collisionCount</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 期望副本数</span></span><br><span class="line">	replicaCount := <span class="keyword">int</span>(*set.Spec.Replicas)</span><br><span class="line">	<span class="comment">// slice that will contain all Pods such that getStartOrdinal(set) &lt;= getOrdinal(pod) &lt;= getEndOrdinal(set)</span></span><br><span class="line">	<span class="comment">// 记录在范围之内的pod</span></span><br><span class="line">	replicas := <span class="built_in">make</span>([]*v1.Pod, replicaCount)</span><br><span class="line">	<span class="comment">// slice that will contain all Pods such that getOrdinal(pod) &lt; getStartOrdinal(set) OR getOrdinal(pod) &gt; getEndOrdinal(set)</span></span><br><span class="line">	<span class="comment">// condemned记录的应该是要遗弃的pod</span></span><br><span class="line">	condemned := <span class="built_in">make</span>([]*v1.Pod, <span class="number">0</span>, <span class="built_in">len</span>(pods))</span><br><span class="line">	unhealthy := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> firstUnhealthyPod *v1.Pod</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First we partition pods into two lists valid replicas and condemned Pods</span></span><br><span class="line">	<span class="comment">// 遍历pods,分别记录到replicas和condemned</span></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		<span class="comment">// 统计sts副本数</span></span><br><span class="line">		status.Replicas++</span><br><span class="line"></span><br><span class="line">		<span class="comment">// count the number of running and ready replicas</span></span><br><span class="line">		<span class="keyword">if</span> isRunningAndReady(pod) &#123;</span><br><span class="line">			<span class="comment">// 统计Ready状态的副本数</span></span><br><span class="line">			status.ReadyReplicas++</span><br><span class="line">			<span class="comment">// 统计Running和Available状态的副本数</span></span><br><span class="line">			<span class="keyword">if</span> isRunningAndAvailable(pod, set.Spec.MinReadySeconds) &#123;</span><br><span class="line">				status.AvailableReplicas++</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// count the number of current and update replicas</span></span><br><span class="line">		<span class="keyword">if</span> isCreated(pod) &amp;&amp; !isTerminating(pod) &#123;</span><br><span class="line">			<span class="keyword">if</span> getPodRevision(pod) == currentRevision.Name &#123;</span><br><span class="line">				status.CurrentReplicas++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> getPodRevision(pod) == updateRevision.Name &#123;</span><br><span class="line">				status.UpdatedReplicas++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> podInOrdinalRange(pod, set) &#123;</span><br><span class="line">			<span class="comment">// if the ordinal of the pod is within the range of the current number of replicas,</span></span><br><span class="line">			<span class="comment">// insert it at the indirection of its ordinal</span></span><br><span class="line">			<span class="comment">// 将符合条件的pod添加到replicas列表中</span></span><br><span class="line">			replicas[getOrdinal(pod)-getStartOrdinal(set)] = pod</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> getOrdinal(pod) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// if the ordinal is valid, but not within the range add it to the condemned list</span></span><br><span class="line">			condemned = <span class="built_in">append</span>(condemned, pod)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If the ordinal could not be parsed (ord &lt; 0), ignore the Pod.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for any empty indices in the sequence [0,set.Spec.Replicas) create a new Pod at the correct revision</span></span><br><span class="line">	<span class="comment">// 为每个pod创建revision</span></span><br><span class="line">	<span class="keyword">for</span> ord := getStartOrdinal(set); ord &lt;= getEndOrdinal(set); ord++ &#123;</span><br><span class="line">		replicaIdx := ord - getStartOrdinal(set)</span><br><span class="line">		<span class="keyword">if</span> replicas[replicaIdx] == <span class="literal">nil</span> &#123;</span><br><span class="line">			replicas[replicaIdx] = newVersionedStatefulSetPod(</span><br><span class="line">				currentSet,</span><br><span class="line">				updateSet,</span><br><span class="line">				currentRevision.Name,</span><br><span class="line">				updateRevision.Name, ord)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort the condemned Pods by their ordinals</span></span><br><span class="line">	<span class="comment">// 对condemned pods根据ordinal排序</span></span><br><span class="line">	sort.Sort(ascendingOrdinal(condemned))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the first unhealthy Pod</span></span><br><span class="line">	<span class="comment">// 找到第一个unhealthy的pod,并统计unhealthy pod数量</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">		<span class="keyword">if</span> !isHealthy(replicas[i]) &#123;</span><br><span class="line">			unhealthy++</span><br><span class="line">			<span class="keyword">if</span> firstUnhealthyPod == <span class="literal">nil</span> &#123;</span><br><span class="line">				firstUnhealthyPod = replicas[i]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> condemned &#123;</span><br><span class="line">		<span class="keyword">if</span> !isHealthy(condemned[i]) &#123;</span><br><span class="line">			unhealthy++</span><br><span class="line">			<span class="keyword">if</span> firstUnhealthyPod == <span class="literal">nil</span> &#123;</span><br><span class="line">				firstUnhealthyPod = condemned[i]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> unhealthy &gt; <span class="number">0</span> &#123;</span><br><span class="line">		logger.V(<span class="number">4</span>).Info(<span class="string">"StatefulSet has unhealthy Pods"</span>, <span class="string">"statefulSet"</span>, klog.KObj(set), <span class="string">"unhealthyReplicas"</span>, unhealthy, <span class="string">"pod"</span>, klog.KObj(firstUnhealthyPod))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the StatefulSet is being deleted, don't do anything other than updating</span></span><br><span class="line">	<span class="comment">// status.</span></span><br><span class="line">	<span class="comment">// sts已经被删除，返回</span></span><br><span class="line">	<span class="keyword">if</span> set.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	monotonic := !allowsBurst(set)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Examine each replica with respect to its ordinal</span></span><br><span class="line">	<span class="comment">// 遍历replicas</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">		<span class="comment">// delete and recreate failed pods</span></span><br><span class="line">		<span class="keyword">if</span> isFailed(replicas[i]) &#123;</span><br><span class="line">			ssc.recorder.Eventf(set, v1.EventTypeWarning, <span class="string">"RecreatingFailedPod"</span>,</span><br><span class="line">				<span class="string">"StatefulSet %s/%s is recreating failed Pod %s"</span>,</span><br><span class="line">				set.Namespace,</span><br><span class="line">				set.Name,</span><br><span class="line">				replicas[i].Name)</span><br><span class="line">			<span class="comment">// 删除pod</span></span><br><span class="line">			<span class="keyword">if</span> err := ssc.podControl.DeleteStatefulPod(set, replicas[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;status, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> getPodRevision(replicas[i]) == currentRevision.Name &#123;</span><br><span class="line">				status.CurrentReplicas--</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> getPodRevision(replicas[i]) == updateRevision.Name &#123;</span><br><span class="line">				status.UpdatedReplicas--</span><br><span class="line">			&#125;</span><br><span class="line">			status.Replicas--</span><br><span class="line">			replicaOrd := i + getStartOrdinal(set)</span><br><span class="line">			<span class="comment">// 设置新的revision</span></span><br><span class="line">			replicas[i] = newVersionedStatefulSetPod(</span><br><span class="line">				currentSet,</span><br><span class="line">				updateSet,</span><br><span class="line">				currentRevision.Name,</span><br><span class="line">				updateRevision.Name,</span><br><span class="line">				replicaOrd)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If we find a Pod that has not been created we create the Pod</span></span><br><span class="line">		<span class="comment">// 没有创建对应的pod,则创建</span></span><br><span class="line">		<span class="keyword">if</span> !isCreated(replicas[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) &#123;</span><br><span class="line">				<span class="keyword">if</span> isStale, err := ssc.podControl.PodClaimIsStale(set, replicas[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> &amp;status, err</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> isStale &#123;</span><br><span class="line">					<span class="comment">// If a pod has a stale PVC, no more work can be done this round.</span></span><br><span class="line">					<span class="keyword">return</span> &amp;status, err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 创建pod</span></span><br><span class="line">			<span class="keyword">if</span> err := ssc.podControl.CreateStatefulPod(ctx, set, replicas[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;status, err</span><br><span class="line">			&#125;</span><br><span class="line">			status.Replicas++</span><br><span class="line">			<span class="keyword">if</span> getPodRevision(replicas[i]) == currentRevision.Name &#123;</span><br><span class="line">				status.CurrentReplicas++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> getPodRevision(replicas[i]) == updateRevision.Name &#123;</span><br><span class="line">				status.UpdatedReplicas++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// if the set does not allow bursting, return immediately</span></span><br><span class="line">			<span class="keyword">if</span> monotonic &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// pod created, no more work possible for this round</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果pod处于pending状态，会触发创建缺失PVC的动作</span></span><br><span class="line">		<span class="keyword">if</span> isPending(replicas[i]) &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(</span><br><span class="line">				<span class="string">"StatefulSet %s/%s is triggering PVC creation for pending Pod %s"</span>,</span><br><span class="line">				set.Namespace,</span><br><span class="line">				set.Name,</span><br><span class="line">				replicas[i].Name)</span><br><span class="line">			<span class="keyword">if</span> err := ssc.podControl.createMissingPersistentVolumeClaims(ctx, set, replicas[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;status, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If we find a Pod that is currently terminating, we must wait until graceful deletion</span></span><br><span class="line">		<span class="comment">// completes before we continue to make progress.</span></span><br><span class="line">		<span class="comment">// 如果一个pod处于terminating状态，我们必须等待pod优雅删除完成，才成继续往下走</span></span><br><span class="line">		<span class="keyword">if</span> isTerminating(replicas[i]) &amp;&amp; monotonic &#123;</span><br><span class="line">			logger.V(<span class="number">4</span>).Info(<span class="string">"StatefulSet is waiting for Pod to Terminate"</span>,</span><br><span class="line">				<span class="string">"statefulSet"</span>, klog.KObj(set), <span class="string">"pod"</span>, klog.KObj(replicas[i]))</span><br><span class="line">			<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If we have a Pod that has been created but is not running and ready we can not make progress.</span></span><br><span class="line">		<span class="comment">// We must ensure that all for each Pod, when we create it, all of its predecessors, with respect to its</span></span><br><span class="line">		<span class="comment">// ordinal, are Running and Ready.</span></span><br><span class="line">		<span class="comment">// 如果一个pod不是running和ready状态，我们可以退出这次调谐</span></span><br><span class="line">		<span class="keyword">if</span> !isRunningAndReady(replicas[i]) &amp;&amp; monotonic &#123;</span><br><span class="line">			logger.V(<span class="number">4</span>).Info(<span class="string">"StatefulSet is waiting for Pod to be Running and Ready"</span>,</span><br><span class="line">				<span class="string">"statefulSet"</span>, klog.KObj(set), <span class="string">"pod"</span>, klog.KObj(replicas[i]))</span><br><span class="line">			<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If we have a Pod that has been created but is not available we can not make progress.</span></span><br><span class="line">		<span class="comment">// We must ensure that all for each Pod, when we create it, all of its predecessors, with respect to its</span></span><br><span class="line">		<span class="comment">// ordinal, are Available.</span></span><br><span class="line">		<span class="keyword">if</span> !isRunningAndAvailable(replicas[i], set.Spec.MinReadySeconds) &amp;&amp; monotonic &#123;</span><br><span class="line">			logger.V(<span class="number">4</span>).Info(<span class="string">"StatefulSet is waiting for Pod to be Available"</span>,</span><br><span class="line">				<span class="string">"statefulSet"</span>, klog.KObj(set), <span class="string">"pod"</span>, klog.KObj(replicas[i]))</span><br><span class="line">			<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Enforce the StatefulSet invariants</span></span><br><span class="line">		retentionMatch := <span class="literal">true</span></span><br><span class="line">		<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) &#123;</span><br><span class="line">			<span class="keyword">var</span> err error</span><br><span class="line">			retentionMatch, err = ssc.podControl.ClaimsMatchRetentionPolicy(ctx, updateSet, replicas[i])</span><br><span class="line">			<span class="comment">// An error is expected if the pod is not yet fully updated, and so return is treated as matching.</span></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				retentionMatch = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> identityMatches(set, replicas[i]) &amp;&amp; storageMatches(set, replicas[i]) &amp;&amp; retentionMatch &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Make a deep copy so we don't mutate the shared cache</span></span><br><span class="line">		replica := replicas[i].DeepCopy()</span><br><span class="line">		<span class="keyword">if</span> err := ssc.podControl.UpdateStatefulPod(ctx, updateSet, replica); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;status, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC) &#123;</span><br><span class="line">		<span class="comment">// Ensure ownerRefs are set correctly for the condemned pods.</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> condemned &#123;</span><br><span class="line">			<span class="keyword">if</span> matchPolicy, err := ssc.podControl.ClaimsMatchRetentionPolicy(ctx, updateSet, condemned[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;status, err</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> !matchPolicy &#123;</span><br><span class="line">				<span class="keyword">if</span> err := ssc.podControl.UpdatePodClaimForRetentionPolicy(ctx, updateSet, condemned[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> &amp;status, err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// At this point, all of the current Replicas are Running, Ready and Available, we can consider termination.</span></span><br><span class="line">	<span class="comment">// We will wait for all predecessors to be Running and Ready prior to attempting a deletion.</span></span><br><span class="line">	<span class="comment">// We will terminate Pods in a monotonically decreasing order.</span></span><br><span class="line">	<span class="comment">// Note that we do not resurrect Pods in this interval. Also note that scaling will take precedence over</span></span><br><span class="line">	<span class="comment">// updates.</span></span><br><span class="line">	<span class="keyword">for</span> target := <span class="built_in">len</span>(condemned) - <span class="number">1</span>; target &gt;= <span class="number">0</span>; target-- &#123;</span><br><span class="line">		<span class="comment">// wait for terminating pods to expire</span></span><br><span class="line">		<span class="keyword">if</span> isTerminating(condemned[target]) &#123;</span><br><span class="line">			logger.V(<span class="number">4</span>).Info(<span class="string">"StatefulSet is waiting for Pod to Terminate prior to scale down"</span>,</span><br><span class="line">				<span class="string">"statefulSet"</span>, klog.KObj(set), <span class="string">"pod"</span>, klog.KObj(condemned[target]))</span><br><span class="line">			<span class="comment">// block if we are in monotonic mode</span></span><br><span class="line">			<span class="keyword">if</span> monotonic &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// if we are in monotonic mode and the condemned target is not the first unhealthy Pod block</span></span><br><span class="line">		<span class="keyword">if</span> !isRunningAndReady(condemned[target]) &amp;&amp; monotonic &amp;&amp; condemned[target] != firstUnhealthyPod &#123;</span><br><span class="line">			logger.V(<span class="number">4</span>).Info(<span class="string">"StatefulSet is waiting for Pod to be Running and Ready prior to scale down"</span>,</span><br><span class="line">				<span class="string">"statefulSet"</span>, klog.KObj(set), <span class="string">"pod"</span>, klog.KObj(firstUnhealthyPod))</span><br><span class="line">			<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// if we are in monotonic mode and the condemned target is not the first unhealthy Pod, block.</span></span><br><span class="line">		<span class="keyword">if</span> !isRunningAndAvailable(condemned[target], set.Spec.MinReadySeconds) &amp;&amp; monotonic &amp;&amp; condemned[target] != firstUnhealthyPod &#123;</span><br><span class="line">			logger.V(<span class="number">4</span>).Info(<span class="string">"StatefulSet is waiting for Pod to be Available prior to scale down"</span>,</span><br><span class="line">				<span class="string">"statefulSet"</span>, klog.KObj(set), <span class="string">"pod"</span>, klog.KObj(firstUnhealthyPod))</span><br><span class="line">			<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		logger.V(<span class="number">2</span>).Info(<span class="string">"Pod of StatefulSet is terminating for scale down"</span>,</span><br><span class="line">			<span class="string">"statefulSet"</span>, klog.KObj(set), <span class="string">"pod"</span>, klog.KObj(condemned[target]))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := ssc.podControl.DeleteStatefulPod(set, condemned[target]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;status, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> getPodRevision(condemned[target]) == currentRevision.Name &#123;</span><br><span class="line">			status.CurrentReplicas--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> getPodRevision(condemned[target]) == updateRevision.Name &#123;</span><br><span class="line">			status.UpdatedReplicas--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> monotonic &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for the OnDelete strategy we short circuit. Pods will be updated when they are manually deleted.</span></span><br><span class="line">	<span class="keyword">if</span> set.Spec.UpdateStrategy.Type == apps.OnDeleteStatefulSetStrategyType &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.MaxUnavailableStatefulSet) &#123;</span><br><span class="line">		<span class="keyword">return</span> updateStatefulSetAfterInvariantEstablished(ctx,</span><br><span class="line">			ssc,</span><br><span class="line">			set,</span><br><span class="line">			replicas,</span><br><span class="line">			updateRevision,</span><br><span class="line">			status,</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we compute the minimum ordinal of the target sequence for a destructive update based on the strategy.</span></span><br><span class="line">	updateMin := <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> set.Spec.UpdateStrategy.RollingUpdate != <span class="literal">nil</span> &#123;</span><br><span class="line">		updateMin = <span class="keyword">int</span>(*set.Spec.UpdateStrategy.RollingUpdate.Partition)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// we terminate the Pod with the largest ordinal that does not match the update revision.</span></span><br><span class="line">	<span class="keyword">for</span> target := <span class="built_in">len</span>(replicas) - <span class="number">1</span>; target &gt;= updateMin; target-- &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// delete the Pod if it is not already terminating and does not match the update revision.</span></span><br><span class="line">		<span class="keyword">if</span> getPodRevision(replicas[target]) != updateRevision.Name &amp;&amp; !isTerminating(replicas[target]) &#123;</span><br><span class="line">			logger.V(<span class="number">2</span>).Info(<span class="string">"Pod of StatefulSet is terminating for update"</span>,</span><br><span class="line">				<span class="string">"statefulSet"</span>, klog.KObj(set), <span class="string">"pod"</span>, klog.KObj(replicas[target]))</span><br><span class="line">			<span class="keyword">if</span> err := ssc.podControl.DeleteStatefulPod(set, replicas[target]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> !errors.IsNotFound(err) &#123;</span><br><span class="line">					<span class="keyword">return</span> &amp;status, err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			status.CurrentReplicas--</span><br><span class="line">			<span class="keyword">return</span> &amp;status, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// wait for unhealthy Pods on update</span></span><br><span class="line">		<span class="keyword">if</span> !isHealthy(replicas[target]) &#123;</span><br><span class="line">			logger.V(<span class="number">4</span>).Info(<span class="string">"StatefulSet is waiting for Pod to update"</span>,</span><br><span class="line">				<span class="string">"statefulSet"</span>, klog.KObj(set), <span class="string">"pod"</span>, klog.KObj(replicas[target]))</span><br><span class="line">			<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;status, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/statefulset/stateful_set.go" target="_blank" rel="noopener">pkg/controller/statefulset/stateful_set.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/statefulset/stateful_set_control.go" target="_blank" rel="noopener">pkg/controller/statefulset/stateful_set_control.go</a></p>
<ol>
<li><a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/vendor/k8s.io/api/apps/v1/types.go" target="_blank" rel="noopener">vendor/k8s.io/api/apps/v1/types.go</a></li>
</ol>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller之ttlafterfinished</title>
    <url>/2023/06/24/kube-controller%E4%B9%8Bttlafterfinished/</url>
    <content><![CDATA[<h5 id="TTLAfterFinished"><a href="#TTLAfterFinished" class="headerlink" title="TTLAfterFinished"></a>TTLAfterFinished</h5><p><code>TTLAfterFinished</code>是一种自动清理已完成的 <code>Job</code>（包括 <code>Complete</code> 或 <code>Failed</code> 状态）的方法。其使用 <code>TTL</code> 机制，通过指定 <code>Job</code>的 <code>.spec.ttlSecondsAfterFinished</code> 字段。</p>
<p>当 <code>TTLAfterFinished-Controller</code>清理 <code>Job</code> 时，它将级联删除该 <code>Job</code>，即连同 <code>Job</code> 依赖的对象（例如 <code>Pods</code>）一起删除。请注意，当 <code>Jo</code>b 被删除时，将遵守其生命周期保证，例如 <code>finalizer</code>。</p>
<p><code>TTLAfterFinished-Controller</code> 是负责监视 <code>Job API</code> 对象变化的组件。它通过监听 <code>Job</code> 的创建和更新事件，并将具有非空 <code>.spec.ttlSecondsAfterFinished</code> 字段的 <code>Job</code> 加入到队列中。<code>TTLAfterFinished-Controller</code>从队列中获取 <code>Job</code>，检查 <code>Job</code> 的 <code>TTL</code> 是否已过期。如果 <code>Job</code> 的 <code>TTL</code> 尚未过期，<code>Worker</code>将在预计 <code>TTL</code> 过期后将 <code>Job</code> 再次加入队列；如果 <code>TTL</code> 已过期，<code>Worker</code>将向 <code>APIServer</code>发送请求以相应地删除这些 <code>Job</code>。</p>
<p>这部分功能的实现与 <code>Job</code> 控制器分开，是为了分离关注点，并且可以扩展到处理其他可完成的资源类型。这种设计可以让 <code>Job-Controller</code> 只关注监视和管理 <code>Job</code> 的状态，而将具体的 <code>TTL</code>过期处理逻辑交给独立的组件来实现。这样可以提高代码的可维护性和可扩展性，并使代码结构更清晰。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi-with-ttl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="comment"># job pi-with-ttl将会在job完成后的100秒被删除</span></span><br><span class="line"><span class="comment"># 如果ttlSecondsAfterFinished设置为0,将会在job完成后立即删除 </span></span><br><span class="line">  <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl:5.34.0</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">["perl",</span>  <span class="string">"-Mbignum=bpi"</span><span class="string">,</span> <span class="string">"-wle"</span><span class="string">,</span> <span class="string">"print bpi(2000)"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/ttlafterfinished/ttlafterfinished_controller.go</span></span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">	client   clientset.Interface</span><br><span class="line">	recorder record.EventRecorder</span><br><span class="line"></span><br><span class="line">	<span class="comment">// jLister can list/get Jobs from the shared informer's store</span></span><br><span class="line">	jLister batchlisters.JobLister</span><br><span class="line"></span><br><span class="line">	<span class="comment">// jStoreSynced returns true if the Job store has been synced at least once.</span></span><br><span class="line">	<span class="comment">// Added as a member to the struct to allow injection for testing.</span></span><br><span class="line">	jListerSynced cache.InformerSynced</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Jobs that the controller will check its TTL and attempt to delete when the TTL expires.</span></span><br><span class="line">	queue workqueue.RateLimitingInterface</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The clock for tracking time</span></span><br><span class="line">	clock clock.Clock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个Controller</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(ctx context.Context, jobInformer batchinformers.JobInformer, client clientset.Interface)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">	eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">	eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">	eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: client.CoreV1().Events(<span class="string">""</span>)&#125;)</span><br><span class="line"></span><br><span class="line">	metrics.Register()</span><br><span class="line"></span><br><span class="line">	tc := &amp;Controller&#123;</span><br><span class="line">		client:   client,</span><br><span class="line">		recorder: eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">"ttl-after-finished-controller"</span>&#125;),</span><br><span class="line">		queue:    workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"ttl_jobs_to_delete"</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">    <span class="comment">// Informer</span></span><br><span class="line">	jobInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			tc.addJob(logger, obj)</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			tc.updateJob(logger, oldObj, newObj)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	tc.jLister = jobInformer.Lister()</span><br><span class="line">	tc.jListerSynced = jobInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line">	tc.clock = clock.RealClock&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tc *Controller)</span> <span class="title">addJob</span><span class="params">(logger klog.Logger, obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	job := obj.(*batch.Job)</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Adding job"</span>, <span class="string">"job"</span>, klog.KObj(job))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// job没有被删除和j.Spec.TTLSecondsAfterFinished不为空和job已经完成 </span></span><br><span class="line">	<span class="keyword">if</span> job.DeletionTimestamp == <span class="literal">nil</span> &amp;&amp; needsCleanup(job) &#123;</span><br><span class="line">		tc.enqueue(logger, job)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tc *Controller)</span> <span class="title">updateJob</span><span class="params">(logger klog.Logger, old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	job := cur.(*batch.Job)</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Updating job"</span>, <span class="string">"job"</span>, klog.KObj(job))</span><br><span class="line">    <span class="comment">// job没有被删除和j.Spec.TTLSecondsAfterFinished不为空和job已经完成 </span></span><br><span class="line">	<span class="keyword">if</span> job.DeletionTimestamp == <span class="literal">nil</span> &amp;&amp; needsCleanup(job) &#123;</span><br><span class="line">		tc.enqueue(logger, job)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TTLSecondsAfterFinished != nil &amp;&amp; Job已经完成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needsCleanup</span><span class="params">(j *batch.Job)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> j.Spec.TTLSecondsAfterFinished != <span class="literal">nil</span> &amp;&amp; jobutil.IsJobFinished(j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动Worker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tc *Controller)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> tc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.Info(<span class="string">"Starting TTL after finished controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> logger.Info(<span class="string">"Shutting down TTL after finished controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"TTL after finished"</span>, ctx.Done(), tc.jListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, tc.worker, time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tc *Controller)</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> tc.processNextWorkItem(ctx) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tc *Controller)</span> <span class="title">processNextWorkItem</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	key, quit := tc.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> tc.queue.Done(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调谐函数为processJob</span></span><br><span class="line">	err := tc.processJob(ctx, key.(<span class="keyword">string</span>))</span><br><span class="line">	tc.handleErr(err, key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processJob 函数用于检查 Job 的状态和 TTL，并在 Job 完成并且其 TTL 过期后将其删除。</span></span><br><span class="line"><span class="comment">// 如果 Job 尚未完成或者其 TTL 尚未过期，将在预计 TTL 过期后将 Job 重新添加到队列中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是，该函数不应在相同的 key 下并发调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tc *Controller)</span> <span class="title">processJob</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从key中解析出namespace和资源名称</span></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ignore the Jobs that are already deleted or being deleted, or the ones that don't need clean up.</span></span><br><span class="line">    <span class="comment">// 获取对应的Job</span></span><br><span class="line">	job, err := tc.jLister.Jobs(namespace).Get(name)</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Checking if Job is ready for cleanup"</span>, <span class="string">"job"</span>, klog.KRef(namespace, name))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> expiredAt, err := tc.processTTL(logger, job); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> expiredAt == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The Job's TTL is assumed to have expired, but the Job TTL might be stale.</span></span><br><span class="line">	<span class="comment">// Before deleting the Job, do a final sanity check.</span></span><br><span class="line">	<span class="comment">// If TTL is modified before we do this check, we cannot be sure if the TTL truly expires.</span></span><br><span class="line">	<span class="comment">// The latest Job may have a different UID, but it's fine because the checks will be run again.</span></span><br><span class="line">    <span class="comment">// 在删除前再检查一个Job</span></span><br><span class="line">	fresh, err := tc.client.BatchV1().Jobs(namespace).Get(ctx, name, metav1.GetOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Use the latest Job TTL to see if the TTL truly expires.</span></span><br><span class="line">    <span class="comment">// 用最新的job检查TTL是否真正的过期</span></span><br><span class="line">	expiredAt, err := tc.processTTL(logger, fresh)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> expiredAt == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Cascade deletes the Jobs if TTL truly expires.</span></span><br><span class="line">	policy := metav1.DeletePropagationForeground</span><br><span class="line">	options := metav1.DeleteOptions&#123;</span><br><span class="line">		PropagationPolicy: &amp;policy,</span><br><span class="line">		Preconditions:     &amp;metav1.Preconditions&#123;UID: &amp;fresh.UID&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Cleaning up Job"</span>, <span class="string">"job"</span>, klog.KObj(fresh))</span><br><span class="line">    <span class="comment">// 删除对应的job</span></span><br><span class="line">	<span class="keyword">if</span> err := tc.client.BatchV1().Jobs(fresh.Namespace).Delete(ctx, fresh.Name, options); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	metrics.JobDeletionDurationSeconds.Observe(time.Since(*expiredAt).Seconds())</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processTTL检查Job的TTL是否过期，将在预计 TTL 过期后将 Job 重新添加到队列中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tc *Controller)</span> <span class="title">processTTL</span><span class="params">(logger klog.Logger, job *batch.Job)</span> <span class="params">(expiredAt *time.Time, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We don't care about the Jobs that are going to be deleted, or the ones that don't need clean up.</span></span><br><span class="line">    <span class="comment">// job已经删除或者不需要清理(TTL为空或者Job未完成)</span></span><br><span class="line">	<span class="keyword">if</span> job.DeletionTimestamp != <span class="literal">nil</span> || !needsCleanup(job) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	now := tc.clock.Now()</span><br><span class="line">	t, e, err := timeLeft(logger, job, &amp;now)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TTL has expired</span></span><br><span class="line">	<span class="keyword">if</span> *t &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> e, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tc.enqueueAfter(job, *t)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/controller/ttlafterfinished/ttlafterfinished_controller.go" target="_blank" rel="noopener">pkg/controller/ttlafterfinished/ttlafterfinished_controller.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet之pod_manager</title>
    <url>/2023/05/17/kubelet%E4%B9%8Bpod-manager/</url>
    <content><![CDATA[<p><code>Manager</code>定义了访问<code>Pod</code>的一系列方法，维护了<code>static pod</code>和<code>mirror pod</code>之间的关系。<br><code>kubelet</code>从三个来源获取pod变化:<code>file</code>,<code>http</code>,<code>apiserver</code>。<code>pod</code>中除了<code>apiserver</code>这一来源<br>的<code>pod</code>都叫<code>static pod</code>(apiserver并不知道这些pod的存在)。为了让<code>apiserver</code>感知到这些<code>pod</code>的存在，<br><code>kubelet</code>为每个<code>static pod</code>都创建了<code>mirror pod</code>，这些<code>mirror pod</code>只能查看不能修改。<br><code>mirror pod</code>作为<code>static pod</code>的副本(尽管有不同的元数据如UID…)拥有一样的全名称(相同的名称和命名空间)。<br><code>kubelet</code>通过<code>pod全名</code>向<code>apiserver</code>上报<code>pod</code>状态。当<code>static pod</code>被删除,对应的<code>mirror pod</code>也会被删除。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/pod/pod_manager.go</span></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// GetPods returns the regular pods bound to the kubelet and their spec.</span></span><br><span class="line">	GetPods() []*v1.Pod</span><br><span class="line">	<span class="comment">// GetPodByFullName returns the (non-mirror) pod that matches full name, as well as</span></span><br><span class="line">	<span class="comment">// whether the pod was found.</span></span><br><span class="line">	GetPodByFullName(podFullName <span class="keyword">string</span>) (*v1.Pod, <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// GetPodByName provides the (non-mirror) pod that matches namespace and</span></span><br><span class="line">	<span class="comment">// name, as well as whether the pod was found.</span></span><br><span class="line">	GetPodByName(namespace, name <span class="keyword">string</span>) (*v1.Pod, <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// GetPodByUID provides the (non-mirror) pod that matches pod UID, as well as</span></span><br><span class="line">	<span class="comment">// whether the pod is found.</span></span><br><span class="line">	GetPodByUID(types.UID) (*v1.Pod, <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// GetPodByMirrorPod returns the static pod for the given mirror pod and</span></span><br><span class="line">	<span class="comment">// whether it was known to the pod manager.</span></span><br><span class="line">	GetPodByMirrorPod(*v1.Pod) (*v1.Pod, <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// GetMirrorPodByPod returns the mirror pod for the given static pod and</span></span><br><span class="line">	<span class="comment">// whether it was known to the pod manager.</span></span><br><span class="line">	GetMirrorPodByPod(*v1.Pod) (*v1.Pod, <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// GetPodsAndMirrorPods returns the both regular and mirror pods.</span></span><br><span class="line">	GetPodsAndMirrorPods() ([]*v1.Pod, []*v1.Pod)</span><br><span class="line">	<span class="comment">// SetPods replaces the internal pods with the new pods.</span></span><br><span class="line">	<span class="comment">// It is currently only used for testing.</span></span><br><span class="line">	SetPods(pods []*v1.Pod)</span><br><span class="line">	<span class="comment">// AddPod adds the given pod to the manager.</span></span><br><span class="line">	AddPod(pod *v1.Pod)</span><br><span class="line">	<span class="comment">// UpdatePod updates the given pod in the manager.</span></span><br><span class="line">	UpdatePod(pod *v1.Pod)</span><br><span class="line">	<span class="comment">// DeletePod deletes the given pod from the manager.  For mirror pods,</span></span><br><span class="line">	<span class="comment">// this means deleting the mappings related to mirror pods.  For non-</span></span><br><span class="line">	<span class="comment">// mirror pods, this means deleting from indexes for all non-mirror pods.</span></span><br><span class="line">	DeletePod(pod *v1.Pod)</span><br><span class="line">	<span class="comment">// GetOrphanedMirrorPodNames returns names of orphaned mirror pods</span></span><br><span class="line">	GetOrphanedMirrorPodNames() []<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// TranslatePodUID returns the actual UID of a pod. If the UID belongs to</span></span><br><span class="line">	<span class="comment">// a mirror pod, returns the UID of its static pod. Otherwise, returns the</span></span><br><span class="line">	<span class="comment">// original UID.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// All public-facing functions should perform this translation for UIDs</span></span><br><span class="line">	<span class="comment">// because user may provide a mirror pod UID, which is not recognized by</span></span><br><span class="line">	<span class="comment">// internal Kubelet functions.</span></span><br><span class="line">	TranslatePodUID(uid types.UID) kubetypes.ResolvedPodUID</span><br><span class="line">	<span class="comment">// GetUIDTranslations returns the mappings of static pod UIDs to mirror pod</span></span><br><span class="line">	<span class="comment">// UIDs and mirror pod UIDs to static pod UIDs.</span></span><br><span class="line">	GetUIDTranslations() (podToMirror <span class="keyword">map</span>[kubetypes.ResolvedPodUID]kubetypes.MirrorPodUID, mirrorToPod <span class="keyword">map</span>[kubetypes.MirrorPodUID]kubetypes.ResolvedPodUID)</span><br><span class="line">	<span class="comment">// IsMirrorPodOf returns true if mirrorPod is a correct representation of</span></span><br><span class="line">	<span class="comment">// pod; false otherwise.</span></span><br><span class="line">	IsMirrorPodOf(mirrorPod, pod *v1.Pod) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	MirrorClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basicManager实现Manager接口方法</span></span><br><span class="line"><span class="keyword">type</span> basicManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Protects all internal maps.</span></span><br><span class="line">	lock sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Regular pods indexed by UID.</span></span><br><span class="line">	podByUID <span class="keyword">map</span>[kubetypes.ResolvedPodUID]*v1.Pod</span><br><span class="line">	<span class="comment">// Mirror pods indexed by UID.</span></span><br><span class="line">	mirrorPodByUID <span class="keyword">map</span>[kubetypes.MirrorPodUID]*v1.Pod</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pods indexed by full name for easy access.</span></span><br><span class="line">	podByFullName       <span class="keyword">map</span>[<span class="keyword">string</span>]*v1.Pod</span><br><span class="line">	mirrorPodByFullName <span class="keyword">map</span>[<span class="keyword">string</span>]*v1.Pod</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mirror pod UID to pod UID map.</span></span><br><span class="line">	translationByUID <span class="keyword">map</span>[kubetypes.MirrorPodUID]kubetypes.ResolvedPodUID</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A mirror pod client to create/delete mirror pods.</span></span><br><span class="line">    <span class="comment">// MirrorClient实现了CreateMirrorPod和DeleteMirrorPod方法</span></span><br><span class="line">	MirrorClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBasicPodManager</span><span class="params">(client MirrorClient)</span> <span class="title">Manager</span></span> &#123;</span><br><span class="line">	pm := &amp;basicManager&#123;&#125;</span><br><span class="line">	pm.MirrorClient = client</span><br><span class="line">	pm.SetPods(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> pm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the internal pods based on the new pods.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">SetPods</span><span class="params">(newPods []*v1.Pod)</span></span> &#123;</span><br><span class="line">	pm.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化对象</span></span><br><span class="line">	pm.podByUID = <span class="built_in">make</span>(<span class="keyword">map</span>[kubetypes.ResolvedPodUID]*v1.Pod)</span><br><span class="line">	pm.podByFullName = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*v1.Pod)</span><br><span class="line">	pm.mirrorPodByUID = <span class="built_in">make</span>(<span class="keyword">map</span>[kubetypes.MirrorPodUID]*v1.Pod)</span><br><span class="line">	pm.mirrorPodByFullName = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*v1.Pod)</span><br><span class="line">	pm.translationByUID = <span class="built_in">make</span>(<span class="keyword">map</span>[kubetypes.MirrorPodUID]kubetypes.ResolvedPodUID)</span><br><span class="line"></span><br><span class="line">	pm.updatePodsInternal(newPods...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个pod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">AddPod</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">	pm.UpdatePod(pod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新pod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">UpdatePod</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">	pm.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.Unlock()</span><br><span class="line">	pm.updatePodsInternal(pod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// updateMetrics updates the metrics surfaced by the pod manager.</span></span><br><span class="line"><span class="comment">// oldPod or newPod may be nil to signify creation or deletion.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateMetrics</span><span class="params">(oldPod, newPod *v1.Pod)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> numEC <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">if</span> oldPod != <span class="literal">nil</span> &#123;</span><br><span class="line">		numEC -= <span class="built_in">len</span>(oldPod.Spec.EphemeralContainers)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> newPod != <span class="literal">nil</span> &#123;</span><br><span class="line">		numEC += <span class="built_in">len</span>(newPod.Spec.EphemeralContainers)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> numEC != <span class="number">0</span> &#123;</span><br><span class="line">		metrics.ManagedEphemeralContainers.Add(<span class="keyword">float64</span>(numEC))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// updatePodsInternal replaces the given pods in the current state of the</span></span><br><span class="line"><span class="comment">// manager, updating the various indices. The caller is assumed to hold the</span></span><br><span class="line"><span class="comment">// lock.</span></span><br><span class="line"><span class="comment">// 更新缓存中的pod,调用此方法需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">updatePodsInternal</span><span class="params">(pods ...*v1.Pod)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		podFullName := kubecontainer.GetPodFullName(pod)</span><br><span class="line">		<span class="comment">// This logic relies on a static pod and its mirror to have the same name.</span></span><br><span class="line">		<span class="comment">// It is safe to type convert here due to the IsMirrorPod guard.</span></span><br><span class="line">		<span class="keyword">if</span> kubetypes.IsMirrorPod(pod) &#123;</span><br><span class="line">			mirrorPodUID := kubetypes.MirrorPodUID(pod.UID)</span><br><span class="line">			pm.mirrorPodByUID[mirrorPodUID] = pod</span><br><span class="line">			pm.mirrorPodByFullName[podFullName] = pod</span><br><span class="line">			<span class="keyword">if</span> p, ok := pm.podByFullName[podFullName]; ok &#123;</span><br><span class="line">				pm.translationByUID[mirrorPodUID] = kubetypes.ResolvedPodUID(p.UID)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			resolvedPodUID := kubetypes.ResolvedPodUID(pod.UID)</span><br><span class="line">			updateMetrics(pm.podByUID[resolvedPodUID], pod)</span><br><span class="line">			pm.podByUID[resolvedPodUID] = pod</span><br><span class="line">			pm.podByFullName[podFullName] = pod</span><br><span class="line">			<span class="keyword">if</span> mirror, ok := pm.mirrorPodByFullName[podFullName]; ok &#123;</span><br><span class="line">				pm.translationByUID[kubetypes.MirrorPodUID(mirror.UID)] = resolvedPodUID</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">DeletePod</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">	updateMetrics(pod, <span class="literal">nil</span>)</span><br><span class="line">	pm.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.Unlock()</span><br><span class="line">	podFullName := kubecontainer.GetPodFullName(pod)</span><br><span class="line">	<span class="comment">// It is safe to type convert here due to the IsMirrorPod guard.</span></span><br><span class="line">	<span class="keyword">if</span> kubetypes.IsMirrorPod(pod) &#123;</span><br><span class="line">		mirrorPodUID := kubetypes.MirrorPodUID(pod.UID)</span><br><span class="line">		<span class="built_in">delete</span>(pm.mirrorPodByUID, mirrorPodUID)</span><br><span class="line">		<span class="built_in">delete</span>(pm.mirrorPodByFullName, podFullName)</span><br><span class="line">		<span class="built_in">delete</span>(pm.translationByUID, mirrorPodUID)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(pm.podByUID, kubetypes.ResolvedPodUID(pod.UID))</span><br><span class="line">		<span class="built_in">delete</span>(pm.podByFullName, podFullName)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取缓存中的pods</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">GetPods</span><span class="params">()</span> []*<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line">	pm.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> podsMapToPods(pm.podByUID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">GetPodsAndMirrorPods</span><span class="params">()</span> <span class="params">([]*v1.Pod, []*v1.Pod)</span></span> &#123;</span><br><span class="line">	pm.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.RUnlock()</span><br><span class="line">	pods := podsMapToPods(pm.podByUID)</span><br><span class="line">	mirrorPods := mirrorPodsMapToMirrorPods(pm.mirrorPodByUID)</span><br><span class="line">	<span class="keyword">return</span> pods, mirrorPods</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">GetPodByUID</span><span class="params">(uid types.UID)</span> <span class="params">(*v1.Pod, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	pm.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.RUnlock()</span><br><span class="line">	pod, ok := pm.podByUID[kubetypes.ResolvedPodUID(uid)] <span class="comment">// Safe conversion, map only holds non-mirrors.</span></span><br><span class="line">	<span class="keyword">return</span> pod, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">GetPodByName</span><span class="params">(namespace, name <span class="keyword">string</span>)</span> <span class="params">(*v1.Pod, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	podFullName := kubecontainer.BuildPodFullName(name, namespace)</span><br><span class="line">	<span class="keyword">return</span> pm.GetPodByFullName(podFullName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">GetPodByFullName</span><span class="params">(podFullName <span class="keyword">string</span>)</span> <span class="params">(*v1.Pod, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	pm.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.RUnlock()</span><br><span class="line">	pod, ok := pm.podByFullName[podFullName]</span><br><span class="line">	<span class="keyword">return</span> pod, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">TranslatePodUID</span><span class="params">(uid types.UID)</span> <span class="title">kubetypes</span>.<span class="title">ResolvedPodUID</span></span> &#123;</span><br><span class="line">	<span class="comment">// It is safe to type convert to a resolved UID because type conversion is idempotent.</span></span><br><span class="line">	<span class="keyword">if</span> uid == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> kubetypes.ResolvedPodUID(uid)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pm.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> translated, ok := pm.translationByUID[kubetypes.MirrorPodUID(uid)]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> translated</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> kubetypes.ResolvedPodUID(uid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">GetUIDTranslations</span><span class="params">()</span> <span class="params">(podToMirror <span class="keyword">map</span>[kubetypes.ResolvedPodUID]kubetypes.MirrorPodUID,</span></span></span><br><span class="line"><span class="function"><span class="params">	mirrorToPod <span class="keyword">map</span>[kubetypes.MirrorPodUID]kubetypes.ResolvedPodUID)</span></span> &#123;</span><br><span class="line">	pm.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	podToMirror = <span class="built_in">make</span>(<span class="keyword">map</span>[kubetypes.ResolvedPodUID]kubetypes.MirrorPodUID, <span class="built_in">len</span>(pm.translationByUID))</span><br><span class="line">	mirrorToPod = <span class="built_in">make</span>(<span class="keyword">map</span>[kubetypes.MirrorPodUID]kubetypes.ResolvedPodUID, <span class="built_in">len</span>(pm.translationByUID))</span><br><span class="line">	<span class="comment">// Insert empty translation mapping for all static pods.</span></span><br><span class="line">	<span class="keyword">for</span> uid, pod := <span class="keyword">range</span> pm.podByUID &#123;</span><br><span class="line">		<span class="keyword">if</span> !kubetypes.IsStaticPod(pod) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		podToMirror[uid] = <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Fill in translations. Notice that if there is no mirror pod for a</span></span><br><span class="line">	<span class="comment">// static pod, its uid will be translated into empty string "". This</span></span><br><span class="line">	<span class="comment">// is WAI, from the caller side we can know that the static pod doesn't</span></span><br><span class="line">	<span class="comment">// have a corresponding mirror pod instead of using static pod uid directly.</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> pm.translationByUID &#123;</span><br><span class="line">		mirrorToPod[k] = v</span><br><span class="line">		podToMirror[v] = k</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> podToMirror, mirrorToPod</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">GetOrphanedMirrorPodNames</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	pm.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.RUnlock()</span><br><span class="line">	<span class="keyword">var</span> podFullNames []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> podFullName := <span class="keyword">range</span> pm.mirrorPodByFullName &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := pm.podByFullName[podFullName]; !ok &#123;</span><br><span class="line">			podFullNames = <span class="built_in">append</span>(podFullNames, podFullName)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> podFullNames</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">IsMirrorPodOf</span><span class="params">(mirrorPod, pod *v1.Pod)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check name and namespace first.</span></span><br><span class="line">	<span class="keyword">if</span> pod.Name != mirrorPod.Name || pod.Namespace != mirrorPod.Namespace &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	hash, ok := getHashFromMirrorPod(mirrorPod)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hash == getPodHash(pod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">podsMapToPods</span><span class="params">(UIDMap <span class="keyword">map</span>[kubetypes.ResolvedPodUID]*v1.Pod)</span> []*<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line">	pods := <span class="built_in">make</span>([]*v1.Pod, <span class="number">0</span>, <span class="built_in">len</span>(UIDMap))</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> UIDMap &#123;</span><br><span class="line">		pods = <span class="built_in">append</span>(pods, pod)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pods</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mirrorPodsMapToMirrorPods</span><span class="params">(UIDMap <span class="keyword">map</span>[kubetypes.MirrorPodUID]*v1.Pod)</span> []*<span class="title">v1</span>.<span class="title">Pod</span></span> &#123;</span><br><span class="line">	pods := <span class="built_in">make</span>([]*v1.Pod, <span class="number">0</span>, <span class="built_in">len</span>(UIDMap))</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> UIDMap &#123;</span><br><span class="line">		pods = <span class="built_in">append</span>(pods, pod)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pods</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">GetMirrorPodByPod</span><span class="params">(pod *v1.Pod)</span> <span class="params">(*v1.Pod, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	pm.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.RUnlock()</span><br><span class="line">	mirrorPod, ok := pm.mirrorPodByFullName[kubecontainer.GetPodFullName(pod)]</span><br><span class="line">	<span class="keyword">return</span> mirrorPod, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *basicManager)</span> <span class="title">GetPodByMirrorPod</span><span class="params">(mirrorPod *v1.Pod)</span> <span class="params">(*v1.Pod, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	pm.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> pm.lock.RUnlock()</span><br><span class="line">	pod, ok := pm.podByFullName[kubecontainer.GetPodFullName(mirrorPod)]</span><br><span class="line">	<span class="keyword">return</span> pod, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/pod/mirror_client.go</span></span><br><span class="line"><span class="keyword">type</span> MirrorClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// CreateMirrorPod creates a mirror pod in the API server for the given</span></span><br><span class="line">	<span class="comment">// pod or returns an error.  The mirror pod will have the same annotations</span></span><br><span class="line">	<span class="comment">// as the given pod as well as an extra annotation containing the hash of</span></span><br><span class="line">	<span class="comment">// the static pod.</span></span><br><span class="line">	CreateMirrorPod(pod *v1.Pod) error</span><br><span class="line">	<span class="comment">// DeleteMirrorPod deletes the mirror pod with the given full name from</span></span><br><span class="line">	<span class="comment">// the API server or returns an error.</span></span><br><span class="line">	DeleteMirrorPod(podFullName <span class="keyword">string</span>, uid *types.UID) (<span class="keyword">bool</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nodeGetter is a subset of NodeLister, simplified for testing.</span></span><br><span class="line"><span class="keyword">type</span> nodeGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Get retrieves the Node for a given name.</span></span><br><span class="line">	Get(name <span class="keyword">string</span>) (*v1.Node, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basicMirrorClient is a functional MirrorClient.  Mirror pods are stored in</span></span><br><span class="line"><span class="comment">// the kubelet directly because they need to be in sync with the internal</span></span><br><span class="line"><span class="comment">// pods.</span></span><br><span class="line"><span class="keyword">type</span> basicMirrorClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	apiserverClient clientset.Interface</span><br><span class="line">	nodeGetter      nodeGetter</span><br><span class="line">	nodeName        <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewBasicMirrorClient returns a new MirrorClient.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBasicMirrorClient</span><span class="params">(apiserverClient clientset.Interface, nodeName <span class="keyword">string</span>, nodeGetter nodeGetter)</span> <span class="title">MirrorClient</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;basicMirrorClient&#123;</span><br><span class="line">		apiserverClient: apiserverClient,</span><br><span class="line">		nodeName:        nodeName,</span><br><span class="line">		nodeGetter:      nodeGetter,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建MirrorPod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *basicMirrorClient)</span> <span class="title">CreateMirrorPod</span><span class="params">(pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> mc.apiserverClient == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Make a copy of the pod.</span></span><br><span class="line">	copyPod := *pod</span><br><span class="line">	copyPod.Annotations = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> pod.Annotations &#123;</span><br><span class="line">		copyPod.Annotations[k] = v</span><br><span class="line">	&#125;</span><br><span class="line">	hash := getPodHash(pod)</span><br><span class="line">	copyPod.Annotations[kubetypes.ConfigMirrorAnnotationKey] = hash</span><br><span class="line"></span><br><span class="line">	<span class="comment">// With the MirrorPodNodeRestriction feature, mirror pods are required to have an owner reference</span></span><br><span class="line">	<span class="comment">// to the owning node.</span></span><br><span class="line">	<span class="comment">// See https://git.k8s.io/enhancements/keps/sig-auth/1314-node-restriction-pods/README.md</span></span><br><span class="line">	nodeUID, err := mc.getNodeUID()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get node UID: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	controller := <span class="literal">true</span></span><br><span class="line">	copyPod.OwnerReferences = []metav1.OwnerReference&#123;&#123;</span><br><span class="line">		APIVersion: v1.SchemeGroupVersion.String(),</span><br><span class="line">		Kind:       <span class="string">"Node"</span>,</span><br><span class="line">		Name:       mc.nodeName,</span><br><span class="line">		UID:        nodeUID,</span><br><span class="line">		Controller: &amp;controller,</span><br><span class="line">	&#125;&#125;</span><br><span class="line"></span><br><span class="line">	apiPod, err := mc.apiserverClient.CoreV1().Pods(copyPod.Namespace).Create(context.TODO(), &amp;copyPod, metav1.CreateOptions&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; apierrors.IsAlreadyExists(err) &#123;</span><br><span class="line">		<span class="comment">// Check if the existing pod is the same as the pod we want to create.</span></span><br><span class="line">		<span class="keyword">if</span> h, ok := apiPod.Annotations[kubetypes.ConfigMirrorAnnotationKey]; ok &amp;&amp; h == hash &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeleteMirrorPod deletes a mirror pod.</span></span><br><span class="line"><span class="comment">// It takes the full name of the pod and optionally a UID.  If the UID</span></span><br><span class="line"><span class="comment">// is non-nil, the pod is deleted only if its UID matches the supplied UID.</span></span><br><span class="line"><span class="comment">// It returns whether the pod was actually deleted, and any error returned</span></span><br><span class="line"><span class="comment">// while parsing the name of the pod.</span></span><br><span class="line"><span class="comment">// Non-existence of the pod or UID mismatch is not treated as an error; the</span></span><br><span class="line"><span class="comment">// routine simply returns false in that case.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *basicMirrorClient)</span> <span class="title">DeleteMirrorPod</span><span class="params">(podFullName <span class="keyword">string</span>, uid *types.UID)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> mc.apiserverClient == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	name, namespace, err := kubecontainer.ParsePodFullName(podFullName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">"Failed to parse a pod full name"</span>, <span class="string">"podFullName"</span>, podFullName)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> uidValue types.UID</span><br><span class="line">	<span class="keyword">if</span> uid != <span class="literal">nil</span> &#123;</span><br><span class="line">		uidValue = *uid</span><br><span class="line">	&#125;</span><br><span class="line">	klog.V(<span class="number">2</span>).InfoS(<span class="string">"Deleting a mirror pod"</span>, <span class="string">"pod"</span>, klog.KRef(namespace, name), <span class="string">"podUID"</span>, uidValue)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> GracePeriodSeconds <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> err := mc.apiserverClient.CoreV1().Pods(namespace).Delete(context.TODO(), name, metav1.DeleteOptions&#123;GracePeriodSeconds: &amp;GracePeriodSeconds, Preconditions: &amp;metav1.Preconditions&#123;UID: uid&#125;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Unfortunately, there's no generic error for failing a precondition</span></span><br><span class="line">		<span class="keyword">if</span> !(apierrors.IsNotFound(err) || apierrors.IsConflict(err)) &#123;</span><br><span class="line">			<span class="comment">// We should return the error here, but historically this routine does</span></span><br><span class="line">			<span class="comment">// not return an error unless it can't parse the pod name</span></span><br><span class="line">			klog.ErrorS(err, <span class="string">"Failed deleting a mirror pod"</span>, <span class="string">"pod"</span>, klog.KRef(namespace, name))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *basicMirrorClient)</span> <span class="title">getNodeUID</span><span class="params">()</span> <span class="params">(types.UID, error)</span></span> &#123;</span><br><span class="line">	node, err := mc.nodeGetter.Get(mc.nodeName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> node.UID == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"UID unset for node %s"</span>, mc.nodeName)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node.UID, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHashFromMirrorPod</span><span class="params">(pod *v1.Pod)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	hash, ok := pod.Annotations[kubetypes.ConfigMirrorAnnotationKey]</span><br><span class="line">	<span class="keyword">return</span> hash, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPodHash</span><span class="params">(pod *v1.Pod)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// The annotation exists for all static pods.</span></span><br><span class="line">	<span class="keyword">return</span> pod.Annotations[kubetypes.ConfigHashAnnotationKey]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/pod/mirror_client.go" target="_blank" rel="noopener">pkg/kubelet/pod/mirror_client.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/pod/pod_manager.go" target="_blank" rel="noopener">pkg/kubelet/pod/pod_manager.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubelet</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet之pleg</title>
    <url>/2023/05/16/kubelet%E4%B9%8Bpleg/</url>
    <content><![CDATA[<p>在<code>k8s</code>中<code>kubelet</code>是运行在<code>k8s</code>节点中的<code>daemon</code>程序，负责管理节点上的<code>pod</code>并将状态上报给<code>apiserver</code>，并驱动对应的<code>pod</code>更新到预期的状态。为此<code>kubelet</code>需要对<code>pod specs</code>和容器状态进行响应。<code>kubelet</code>从多个源中监听<code>pod specs</code>变化,<code>kubelet</code>会定期调用容器运行时获取容器最新的状态。</p>
<p>随着 <code>pod/容器</code>数量的增加，轮询会产生不可忽略的开销，而且因为<code>kubelet</code>的并行性(它会为每一个pod创建一个goroutine调用容器)更加会增加资源的消耗。同期性的大量并发请求将导致容器运行时消耗大量<code>CPU</code>(即使spec/state没有改变)，这将导致极差的性能和一些可靠性问题。 最终，它限制了 Kubelet 的可扩展性。</p>
<p>这个提案的目标是通过降低<code>pod</code>的管理开销以改善<code>kubelet</code>的可扩展性和性能。</p>
<ul>
<li>减少不必要的工作(如果spec/state没有变化则不需要处理)</li>
<li>降低对容器运行时的并发访问</li>
</ul>
<p>通过事件驱动的方式代替轮询<br><img src="https://img.hysyeah.top/2023/5/pleg.png" alt="image"></p>
<p>通过<code>Relisting</code>获取容器状态变化。为了获取<code>pod</code>生命周期事件，。我们可以通过<code>relisting</code>所有的容器(比如docker ps)，获取<code>PLEG</code>所需要的容器状态变化。虽然这跟原来的轮询有点类似，但这只会有一个线程对容器运行时进行访问。</p>
<hr>
<p>以上的内容来自于<a href="https://github.com/kubernetes/design-proposals-archive/blob/main/node/pod-lifecycle-event-generator.md" target="_blank" rel="noopener">k8s-design-proposals</a>,详细的内容可以自己去看看。</p>
<hr>
<p><code>PLEG</code>全称<code>Pod Lifecycle Event Generator</code></p>
<h5 id="PodLifecycleEvent"><a href="#PodLifecycleEvent" class="headerlink" title="PodLifecycleEvent"></a>PodLifecycleEvent</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/pleg/pleg.go</span></span><br><span class="line"><span class="comment">// PodLifecycleEvent is an event that reflects the change of the pod state.</span></span><br><span class="line"><span class="comment">// 描述pod状态变化</span></span><br><span class="line"><span class="keyword">type</span> PodLifecycleEvent <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The pod ID.</span></span><br><span class="line">	ID types.UID</span><br><span class="line">	<span class="comment">// The type of the event.</span></span><br><span class="line">	Type PodLifeCycleEventType</span><br><span class="line">	<span class="comment">// The accompanied data which varies based on the event type.</span></span><br><span class="line">	<span class="comment">//   - ContainerStarted/ContainerStopped: the container name (string).</span></span><br><span class="line">	<span class="comment">//   - All other event types: unused.</span></span><br><span class="line">	Data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PodLifecycleEventGenerator <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start()</span><br><span class="line">	Stop()</span><br><span class="line">	Update(relistDuration *RelistDuration)</span><br><span class="line">	Watch() <span class="keyword">chan</span> *PodLifecycleEvent</span><br><span class="line">	Healthy() (<span class="keyword">bool</span>, error)</span><br><span class="line">	Relist()</span><br><span class="line">	UpdateCache(*kubecontainer.Pod, types.UID) (error, <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PodLifeCycleEventType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RelistDuration <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The period for relisting.</span></span><br><span class="line">	<span class="comment">// 相当于轮询周期</span></span><br><span class="line">	RelistPeriod time.Duration</span><br><span class="line">	<span class="comment">// The relisting threshold needs to be greater than the relisting period +</span></span><br><span class="line">	<span class="comment">// the relisting time, which can vary significantly. Set a conservative</span></span><br><span class="line">	<span class="comment">// threshold to avoid flipping between healthy and unhealthy.</span></span><br><span class="line">    <span class="comment">// 这个时间必须大于 relistingPeriod + relisting所花费的时间</span></span><br><span class="line">	RelistThreshold time.Duration</span><br><span class="line">&#125;</span><br><span class="line">changes</span><br><span class="line"><span class="comment">// 事件的类型</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// ContainerStarted - event type when the new state of container is running.</span></span><br><span class="line">	ContainerStarted PodLifeCycleEventType = <span class="string">"ContainerStarted"</span></span><br><span class="line">	<span class="comment">// ContainerDied - event type when the new state of container is exited.</span></span><br><span class="line">	ContainerDied PodLifeCycleEventType = <span class="string">"ContainerDied"</span></span><br><span class="line">	<span class="comment">// ContainerRemoved - event type when the old state of container is exited.</span></span><br><span class="line">	ContainerRemoved PodLifeCycleEventType = <span class="string">"ContainerRemoved"</span></span><br><span class="line">	<span class="comment">// PodSync is used to trigger syncing of a pod when the observed change of</span></span><br><span class="line">	<span class="comment">// the state of the pod cannot be captured by any single event above.</span></span><br><span class="line">	<span class="comment">// 当一个pod的状态变化没有被任何一个事件补获到时会触发PodSync</span></span><br><span class="line">	PodSync PodLifeCycleEventType = <span class="string">"PodSync"</span></span><br><span class="line">	<span class="comment">// ContainerChanged - event type when the new state of container is unknown.</span></span><br><span class="line">	ContainerChanged PodLifeCycleEventType = <span class="string">"ContainerChanged"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/kubelet/kubelet.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMainKubelet</span><span class="params">(kubeCfg *kubeletconfiginternal.KubeletConfiguration,...)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// pleg和eventedPleg使用的是同一个channel</span></span><br><span class="line">    eventChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> *pleg.PodLifecycleEvent, plegChannelCapacity)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.EventedPLEG) &#123;</span><br><span class="line">		<span class="comment">// adjust Generic PLEG relisting period and threshold to higher value when Evented PLEG is turned on</span></span><br><span class="line">		genericRelistDuration := &amp;pleg.RelistDuration&#123;</span><br><span class="line">			RelistPeriod:    eventedPlegRelistPeriod,</span><br><span class="line">			RelistThreshold: eventedPlegRelistThreshold,</span><br><span class="line">		&#125;</span><br><span class="line">		klet.pleg = pleg.NewGenericPLEG(klet.containerRuntime, eventChannel, genericRelistDuration, klet.podCache, clock.RealClock&#123;&#125;)</span><br><span class="line">		<span class="comment">// In case Evented PLEG has to fall back on Generic PLEG due to an error,</span></span><br><span class="line">		<span class="comment">// Evented PLEG should be able to reset the Generic PLEG relisting duration</span></span><br><span class="line">		<span class="comment">// to the default value.</span></span><br><span class="line">		eventedRelistDuration := &amp;pleg.RelistDuration&#123;</span><br><span class="line">			RelistPeriod:    genericPlegRelistPeriod,</span><br><span class="line">			RelistThreshold: genericPlegRelistThreshold,</span><br><span class="line">		&#125;</span><br><span class="line">		klet.eventedPleg = pleg.NewEventedPLEG(klet.containerRuntime, klet.runtimeService, eventChannel,</span><br><span class="line">			klet.podCache, klet.pleg, eventedPlegMaxStreamRetries, eventedRelistDuration, clock.RealClock&#123;&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		genericRelistDuration := &amp;pleg.RelistDuration&#123;</span><br><span class="line">			RelistPeriod:    genericPlegRelistPeriod,</span><br><span class="line">			RelistThreshold: genericPlegRelistThreshold,</span><br><span class="line">		&#125;</span><br><span class="line">		klet.pleg = pleg.NewGenericPLEG(klet.containerRuntime, eventChannel, genericRelistDuration, klet.podCache, clock.RealClock&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/kubelet.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">Run</span><span class="params">(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    	<span class="comment">// Start the pod lifecycle event generator.</span></span><br><span class="line">	kl.pleg.Start()</span><br><span class="line">	<span class="comment">// Feature gate打开后才会远行eventedPLEG</span></span><br><span class="line">	<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.EventedPLEG) &#123;</span><br><span class="line">		kl.eventedPleg.Start()</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="GenericPLEG"><a href="#GenericPLEG" class="headerlink" title="GenericPLEG"></a>GenericPLEG</h5><p><code>GenericPLEG</code>通过周期性的<code>listing</code>以发现容器变化，它假设在一个<code>relist</code>周期中容器不会发生创建，终止和垃圾回收。<br>如果在<code>relisting</code>过程中发生了容器变化，<code>GenericPLEG</code>将会丢失这些信息。如果此次<code>relisting</code>发生了错误时间窗口会变得更长。<br>许多kubelet的内部组件都依赖于终止的容器作为保留记录的墓碑。垃圾回收器的实现可以处理这种情况。<br>然而，为了保证kubelet能够处理丢失的容器事件，建议将重列周期设置短，并在kubelet中设置一个辅助的、较长的定期同步作为安全措施<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/pleg/generic.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GenericPLEG <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The container runtime.</span></span><br><span class="line">	runtime kubecontainer.Runtime</span><br><span class="line">	<span class="comment">// The channel from which the subscriber listens events.</span></span><br><span class="line">	eventChannel <span class="keyword">chan</span> *PodLifecycleEvent</span><br><span class="line">	<span class="comment">// The internal cache for pod/container information.</span></span><br><span class="line">	podRecords podRecords</span><br><span class="line">	<span class="comment">// Time of the last relisting.</span></span><br><span class="line">	relistTime atomic.Value</span><br><span class="line">	<span class="comment">// Cache for storing the runtime states required for syncing pods.</span></span><br><span class="line">	cache kubecontainer.Cache</span><br><span class="line">	<span class="comment">// For testability.</span></span><br><span class="line">	clock clock.Clock</span><br><span class="line">	<span class="comment">// Pods that failed to have their status retrieved during a relist. These pods will be</span></span><br><span class="line">	<span class="comment">// retried during the next relisting.</span></span><br><span class="line">	podsToReinspect <span class="keyword">map</span>[types.UID]*kubecontainer.Pod</span><br><span class="line">	<span class="comment">// Stop the Generic PLEG by closing the channel.</span></span><br><span class="line">	stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// Locks the relisting of the Generic PLEG</span></span><br><span class="line">	relistLock sync.Mutex</span><br><span class="line">	<span class="comment">// Indicates if the Generic PLEG is running or not</span></span><br><span class="line">	isRunning <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Locks the start/stop operation of Generic PLEG</span></span><br><span class="line">	runningMu sync.Mutex</span><br><span class="line">	<span class="comment">// Indicates relisting related parameters</span></span><br><span class="line">	relistDuration *RelistDuration</span><br><span class="line">	<span class="comment">// Mutex to serialize updateCache called by relist vs UpdateCache interface</span></span><br><span class="line">	podCacheMutex sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewGenericPLEG 创建一个GenericPLEG</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGenericPLEG</span><span class="params">(runtime kubecontainer.Runtime, eventChannel <span class="keyword">chan</span> *PodLifecycleEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">	relistDuration *RelistDuration, cache kubecontainer.Cache,</span></span></span><br><span class="line"><span class="function"><span class="params">	clock clock.Clock)</span> <span class="title">PodLifecycleEventGenerator</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;GenericPLEG&#123;</span><br><span class="line">		relistDuration: relistDuration,</span><br><span class="line">		runtime:        runtime,</span><br><span class="line">		eventChannel:   eventChannel,</span><br><span class="line">		podRecords:     <span class="built_in">make</span>(podRecords),</span><br><span class="line">		cache:          cache,</span><br><span class="line">		clock:          clock,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行Relist, 周期为g.relistDuration.RelistPeriod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GenericPLEG)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g.runningMu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> g.runningMu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> !g.isRunning &#123;</span><br><span class="line">		g.isRunning = <span class="literal">true</span></span><br><span class="line">		g.stopCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">go</span> wait.Until(g.Relist, g.relistDuration.RelistPeriod, g.stopCh)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定期执行的函数</span></span><br><span class="line"><span class="comment">// 查询容器运行时获取pods/containers列表并和本地缓存中的pods/containers比较，然后生成事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GenericPLEG)</span> <span class="title">Relist</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g.relistLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> g.relistLock.Unlock()</span><br><span class="line"></span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	klog.V(<span class="number">5</span>).InfoS(<span class="string">"GenericPLEG: Relisting"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> lastRelistTime := g.getRelistTime(); !lastRelistTime.IsZero() &#123;</span><br><span class="line">		metrics.PLEGRelistInterval.Observe(metrics.SinceInSeconds(lastRelistTime))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timestamp := g.clock.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		metrics.PLEGRelistDuration.Observe(metrics.SinceInSeconds(timestamp))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取所的Pod</span></span><br><span class="line">	podList, err := g.runtime.GetPods(ctx, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">"GenericPLEG: Unable to retrieve pods"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g.updateRelistTime(timestamp)</span><br><span class="line"></span><br><span class="line">	pods := kubecontainer.Pods(podList)</span><br><span class="line">	<span class="comment">// update running pod and container count</span></span><br><span class="line">	updateRunningPodAndContainerMetrics(pods)</span><br><span class="line">	g.podRecords.setCurrent(pods)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compare the old and the current pods, and generate events.</span></span><br><span class="line">	eventsByPodID := <span class="keyword">map</span>[types.UID][]*PodLifecycleEvent&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> pid := <span class="keyword">range</span> g.podRecords &#123;</span><br><span class="line">		oldPod := g.podRecords.getOld(pid)</span><br><span class="line">		pod := g.podRecords.getCurrent(pid)</span><br><span class="line">		<span class="comment">// 获取oldPod和pod中的container</span></span><br><span class="line">		allContainers := getContainersFromPods(oldPod, pod)</span><br><span class="line">		<span class="keyword">for</span> _, container := <span class="keyword">range</span> allContainers &#123;</span><br><span class="line">			<span class="comment">// 生成事件</span></span><br><span class="line">			events := computeEvents(oldPod, pod, &amp;container.ID)</span><br><span class="line">			<span class="keyword">for</span> _, e := <span class="keyword">range</span> events &#123;</span><br><span class="line">				updateEvents(eventsByPodID, e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> needsReinspection <span class="keyword">map</span>[types.UID]*kubecontainer.Pod</span><br><span class="line">	<span class="keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">		needsReinspection = <span class="built_in">make</span>(<span class="keyword">map</span>[types.UID]*kubecontainer.Pod)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If there are events associated with a pod, we should update the</span></span><br><span class="line">	<span class="comment">// podCache.</span></span><br><span class="line">	<span class="keyword">for</span> pid, events := <span class="keyword">range</span> eventsByPodID &#123;</span><br><span class="line">		pod := g.podRecords.getCurrent(pid)</span><br><span class="line">		<span class="keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">			<span class="comment">// updateCache() will inspect the pod and update the cache. If an</span></span><br><span class="line">			<span class="comment">// error occurs during the inspection, we want PLEG to retry again</span></span><br><span class="line">			<span class="comment">// in the next relist. To achieve this, we do not update the</span></span><br><span class="line">			<span class="comment">// associated podRecord of the pod, so that the change will be</span></span><br><span class="line">			<span class="comment">// detect again in the next relist.</span></span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> If many pods changed during the same relist period,</span></span><br><span class="line">			<span class="comment">// inspecting the pod and getting the PodStatus to update the cache</span></span><br><span class="line">			<span class="comment">// serially may take a while. We should be aware of this and</span></span><br><span class="line">			<span class="comment">// parallelize if needed.</span></span><br><span class="line">			<span class="keyword">if</span> err, updated := g.updateCache(ctx, pod, pid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// Rely on updateCache calling GetPodStatus to log the actual error.</span></span><br><span class="line">				klog.V(<span class="number">4</span>).ErrorS(err, <span class="string">"PLEG: Ignoring events for pod"</span>, <span class="string">"pod"</span>, klog.KRef(pod.Namespace, pod.Name))</span><br><span class="line"></span><br><span class="line">				<span class="comment">// make sure we try to reinspect the pod during the next relisting</span></span><br><span class="line">				needsReinspection[pid] = pod</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// this pod was in the list to reinspect and we did so because it had events, so remove it</span></span><br><span class="line">				<span class="comment">// from the list (we don't want the reinspection code below to inspect it a second time in</span></span><br><span class="line">				<span class="comment">// this relist execution)</span></span><br><span class="line">				<span class="built_in">delete</span>(g.podsToReinspect, pid)</span><br><span class="line">				<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.EventedPLEG) &#123;</span><br><span class="line">					<span class="keyword">if</span> !updated &#123;</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Update the internal storage and send out the events.</span></span><br><span class="line">		g.podRecords.update(pid)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Map from containerId to exit code; used as a temporary cache for lookup</span></span><br><span class="line">		containerExitCode := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> events &#123;</span><br><span class="line">			<span class="comment">// Filter out events that are not reliable and no other components use yet.</span></span><br><span class="line">			<span class="keyword">if</span> events[i].Type == ContainerChanged &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">// 将事件发送到eventChannel中</span></span><br><span class="line">			<span class="comment">// 在kubelet的主循环syncLoop中会对eventChannel进行watch</span></span><br><span class="line">			<span class="keyword">case</span> g.eventChannel &lt;- events[i]:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				metrics.PLEGDiscardEvents.Inc()</span><br><span class="line">				klog.ErrorS(<span class="literal">nil</span>, <span class="string">"Event channel is full, discard this relist() cycle event"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Log exit code of containers when they finished in a particular event</span></span><br><span class="line">			<span class="keyword">if</span> events[i].Type == ContainerDied &#123;</span><br><span class="line">				<span class="comment">// Fill up containerExitCode map for ContainerDied event when first time appeared</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(containerExitCode) == <span class="number">0</span> &amp;&amp; pod != <span class="literal">nil</span> &amp;&amp; g.cache != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="comment">// Get updated podStatus</span></span><br><span class="line">					status, err := g.cache.Get(pod.ID)</span><br><span class="line">					<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">for</span> _, containerStatus := <span class="keyword">range</span> status.ContainerStatuses &#123;</span><br><span class="line">							containerExitCode[containerStatus.ID.ID] = containerStatus.ExitCode</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> containerID, ok := events[i].Data.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">					<span class="keyword">if</span> exitCode, ok := containerExitCode[containerID]; ok &amp;&amp; pod != <span class="literal">nil</span> &#123;</span><br><span class="line">						klog.V(<span class="number">2</span>).InfoS(<span class="string">"Generic (PLEG): container finished"</span>, <span class="string">"podID"</span>, pod.ID, <span class="string">"containerID"</span>, containerID, <span class="string">"exitCode"</span>, exitCode)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">		<span class="comment">// reinspect any pods that failed inspection during the previous relist</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(g.podsToReinspect) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			klog.V(<span class="number">5</span>).InfoS(<span class="string">"GenericPLEG: Reinspecting pods that previously failed inspection"</span>)</span><br><span class="line">			<span class="keyword">for</span> pid, pod := <span class="keyword">range</span> g.podsToReinspect &#123;</span><br><span class="line">				<span class="keyword">if</span> err, _ := g.updateCache(ctx, pod, pid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="comment">// Rely on updateCache calling GetPodStatus to log the actual error.</span></span><br><span class="line">					klog.V(<span class="number">5</span>).ErrorS(err, <span class="string">"PLEG: pod failed reinspection"</span>, <span class="string">"pod"</span>, klog.KRef(pod.Namespace, pod.Name))</span><br><span class="line">					needsReinspection[pid] = pod</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update the cache timestamp.  This needs to happen *after*</span></span><br><span class="line">		<span class="comment">// all pods have been properly updated in the cache.</span></span><br><span class="line">		g.cache.UpdateTime(timestamp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// make sure we retain the list of pods that need reinspecting the next time relist is called玄武</span></span><br><span class="line">	g.podsToReinspect = needsReinspection</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/kubelet/kubelet.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoop</span><span class="params">(ctx context.Context, updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	plegCh := kl.pleg.Watch()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := kl.runtimeState.runtimeErrors(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.ErrorS(err, <span class="string">"Skipping pod synchronization"</span>)</span><br><span class="line">			<span class="comment">// exponential backoff</span></span><br><span class="line">			time.Sleep(duration)</span><br><span class="line">			duration = time.Duration(math.Min(<span class="keyword">float64</span>(max), factor*<span class="keyword">float64</span>(duration)))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// reset backoff if we have a success</span></span><br><span class="line">		duration = base</span><br><span class="line"></span><br><span class="line">		kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">		<span class="comment">// 在syncLoopIteration中处理plegCh,也就是上面的eventChannel</span></span><br><span class="line">		<span class="keyword">if</span> !kl.syncLoopIteration(ctx, updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="EventedPLEG"><a href="#EventedPLEG" class="headerlink" title="EventedPLEG"></a>EventedPLEG</h5><p>通过事件驱动的PLEG(pod lifecycle event generator)降低relisting频率以提高性能。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/pleg/evented.go</span></span><br><span class="line"><span class="keyword">type</span> EventedPLEG <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The container runtime.</span></span><br><span class="line">	runtime kubecontainer.Runtime</span><br><span class="line">	<span class="comment">// The runtime service.</span></span><br><span class="line">	runtimeService internalapi.RuntimeService</span><br><span class="line">	<span class="comment">// The channel from which the subscriber listens events.</span></span><br><span class="line">	eventChannel <span class="keyword">chan</span> *PodLifecycleEvent</span><br><span class="line">	<span class="comment">// Cache for storing the runtime states required for syncing pods.</span></span><br><span class="line">	cache kubecontainer.Cache</span><br><span class="line">	<span class="comment">// For testability.</span></span><br><span class="line">	clock clock.Clock</span><br><span class="line">	<span class="comment">// GenericPLEG is used to force relist when required.</span></span><br><span class="line">	genericPleg PodLifecycleEventGenerator</span><br><span class="line">	<span class="comment">// The maximum number of retries when getting container events from the runtime.</span></span><br><span class="line">	eventedPlegMaxStreamRetries <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// Indicates relisting related parameters</span></span><br><span class="line">	relistDuration *RelistDuration</span><br><span class="line">	<span class="comment">// Stop the Evented PLEG by closing the channel.</span></span><br><span class="line">	stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// Stops the periodic update of the cache global timestamp.</span></span><br><span class="line">	stopCacheUpdateCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// Locks the start/stop operation of the Evented PLEG.</span></span><br><span class="line">	runningMu sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewEventedPLEG instantiates a new EventedPLEG object and return it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEventedPLEG</span><span class="params">(runtime kubecontainer.Runtime, runtimeService internalapi.RuntimeService, eventChannel <span class="keyword">chan</span> *PodLifecycleEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">	cache kubecontainer.Cache, genericPleg PodLifecycleEventGenerator, eventedPlegMaxStreamRetries <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	relistDuration *RelistDuration, clock clock.Clock)</span> <span class="title">PodLifecycleEventGenerator</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;EventedPLEG&#123;</span><br><span class="line">		runtime:                     runtime,</span><br><span class="line">		runtimeService:              runtimeService,</span><br><span class="line">		eventChannel:                eventChannel,</span><br><span class="line">		cache:                       cache,</span><br><span class="line">		genericPleg:                 genericPleg,</span><br><span class="line">		eventedPlegMaxStreamRetries: eventedPlegMaxStreamRetries,</span><br><span class="line">		relistDuration:              relistDuration,</span><br><span class="line">		clock:                       clock,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EventedPLEG)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e.runningMu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> e.runningMu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> isEventedPLEGInUse() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	setEventedPLEGUsage(<span class="literal">true</span>)</span><br><span class="line">	e.stopCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	e.stopCacheUpdateCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> wait.Until(e.watchEventsChannel, <span class="number">0</span>, e.stopCh)</span><br><span class="line">	<span class="keyword">go</span> wait.Until(e.updateGlobalCache, globalCacheUpdatePeriod, e.stopCacheUpdateCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EventedPLEG)</span> <span class="title">watchEventsChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">	containerEventsResponseCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *runtimeapi.ContainerEventResponse, <span class="built_in">cap</span>(e.eventChannel))</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(containerEventsResponseCh)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the container events from the runtime.</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		numAttempts := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 如果重试次数超过一定的次数则表示EventedPLEG</span></span><br><span class="line">			<span class="keyword">if</span> numAttempts &gt;= e.eventedPlegMaxStreamRetries &#123;</span><br><span class="line">				<span class="comment">// 判断是否使用EventedPLEG</span></span><br><span class="line">				<span class="comment">// 即使打开了EventedPLEG feature gate,EventedPLEG也可能不可用</span></span><br><span class="line">				<span class="comment">// 原因可能是容器运行时没实现容器事件流(container events stream)</span></span><br><span class="line">				<span class="keyword">if</span> isEventedPLEGInUse() &#123;</span><br><span class="line">					<span class="comment">// Fall back to Generic PLEG relisting since Evented PLEG is not working.</span></span><br><span class="line">					klog.V(<span class="number">4</span>).InfoS(<span class="string">"Fall back to Generic PLEG relisting since Evented PLEG is not working"</span>)</span><br><span class="line">					e.Stop()</span><br><span class="line">					e.genericPleg.Stop()       <span class="comment">// Stop the existing Generic PLEG which runs with longer relisting period when Evented PLEG is in use.</span></span><br><span class="line">					e.Update(e.relistDuration) <span class="comment">// Update the relisting period to the default value for the Generic PLEG.</span></span><br><span class="line">					<span class="comment">// 重新切换加genericPleg</span></span><br><span class="line">					e.genericPleg.Start()</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 从容器运行中获取事件</span></span><br><span class="line">			err := e.runtimeService.GetContainerEvents(containerEventsResponseCh)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				metrics.EventedPLEGConnErr.Inc()</span><br><span class="line">				numAttempts++</span><br><span class="line">				<span class="comment">// 如果获取事件失败，则进行Relist以获取容器的最新状态</span></span><br><span class="line">				e.Relist() <span class="comment">// Force a relist to get the latest container and pods running metric.</span></span><br><span class="line">				klog.V(<span class="number">4</span>).InfoS(<span class="string">"Evented PLEG: Failed to get container events, retrying: "</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> isEventedPLEGInUse() &#123;</span><br><span class="line">		<span class="comment">// 处理容器运行时事件</span></span><br><span class="line">		e.processCRIEvents(containerEventsResponseCh)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EventedPLEG)</span> <span class="title">Watch</span><span class="params">()</span> <span class="title">chan</span> *<span class="title">PodLifecycleEvent</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.eventChannel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Relist relists all containers using GenericPLEG</span></span><br><span class="line"><span class="comment">// 这里使用的是GenericPLEG中的Relist方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EventedPLEG)</span> <span class="title">Relist</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e.genericPleg.Relist()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In case the Evented PLEG experiences undetectable issues in the underlying</span></span><br><span class="line"><span class="comment">// GRPC connection there is a remote chance the pod might get stuck in a</span></span><br><span class="line"><span class="comment">// given state while it has progressed in its life cycle. This function will be</span></span><br><span class="line"><span class="comment">// called periodically to update the global timestamp of the cache so that those</span></span><br><span class="line"><span class="comment">// pods stuck at GetNewerThan in pod workers will get unstuck.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EventedPLEG)</span> <span class="title">updateGlobalCache</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e.cache.UpdateTime(time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EventedPLEG)</span> <span class="title">processCRIEvents</span><span class="params">(containerEventsResponseCh <span class="keyword">chan</span> *runtimeapi.ContainerEventResponse)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> event := <span class="keyword">range</span> containerEventsResponseCh &#123;</span><br><span class="line">		<span class="comment">// Ignore the event if PodSandboxStatus is nil.</span></span><br><span class="line">		<span class="comment">// This might happen under some race condition where the podSandbox has</span></span><br><span class="line">		<span class="comment">// been deleted, and therefore container runtime couldn't find the</span></span><br><span class="line">		<span class="comment">// podSandbox for the container when generating the event.</span></span><br><span class="line">		<span class="comment">// It is safe to ignore because</span></span><br><span class="line">		<span class="comment">// a) a event would have been received for the sandbox deletion,</span></span><br><span class="line">		<span class="comment">// b) in worst case, a relist will eventually sync the pod status.</span></span><br><span class="line">		<span class="comment">// TODO(#114371): Figure out a way to handle this case instead of ignoring.</span></span><br><span class="line">		<span class="keyword">if</span> event.PodSandboxStatus == <span class="literal">nil</span> || event.PodSandboxStatus.Metadata == <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">"Evented PLEG: received ContainerEventResponse with nil PodSandboxStatus or PodSandboxStatus.Metadata"</span>, <span class="string">"containerEventResponse"</span>, event)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		podID := types.UID(event.PodSandboxStatus.Metadata.Uid)</span><br><span class="line">		shouldSendPLEGEvent := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		status, err := e.runtime.GeneratePodStatus(event)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// nolint:logcheck // Not using the result of klog.V inside the</span></span><br><span class="line">			<span class="comment">// if branch is okay, we just use it to determine whether the</span></span><br><span class="line">			<span class="comment">// additional "podStatus" key and its value should be added.</span></span><br><span class="line">			<span class="keyword">if</span> klog.V(<span class="number">6</span>).Enabled() &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Evented PLEG: error generating pod status from the received event"</span>, <span class="string">"podUID"</span>, podID, <span class="string">"podStatus"</span>, status)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">"Evented PLEG: error generating pod status from the received event"</span>, <span class="string">"podUID"</span>, podID, <span class="string">"podStatus"</span>, status)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> klogV := klog.V(<span class="number">6</span>); klogV.Enabled() &#123;</span><br><span class="line">				klogV.InfoS(<span class="string">"Evented PLEG: Generated pod status from the received event"</span>, <span class="string">"podUID"</span>, podID, <span class="string">"podStatus"</span>, status)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				klog.V(<span class="number">4</span>).InfoS(<span class="string">"Evented PLEG: Generated pod status from the received event"</span>, <span class="string">"podUID"</span>, podID)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Preserve the pod IP across cache updates if the new IP is empty.</span></span><br><span class="line">			<span class="comment">// When a pod is torn down, kubelet may race with PLEG and retrieve</span></span><br><span class="line">			<span class="comment">// a pod status after network teardown, but the kubernetes API expects</span></span><br><span class="line">			<span class="comment">// the completed pod's IP to be available after the pod is dead.</span></span><br><span class="line">			status.IPs = e.getPodIPs(podID, status)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		e.updateRunningPodMetric(status)</span><br><span class="line">		e.updateRunningContainerMetric(status)</span><br><span class="line">		e.updateLatencyMetric(event)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> event.ContainerEventType == runtimeapi.ContainerEventType_CONTAINER_DELETED_EVENT &#123;</span><br><span class="line">			<span class="keyword">for</span> _, sandbox := <span class="keyword">range</span> status.SandboxStatuses &#123;</span><br><span class="line">				<span class="keyword">if</span> sandbox.Id == event.ContainerId &#123;</span><br><span class="line">					<span class="comment">// When the CONTAINER_DELETED_EVENT is received by the kubelet,</span></span><br><span class="line">					<span class="comment">// the runtime has indicated that the container has been removed</span></span><br><span class="line">					<span class="comment">// by the runtime and hence, it must be removed from the cache</span></span><br><span class="line">					<span class="comment">// of kubelet too.</span></span><br><span class="line">					e.cache.Delete(podID)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			shouldSendPLEGEvent = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> e.cache.Set(podID, status, err, time.Unix(event.GetCreatedAt(), <span class="number">0</span>)) &#123;</span><br><span class="line">				shouldSendPLEGEvent = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> shouldSendPLEGEvent &#123;</span><br><span class="line">			<span class="comment">// 将事件发送到e.eventChannel中</span></span><br><span class="line">			e.processCRIEvent(event)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/design-proposals-archive/blob/main/node/pod-lifecycle-event-generator.md" target="_blank" rel="noopener">https://github.com/kubernetes/design-proposals-archive/blob/main/node/pod-lifecycle-event-generator.md</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/pleg/pleg.go" target="_blank" rel="noopener">pkg/kubelet/pleg/pleg.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/kubelet.go" target="_blank" rel="noopener">pkg/kubelet/kubelet.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/pleg/evented.go" target="_blank" rel="noopener">pkg/kubelet/pleg/evented.go</a><br>5.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/pleg/generic.go" target="_blank" rel="noopener">pkg/kubelet/pleg/generic.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubelet</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet之prober</title>
    <url>/2023/05/19/kubelet%E4%B9%8Bprober/</url>
    <content><![CDATA[<p>在 <code>Kubernetes</code> 中，<code>kubelet</code> 组件负责管理和运行每个节点上的容器。<code>kubelet</code> 组件包含一个名为 <code>prober</code> 的子组件，它是用于容器的健康检查的一部分。</p>
<p><code>prober</code> 是 <code>kubelet</code> 组件的一部分，它负责执行容器的健康检查。健康检查是一种用于确定容器是否正常运行的机制。<code>prober</code> 会定期向容器发送健康检查请求，并根据容器的响应来确定其状态。</p>
<p><code>prober</code> 支持多种健康检查方式，包括：</p>
<ul>
<li>HTTP 健康检查：向容器的指定端口发送 <code>HTTP</code> 请求，并根据响应的状态码判断容器的健康状态。</li>
<li>TCP 健康检查：向容器的指定端口发送 <code>TCP</code> 连接请求，并根据连接是否成功判断容器的健康状态。</li>
<li>Exec 健康检查：在容器内部执行指定的命令，并根据命令的执行结果判断容器的健康状态。</li>
<li>gRPC 健康检查：与容器内的<code>gRPC</code>服务建立连接，并发送指定的<code>gRPC</code> 请求。根据服务端返回的响应，<code>prober</code> 可以确定服务是否正常运行<br>通过定期执行这些健康检查，<code>prober</code> 可以监测容器的运行状态，并及时采取相应的措施，如重启容器或报告容器的健康状态给 <code>Kubernetes</code> 控制平面。</li>
</ul>
<hr>
<h5 id="prober"><a href="#prober" class="headerlink" title="prober"></a>prober</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/prober/prober.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prober helps to check the liveness/readiness/startup of a container.</span></span><br><span class="line"><span class="keyword">type</span> prober <span class="keyword">struct</span> &#123;</span><br><span class="line">	exec   execprobe.Prober</span><br><span class="line">	http   httpprobe.Prober</span><br><span class="line">	tcp    tcpprobe.Prober</span><br><span class="line">	grpc   grpcprobe.Prober</span><br><span class="line">	runner kubecontainer.CommandRunner</span><br><span class="line"></span><br><span class="line">	recorder record.EventRecorder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newProber</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	runner kubecontainer.CommandRunner,</span></span></span><br><span class="line"><span class="function"><span class="params">	recorder record.EventRecorder)</span> *<span class="title">prober</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> followNonLocalRedirects = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">return</span> &amp;prober&#123;</span><br><span class="line">		exec:     execprobe.New(),</span><br><span class="line">		http:     httpprobe.New(followNonLocalRedirects),</span><br><span class="line">		tcp:      tcpprobe.New(),</span><br><span class="line">		grpc:     grpcprobe.New(),</span><br><span class="line">		runner:   runner,</span><br><span class="line">		recorder: recorder,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *prober)</span> <span class="title">probe</span><span class="params">(ctx context.Context, probeType probeType, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID)</span> <span class="params">(results.Result, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> probeSpec *v1.Probe</span><br><span class="line">	<span class="keyword">switch</span> probeType &#123;</span><br><span class="line">	<span class="keyword">case</span> readiness:</span><br><span class="line">		probeSpec = container.ReadinessProbe</span><br><span class="line">	<span class="keyword">case</span> liveness:</span><br><span class="line">		probeSpec = container.LivenessProbe</span><br><span class="line">	<span class="keyword">case</span> startup:</span><br><span class="line">		probeSpec = container.StartupProbe</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> results.Failure, fmt.Errorf(<span class="string">"unknown probe type: %q"</span>, probeType)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> probeSpec == <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.InfoS(<span class="string">"Probe is nil"</span>, <span class="string">"probeType"</span>, probeType, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"podUID"</span>, pod.UID, <span class="string">"containerName"</span>, container.Name)</span><br><span class="line">		<span class="keyword">return</span> results.Success, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result, output, err := pb.runProbeWithRetries(ctx, probeType, probeSpec, pod, status, container, containerID, maxProbeRetries)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || (result != probe.Success &amp;&amp; result != probe.Warning) &#123;</span><br><span class="line">		<span class="comment">// Probe failed in one way or another.</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.V(<span class="number">1</span>).ErrorS(err, <span class="string">"Probe errored"</span>, <span class="string">"probeType"</span>, probeType, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"podUID"</span>, pod.UID, <span class="string">"containerName"</span>, container.Name)</span><br><span class="line">			pb.recordContainerEvent(pod, &amp;container, v1.EventTypeWarning, events.ContainerUnhealthy, <span class="string">"%s probe errored: %v"</span>, probeType, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// result != probe.Success</span></span><br><span class="line">			klog.V(<span class="number">1</span>).InfoS(<span class="string">"Probe failed"</span>, <span class="string">"probeType"</span>, probeType, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"podUID"</span>, pod.UID, <span class="string">"containerName"</span>, container.Name, <span class="string">"probeResult"</span>, result, <span class="string">"output"</span>, output)</span><br><span class="line">			pb.recordContainerEvent(pod, &amp;container, v1.EventTypeWarning, events.ContainerUnhealthy, <span class="string">"%s probe failed: %s"</span>, probeType, output)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> results.Failure, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> result == probe.Warning &#123;</span><br><span class="line">		pb.recordContainerEvent(pod, &amp;container, v1.EventTypeWarning, events.ContainerProbeWarning, <span class="string">"%s probe warning: %s"</span>, probeType, output)</span><br><span class="line">		klog.V(<span class="number">3</span>).InfoS(<span class="string">"Probe succeeded with a warning"</span>, <span class="string">"probeType"</span>, probeType, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"podUID"</span>, pod.UID, <span class="string">"containerName"</span>, container.Name, <span class="string">"output"</span>, output)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		klog.V(<span class="number">3</span>).InfoS(<span class="string">"Probe succeeded"</span>, <span class="string">"probeType"</span>, probeType, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"podUID"</span>, pod.UID, <span class="string">"containerName"</span>, container.Name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results.Success, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有重试的probe, 成功后立刻返回；如果一直不成功返回最后一次的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *prober)</span> <span class="title">runProbeWithRetries</span><span class="params">(ctx context.Context, probeType probeType, p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID, retries <span class="keyword">int</span>)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> result probe.Result</span><br><span class="line">	<span class="keyword">var</span> output <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; retries; i++ &#123;</span><br><span class="line">		result, output, err = pb.runProbe(ctx, probeType, p, pod, status, container, containerID)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> result, output, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result, output, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *prober)</span> <span class="title">runProbe</span><span class="params">(ctx context.Context, probeType probeType, p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	timeout := time.Duration(p.TimeoutSeconds) * time.Second</span><br><span class="line">    <span class="comment">// 分别执行对应的健康检查</span></span><br><span class="line">	<span class="keyword">if</span> p.Exec != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">"Exec-Probe runProbe"</span>, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"containerName"</span>, container.Name, <span class="string">"execCommand"</span>, p.Exec.Command)</span><br><span class="line">		command := kubecontainer.ExpandContainerCommandOnlyStatic(p.Exec.Command, container.Env)</span><br><span class="line">		<span class="keyword">return</span> pb.exec.Probe(pb.newExecInContainer(ctx, container, containerID, command, timeout))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.HTTPGet != <span class="literal">nil</span> &#123;</span><br><span class="line">		req, err := httpprobe.NewRequestForHTTPGetAction(p.HTTPGet, &amp;container, status.PodIP, <span class="string">"probe"</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> probe.Unknown, <span class="string">""</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> klogV4 := klog.V(<span class="number">4</span>); klogV4.Enabled() &#123;</span><br><span class="line">			port := req.URL.Port()</span><br><span class="line">			host := req.URL.Hostname()</span><br><span class="line">			path := req.URL.Path</span><br><span class="line">			scheme := req.URL.Scheme</span><br><span class="line">			headers := p.HTTPGet.HTTPHeaders</span><br><span class="line">			klogV4.InfoS(<span class="string">"HTTP-Probe"</span>, <span class="string">"scheme"</span>, scheme, <span class="string">"host"</span>, host, <span class="string">"port"</span>, port, <span class="string">"path"</span>, path, <span class="string">"timeout"</span>, timeout, <span class="string">"headers"</span>, headers)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pb.http.Probe(req, timeout)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.TCPSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">		port, err := probe.ResolveContainerPort(p.TCPSocket.Port, &amp;container)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> probe.Unknown, <span class="string">""</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		host := p.TCPSocket.Host</span><br><span class="line">		<span class="keyword">if</span> host == <span class="string">""</span> &#123;</span><br><span class="line">			host = status.PodIP</span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">"TCP-Probe"</span>, <span class="string">"host"</span>, host, <span class="string">"port"</span>, port, <span class="string">"timeout"</span>, timeout)</span><br><span class="line">		<span class="keyword">return</span> pb.tcp.Probe(host, port, timeout)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p.GRPC != <span class="literal">nil</span> &#123;</span><br><span class="line">		host := status.PodIP</span><br><span class="line">		service := <span class="string">""</span></span><br><span class="line">		<span class="keyword">if</span> p.GRPC.Service != <span class="literal">nil</span> &#123;</span><br><span class="line">			service = *p.GRPC.Service</span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">"GRPC-Probe"</span>, <span class="string">"host"</span>, host, <span class="string">"service"</span>, service, <span class="string">"port"</span>, p.GRPC.Port, <span class="string">"timeout"</span>, timeout)</span><br><span class="line">		<span class="keyword">return</span> pb.grpc.Probe(host, service, <span class="keyword">int</span>(p.GRPC.Port), timeout)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.InfoS(<span class="string">"Failed to find probe builder for container"</span>, <span class="string">"containerName"</span>, container.Name)</span><br><span class="line">	<span class="keyword">return</span> probe.Unknown, <span class="string">""</span>, fmt.Errorf(<span class="string">"missing probe handler for %s:%s"</span>, format.Pod(pod), container.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/prober/prober_manager.go</span></span><br><span class="line"><span class="comment">// Manager它用于管理Pod的探测（probing）过程。对于每个指定了探测（probe）的容器（container）,</span></span><br><span class="line"><span class="comment">//Manager会创建一个探测工作者（probe worker）。探测工作者会定期对其所分配的容器进行探</span></span><br><span class="line"><span class="comment">//测，并缓存探测结果。当需要时（通过UpdatePodStatus方法请求），Manager会使用缓存的探测结果//来设置相应的Ready状态（PodStatus）</span></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 为每个创建了probe的容器创建probe workers.每个新建的pod都应该调用这个方法</span></span><br><span class="line">	AddPod(pod *v1.Pod)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// StopLivenessAndStartup handles stopping liveness and startup probes during termination.</span></span><br><span class="line">	StopLivenessAndStartup(pod *v1.Pod)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除removed pod状态,包括终止probe workers和删除缓存</span></span><br><span class="line">	RemovePod(pod *v1.Pod)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CleanupPods handles cleaning up pods which should no longer be running.</span></span><br><span class="line">	<span class="comment">// It takes a map of "desired pods" which should not be cleaned up.</span></span><br><span class="line">	CleanupPods(desiredPods <span class="keyword">map</span>[types.UID]sets.Empty)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// UpdatePodStatus modifies the given PodStatus with the appropriate Ready state for each</span></span><br><span class="line">	<span class="comment">// container based on container running status, cached probe results and worker states.</span></span><br><span class="line">	UpdatePodStatus(types.UID, *v1.PodStatus)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// manager 实现了Manager接口</span></span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Map of active workers for probes</span></span><br><span class="line">	workers <span class="keyword">map</span>[probeKey]*worker</span><br><span class="line">	<span class="comment">// Lock for accessing &amp; mutating workers</span></span><br><span class="line">	workerLock sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The statusManager cache provides pod IP and container IDs for probing.</span></span><br><span class="line">	statusManager status.Manager</span><br><span class="line"></span><br><span class="line">	<span class="comment">// readinessManager manages the results of readiness probes</span></span><br><span class="line">	readinessManager results.Manager</span><br><span class="line"></span><br><span class="line">	<span class="comment">// livenessManager manages the results of liveness probes</span></span><br><span class="line">	livenessManager results.Manager</span><br><span class="line"></span><br><span class="line">	<span class="comment">// startupManager manages the results of startup probes</span></span><br><span class="line">	startupManager results.Manager</span><br><span class="line"></span><br><span class="line">	<span class="comment">// prober executes the probe actions.</span></span><br><span class="line">	prober *prober</span><br><span class="line"></span><br><span class="line">	start time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">AddPod</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">	m.workerLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.workerLock.Unlock()</span><br><span class="line"></span><br><span class="line">	key := probeKey&#123;podUID: pod.UID&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">		key.containerName = c.Name</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> c.StartupProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">			key.probeType = startup</span><br><span class="line">			<span class="keyword">if</span> _, ok := m.workers[key]; ok &#123;</span><br><span class="line">				klog.V(<span class="number">8</span>).ErrorS(<span class="literal">nil</span>, <span class="string">"Startup probe already exists for container"</span>,</span><br><span class="line">					<span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"containerName"</span>, c.Name)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			w := newWorker(m, startup, pod, c)</span><br><span class="line">			m.workers[key] = w</span><br><span class="line">			<span class="keyword">go</span> w.run()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> c.ReadinessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">			key.probeType = readiness</span><br><span class="line">			<span class="keyword">if</span> _, ok := m.workers[key]; ok &#123;</span><br><span class="line">				klog.V(<span class="number">8</span>).ErrorS(<span class="literal">nil</span>, <span class="string">"Readiness probe already exists for container"</span>,</span><br><span class="line">					<span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"containerName"</span>, c.Name)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			w := newWorker(m, readiness, pod, c)</span><br><span class="line">			m.workers[key] = w</span><br><span class="line">			<span class="keyword">go</span> w.run()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> c.LivenessProbe != <span class="literal">nil</span> &#123;</span><br><span class="line">			key.probeType = liveness</span><br><span class="line">			<span class="keyword">if</span> _, ok := m.workers[key]; ok &#123;</span><br><span class="line">				klog.V(<span class="number">8</span>).ErrorS(<span class="literal">nil</span>, <span class="string">"Liveness probe already exists for container"</span>,</span><br><span class="line">					<span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"containerName"</span>, c.Name)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			w := newWorker(m, liveness, pod, c)</span><br><span class="line">			m.workers[key] = w</span><br><span class="line">			<span class="keyword">go</span> w.run()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">StopLivenessAndStartup</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">	m.workerLock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> m.workerLock.RUnlock()</span><br><span class="line"></span><br><span class="line">	key := probeKey&#123;podUID: pod.UID&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">		key.containerName = c.Name</span><br><span class="line">		<span class="keyword">for</span> _, probeType := <span class="keyword">range</span> [...]probeType&#123;liveness, startup&#125; &#123;</span><br><span class="line">			key.probeType = probeType</span><br><span class="line">			<span class="keyword">if</span> worker, ok := m.workers[key]; ok &#123;</span><br><span class="line">				worker.stop()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">RemovePod</span><span class="params">(pod *v1.Pod)</span></span> &#123;</span><br><span class="line">	m.workerLock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> m.workerLock.RUnlock()</span><br><span class="line"></span><br><span class="line">	key := probeKey&#123;podUID: pod.UID&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">		key.containerName = c.Name</span><br><span class="line">		<span class="keyword">for</span> _, probeType := <span class="keyword">range</span> [...]probeType&#123;readiness, liveness, startup&#125; &#123;</span><br><span class="line">			key.probeType = probeType</span><br><span class="line">			<span class="keyword">if</span> worker, ok := m.workers[key]; ok &#123;</span><br><span class="line">				worker.stop()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">CleanupPods</span><span class="params">(desiredPods <span class="keyword">map</span>[types.UID]sets.Empty)</span></span> &#123;</span><br><span class="line">	m.workerLock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> m.workerLock.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> key, worker := <span class="keyword">range</span> m.workers &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := desiredPods[key.podUID]; !ok &#123;</span><br><span class="line">			worker.stop()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *manager)</span> <span class="title">UpdatePodStatus</span><span class="params">(podUID types.UID, podStatus *v1.PodStatus)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> podStatus.ContainerStatuses &#123;</span><br><span class="line">		<span class="keyword">var</span> started <span class="keyword">bool</span></span><br><span class="line">		<span class="keyword">if</span> c.State.Running == <span class="literal">nil</span> &#123;</span><br><span class="line">			started = <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> result, ok := m.startupManager.Get(kubecontainer.ParseContainerID(c.ContainerID)); ok &#123;</span><br><span class="line">			started = result == results.Success</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// The check whether there is a probe which hasn't run yet.</span></span><br><span class="line">			_, exists := m.getWorker(podUID, c.Name, startup)</span><br><span class="line">			started = !exists</span><br><span class="line">		&#125;</span><br><span class="line">		podStatus.ContainerStatuses[i].Started = &amp;started</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> started &#123;</span><br><span class="line">			<span class="keyword">var</span> ready <span class="keyword">bool</span></span><br><span class="line">			<span class="keyword">if</span> c.State.Running == <span class="literal">nil</span> &#123;</span><br><span class="line">				ready = <span class="literal">false</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> result, ok := m.readinessManager.Get(kubecontainer.ParseContainerID(c.ContainerID)); ok &amp;&amp; result == results.Success &#123;</span><br><span class="line">				ready = <span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// The check whether there is a probe which hasn't run yet.</span></span><br><span class="line">				w, exists := m.getWorker(podUID, c.Name, readiness)</span><br><span class="line">				ready = !exists <span class="comment">// no readinessProbe -&gt; always ready</span></span><br><span class="line">				<span class="keyword">if</span> exists &#123;</span><br><span class="line">					<span class="comment">// Trigger an immediate run of the readinessProbe to update ready state</span></span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> w.manualTriggerCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">					<span class="keyword">default</span>: <span class="comment">// Non-blocking.</span></span><br><span class="line">						klog.InfoS(<span class="string">"Failed to trigger a manual run"</span>, <span class="string">"probe"</span>, w.probeType.String())</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			podStatus.ContainerStatuses[i].Ready = ready</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// init containers are ready if they have exited with success or if a readiness probe has</span></span><br><span class="line">	<span class="comment">// succeeded.</span></span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> podStatus.InitContainerStatuses &#123;</span><br><span class="line">		<span class="keyword">var</span> ready <span class="keyword">bool</span></span><br><span class="line">		<span class="keyword">if</span> c.State.Terminated != <span class="literal">nil</span> &amp;&amp; c.State.Terminated.ExitCode == <span class="number">0</span> &#123;</span><br><span class="line">			ready = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		podStatus.InitContainerStatuses[i].Ready = ready</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pkg/kubelet/prober/worker.go</span></span><br><span class="line"><span class="comment">// 同期性的执行探针健康检测</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	probeTickerPeriod := time.Duration(w.spec.PeriodSeconds) * time.Second</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If kubelet restarted the probes could be started in rapid succession.</span></span><br><span class="line">	<span class="comment">// Let the worker wait for a random portion of tickerPeriod before probing.</span></span><br><span class="line">	<span class="comment">// Do it only if the kubelet has started recently.</span></span><br><span class="line">	<span class="keyword">if</span> probeTickerPeriod &gt; time.Since(w.probeManager.start) &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Float64() * <span class="keyword">float64</span>(probeTickerPeriod)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	probeTicker := time.NewTicker(probeTickerPeriod)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// Clean up.</span></span><br><span class="line">		probeTicker.Stop()</span><br><span class="line">		<span class="keyword">if</span> !w.containerID.IsEmpty() &#123;</span><br><span class="line">			w.resultsManager.Remove(w.containerID)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		w.probeManager.removeWorker(w.pod.UID, w.container.Name, w.probeType)</span><br><span class="line">		ProberResults.Delete(w.proberResultsSuccessfulMetricLabels)</span><br><span class="line">		ProberResults.Delete(w.proberResultsFailedMetricLabels)</span><br><span class="line">		ProberResults.Delete(w.proberResultsUnknownMetricLabels)</span><br><span class="line">		ProberDuration.Delete(w.proberDurationSuccessfulMetricLabels)</span><br><span class="line">		ProberDuration.Delete(w.proberDurationUnknownMetricLabels)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">probeLoop:</span><br><span class="line">	<span class="keyword">for</span> w.doProbe(ctx) &#123;</span><br><span class="line">		<span class="comment">// Wait for next probe tick.</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-w.stopCh:</span><br><span class="line">			<span class="keyword">break</span> probeLoop</span><br><span class="line">		<span class="keyword">case</span> &lt;-probeTicker.C:</span><br><span class="line">		<span class="keyword">case</span> &lt;-w.manualTriggerCh:</span><br><span class="line">			<span class="comment">// continue</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="execProbe"><a href="#execProbe" class="headerlink" title="execProbe"></a>execProbe</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/probe/exec/exec.go</span></span><br><span class="line"><span class="comment">// 返回结构体execProber(实现了Prober接口)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">Prober</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> execProber&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prober is an interface defining the Probe object for container readiness/liveness checks.</span></span><br><span class="line"><span class="keyword">type</span> Prober <span class="keyword">interface</span> &#123;</span><br><span class="line">	Probe(e exec.Cmd) (probe.Result, <span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> execProber <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pr execProber)</span> <span class="title">Probe</span><span class="params">(e exec.Cmd)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> dataBuffer bytes.Buffer</span><br><span class="line">	writer := ioutils.LimitWriter(&amp;dataBuffer, maxReadLength)</span><br><span class="line"></span><br><span class="line">	e.SetStderr(writer)</span><br><span class="line">	e.SetStdout(writer)</span><br><span class="line">    <span class="comment">// Start and Wait are for running a process non-blocking</span></span><br><span class="line">    <span class="comment">// 以非阻塞的方式执行命令，不等待结果返回</span></span><br><span class="line">	err := e.Start()</span><br><span class="line">    <span class="comment">// 执行成功后必须调用Wait方法释放系统资源</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		err = e.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	data := dataBuffer.Bytes()</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"Exec probe response: %q"</span>, <span class="keyword">string</span>(data))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		exit, ok := err.(exec.ExitError)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="comment">// ExitStatus() == 0 命令执行成功</span></span><br><span class="line">			<span class="keyword">if</span> exit.ExitStatus() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> probe.Success, <span class="keyword">string</span>(data), <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> probe.Failure, <span class="keyword">string</span>(data), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		timeoutErr, ok := err.(*TimeoutError)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.ExecProbeTimeout) &#123;</span><br><span class="line">				<span class="comment">// When exec probe timeout, data is empty, so we should return timeoutErr.Error() as the stdout.</span></span><br><span class="line">				<span class="keyword">return</span> probe.Failure, timeoutErr.Error(), <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			klog.Warningf(<span class="string">"Exec probe timed out after %s but ExecProbeTimeout feature gate was disabled"</span>, timeoutErr.Timeout())</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 返回的error不是ExitError，则返回Unknown</span></span><br><span class="line">		<span class="keyword">return</span> probe.Unknown, <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 命令执行未出错返回Success</span></span><br><span class="line">	<span class="keyword">return</span> probe.Success, <span class="keyword">string</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="tcpProbe"><a href="#tcpProbe" class="headerlink" title="tcpProbe"></a>tcpProbe</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/probe/tcp/tcp.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">Prober</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> tcpProber&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prober is an interface that defines the Probe function for doing TCP readiness/liveness checks.</span></span><br><span class="line"><span class="keyword">type</span> Prober <span class="keyword">interface</span> &#123;</span><br><span class="line">	Probe(host <span class="keyword">string</span>, port <span class="keyword">int</span>, timeout time.Duration) (probe.Result, <span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tcpProber <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Probe checks that a TCP connection to the address can be opened.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pr tcpProber)</span> <span class="title">Probe</span><span class="params">(host <span class="keyword">string</span>, port <span class="keyword">int</span>, timeout time.Duration)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> DoTCPProbe(net.JoinHostPort(host, strconv.Itoa(port)), timeout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoTCPProbe checks that a TCP socket to the address can be opened.</span></span><br><span class="line"><span class="comment">// If the socket can be opened, it returns Success</span></span><br><span class="line"><span class="comment">// If the socket fails to open, it returns Failure.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoTCPProbe</span><span class="params">(addr <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	d := probe.ProbeDialer()</span><br><span class="line">	d.Timeout = timeout</span><br><span class="line">	conn, err := d.Dial(<span class="string">"tcp"</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Convert errors to failures to handle timeouts.</span></span><br><span class="line">		<span class="keyword">return</span> probe.Failure, err.Error(), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = conn.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">"Unexpected error closing TCP probe socket: %v (%#v)"</span>, err, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> probe.Success, <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="httpProbe"><a href="#httpProbe" class="headerlink" title="httpProbe"></a>httpProbe</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/probe/http/http.go</span></span><br><span class="line"><span class="comment">// New creates Prober that will skip TLS verification while probing.</span></span><br><span class="line"><span class="comment">// followNonLocalRedirects configures whether the prober should follow redirects to a different hostname.</span></span><br><span class="line"><span class="comment">// If disabled, redirects to other hosts will trigger a warning result.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(followNonLocalRedirects <span class="keyword">bool</span>)</span> <span class="title">Prober</span></span> &#123;</span><br><span class="line">	tlsConfig := &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">true</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> NewWithTLSConfig(tlsConfig, followNonLocalRedirects)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewWithTLSConfig takes tls config as parameter.</span></span><br><span class="line"><span class="comment">// followNonLocalRedirects configures whether the prober should follow redirects to a different hostname.</span></span><br><span class="line"><span class="comment">// If disabled, redirects to other hosts will trigger a warning result.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWithTLSConfig</span><span class="params">(config *tls.Config, followNonLocalRedirects <span class="keyword">bool</span>)</span> <span class="title">Prober</span></span> &#123;</span><br><span class="line">	<span class="comment">// We do not want the probe use node's local proxy set.</span></span><br><span class="line">	transport := utilnet.SetTransportDefaults(</span><br><span class="line">		&amp;http.Transport&#123;</span><br><span class="line">			TLSClientConfig:    config,</span><br><span class="line">			DisableKeepAlives:  <span class="literal">true</span>,</span><br><span class="line">			Proxy:              http.ProxyURL(<span class="literal">nil</span>),</span><br><span class="line">			DisableCompression: <span class="literal">true</span>, <span class="comment">// removes Accept-Encoding header</span></span><br><span class="line">			<span class="comment">// DialContext creates unencrypted TCP connections</span></span><br><span class="line">			<span class="comment">// and is also used by the transport for HTTPS connection</span></span><br><span class="line">			DialContext: probe.ProbeDialer().DialContext,</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> httpProber&#123;transport, followNonLocalRedirects&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prober is an interface that defines the Probe function for doing HTTP readiness/liveness checks.</span></span><br><span class="line"><span class="keyword">type</span> Prober <span class="keyword">interface</span> &#123;</span><br><span class="line">	Probe(req *http.Request, timeout time.Duration) (probe.Result, <span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> httpProber <span class="keyword">struct</span> &#123;</span><br><span class="line">	transport               *http.Transport</span><br><span class="line">	followNonLocalRedirects <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Probe returns a ProbeRunner capable of running an HTTP check.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pr httpProber)</span> <span class="title">Probe</span><span class="params">(req *http.Request, timeout time.Duration)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	client := &amp;http.Client&#123;</span><br><span class="line">		Timeout:       timeout,</span><br><span class="line">		Transport:     pr.transport,</span><br><span class="line">		CheckRedirect: RedirectChecker(pr.followNonLocalRedirects),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DoHTTPProbe(req, client)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetHTTPInterface is an interface for making HTTP requests, that returns a response and error.</span></span><br><span class="line"><span class="keyword">type</span> GetHTTPInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Do(req *http.Request) (*http.Response, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoHTTPProbe checks if a GET request to the url succeeds.</span></span><br><span class="line"><span class="comment">// If the HTTP response code is successful (i.e. 400 &gt; code &gt;= 200), it returns Success.</span></span><br><span class="line"><span class="comment">// If the HTTP response code is unsuccessful or HTTP communication fails, it returns Failure.</span></span><br><span class="line"><span class="comment">// This is exported because some other packages may want to do direct HTTP probes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoHTTPProbe</span><span class="params">(req *http.Request, client GetHTTPInterface)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	url := req.URL</span><br><span class="line">	headers := req.Header</span><br><span class="line">	res, err := client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Convert errors into failures to catch timeouts.</span></span><br><span class="line">		<span class="keyword">return</span> probe.Failure, err.Error(), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">	b, err := utilio.ReadAtMost(res.Body, maxRespBodyLength)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err == utilio.ErrLimitReached &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"Non fatal body truncation for %s, Response: %v"</span>, url.String(), *res)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> probe.Failure, <span class="string">""</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	body := <span class="keyword">string</span>(b)</span><br><span class="line">	<span class="keyword">if</span> res.StatusCode &gt;= http.StatusOK &amp;&amp; res.StatusCode &lt; http.StatusBadRequest &#123;</span><br><span class="line">		<span class="keyword">if</span> res.StatusCode &gt;= http.StatusMultipleChoices &#123; <span class="comment">// Redirect</span></span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"Probe terminated redirects for %s, Response: %v"</span>, url.String(), *res)</span><br><span class="line">			<span class="keyword">return</span> probe.Warning, fmt.Sprintf(<span class="string">"Probe terminated redirects, Response body: %v"</span>, body), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).Infof(<span class="string">"Probe succeeded for %s, Response: %v"</span>, url.String(), *res)</span><br><span class="line">		<span class="keyword">return</span> probe.Success, body, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"Probe failed for %s with request headers %v, response body: %v"</span>, url.String(), headers, body)</span><br><span class="line">	<span class="comment">// Note: Until https://issue.k8s.io/99425 is addressed, this user-facing failure message must not contain the response body.</span></span><br><span class="line">	failureMsg := fmt.Sprintf(<span class="string">"HTTP probe failed with statuscode: %d"</span>, res.StatusCode)</span><br><span class="line">	<span class="keyword">return</span> probe.Failure, failureMsg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="grpcProbe"><a href="#grpcProbe" class="headerlink" title="grpcProbe"></a>grpcProbe</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/probe/grpc/grpc.go</span></span><br><span class="line"><span class="comment">// Prober is an interface that defines the Probe function for doing GRPC readiness/liveness/startup checks.</span></span><br><span class="line"><span class="keyword">type</span> Prober <span class="keyword">interface</span> &#123;</span><br><span class="line">	Probe(host, service <span class="keyword">string</span>, port <span class="keyword">int</span>, timeout time.Duration) (probe.Result, <span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> grpcProber <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New Prober for execute grpc probe</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">Prober</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> grpcProber&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Probe executes a grpc call to check the liveness/readiness/startup of container.</span></span><br><span class="line"><span class="comment">// Returns the Result status, command output, and errors if any.</span></span><br><span class="line"><span class="comment">// Any failure is considered as a probe failure to mimic grpc_health_probe tool behavior.</span></span><br><span class="line"><span class="comment">// err is always nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p grpcProber)</span> <span class="title">Probe</span><span class="params">(host, service <span class="keyword">string</span>, port <span class="keyword">int</span>, timeout time.Duration)</span> <span class="params">(probe.Result, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	v := version.Get()</span><br><span class="line"></span><br><span class="line">	opts := []grpc.DialOption&#123;</span><br><span class="line">		grpc.WithUserAgent(fmt.Sprintf(<span class="string">"kube-probe/%s.%s"</span>, v.Major, v.Minor)),</span><br><span class="line">		grpc.WithBlock(),</span><br><span class="line">		grpc.WithTransportCredentials(insecure.NewCredentials()), <span class="comment">//credentials are currently not supported</span></span><br><span class="line">		grpc.WithContextDialer(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> probe.ProbeDialer().DialContext(ctx, <span class="string">"tcp"</span>, addr)</span><br><span class="line">		&#125;),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), timeout)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	addr := net.JoinHostPort(host, fmt.Sprintf(<span class="string">"%d"</span>, port))</span><br><span class="line">	conn, err := grpc.DialContext(ctx, addr, opts...)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err == context.DeadlineExceeded &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).ErrorS(err, <span class="string">"failed to connect grpc service due to timeout"</span>, <span class="string">"addr"</span>, addr, <span class="string">"service"</span>, service, <span class="string">"timeout"</span>, timeout)</span><br><span class="line">			<span class="keyword">return</span> probe.Failure, fmt.Sprintf(<span class="string">"timeout: failed to connect service %q within %v: %+v"</span>, addr, timeout, err), <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).ErrorS(err, <span class="string">"failed to connect grpc service"</span>, <span class="string">"service"</span>, addr)</span><br><span class="line">			<span class="keyword">return</span> probe.Failure, fmt.Sprintf(<span class="string">"error: failed to connect service at %q: %+v"</span>, addr, err), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		_ = conn.Close()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	client := grpchealth.NewHealthClient(conn)</span><br><span class="line"></span><br><span class="line">	resp, err := client.Check(metadata.NewOutgoingContext(ctx, <span class="built_in">make</span>(metadata.MD)), &amp;grpchealth.HealthCheckRequest&#123;</span><br><span class="line">		Service: service,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		stat, ok := status.FromError(err)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="keyword">switch</span> stat.Code() &#123;</span><br><span class="line">			<span class="keyword">case</span> codes.Unimplemented:</span><br><span class="line">				klog.V(<span class="number">4</span>).ErrorS(err, <span class="string">"server does not implement the grpc health protocol (grpc.health.v1.Health)"</span>, <span class="string">"addr"</span>, addr, <span class="string">"service"</span>, service)</span><br><span class="line">				<span class="keyword">return</span> probe.Failure, fmt.Sprintf(<span class="string">"error: this server does not implement the grpc health protocol (grpc.health.v1.Health): %s"</span>, stat.Message()), <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">case</span> codes.DeadlineExceeded:</span><br><span class="line">				klog.V(<span class="number">4</span>).ErrorS(err, <span class="string">"rpc request not finished within timeout"</span>, <span class="string">"addr"</span>, addr, <span class="string">"service"</span>, service, <span class="string">"timeout"</span>, timeout)</span><br><span class="line">				<span class="keyword">return</span> probe.Failure, fmt.Sprintf(<span class="string">"timeout: health rpc did not complete within %v"</span>, timeout), <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				klog.V(<span class="number">4</span>).ErrorS(err, <span class="string">"rpc probe failed"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).ErrorS(err, <span class="string">"health rpc probe failed"</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> probe.Failure, fmt.Sprintf(<span class="string">"error: health rpc probe failed: %+v"</span>, err), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> resp.GetStatus() != grpchealth.HealthCheckResponse_SERVING &#123;</span><br><span class="line">		<span class="keyword">return</span> probe.Failure, fmt.Sprintf(<span class="string">"service unhealthy (responded with %q)"</span>, resp.GetStatus().String()), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> probe.Success, fmt.Sprintf(<span class="string">"service healthy"</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h5><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/kubelet.go</span></span><br><span class="line"><span class="comment">// 初始化，NewMainKubelet省略了部分参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMainKubelet</span><span class="params">(kubeCfg *kubeletconfiginternal.KubeletConfiguration,...)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">if</span> kubeDeps.ProbeManager != <span class="literal">nil</span> &#123;</span><br><span class="line">		klet.probeManager = kubeDeps.ProbeManager</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		klet.probeManager = prober.NewManager(</span><br><span class="line">			klet.statusManager,</span><br><span class="line">			klet.livenessManager,</span><br><span class="line">			klet.readinessManager,</span><br><span class="line">			klet.startupManager,</span><br><span class="line">			klet.runner,</span><br><span class="line">			kubeDeps.Recorder)</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">SyncPod</span><span class="params">(ctx context.Context, updateType kubetypes.SyncPodType, pod, mirrorPod *v1.Pod, podStatus *kubecontainer.PodStatus)</span> <span class="params">(isTerminal <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 写入缓存，并启动probe workers</span></span><br><span class="line">    kl.probeManager.AddPod(pod)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/prober/prober.go" target="_blank" rel="noopener">pkg/kubelet/prober/prober.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/prober/prober_manager.go" target="_blank" rel="noopener">pkg/kubelet/prober/prober_manager.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/prober/worker.go" target="_blank" rel="noopener">pkg/kubelet/prober/worker.go</a><br>4.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/probe/exec/exec.go" target="_blank" rel="noopener">pkg/probe/exec/exec.go</a><br>5.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/probe/tcp/tcp.go" target="_blank" rel="noopener">pkg/probe/tcp/tcp.go</a><br>6.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/probe/http/http.go" target="_blank" rel="noopener">pkg/probe/http/http.go</a><br>7.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/probe/grpc/grpc.go" target="_blank" rel="noopener">pkg/probe/grpc/grpc.go</a><br>8.<a href="https://github.com/kubernetes/kubernetes/blob/release-1.27/pkg/kubelet/kubelet.go" target="_blank" rel="noopener">pkg/kubelet/kubelet.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubelet</tag>
      </tags>
  </entry>
  <entry>
    <title>kuberntes Custom Resources</title>
    <url>/2020/06/27/kuberntes-Custom-Resources/</url>
    <content><![CDATA[<h4 id="Custom-resources"><a href="#Custom-resources" class="headerlink" title="Custom resources"></a>Custom resources</h4><p>自定义资源(Custom Resources):是对现有Kubernetes API的一种扩展。当你创建一个<code>CR</code>后，你可以使用<code>kubectl</code>命令，像操作<code>Pod</code>一样操作自定义资源。</p>
<h4 id="Custom-controllers"><a href="#Custom-controllers" class="headerlink" title="Custom controllers"></a>Custom controllers</h4><p><code>custom resources</code>只是定义了如何存储和查询结构化数据。如果要想<code>CR</code>真正的被使用起来，还需要定义<code>Custom controllers</code>,定义<code>Custom controllers</code>之后才可以真正的提供描述性接口。<br>描述性接口允许你只定义资源所需要达到的理想状态，控制器会为了达到理想状态进行一系列的操作，并维护这个理想状态。｀Operatorr pattern<code>可以使</code>Custom resourcs<code>和</code>Custom controllers`完美结合。</p>
<h4 id="如何添加custom-resources"><a href="#如何添加custom-resources" class="headerlink" title="如何添加custom resources"></a>如何添加<code>custom resources</code></h4><p>k8s提供了两种方法添加自定义资源到kubernetes集群。</p>
<p>－ CRD:<a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" target="_blank" rel="noopener">CustomResourceDefinitions</a>:简单不需要编程</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/" target="_blank" rel="noopener">API Aggregation</a>:功能强大需要编程</li>
</ul>
<p>两者使用难度对比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>CRDs</th>
<th>Aggregated API</th>
</tr>
</thead>
<tbody>
<tr>
<td>Do not require programming. Users can choose any language for a CRD controller.</td>
<td>Requires programming in Go and building binary and image.</td>
</tr>
<tr>
<td>No additional service to run; CRDs are handled by API server.</td>
<td>An additional service to create and that could fail.</td>
</tr>
<tr>
<td>No ongoing support once the CRD is created. Any bug fixes are picked up as part of normal Kubernetes Master upgrades.</td>
<td>May need to periodically pickup bug fixes from upstream and rebuild and update the Aggregated API server.</td>
</tr>
<tr>
<td>No need to handle multiple versions of your API; for example, when you control the client for this resource, you can upgrade it in sync with the API.</td>
<td>You need to handle multiple versions of your API; for example, when developing an extension to share with the world.</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>Ref：<br>1.<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-state-metrics</title>
    <url>/2023/12/24/kube-state-metrics/</url>
    <content><![CDATA[<p>kube-state-metrics（KSM）是一个简单的服务，它监听Kubernetes API服务器并生成关于对象状态的指标（请参见下面“指标”部分中的示例）。它的重点不在于个别Kubernetes组件的健康状况，而是关注其中各种对象（如部署、节点和Pod）的健康状况。</p>
<p>kube-state-metrics通过从Kubernetes API对象生成指标，而无需修改这些对象，确保了其提供的功能与Kubernetes API对象本身具有相同的稳定性。这意味着在某些情况下，kube-state-metrics可能不会显示与kubectl完全相同的值，因为kubectl会应用一定的启发式方法来显示可理解的消息。kube-state-metrics提供了未经修改的来自Kubernetes API的原始数据，这样用户就可以获得他们所需的所有数据，并根据需要执行启发式方法。</p>
<p>这些指标通过HTTP端点 /metrics 在监听端口（默认为8080）上以纯文本形式导出。它们旨在被Prometheus本身或与抓取Prometheus客户端端点兼容的抓取器消费。您也可以在浏览器中打开 /metrics 来查看原始指标数据。请注意，/metrics 端点上公开的指标反映了Kubernetes集群的当前状态。当Kubernetes对象被删除时，它们将不再在 /metrics 端点上可见。</p>
<hr>
<p>为<code>kube-state-metrics</code>新增自定义的crd指标<br>指标如下  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Metric Name</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_cpu_total</td>
<td>用户可以使用的cpu</td>
</tr>
<tr>
<td>user_memory_total</td>
<td>用户可以使用的memory</td>
</tr>
</tbody>
</table>
</div>
<p><code>kube-state-metrics</code>在<code>internal/store</code>目录下记录了所有的<code>metricFamily</code>,所以我们需要的指标写在这个目录下面。</p>
<p>在<code>internal/store</code>下面新增了三个文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user_types.go</span><br><span class="line">user_test.go</span><br><span class="line">user.go</span><br></pre></td></tr></table></figure></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// internal/store/user_types.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为我们这次监听的CRD是kubeshper User，这里直接把代码copy过来</span></span><br><span class="line"><span class="comment">// 当然也不是一定要使用结构体，一些情况下可以使用unstructured.Unstructured&#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	metav1.ObjectMeta <span class="string">`json:"metadata,omitempty"`</span></span><br><span class="line"></span><br><span class="line">	Spec UserSpec <span class="string">`json:"spec"`</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Status UserStatus <span class="string">`json:"status,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FinalizerName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UserSpec defines the desired state of User</span></span><br><span class="line"><span class="keyword">type</span> UserSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Unique email address(https://www.ietf.org/rfc/rfc5322.txt).</span></span><br><span class="line">	Email <span class="keyword">string</span> <span class="string">`json:"email"`</span></span><br><span class="line">	<span class="comment">// The preferred written or spoken language for the user.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Lang <span class="keyword">string</span> <span class="string">`json:"lang,omitempty"`</span></span><br><span class="line">	<span class="comment">// Description of the user.</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Description <span class="keyword">string</span> <span class="string">`json:"description,omitempty"`</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	DisplayName <span class="keyword">string</span> <span class="string">`json:"displayName,omitempty"`</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Groups []<span class="keyword">string</span> <span class="string">`json:"groups,omitempty"`</span></span><br><span class="line"></span><br><span class="line">	EncryptedPassword <span class="keyword">string</span> <span class="string">`json:"password,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserState <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These are the valid phases of a user.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// UserActive means the user is available.</span></span><br><span class="line">	UserActive UserState = <span class="string">"Active"</span></span><br><span class="line">	<span class="comment">// UserDisabled means the user is disabled.</span></span><br><span class="line">	UserDisabled UserState = <span class="string">"Disabled"</span></span><br><span class="line">	<span class="comment">// UserAuthLimitExceeded means restrict user login.</span></span><br><span class="line">	UserAuthLimitExceeded UserState = <span class="string">"AuthLimitExceeded"</span></span><br><span class="line"></span><br><span class="line">	AuthenticatedSuccessfully = <span class="string">"authenticated successfully"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserStatus defines the observed state of User</span></span><br><span class="line"><span class="keyword">type</span> UserStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The user status</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	State UserState <span class="string">`json:"state,omitempty"`</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Reason <span class="keyword">string</span> <span class="string">`json:"reason,omitempty"`</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	LastTransitionTime *metav1.Time <span class="string">`json:"lastTransitionTime,omitempty"`</span></span><br><span class="line">	<span class="comment">// Last login attempt timestamp</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	LastLoginTime *metav1.Time <span class="string">`json:"lastLoginTime,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// internal/store/user.go</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/api/resource"</span></span><br><span class="line">	metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/runtime"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/runtime/schema"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/watch"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/dynamic"</span></span><br><span class="line">	clientset <span class="string">"k8s.io/client-go/kubernetes"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/tools/cache"</span></span><br><span class="line">	<span class="string">"k8s.io/kube-state-metrics/v2/pkg/metric"</span></span><br><span class="line">	generator <span class="string">"k8s.io/kube-state-metrics/v2/pkg/metric_generator"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userAnnotationCpuLimitKey = <span class="string">"user-cpu-limit"</span></span><br><span class="line"><span class="keyword">var</span> userAnnotationMemoryLimitKey = <span class="string">"user-memory-limit"</span></span><br><span class="line"><span class="keyword">var</span> schemeGroupVersionResource = schema.GroupVersionResource&#123;Group: <span class="string">"iam.kubesphere.io"</span>, Version: <span class="string">"v1alpha2"</span>, Resource: <span class="string">"users"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> descUserDefaultLabels = []<span class="keyword">string</span>&#123;<span class="string">"user"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CpuOrMemory <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Cpu CpuOrMemory = <span class="string">"cpu"</span></span><br><span class="line"><span class="keyword">var</span> Memory CpuOrMemory = <span class="string">"memory"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了MetricFamilies</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">userMetricFamilies</span><span class="params">()</span> []<span class="title">generator</span>.<span class="title">FamilyGenerator</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> []generator.FamilyGenerator&#123;</span><br><span class="line">		*generator.NewFamilyGenerator(</span><br><span class="line">			<span class="string">"kube_user_cpu_total"</span>,</span><br><span class="line">			<span class="string">"The number of user's cpu core."</span>,</span><br><span class="line">			metric.Gauge,</span><br><span class="line">			<span class="string">""</span>,</span><br><span class="line">			wrapUserFunc(<span class="function"><span class="keyword">func</span><span class="params">(u *User)</span> *<span class="title">metric</span>.<span class="title">Family</span></span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;metric.Family&#123;</span><br><span class="line">					Metrics: []*metric.Metric&#123;</span><br><span class="line">						&#123;</span><br><span class="line">                            <span class="comment">// 设置metric kube_user_cpu_total的值</span></span><br><span class="line">							Value: getUserLimit(u, Cpu),</span><br><span class="line">						&#125;,</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;),</span><br><span class="line">		),</span><br><span class="line">		*generator.NewFamilyGenerator(</span><br><span class="line">			<span class="string">"kube_user_memory_total"</span>,</span><br><span class="line">			<span class="string">"The byte of user's memory."</span>,</span><br><span class="line">			metric.Gauge,</span><br><span class="line">			<span class="string">""</span>,</span><br><span class="line">			wrapUserFunc(<span class="function"><span class="keyword">func</span><span class="params">(u *User)</span> *<span class="title">metric</span>.<span class="title">Family</span></span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;metric.Family&#123;</span><br><span class="line">					Metrics: []*metric.Metric&#123;</span><br><span class="line">						&#123;</span><br><span class="line">                            <span class="comment">// 设置metric kube_user_memory_total的值</span></span><br><span class="line">							Value: getUserLimit(u, Memory),</span><br><span class="line">						&#125;,</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;),</span><br><span class="line">		),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUserLimit</span><span class="params">(u *User, metricType CpuOrMemory)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	s, _ := u.Annotations[userAnnotationCpuLimitKey]</span><br><span class="line">	<span class="keyword">if</span> metricType == Memory &#123;</span><br><span class="line">		s, _ = u.Annotations[userAnnotationMemoryLimitKey]</span><br><span class="line">	&#125;</span><br><span class="line">	limit, err := resource.ParseQuantity(s)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> limit.AsApproximateFloat64()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wrapUserFunc</span><span class="params">(f <span class="keyword">func</span>(*User)</span> *<span class="title">metric</span>.<span class="title">Family</span>) <span class="title">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">metric</span>.<span class="title">Family</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">metric</span>.<span class="title">Family</span></span> &#123;</span><br><span class="line">		<span class="comment">//user := obj.(*User)</span></span><br><span class="line">		<span class="keyword">var</span> user User</span><br><span class="line">		userUnstructured := obj.(*unstructured.Unstructured)</span><br><span class="line">		err := runtime.DefaultUnstructuredConverter.FromUnstructured(userUnstructured.UnstructuredContent(), &amp;user)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"transfer from unstructured to object error"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		metricFamily := f(&amp;user)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, m := <span class="keyword">range</span> metricFamily.Metrics &#123;</span><br><span class="line">			m.LabelKeys = <span class="built_in">append</span>(descUserDefaultLabels, m.LabelKeys...)</span><br><span class="line">			m.LabelValues = <span class="built_in">append</span>([]<span class="keyword">string</span>&#123;user.Name&#125;, m.LabelValues...)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> metricFamily</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createUserListWatchFunc 为user创建List Watch </span></span><br><span class="line"><span class="comment">// 这里采用多层函数嵌套可以不用返回待定的结构，返回函数只要实现了对应的接口就行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createUserListWatchFunc</span><span class="params">(userClient dynamic.Interface)</span> <span class="title">func</span><span class="params">(kubeClient clientset.Interface, _ <span class="keyword">string</span>, _ <span class="keyword">string</span>)</span> <span class="title">cache</span>.<span class="title">ListerWatcher</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(kubeClient clientset.Interface, _ <span class="keyword">string</span>, _ <span class="keyword">string</span>)</span> <span class="title">cache</span>.<span class="title">ListerWatcher</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;cache.ListWatch&#123;</span><br><span class="line">			ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(opts metav1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">				<span class="keyword">return</span> userClient.Resource(schemeGroupVersionResource).List(context.TODO(), opts)</span><br><span class="line">			&#125;,</span><br><span class="line">			WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(opts metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">				<span class="keyword">return</span> userClient.Resource(schemeGroupVersionResource).Watch(context.TODO(), opts)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// internal/store/user_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserStore</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> metadata = <span class="string">`</span></span><br><span class="line"><span class="string">	    # HELP kube_user_cpu_total The number of user's cpu core.</span></span><br><span class="line"><span class="string">		# TYPE kube_user_cpu_total gauge</span></span><br><span class="line"><span class="string">	    # HELP kube_user_memory_total The byte of user's memory.</span></span><br><span class="line"><span class="string">		# TYPE kube_user_memory_total gauge</span></span><br><span class="line"><span class="string">	`</span></span><br><span class="line">	cases := []generateMetricsTestCase&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			AllowAnnotationsList: []<span class="keyword">string</span>&#123;userAnnotationCpuLimitKey, userAnnotationMemoryLimitKey&#125;,</span><br><span class="line">			Obj: &amp;User&#123;</span><br><span class="line">				ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">					Name:      <span class="string">"bob"</span>,</span><br><span class="line">					Namespace: <span class="string">"ns1"</span>,</span><br><span class="line">					Annotations: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">						userAnnotationCpuLimitKey:    <span class="string">"1"</span>,</span><br><span class="line">						userAnnotationMemoryLimitKey: <span class="string">"1G"</span>,</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">			Want: metadata + <span class="string">`</span></span><br><span class="line"><span class="string">        kube_user_cpu_total&#123;user="bob"&#125; 1</span></span><br><span class="line"><span class="string">		kube_user_memory_total&#123;user="bob"&#125; 1e+09</span></span><br><span class="line"><span class="string">       `</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		c.Func = generator.ComposeMetricGenFuncs(userMetricFamilies())</span><br><span class="line">		c.Headers = generator.ExtractMetricFamilyHeaders(userMetricFamilies())</span><br><span class="line">		<span class="keyword">if</span> err := c.run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.Errorf(<span class="string">"unexpected collecting result in %vth run:\n%s"</span>, i, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// internal/store/builder.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Builder <span class="keyword">struct</span> &#123;</span><br><span class="line">	kubeClient            clientset.Interface</span><br><span class="line">	vpaClient             vpaclientset.Interface</span><br><span class="line">    <span class="comment">// 因为我们新增监听对象是CRD,所以需要创建一个单独的client才能获取对应的资源对象</span></span><br><span class="line">    <span class="comment">// 新增dynamic.Interface,用于list,watch CRD</span></span><br><span class="line">+	userClient            dynamic.Interface</span><br><span class="line">	namespaces            options.NamespaceList</span><br><span class="line">	namespaceFilter       <span class="keyword">string</span></span><br><span class="line">	ctx                   context.Context</span><br><span class="line">	enabledResources      []<span class="keyword">string</span></span><br><span class="line">	familyGeneratorFilter generator.FamilyGeneratorFilter</span><br><span class="line">	listWatchMetrics      *watch.ListWatchMetrics</span><br><span class="line">	shardingMetrics       *sharding.Metrics</span><br><span class="line">	shard                 <span class="keyword">int32</span></span><br><span class="line">	totalShards           <span class="keyword">int</span></span><br><span class="line">	buildStoresFunc       ksmtypes.BuildStoresFunc</span><br><span class="line">	allowAnnotationsList  <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line">	allowLabelsList       <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line">	useAPIServerCache     <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ <span class="comment">// WithUserClient sets the userClient property of a Builder</span></span><br><span class="line">+ <span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WithUserClient</span><span class="params">(c dynamic.Interface)</span></span> &#123;</span><br><span class="line">+	b.userClient = c</span><br><span class="line">+ &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> availableStores = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(f *Builder)</span> []<span class="title">cache</span>.<span class="title">Store</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">+	<span class="string">"users"</span>:                           <span class="function"><span class="keyword">func</span><span class="params">(b *Builder)</span> []<span class="title">cache</span>.<span class="title">Store</span></span> &#123; <span class="keyword">return</span> b.buildUserStores() &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ <span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">buildUserStores</span><span class="params">()</span> []<span class="title">cache</span>.<span class="title">Store</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.buildStoresFunc(userMetricFamilies(), &amp;unstructured.Unstructured&#123;&#125;, createUserListWatchFunc(b.userClient), b.useAPIServerCache)</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 新增创建userClient</span></span><br><span class="line">	kubeClient, vpaClient, userClient, err := createKubeClient(opts.Apiserver, opts.Kubeconfig)</span><br><span class="line">    ...</span><br><span class="line">    storeBuilder.WithUserClient(userClient)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createKubeClient</span><span class="params">(apiserver <span class="keyword">string</span>, kubeconfig <span class="keyword">string</span>)</span> <span class="params">(clientset.Interface, vpaclientset.Interface, dynamic.Interface, error)</span></span> &#123;</span><br><span class="line">	config, err := clientcmd.BuildConfigFromFlags(apiserver, kubeconfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	config.UserAgent = version.Version</span><br><span class="line">	config.AcceptContentTypes = <span class="string">"application/vnd.kubernetes.protobuf,application/json"</span></span><br><span class="line">	config.ContentType = <span class="string">"application/vnd.kubernetes.protobuf"</span></span><br><span class="line"></span><br><span class="line">	kubeClient, err := clientset.NewForConfig(config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vpaClient, err := vpaclientset.NewForConfig(config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	+ userClient, err := dynamic.NewForConfig(config)</span><br><span class="line">	+ <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	+ 	 <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	+ &#125;</span><br><span class="line">	<span class="comment">// Informers don't seem to do a good job logging error messages when it</span></span><br><span class="line">	<span class="comment">// can't reach the server, making debugging hard. This makes it easier to</span></span><br><span class="line">	<span class="comment">// figure out if apiserver is configured incorrectly.</span></span><br><span class="line">	klog.Infof(<span class="string">"Testing communication with server"</span>)</span><br><span class="line">	v, err := kubeClient.Discovery().ServerVersion()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"error while trying to communicate with apiserver"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	klog.Infof(<span class="string">"Running with Kubernetes cluster version: v%s.%s. git version: %s. git tree state: %s. commit: %s. platform: %s"</span>,</span><br><span class="line">		v.Major, v.Minor, v.GitVersion, v.GitTreeState, v.GitCommit, v.Platform)</span><br><span class="line">	klog.Infof(<span class="string">"Communication with server successful"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> kubeClient, vpaClient, userClient, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/options/resource.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// DefaultNamespaces is the default namespace selector for selecting and filtering across all namespaces.</span></span><br><span class="line">	DefaultNamespaces = NamespaceList&#123;metav1.NamespaceAll&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DefaultResources represents the default set of resources in kube-state-metrics.</span></span><br><span class="line">	DefaultResources = ResourceSet&#123;</span><br><span class="line">		<span class="string">"certificatesigningrequests"</span>:      <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"configmaps"</span>:                      <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"cronjobs"</span>:                        <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"daemonsets"</span>:                      <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"deployments"</span>:                     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"endpoints"</span>:                       <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"horizontalpodautoscalers"</span>:        <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"ingresses"</span>:                       <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"jobs"</span>:                            <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"leases"</span>:                          <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"limitranges"</span>:                     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"mutatingwebhookconfigurations"</span>:   <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"namespaces"</span>:                      <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"networkpolicies"</span>:                 <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"nodes"</span>:                           <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"persistentvolumes"</span>:               <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"persistentvolumeclaims"</span>:          <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"poddisruptionbudgets"</span>:            <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"pods"</span>:                            <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"replicasets"</span>:                     <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"replicationcontrollers"</span>:          <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"resourcequotas"</span>:                  <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"secrets"</span>:                         <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"services"</span>:                        <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"statefulsets"</span>:                    <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"storageclasses"</span>:                  <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"validatingwebhookconfigurations"</span>: <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">		<span class="string">"volumeattachments"</span>:               <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">+		<span class="string">"users"</span>:                           <span class="keyword">struct</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kube-state-metrics" target="_blank" rel="noopener">https://github.com/kubernetes/kube-state-metrics</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kube-state-metrics</tag>
      </tags>
  </entry>
  <entry>
    <title>k近邻法-k_Nearest Neighbors</title>
    <url>/2018/06/10/k%E8%BF%91%E9%82%BB%E6%B3%95-k_Nearest%20Neighbors/</url>
    <content><![CDATA[<p>k近邻法(knn)就一种基本分类与回归方法。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/knn.png" alt="image"></p>
<pre><code>from scipy.spatial import minkowski_distance
def classify0(inX, dataSet, labels, k):
  #    dataSetSize = dataSet.shape[0]
  #    diffMat = np.tile(inX, (dataSetSize, 1)) - dataSet
  #    sqDiffMat = diffMat **2
  #    sqDistances = sqDiffMat.sum(axis=1)
  #    distances = sqDistances**0.5
  #    print(&#39;distances&#39;, distances)
    distances = minkowski_distance(inX, dataSet) #计算inX与与dataSet各个点的距离，返回个array
    sortedDistIndicies = distances.argsort()     #返回排序后的元素下标
    classCount = {}

    for i in range(k):
        voteIlabel = labels[sortedDistIndicies[i]] #获得对应的label
        classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1
        # 对classCount根据键值进行排序
        sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)
    return sortedClassCount[0][0]

# 将txt转换为矩阵
def file2matrix2(filename):
    data = np.genfromtxt(filename, dtype=&#39;|U8&#39;)
    returnMat = data[:, 0:-1].astype(&#39;float64&#39;)
    return returnMat, data[:,-1]

# 数据进行规格化处理
def autoNorm(dataSet):
    minVals = dataSet.min(0)
    maxVals = dataSet.max(0)
    ranges = maxVals - minVals
    normDataSet = np.zeros(dataSet.shape)
    m = dataSet.shape[0]
    normDataSet = dataSet - np.tile(minVals, (m, 1))
    normDataSet = normDataSet/np.tile(ranges, (m,1))
    return normDataSet, ranges, minVals

 # 这里使用了scikit-learn中的API,结果与autoNorm是一样的
def autoNorm2(dataSet):
    from sklearn.preprocessing import normalize
    minVals = dataSet.min(0)
    maxVals = dataSet.max(0)
    normDataSet = normalize(dataSet, norm=&#39;max&#39;,axis=0)
    return normDataSet, maxVals-minVals, minVals

# 将txt文件转换为向量
 def img2vec(filename):
     rVec = np.zeros((1,1024))
     f = open(filename)
     for i in range(32):
         line = f.readline()
         for j in range(32):
             rVec[0, 32*i+j] = int(line[j])
    return rVec

# 对手写数字进行测试
def handwritingClassTest():
     hwLabels = []
     trainFileList = os.listdir(&#39;digits/trainingDigits/&#39;)
     m = len(trainFileList)
     trainingMat = np.zeros((m, 1024))
     for i in range(m):
         filename = trainFileList[i]
         className = int(filename.split(&#39;_&#39;)[0])
         hwLabels.append(className)
         trainingMat[i,:] = img2vec(&#39;digits/trainingDigits/%s&#39; % filename)
     testFileList = os.listdir(&#39;digits/testDigits&#39;)
     accuracyCount = 0.0
     mTest = len(testFileList)
     for i in range(mTest):
         filename = testFileList[i]
         className = int(filename.split(&#39;_&#39;)[0])
         vecTest = img2vec(&#39;digits/testDigits/%s&#39; % filename)
         classifierResult = classify0(vecTest, trainingMat, hwLabels, 1)
         if classifierResult == className:
             accuracyCount += 1
     print(&quot;the total accuracy rate is: %f&quot; % (accuracyCount/mTest))
</code></pre><p><a href="https://github.com/hys20151008/ml_python/blob/master/knn.py" target="_blank" rel="noopener">完整代码</a></p>
<hr>
<p>在正式进行数据挖掘之前，尤其是使用基于对象距离的 挖掘算法时，如：神经网络、最近邻分类等，必须 进行数据规格化。也就是将其缩至特定的范围之内，如：[0,10]。如：对于一 个顾客信息数据库中的年龄属性或工资属性，由于工资属性的取值比年龄属性的 取值要大许多，如果不进行规格化处理，基于工资属性的距离计算值显然将远超 过基于年龄属性的距离计算值，这就意味着工资属性的作用在整个数据对象的距 离计算中被错误地放大了。 规格化就是将一个属性取值范围投射到一个特定范围之内，以消除数值型属 性因大小不一而造成挖掘结果的偏差。规划化处理常常用于神经网络、基于距离 计算的最近邻分类和聚类挖掘的数据预处理。 。对于神经网络，采用规格化后的数据不仅有助于确保学习结果的正确性，而且也会帮助提高学习的速度。对于基于距离计算的挖掘，规格化方法可以帮助消除因属性取值范围不同而影响挖掘结果 的公正性。<br> 三种规格化方法： </p>
<p> 1.最大最小规格化方法 该方法对初始数据进行一种线性转换。设$ min<em>{A} $和$ max</em>{A} $为属性A的最小和最大值。最大最小规格化方法将属性A的一个值映射为$ v^{‘} $且有$ v^{‘} \in [new<em>min</em>{A},new<em>max</em>{A}] $,具体映射公式如下： $ v^{‘} = \frac{v-min<em>{A}}{max</em>{A}-min<em>{A}} (new_max</em>{A}-new_min_{A})+new_min_{A} $ </p>
<p>2.零均值规格化方法。该方法是根据属性A的均值和偏差来对A进行规格化。属性A的v值可以通过以下计算公式获得其映射值$ v^{‘} $ $ v^{‘} = \frac{v-\bar A}{\sigma<em>{A}} $<br>其中的$ \bar A $和$ \sigma</em>{A} $分别为属性A的均值和方差。这种规格化方法常用于属性A最大值与最小值未知，或使用最大最小规格化方法时会出现异常数据的情况。 </p>
<p>3.十基数变换规格化方法。 该方法通过移动属性A值的小数位置来达到规格化的目的。把移动的小数位取决于属性a绝对值的最大值。属性A的v值可以通过以下计算公式获得其映射值$ v^{‘} $。 $ v^{‘} = \frac{v}{10^{j}} $ 其中j为使$ \max(|v^{‘}|) \lt 1 $成立的最小值。</p>
<hr>
<p>Ref：<br>1.统计学习方法-李航<br>2.数据挖掘导论<br>3.机器学习实战</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>linux-perf</title>
    <url>/2020/11/21/linux-perf/</url>
    <content><![CDATA[<hr>
<p>参考：<br>1.[<a href="https://perf.wiki.kernel.org/index.php/Main_Page" target="_blank" rel="noopener">https://perf.wiki.kernel.org/index.php/Main_Page</a>]</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>latex公式</title>
    <url>/2018/05/11/latex%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="常见特殊符号"><a href="#常见特殊符号" class="headerlink" title="常见特殊符号"></a>常见特殊符号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>语法</th>
<th>公式</th>
<th>语法</th>
<th>公式</th>
</tr>
</thead>
<tbody>
<tr>
<td>\theta</td>
<td>$ \theta $</td>
<td>\alpha</td>
<td>$ \alpha $</td>
</tr>
<tr>
<td>\beta</td>
<td>$ \beta $</td>
<td>\gamma</td>
<td>$ \gamma $</td>
</tr>
<tr>
<td>\delta</td>
<td>$ \delta $</td>
<td>\epsilon</td>
<td>$ \epsilon $</td>
</tr>
<tr>
<td>\zeta</td>
<td>$ \zeta $</td>
<td>\eta</td>
<td>$ \eta $</td>
</tr>
<tr>
<td>\rho</td>
<td>$ \rho $</td>
<td>\lambda</td>
<td>$ \lambda $</td>
</tr>
<tr>
<td>\mu</td>
<td>$ \mu $</td>
<td>\sigma</td>
<td>$ \sigma $</td>
</tr>
<tr>
<td>\phi</td>
<td>$ \phi $</td>
<td>\chi</td>
<td>$ \chi $</td>
</tr>
<tr>
<td>\psi</td>
<td>$ \psi $</td>
<td>\omega</td>
<td>$ \omega $</td>
</tr>
<tr>
<td>\Theta</td>
<td>$ \Theta $</td>
<td>\Phi</td>
<td>$ \Phi $</td>
</tr>
<tr>
<td>\sim</td>
<td>$ \sim $</td>
<td>\mathcal{P}</td>
<td>$ \mathcal{P} $</td>
</tr>
</tbody>
</table>
</div>
<h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><div class="table-container">
<table>
<thead>
<tr>
<th>语法</th>
<th>公式</th>
<th>语法</th>
<th>公式</th>
</tr>
</thead>
<tbody>
<tr>
<td>x^2</td>
<td>$ x^2 $</td>
<td>x_2</td>
<td>$ x_2 $</td>
</tr>
<tr>
<td>x_{i,j}</td>
<td>$ x_{i,j} $</td>
<td>x_2^3</td>
<td>$ x_2^3 $</td>
</tr>
<tr>
<td>{}_1^2!X_3^4</td>
<td>$ {}_1^2!X_3^4 $</td>
<td>x^{2+2}</td>
<td>$ x^{2+2} $</td>
</tr>
<tr>
<td>\hat{\gamma}</td>
<td>$ \hat{\gamma} $</td>
</tr>
</tbody>
</table>
</div>
<h3 id="导数，积分"><a href="#导数，积分" class="headerlink" title="导数，积分"></a>导数，积分</h3><div class="table-container">
<table>
<thead>
<tr>
<th>语法</th>
<th>公式</th>
<th>语法</th>
<th>公式</th>
</tr>
</thead>
<tbody>
<tr>
<td>x’</td>
<td>$ x’ $</td>
<td>x^\prime</td>
<td>$ x^\prime $</td>
</tr>
<tr>
<td>\dot{x}</td>
<td>$ \dot{x} $</td>
<td>\ddot{x}</td>
<td>$ \ddot{y} $</td>
</tr>
<tr>
<td>\vec{c}</td>
<td>$ \vec{c} $</td>
<td>\overleftarrow{a b}</td>
<td>$ \overleftarrow{a } $</td>
</tr>
<tr>
<td>\sum_{k=1}^N k^2</td>
<td>$ \sum_{k=1}^N k^2 $</td>
<td>\prod_{i=1}^N x_i</td>
<td>$ \prod_{i=1}^N x_i $</td>
</tr>
<tr>
<td>\lim_{n \to \infty}x_n</td>
<td>$ \lim_{n \to \infty}x_n $</td>
<td>\int_{-N}^{N} e^x\, dx</td>
<td>$ \int_{-N}^{N} e^x\, dx $</td>
</tr>
</tbody>
</table>
</div>
<h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>语法</th>
<th>公式</th>
<th>语法</th>
<th>公式</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>|\frac{1}{2}| $ \frac{1}{2} $ |</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/05/latex.png" alt="image"></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>linux-xxd</title>
    <url>/2020/11/21/linux-xxd/</url>
    <content><![CDATA[<p><code>xxd</code>是<code>Linux</code>平台下的一款工具，可以用于<code>原文件</code>和<code>二进制文件</code>之间的互相转换。<br><code>man page</code>描述：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxd  creates a hex dump of a given file or standard input.  It can also</span><br><span class="line">convert a hex dump back to its original binary form.  Like  uuencode(1)</span><br><span class="line">and  uudecode(1)  it allows the transmission of binary data in a `mail-</span><br><span class="line">safe&apos; ASCII representation, but has the advantage of decoding to  stan‐</span><br><span class="line">dard output.  Moreover, it can be used to perform binary file patching</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>xxd</code>常用方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  ~ echo <span class="string">'hello,world'</span> &gt; origin.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件内容转换为十六进制内容</span></span><br><span class="line">➜  ~ xxd origin.txt</span><br><span class="line"><span class="number">00000000</span>: <span class="number">6865</span> <span class="number">6</span>c6c <span class="number">6</span>f2c <span class="number">776</span>f <span class="number">726</span>c <span class="number">640</span>a            hello,world.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将十六进制内容恢复到一个新文件中</span></span><br><span class="line">➜  ~ xxd origin.txt |xxd -r &gt; new.text</span><br><span class="line">➜  ~ cat new.text </span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure>
<p>xxd还支持将文件转换成二进制，格式化输出等。具体可查看官方文档</p>
<hr>
<p>参考:<br>1.<a href="https://linux.die.net/man/1/xxd" target="_blank" rel="noopener">linux-man-page-xxd</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中有关网络相关参数的设置</title>
    <url>/2019/06/01/linux%E4%B8%AD%E6%9C%89%E5%85%B3%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>在<code>/etc/sysctl.conf</code>文件下存放着一些系统级别的参数，可以通过修改这个文件修改系统参数，当然也包括网络，比如<code>TCP</code>协议的相关设置。 修改完文件后，执行<code>sysctl -p</code>可使修改内容生效。 执行<code>sysctl -a</code>查看当前系统中生效的所有参数。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/sysctl_a.png" alt> Linux常用网络内核参数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>net.core.rmem_default</td>
<td>默认的 TCP 数据接收窗口大小（字节）</td>
</tr>
<tr>
<td>net.core.rmem_max</td>
<td>最大的 TCP 数据接收窗口（字节）</td>
</tr>
<tr>
<td>net.core.wmem_default</td>
<td>默认的 TCP 数据发送窗口大小（字节）</td>
</tr>
<tr>
<td>net.core.wmem_max</td>
<td>最大的 TCP 数据发送窗口（字节）</td>
</tr>
<tr>
<td>net.core.netdev_max_backlog</td>
<td>在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目</td>
</tr>
<tr>
<td>net.core.somaxconn</td>
<td>定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数</td>
</tr>
<tr>
<td>net.core.optmem_max</td>
<td>表示每个套接字所允许的最大缓冲区的大小</td>
</tr>
<tr>
<td>net.ipv4.tcp_mem</td>
<td>确定 TCP 栈应该如何反映内存使用，每个值的单位都是内存页（通常是 4KB）  第一个值是内存使用的下限；第二个值是内存压力模式开始对缓冲区使用应用压力的上限；第三个值是内存使用的上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的 BDP 可以增大这些值（注意：其单位是内存页而不是字节）</td>
</tr>
<tr>
<td>net.ipv4.tcp_rmem</td>
<td>为自动调优定义 socket 使用的内存。第一个值是为 socket 接收缓冲区分配的最少字节数；第二个值是默认值（该值会被 rmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是接收缓冲区空间的最大字节数（该值会被 rmem_max 覆盖）</td>
</tr>
<tr>
<td>net.ipv4.tcp_wmem</td>
<td>为自动调优定义 socket 使用的内存。第一个值是为 socket 发送缓冲区分配的最少字节数；第二个值是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）</td>
</tr>
<tr>
<td>net.ipv4.tcp_keepalive_time</td>
<td>TCP 发送 keepalive 探测消息的间隔时间（秒），用于确认 TCP 连接是否有效</td>
</tr>
<tr>
<td>net.ipv4.tcp_keepalive_intvl</td>
<td>探测消息未获得响应时，重发该消息的间隔时间（秒）</td>
</tr>
<tr>
<td>net.ipv4.tcp_keepalive_probes</td>
<td>在认定 TCP 连接失效之前，最多发送多少个 keepalive 探测消息</td>
</tr>
<tr>
<td>net.ipv4.tcp_sack</td>
<td>启用有选择的应答（1 表示启用），通过有选择地应答乱序接收到的报文来提高性能，让发送者只发送丢失的报文段，（对于广域网通信来说）这个选项应该启用，但是会增加对 CPU 的占用</td>
</tr>
<tr>
<td>net.ipv4.tcp_fack</td>
<td>启用转发应答，可以进行有选择应答（SACK）从而减少拥塞情况的发生，这个选项也应该启用</td>
</tr>
<tr>
<td>net.ipv4.tcp_timestamps</td>
<td>TCP 时间戳（会在 TCP 包头增加 12 B），以一种比重发超时更精确的方法（Ref RFC 1323）来启用对 RTT 的计算，为实现更好的性能应该启用这个选项</td>
</tr>
<tr>
<td>net.ipv4.tcp_window_scaling</td>
<td>启用 RFC 1323 定义的 window scaling，要支持超过 64KB 的 TCP 窗口，必须启用该值（1 表示启用），TCP 窗口最大至 1GB，TCP 连接双方都启用时才生效</td>
</tr>
<tr>
<td>net.ipv4.tcp_syncookies</td>
<td>表示是否打开 TCP 同步标签（syncookie），内核必须打开了 CONFIG_SYN_COOKIES 项进行编译，同步标签可以防止一个套接字在有过多试图连接到达时引起过载。默认值 0 表示关闭</td>
</tr>
<tr>
<td>net.ipv4.tcp_tw_reuse</td>
<td>表示是否允许将处于 TIME-WAIT 状态的 socket （TIME-WAIT 的端口）用于新的 TCP 连接</td>
</tr>
<tr>
<td>net.ipv4.tcp_tw_recycle</td>
<td>能够更快地回收 TIME-WAIT 套接字</td>
</tr>
<tr>
<td>net.ipv4.tcp_fin_timeout</td>
<td>对于本端断开的 socket 连接，TCP 保持在 FIN-WAIT-2 状态的时间（秒）。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。</td>
</tr>
<tr>
<td>net.ipv4.ip_local_port_range</td>
<td>表示 TCP/UDP 协议允许使用的本地端口号</td>
</tr>
<tr>
<td>net.ipv4.tcp_max_syn_backlog</td>
<td>对于还未获得对方确认的连接请求，可保存在队列中的最大数目。如果服务器经常出现过载，可以尝试增加这个数字。默认为 1024</td>
</tr>
<tr>
<td>net.ipv4.tcp_low_latency</td>
<td>允许 TCP/IP 栈适应在高吞吐量情况下低延时的情况，这个选项应该禁用</td>
</tr>
<tr>
<td>net.ipv4.tcp_westwood</td>
<td>启用发送者端的拥塞控制算法，它可以维护对吞吐量的评估，并试图对带宽的整体利用情况进行优化，对于 WAN 通信来说应该启用这个选项</td>
</tr>
<tr>
<td>net.ipv4.tcp_bic</td>
<td>为快速长距离网络启用 Binary Increase Congestion，这样可以更好地利用以 GB 速度进行操作的链接，对于 WAN 通信应该启用这个选项</td>
</tr>
<tr>
<td>net.ipv4.tcp_max_tw_buckets</td>
<td>该参数设置系统的 TIME_WAIT 的数量，如果超过默认值则会被立即清除。默认为 180000</td>
</tr>
<tr>
<td>net.ipv4.tcp_synack_retries</td>
<td>指明了处于 SYN_RECV 状态时重传 SYN+ACK 包的次数</td>
</tr>
<tr>
<td>net.ipv4.tcp_abort_on_overflow</td>
<td>设置改参数为 1 时，当系统在短时间内收到了大量的请求，而相关的应用程序未能处理时，就会发送 Reset 包直接终止这些链接。建议通过优化应用程序的效率来提高处理能力，而不是简单地 Reset。默认值： 0</td>
</tr>
<tr>
<td>net.ipv4.route.max_size</td>
<td>内核所允许的最大路由数目</td>
</tr>
<tr>
<td>net.ipv4.ip_forward</td>
<td>接口间转发报文</td>
</tr>
<tr>
<td>net.ipv4.ip_default_ttl</td>
<td>报文可以经过的最大跳数</td>
</tr>
<tr>
<td>net.netfilter.nf_conntrack_tcp_timeout_established</td>
<td>让 iptables 对于已建立的连接，在设置时间内若没有活动，那么则清除掉</td>
</tr>
<tr>
<td>net.netfilter.nf_conntrack_max</td>
<td>哈希表项最大值</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>Ref：<br>1.<a href="https://help.aliyun.com/knowledge_detail/41334.html" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/41334.html</a><br>2.<a href="https://www.ibm.com/support/knowledgecenter/en/linuxonibm/liaag/wkvm/wkvm_c_tune_tcpip.htm" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/en/linuxonibm/liaag/wkvm/wkvm_c_tune_tcpip.htm</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令strace</title>
    <url>/2019/03/30/linux%E5%91%BD%E4%BB%A4strace/</url>
    <content><![CDATA[<p><code>strace</code>是Linux/Unix下的一款可以追踪系统调用的工具。 1.安装<code>strace</code></p>
<pre><code>apt-get install strace           # ubuntu
yum install strace               # centos
</code></pre><h4 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2.使用示例"></a>2.使用示例</h4><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/03/strace.png" alt></p>
<h4 id="3-strace-p"><a href="#3-strace-p" class="headerlink" title="3.strace -p"></a>3.strace -p</h4><pre><code>strace -p pid     # 根据进程id,追踪此进程系统调用 
</code></pre><h5 id="查看nginx-worker-process进程的系统调用"><a href="#查看nginx-worker-process进程的系统调用" class="headerlink" title="查看nginx: worker process进程的系统调用"></a>查看nginx: worker process进程的系统调用</h5><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/03/strace_p.png" alt></p>
<h4 id="4-strace-c"><a href="#4-strace-c" class="headerlink" title="4.strace -c"></a>4.strace -c</h4><h5 id="统计时间，调用数，错误"><a href="#统计时间，调用数，错误" class="headerlink" title="统计时间，调用数，错误"></a>统计时间，调用数，错误</h5><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/03/strace_c.png" alt></p>
<h4 id="5-strace-e-type-expr"><a href="#5-strace-e-type-expr" class="headerlink" title="5.strace -e type=expr"></a>5.strace -e type=expr</h4><p>expr = set, file, process, network, signal,ipc, desc,memory <img src="http://img.hysyeah.top/wp-content/uploads/2019/03/strace_type.png" alt></p>
<h5 id="指定追踪系统调用类型"><a href="#指定追踪系统调用类型" class="headerlink" title="指定追踪系统调用类型"></a>指定追踪系统调用类型</h5><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/03/strace_e.png" alt></p>
<h4 id="6-strace-o-out-txt"><a href="#6-strace-o-out-txt" class="headerlink" title="6.strace -o out.txt"></a>6.strace -o out.txt</h4><h5 id="将输出重定向一-个文件"><a href="#将输出重定向一-个文件" class="headerlink" title="将输出重定向一 个文件"></a>将输出重定向一 个文件</h5><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/03/strace_o.png" alt></p>
<h4 id="7-strace-i"><a href="#7-strace-i" class="headerlink" title="7.strace -i"></a>7.strace -i</h4><h5 id="输出系统调用的指针地址"><a href="#输出系统调用的指针地址" class="headerlink" title="输出系统调用的指针地址"></a>输出系统调用的指针地址</h5><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/03/strace_i.png" alt></p>
<h4 id="8-详细参数可通过下面命令查看"><a href="#8-详细参数可通过下面命令查看" class="headerlink" title="8.详细参数可通过下面命令查看"></a>8.详细参数可通过下面命令查看</h4><pre><code>man strace
</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>lua -e</title>
    <url>/2017/09/22/lua-e/</url>
    <content><![CDATA[<pre><code>lua -e &quot;print(&quot;hello&quot;)&quot; --ouput nil

lua -e &quot;print(&quot;1&quot;)&quot; -- output 1
</code></pre><p>为什么lua -e “print(“hello”)”输出来nil, 而不是hello,这与shell的解析机制有关。 lua -e “print(“hello”)”相当于lua -e “print(hello)”(“print” + hello + “)”)，而hello未定义所以输出nil。 可以通过单引号禁止shell解析，或者使用转义符，</p>
<pre><code>lua -e &#39;print(&quot;hello&quot;)&#39; -- output: hello
lua -e &quot;print(\&quot;hello\&quot;)&quot; -- output: hello
</code></pre>]]></content>
      <categories>
        <category>LUA</category>
      </categories>
  </entry>
  <entry>
    <title>lua变量类型</title>
    <url>/2017/09/27/lua%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>lua是动态语言，变量不需要定义。lua中有8个基本类型：nil, bollean, number, string, userdata, thread和table.</p>
<pre><code>Lua 5.3.4  Copyright (C) 1994-2017 Lua.org, PUC-Rio
&gt; print(type(&quot;hello, lua&quot;))
string
&gt; print(type(10))
number
&gt; print(type(print))
function
&gt; print(type(true))
boolean
&gt; print(type(nil))
nil
</code></pre><p>1.nil nil是lua中的特殊值，它只有一个值;变量未赋值前值为nil,可以通过给变量赋值为nil,删除变量 2.Booleans Booleans类型有两个值：false和true。Lua中所有的值都可以做为判断条件。在控制结构中的条件判断中除了false和nil为假，其它值都为真，也就是说Lua中0和空字符串也是真。 3.Numbers Numbers表示实数，Lua中没有整数。 4.Strings 字符串，Lua中字符串是不可修改的。Lua自动进行内存分配和释放，一个string可以只包含一个字母也可以包含一本书，Lua可以高效的处理长字符串，1M的string在Lua中是很常见的。可以使用单引号或者双引号表示字符串。</p>
<pre><code>&gt; a = &quot;one string&quot;
&gt; b = string.gsub(a, &quot;one&quot;, &quot;another&quot;)
&gt; print(a)
one string
&gt; print(b)
another string
</code></pre><p>可以使用[[…]]表示字符串，这种 形式的字符串可以包括多行，可以嵌套且不会解释转义序列。 Lua会自动在string和numbers 之间自动进行类型转换，当一个字符串使用算术操作符时，string就会被转成数字。</p>
<pre><code>&gt; print(&quot;10&quot;+1)
11.0

&gt; print(&quot;10+1&quot;)
10+1
</code></pre><p>当Lua期望一个string而碰到数字时，会将数字转成string。如进行字符拼接时</p>
<pre><code>&gt; print(10 .. 20)
1020
&gt; 10 == &quot;10&quot;
false
</code></pre><p>5.Functions(函数) 函数是第一类值（和其他变量相同），意味着函数可以存储在变量中，可以作为函数的参数，也可以作为函数的返回值。</p>
]]></content>
      <categories>
        <category>LUA</category>
      </categories>
  </entry>
  <entry>
    <title>lua求阶乘发生溢出</title>
    <url>/2017/09/21/lua%E6%B1%82%E9%98%B6%E4%B9%98%E5%8F%91%E7%94%9F%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<pre><code>function fact(n)
  if n == 0 then
    return 1
  end
  return n * fact(n-1)
end

for i=1, 100, 1 do
  print(i,fact(i)) --发生溢出
end
</code></pre><ul>
<li><p>通过使用lua的’bn’库可以解决这问题，从<a href="http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/#lbn" target="_blank" rel="noopener">lbn</a>下载lbn.tar.gz，</p>
<p>tar -xzvf lbn.tar.gz<br>cd bn</p>
</li>
</ul>
<ul>
<li>修改Makefile如下</li>
</ul>
<p><img src="http://img.hysyeah.top/wp-content/uploads/2017/09/和-1.png" alt="image"></p>
<pre><code>make
</code></pre><ul>
<li><p>在当前目录下会生成一个bn.so文件，将bn.so拷贝到代码文件所在目录，或者通过LUA_CPATH指定require搜索路径</p>
<p>local bn = require “bn”</p>
<p>function bn_fact(bn.number(n))<br>  if n:tonumber() == 0 then return 1 end<br>  return n * bn_fact(n-1)<br>end</p>
<p>function fact(n)<br>  return bn_fact(bn.number(n))<br>end</p>
<p>for i=1,100,1 do</p>
<pre><code>print(i,fact(i)) -- 未发生溢出
</code></pre><p>end</p>
</li>
</ul>
<p>Ref： 1.<a href="https://stackoverflow.com/questions/46317930/why-lua-and-python-factorial-output-was-different" target="_blank" rel="noopener">stackoverflow</a> 2.<a href="http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/install.html" target="_blank" rel="noopener">http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/install.html</a></p>
]]></content>
      <categories>
        <category>LUA</category>
      </categories>
  </entry>
  <entry>
    <title>linux命令tcpdump与tcp zero window</title>
    <url>/2019/06/01/linux%E5%91%BD%E4%BB%A4tcpdump%E4%B8%8Etcp%20zero%20window/</url>
    <content><![CDATA[<pre><code>example:
tcpdump -i ens250 port 34495 -w t.pcap
# -i: 指定监听网卡
# port: 指定监听端口
# -w file: 将数据保存在外部文件中，以.pcap结尾的文件可以通过wireshark打开
</code></pre><p>常用选项：</p>
<pre><code>-c count                  # 捕获count个packet后退出
</code></pre><hr>
<h5 id="tcp-zero-window"><a href="#tcp-zero-window" class="headerlink" title="tcp zero window"></a>tcp zero window</h5><p><code>TCP Window size</code>是指机器在一个<code>TCP</code>session中可以接收多大的数据量。类似于<code>TCP</code>中的接收缓冲，当客户端和服务端建立连接时，客户端会通过<code>Window Size</code>告诉服务端可以接收多少数据。 当建立TCP连接后，服务端开始向客户端发送数据，客户端会减少<code>Window Size</code>当接收的数据存在于缓冲中时，同时客户端会在缓冲中处理数据，清空缓冲以便接收更多的数据。通过<code>TCP ACK frames</code>客户端会告诉服务端还可以接收多大的数据。当<code>TCP Window Size</code>等于0时，我们称为零窗口，此时客户端不能再接收数据，直到缓冲中的数据被清空。</p>
<p>wireshark提示的[TCP window Full]和[TCP zero windwo]意义不同,前者表示这个包的发送方意识到”在途字节数”已经达到对方所声明的窗口,不能再发了;而后者表示这个包的发送意识到自民 的缓存区已经满了,无法接收更多数据。</p>
<hr>
<p>Ref： 1.<a href="https://wiki.wireshark.org/TCP%20ZeroWindow" target="_blank" rel="noopener">https://wiki.wireshark.org/TCP%20ZeroWindow</a></p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>lua表达式</title>
    <url>/2017/10/09/lua%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>1.关系运算符</p>
<pre><code>&lt;  &gt;  &lt;=  &gt;= ==  ~=  
</code></pre><p>这些操作符返回结果为false或true.==和~=比较两个值，lua是强类型比较，如果两个值类型不同，Lua认为两者不同。 Lua通过引用比较tables、userdata、functions，只有当两者是同一对象时才相等。</p>
<pre><code> &gt; a = {x=1,y=0}
 &gt; b = {x=1,y=0}
 &gt; c == a
 false
 &gt; c = a
 &gt; a == c
 true
 &gt; a == b
 false
</code></pre><p>数字、字符串的比较</p>
<pre><code>&gt; 0 == &quot;0&quot;
false
&gt; 2 &lt; 15
true
&gt; &quot;2&quot; &lt; &quot;15&quot;  --按字母顺序进行比较
false
</code></pre><p>2.逻辑运算符</p>
<pre><code>and  or not
</code></pre><p>逻辑运算符认为false和nil是假，其他为真（true),0也是true。</p>
<pre><code>a and b -- 如果a为false,则返回a,否则返回b
a or b  --如果a为true,则返回a,否则返回b
&gt; print(1 and 2)
2
&gt; print(nil and 1)
nil
&gt; print(1 or 2)
1
&gt; print(false or 1)
1
</code></pre><p>例：</p>
<pre><code>x = x or v
</code></pre><p>等价于：</p>
<pre><code>if not x then
   x = v
end
</code></pre><p>C语言中的三元运算符</p>
<pre><code>a ? b:c
</code></pre><p>在Lua中可以这样实现:</p>
<pre><code>(a and b) or c
</code></pre><p>not 结果只返回false或者true</p>
<pre><code>&gt; print(not 0)
false
</code></pre><p>3.连接运算符</p>
<pre><code>.. --两个点
</code></pre><p>字符串连接，如果操作数为数字，Lua将数字转成字符串</p>
<pre><code>&gt; print(&quot;Hello &quot; .. &quot;World&quot;)
Hello World
&gt; print(0 .. 1)
01
</code></pre>]]></content>
      <categories>
        <category>LUA</category>
      </categories>
  </entry>
  <entry>
    <title>matplotlib.pyplot添加中文显示</title>
    <url>/2018/01/14/matplotlib.pyplot%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<pre><code>1.从C:\Windows\Fonts复制微软雅黑字体到/usr/local/lib/python3.5/dist-packages/matplotlib/mpl-data/fonts/ttf

然后将名称修改为
sudo mv MSYHBD.TTF MSYHBD.ttf
sudo mv MSYH.TTF MSYH.ttf

2.获取配置文件信息，修改文件
In [1]: import matplotlib

In [2]: matplotlib.matplotlib_fname()
Out[2]: &#39;/usr/local/lib/python3.5/dist-packages/matplotlib/mpl-data/matplotlibrc&#39;

font.family         : Microsoft YaHei
font.sans-serif     : DejaVu Sans, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif, Microsoft YaHei

3.删除~/.cache/matplotlib下文件fontList.py3k.cache,重启终端。
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/01/matplotlibrc.png" alt="image"></p>
]]></content>
      <categories>
        <category>pyplot</category>
      </categories>
  </entry>
  <entry>
    <title>matplotlib subplot</title>
    <url>/2018/05/16/matplotlib-subplot/</url>
    <content><![CDATA[<p><img src="http://img.hysyeah.top/wp-content/uploads/2018/05/subplot.png" alt="image"></p>
<h4 id="这两种方式是等价的"><a href="#这两种方式是等价的" class="headerlink" title="这两种方式是等价的"></a>这两种方式是等价的</h4>]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>matplotlib改变坐标轴位置</title>
    <url>/2018/06/29/matplotlib%E6%94%B9%E5%8F%98%E5%9D%90%E6%A0%87%E8%BD%B4%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/ax_right.png" alt></p>
<h4 id="ax-spines-‘top’-set-color-‘none’-隐藏上方的直线"><a href="#ax-spines-‘top’-set-color-‘none’-隐藏上方的直线" class="headerlink" title="ax.spines[‘top’].set_color(‘none’)隐藏上方的直线"></a>ax.spines[‘top’].set_color(‘none’)隐藏上方的直线</h4><hr>
<h4 id="通过set-position方法设置坐标轴的位置"><a href="#通过set-position方法设置坐标轴的位置" class="headerlink" title="通过set_position方法设置坐标轴的位置"></a>通过set_position方法设置坐标轴的位置</h4><p>默认的设置为(‘outward’,0)。<br>(‘axes’,0.0~1.0)，若数值=0.5表示把坐标轴放在整个坐标长度的中间位置(根据比例) (‘data’,xx)，根据实际数值指定坐标轴位置</p>
<hr>
<h3 id="下面将x-y轴移动至中间，画函数y-x的图像"><a href="#下面将x-y轴移动至中间，画函数y-x的图像" class="headerlink" title="下面将x,y轴移动至中间，画函数y=x的图像"></a>下面将x,y轴移动至中间，画函数y=x的图像</h3><pre><code># -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt


fig, ax = plt.subplots()

ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)
ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)
ax.spines[&#39;left&#39;].set_position((&#39;axes&#39;, 0.5))
ax.spines[&#39;bottom&#39;].set_position((&#39;axes&#39;, 0.5))

x = np.linspace(-5, 5, 1000)

ax.plot(x, x)
ax.text(-4, 4, &#39;y=x&#39;, color=&#39;r&#39;)
ax.set_xlabel(&#39;x&#39;, horizontalalignment=&#39;right&#39;, x=1.0)
ax.set_ylabel(&#39;y&#39;, horizontalalignment=&#39;right&#39;, y=1.0, rotation=0)
plt.show()
</code></pre><p><a href="https://github.com/hys20151008/7788/blob/master/fx.py" target="_blank" rel="noopener">代码</a> <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/fx.png" alt></p>
<hr>
<p>Ref： 1.<a href="https://matplotlib.org/api/spines_api.html#matplotlib.spines.Spine.set_position" target="_blank" rel="noopener">matplotlib文档</a></p>
]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>matplotlib.pyplot相关函数</title>
    <url>/2017/11/28/matplotlib.pyplot%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<pre><code>import matplotlib.pyplot as plt

plt.title(s, *args, **kwargs) #标题

plt.xlabel(s, *args, **kwargs) #x轴标题

plt.ylabel(s,  *args, **kwargs) #y轴标题

plt.autoscale() #自动适应

plt.xlim(0, 100) #设置x轴坐标 范围

plt.legend() #左上角或右上角上的说明
plt.grid(True,linestyle=&#39;-&#39;, color=&#39;0.75&#39;) #网格
plt.xticks(locs, [label]) #Set locations and labels
plt.axis([xmin, xmax, ymin, ymax]) #设置x,y轴的最小最大坐标值

matplotlib.pyplot.subplot(*args, **kwargs)
返回一个子图坐标系
subplot(nrows, ncols, plot_number)
subplot(211)

subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None, **fig_kw)
创建个图表和一系列子图
return
fig
ax:坐标对象


plt.imshow(X, cmap=&#39;Greys&#39;) #展示关于X的图像，X可以是矩阵或PIL Image
plt.matshow()               #将矩阵以图像的形式展示出来
</code></pre>]]></content>
      <categories>
        <category>pyplot</category>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>mysql shell 批量恢复</title>
    <url>/2019/03/20/mysql%20shell%20%E6%89%B9%E9%87%8F%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p>有多个mysql的数据文件在文件夹在tmp文件夹下</p>
<pre><code>ls /root/tmp
network.dump igw.dump vpn.dump vpc.dump
</code></pre><p>编写shell恢复数据</p>
<pre><code>#!/root/tmp
for elt in $(ls *.dump)
do
  echo &quot;restore database $elt&quot;
  mysql -uroot -pxxxxx ${elt%%.*} &lt; $elt
done
</code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>mysql-UNION与UNION ALL</title>
    <url>/2017/09/19/mysql-union-e4-b8-8eunion-all/</url>
    <content><![CDATA[<pre><code>SELECT ...
UNION [ALL | DISTINCT] SELECT ...
[UNION [ALL | DISTINCT] SELECT ...]
</code></pre><p>UNION用于将多个SELECT语句的结果整合并放在一个表中,并消除重复的行，UNION ALL并不会消除重复的行</p>
<pre><code>mysql&gt;&gt; select 1 union select 2 union select 2;
+---+
| 1 |
+---+
| 1 |
| 2 |
+---+
2 rows in set (0.01 sec)

mysql&gt;&gt; select 1 union select 2 union all select 2;
+---+
| 1 |
+---+
| 1 |
| 2 |
| 2 |
+---+
3 rows in set (0.00 sec)
</code></pre><p>第一个SELECT语句中的列名将会作为整个结果集的列名。SELECT中对应的列应具有相同的数据类型。 在UNION中使用SELECT有以下的限制 - 只有最后一个SELECT语句才可以使用INTO OUTFILE - 不能使用HIGH_PRIORITY 除非确定需要服务器消除重复的行，否则就一定要使用UNION ALL，如果没有ALL关键字，MYSQL会给临时表加上 DISTINCT选项，这会导致对整个临时表的数据做唯一性检查。即使有ALL关键字，MYSQL仍然会使用临时表存储 结果。MYSQL总是将结果入入临时表，然后再读出，再返回客户端。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>mysql一些语句</title>
    <url>/2017/10/28/mysql%E4%B8%80%E4%BA%9B%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h3 id="获取一张表的所有字段名"><a href="#获取一张表的所有字段名" class="headerlink" title="获取一张表的所有字段名"></a>获取一张表的所有字段名</h3><pre><code>select COLUMN_NAME from information_schema.columns where table_name=&#39;TableName&#39;
</code></pre><h3 id="对一个数据库进行赋权"><a href="#对一个数据库进行赋权" class="headerlink" title="对一个数据库进行赋权"></a>对一个数据库进行赋权</h3><pre><code>grant all privileges on database.* to username@ip identified by &#39;passwd&#39;
flush privileges
</code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>mysqldump</title>
    <url>/2019/04/12/mysqldump/</url>
    <content><![CDATA[<p><code>mysqldump</code>是<code>mysql</code>提供的用于数据备份的工具，通过再次执行<code>SQL</code>语句以达到恢复数据的目的（生产环境慎用)。<code>mysqldump</code>的优势在于方便和在恢复之前可以查看dump文件甚至修改文件内容。通常用于开发测试，及数据量比较小的情况下，当数据量大的情况下可能dump所花费的时间的时间是可以接受的，但恢复的时候会消耗大量的磁盘I/O。 1.<code>mysqldump</code>所需的权限 <code>mysqldump</code>所需要的权限跟其所dump的对象有关，若备份表则需要<code>SELECT</code>权限，若备份视图，则需要<code>SHOW VIEW</code>权限，若备份触发器，则需要<code>TRIGGER</code>权限。 2.锁表问题 <code>mysqldump</code>默认会锁住需要dump的表 3.<code>mysqldump</code>常用参数</p>
<pre><code>mysqldump [options] &gt; dump.sql
</code></pre><h4 id="—options"><a href="#—options" class="headerlink" title="—options"></a>—options</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Format</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>—all-databases</td>
<td>备份所有数据库</td>
</tr>
<tr>
<td>—databases</td>
<td>指定所需备份的数据库</td>
</tr>
<tr>
<td>—no-data</td>
<td>不备份数据</td>
</tr>
<tr>
<td>—user</td>
<td>用户名</td>
</tr>
<tr>
<td>—host</td>
<td>IP或主机名</td>
</tr>
<tr>
<td>—port</td>
<td>端口</td>
</tr>
<tr>
<td>—lock-all-table</td>
<td>锁住需要dump数据库的所有表，会使选项—lock-tables和—single-transaction关闭</td>
</tr>
<tr>
<td>—lock-tables</td>
<td>会锁住每个数据库中需要dump的表</td>
</tr>
<tr>
<td>—password</td>
<td>密码</td>
</tr>
<tr>
<td>—single-transaction</td>
<td>只适用于InnoDB引擎，当执行dump命令时，客户端会发一条START TRANSACTION的语句给server,会dump事务开始时的数据库状态，不会锁表，所以不会对应用造成影响</td>
</tr>
<tr>
<td>—quick</td>
<td>一行一行进行dump，不会将数据缓存在内存中，每次都需要写文件，速度会变慢</td>
</tr>
<tr>
<td>—skip-quick</td>
<td>先将数据缓存在内存中，再一次写到文件中，速度较快，但不适用的大表</td>
</tr>
<tr>
<td>—tables</td>
<td>指定表,会覆盖—databases选项</td>
</tr>
</tbody>
</table>
</div>
<p>详细参数<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html" target="_blank" rel="noopener">请参考</a><br>4.示例</p>
<pre><code># dump
mysqldump -hlocalhost -uroot -pxxxx --databases  test --tables table_a table_b &gt; test.sql

# restore
mysql -uroot -pxxxx test &lt; test.sql
</code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql之cascade delete</title>
    <url>/2019/03/09/mysql%E4%B9%8Bcascade%20delete/</url>
    <content><![CDATA[<p><code>ON DELETE CASCADE</code>表示如果父表中记录删除，则子表中引用了父表记录的行都会被删除。</p>
<pre><code># 新建表
CREATE TABLE a (
id int not null,
name varchar(20),
primary key(id)
);

CREATE TABLE b (
id int not null,
a_id int not null,
CONSTRAINT `fk_a__id` FOREIGN KEY (`a_id`) REFERENCES `a` (`id`) ON DELETE CASCADE
);
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/03/cascade.png" alt> 当设置<code>SET GLOBAL FOREIGN_KEY_CHECKS=0;(下次登录生效)</code>时，级联删除并不会生效。 当我们使用语句<code>delete from a</code>时，mysql会将b表中的数据也会删除，那删除b表中的数据这一操作会不会记在binlog中呢？？ 经过验证不管设置何种<code>binlog_format</code>b表中的数据变化并不会记录在日志文件中。级联操作是根据存储引擎通过外键关系来进行操作的，并不会体现在日志文件中。mysql文档中有详细的<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-and-mysql-replication.html" target="_blank" rel="noopener">解释</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>mysql之binlog-format</title>
    <url>/2019/03/09/mysql%E4%B9%8Bbinlog-format/</url>
    <content><![CDATA[<p><code>mysql</code>支持3种日志记录格式，<code>STATEMENT</code>,<code>ROW</code>,<code>MIXED</code> 可在启动时通过<code>--binlog_format=type</code>指定。</p>
<ul>
<li><code>STATEMENT</code>:也被称作logical logging,记录<code>mysql</code>执行的语句</li>
<li><code>ROW</code>:也被称作physical logging,记录每行数据的变化</li>
<li><p><code>MIXED</code>:即<code>STATEMENT</code>和<code>ROW</code>的混合形式，<code>mysql</code>会根据场景决定使用哪种日志格式</p>
<h1 id="查看目前使用的日志格式"><a href="#查看目前使用的日志格式" class="headerlink" title="查看目前使用的日志格式"></a>查看目前使用的日志格式</h1><p>show variables like ‘binlog_format’;</p>
<h1 id="设置全局binlog-format，重新登录后生效"><a href="#设置全局binlog-format，重新登录后生效" class="headerlink" title="设置全局binlog_format，重新登录后生效"></a>设置全局binlog_format，重新登录后生效</h1><p>SET GLOBAL binlog_format = ‘STATEMENT’;<br>SET GLOBAL binlog_format = ‘ROW’;<br>SET GLOBAL binlog_format = ‘MIXED’;</p>
<h1 id="设置会话级别的binlog-format"><a href="#设置会话级别的binlog-format" class="headerlink" title="设置会话级别的binlog_format"></a>设置会话级别的binlog_format</h1><p>SET SESSION binlog_format = ‘STATEMENT’;<br>SET SESSION binlog_format = ‘ROW’;<br>SET SESSION binlog_format = ‘MIXED’;</p>
</li>
</ul>
<p>设置会话级别binlog_format的几种情况： - 假如对数据库做了比较小的改动，可能会把binlog_format设置为<code>ROW</code> - 假如一次会话中在一条语句中更新了多行记录，此时使用<code>STATEMENT</code>可能会更高效 - 有些语句可能执行需要的时间比较长，但结果只是几行数据被修改，这种情况也可以将binlog_format改为<code>ROW</code> 但一般不建议在运行时改变binlog_format,下面几种不建议改变binlog_format - 如果使用<code>NDB</code>存储引擎 - 如果当前使用的是row-base replication而且存在临时表 当存在任何临时表时都不应该在运行时改变<code>binlog_format</code>,因为只有在<code>STATEMENT</code>的情况下日志才会记录临时的信息，而在<code>ROW</code>的格式下是不会记录的。在<code>MIXED</code>的模式下临时表通常也会记录。 每个mysql实例都可以设置自己的<code>binlog_format</code>，每个实例会以自己的<code>binlog_format</code>方式去解析日志文件，如果主从复制的架构中，master修改了<code>binlog_format</code>而slave没有修改，则会报错。为会确保改变<code>binlog_format</code>安全，需要停止复制并确保各个实例使用的是同一种日志格式。</p>
<hr>
<p>Ref： 1.<a href="https://dev.mysql.com/doc/refman/5.7/en/binary-log-setting.html" target="_blank" rel="noopener">MYSQL Binary Log Format</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>mysql之flush privileges</title>
    <url>/2019/02/19/mysql%E4%B9%8Bflush%20privileges/</url>
    <content><![CDATA[<pre><code>FLUSH PRIVILEGES # 重新从grant tables加载权限

使用GRANT,CREATE USER, CREATE SERVER, INSTALL PLUGIN产生的缓存并不会因为使用对应的REVOKE, DROP USER, DROP SERVER, UNINSTALL PLUGIN而释放缓存。这些缓存可以通过调用FLUSH PRIVILEGES而释放。
</code></pre><h5 id="GRANT-TABLES-IN-MYSQL"><a href="#GRANT-TABLES-IN-MYSQL" class="headerlink" title="GRANT TABLES IN MYSQL"></a>GRANT TABLES IN MYSQL</h5><pre><code>user: 用户帐户，全局权限
db:   database级别的权限
tables_priv: 表级别的权限
columns_priv: 列级别的权限
procs_priv:   存储过程和函数权限
proxies_priv: 代理用户权限
</code></pre><hr>
<p>Ref：<br>1.<a href="https://dev.mysql.com/doc/refman/5.7/en/grant-tables.html" target="_blank" rel="noopener">grant tables</a> 2.<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-privileges" target="_blank" rel="noopener">flush privileges</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>mysql之plugin</title>
    <url>/2019/02/23/mysql%E4%B9%8Bplugin/</url>
    <content><![CDATA[<p>mysql支持可插拔式的认证方式。 插拔式认证拥有以下能力： 1.可选择内置(native)的认证方式 2.外部认证方式，如<code>PAM, Windows login IDs, LDAP, Kerberos</code> 3.代理用户</p>
<ul>
<li>mysql包括两种native认证方式<code>mysql_native_password, mysql_old_password</code>都是通过系统表<code>mysql.user</code>和密码hash算法实现的。</li>
</ul>
<p><img src="http://img.hysyeah.top/wp-content/uploads/2019/02/mysql_native_password.png" alt> 认证的插件都在存在于客户端和服务端的，服务端的是内置于mysql服务器中。客户端的则在于libmysqlclient中。 - SHA-256 Pluggable Authentication 这种认证方法是比mysql_native_password认证方法安全性更高，采用SHA-256哈希算法对明文进行加密。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/02/sha256-pulgin.png" alt> 创建SHA-256认证的用户</p>
<pre><code>CREATE USER &#39;sha256user&#39;@&#39;localhost&#39;
IDENTIFIED WITH sha256_password BY &#39;password&#39;;
</code></pre><ul>
<li><p>Client-Side Cleartext Pluggable Authentication，存储明文 <img src="http://img.hysyeah.top/wp-content/uploads/2019/02/cleartext.png" alt></p>
</li>
<li><p>PAM认证 外部认证方式，使mysql服务器通过PAM服务来进行用户认证</p>
</li>
<li><p>Windows认证 外部认证方式，使mysql服务器通过原生Windows服务授权客户端连接，当用户登录了 Windows也可以连接mysql服务器(通过环境信息确认用户，不用额外的密码)</p>
</li>
<li>LDAP认证 外部认证方式，Lightweight Directory Access Protocol</li>
<li>No-Login 认证 阻止任何使用此plugin的用户连接mysql服务。此种方式不允许直接登录可以使用代理 方式登录</li>
<li>Socket Peer-Credential认证 本地用户通过连接Unix socket文件进行认证。</li>
<li>Test Pluggable Authentication 测试插件用于测试用户认证是否成功，而且会把是否成功的日志打印到server error log。这个插件的目的是用于测试和开发，也可以作为一个如何写认证插件的例子。</li>
</ul>
<hr>
<p>Ref：<br>1.<a href="https://dev.mysql.com/doc/refman/5.7/en/pam-pluggable-authentication.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/pam-pluggable-authentication.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>mysql之ubuntu环境下安装</title>
    <url>/2019/02/19/mysql%E4%B9%8Bubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h5 id="直接上命令"><a href="#直接上命令" class="headerlink" title="直接上命令"></a>直接上命令</h5><pre><code> sudo apt-get install mysql-server
 sudo apt-get install mysql-client
 sudo apt install libmysqlclient-dev   #客户端认证plugin需要依赖这个库
</code></pre><p>但是在这过程中没有提示设置密码。 在<code>/etc/mysql/</code>目录下有一个debian.cnf文件，文件中有一个系统分配的用户和密码。用户名为<code>debian-sys-maint</code>,通过这个用户就可以操作mysql了。</p>
<pre><code>可以新建一个root用户并对其进行授权,然后用新用户进行登录。

create user &#39;root&#39;@&#39;%&#39; ;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;hello&#39;;
flush privileges;
</code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>mysql之修改用户密码</title>
    <url>/2019/02/18/mysql%E4%B9%8B%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>mysql中有几种方式可以修改用户密码。 1.直接修改mysql.user中的password字段</p>
<pre><code>update mysql.user set password=password(&#39;hello&#39;) where user=&#39;t&#39;
flush privileges;
</code></pre><p>2.使用<code>create user</code>,<code>grant</code>或<code>set password</code></p>
<pre><code>create user t identified by &#39;password&#39;;

grant select on cloud.* to &#39;root&#39;@&#39;10.68.6.66&#39; identified by &#39;password&#39;

set password for &#39;root&#39;@&#39;localhost&#39; =&#39;auth_string&#39;; 在5.5.60中执行报错

set password for &#39;root&#39;@&#39;localhost&#39; = password(&#39;auth_string&#39;);  在5.7.6中已废弃这种语法，将来会移除
</code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>mysql之隔离级别(isolation level)</title>
    <url>/2019/04/27/mysql%E4%B9%8B%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB(isolation%20level)/</url>
    <content><![CDATA[<h3 id="一、ACID：事务的4个特性"><a href="#一、ACID：事务的4个特性" class="headerlink" title="一、ACID：事务的4个特性"></a>一、ACID：事务的4个特性</h3><ul>
<li>原子性(atomicity):在一个事务中，操作要么成功，要么失败。如果事务中有一个命令失败，必须回滚操作，回到事务执行之前的状态。</li>
<li>一致性(consistency):事务在完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性(isolation):事务在查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务是不会查看中间状态的。</li>
<li>持久性(durability):事务完成之后，它对于系统的影响是永久性的。</li>
</ul>
<h3 id="二、隔离级别-ACID中的I"><a href="#二、隔离级别-ACID中的I" class="headerlink" title="二、隔离级别(ACID中的I)"></a>二、隔离级别(ACID中的I)</h3><h6 id="InnoDB提供四种隔离级别"><a href="#InnoDB提供四种隔离级别" class="headerlink" title="InnoDB提供四种隔离级别"></a><code>InnoDB</code>提供四种隔离级别</h6><ul>
<li>READ UNCOMMITTED: 读未提交</li>
<li>READ COMMITTED: 读已提交</li>
<li>REPEATABLE READ: 重复读</li>
<li>SERIALIZABLE: 串行化</li>
</ul>
<p>不一致情况： 脏读：一个事务读取了另一个未提交事务写入的数据。 不可重复读：指一个事务重新读取前面读取过的数据时，发现该数据已经被另一个已提交事务修改了。 幻读：一个事务开始后，需要根据数据库中现有的数据做一些更新，于是重新执行一个查询，返回一套符合查询条件的行，这是发现这些行因为其他最近提交的事务而发生了改变，导致现有的事务如果再进行下去就可能会在逻辑上出现一些错误。（幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。）</p>
<h5 id="事务隔离级别的行为"><a href="#事务隔离级别的行为" class="headerlink" title="事务隔离级别的行为"></a>事务隔离级别的行为</h5><div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>读已提交</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>重复读</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可串行化</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody>
</table>
</div>
<p>模拟发生幻读：</p>
<h5 id="事务1"><a href="#事务1" class="headerlink" title="事务1"></a>事务1</h5><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/04/%E5%B9%BB%E8%AF%BB1.png" alt></p>
<h5 id="事务2"><a href="#事务2" class="headerlink" title="事务2"></a>事务2</h5><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/04/%E5%B9%BB%E8%AF%BB2.png" alt> 事务1：检查表中是否有<code>id=10</code>的记录，没有则插入，这是正常逻辑。 事务2: 干拢了事务1的正常执行。</p>
<hr>
<p>用户可以通过<code>SET TRANSACTION</code>命令改变隔离级别，或通过<code>--transaction-isolation</code>配置server级别的隔离性。 <code>MySQL</code>通过使用不同的锁策略实现不同的隔离级别，默认隔离级别是<code>REPEATABLE READ</code>，以提供更高级别的一致性。你也可以指定隔离级别为<code>READ COMMITTED</code>甚至<code>READ UNCOMMITTED</code>一致性要求没那么高的场景(减少锁以提高性能)。<code>SERIALIZABLE</code>提供比<code>REPEATABLE</code>更严格的 规则，一般会用于一些特殊的场景，比如XA事务和用于调试并发或死锁问题。</p>
<hr>
<h5 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h5><p>这是MySQL的默认隔离级别。在同一事务中的读取的数据是一致的，在第一次读时会建立一个快照，同一事务中读取到的都是第一个快照中的值。也就是说在同一个事务中，SELECT(noblocking)所获取到的数据都是一致的。对于<code>REPEATABLE READ</code>隔离级别总是读取事务开始时的行数据。</p>
<hr>
<h5 id="READ-COMMITTED-读已提交"><a href="#READ-COMMITTED-读已提交" class="headerlink" title="READ COMMITTED 读已提交"></a>READ COMMITTED 读已提交</h5><p>每一次读都会建立一个新的快照并从中读取数据,它总是读取行的最新版本，如果行被锁定，则读取该行版本的最新一个快照。 对于<code>READ COMMITTED</code>只支持 row-based的binlog。 其它影响： - 对于<code>UPDATE</code>,<code>DELETE</code>操作，<code>InnoDB</code>只会锁住需要需要更新或删除的行。对于不匹配的行，在执行完<code>WHERE</code>语句后锁会释放。这极大的降低了死锁的概率，但还是有可能发生。 - 对于<code>UPDATE</code>操作，如果行已经被加锁，<code>InnoDB``表现为semi-consistent读，将返回最近提交的版本，</code>MySQL<code>再决定是否符合</code>WHERE<code>条件。如果匹配，</code>MySQL```会重新读取这行，然后获取锁或者等待锁。</p>
<hr>
<h5 id="READ-UNCOMMITTED"><a href="#READ-UNCOMMITTED" class="headerlink" title="READ UNCOMMITTED"></a>READ UNCOMMITTED</h5><p><code>SELECT</code>表现为nonlocking fashion,但是可能会读取到旧版本的数据，所以这种隔离级别不保持一致性读，也称为脏读。</p>
<hr>
<h5 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h5><p><code>SERIALIZABLE</code>和<code>REPEATABLE READ</code>隔离级别类似，当<code>autocommit=false</code>情况下，所有<code>SELECT</code>语句会被转换为<code>SELECT ... LOCK IN SHARE MODE</code>。</p>
<hr>
<p>示例： <code>MySQL</code>默认隔离级别为： <img src="http://img.hysyeah.top/wp-content/uploads/2019/04/iso_repeatable_read.png" alt> 在<code>REPEATABLE READ</code>隔离级别情况下，开启两个session,先左边的窗口开启一个事务读取表a中的数据，然后右边的窗口再开启个事务对表a数据进行修改，右边的事务提交后，在左边的事务再次查看表a中的数据。发现两次得到的数据是一致性的，因为对于<code>REPEATABLE READ</code>隔离级别总是读取事务开始时的行数据。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/04/example_repeatable_read.png" alt> 在<code>READ COMMITTED</code>隔离级别重复上述的操作,发现在右边的事务提交后再查看表a的数据，此时表a的数据已更新。因为在这个隔离级别下，它总是读取行的最新版本，如果行被锁定，则读取该行版本的最新一个快照。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/04/committed_read.png" alt></p>
<hr>
<p>Ref：<br>1.<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener">innodb-transaction-isolation-levels</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-state-metrics源码分析</title>
    <url>/2024/01/11/kube-state-metrics%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><p>介绍下几个比较重要的目录  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>internal/store</td>
<td>定义了各种资源metricsFamily用生成metrics</td>
</tr>
<tr>
<td>pkg/builder</td>
<td>使用builder_pattern构建store</td>
</tr>
<tr>
<td>pkg/metric_generator</td>
<td>生成metrics</td>
</tr>
<tr>
<td>pkg/metric_store</td>
<td>构建了一个MetricsStore 实现了cache接口，用于存储refector获取到的数据</td>
</tr>
<tr>
<td>pkg/metricshandler</td>
<td>实现了/metrics的handler函数｜  </td>
</tr>
</tbody>
</table>
</div>
<h4 id="MetricsStore"><a href="#MetricsStore" class="headerlink" title="MetricsStore"></a>MetricsStore</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/metrics_store/metrics_store.go</span></span><br><span class="line"><span class="comment">// MetricsStore 实现了the k8s.io/client-go/tools/cache.Store接口.MetricsStore</span></span><br><span class="line"><span class="comment">// 不存储k8s资源，只存储基于资源生成的metrics</span></span><br><span class="line"><span class="keyword">type</span> MetricsStore <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Protects metrics</span></span><br><span class="line">	mutex sync.RWMutex</span><br><span class="line">	<span class="comment">// metrics is a map indexed by Kubernetes object id, containing a slice of</span></span><br><span class="line">	<span class="comment">// metric families, containing a slice of metrics. We need to keep metrics</span></span><br><span class="line">	<span class="comment">// grouped by metric families in order to zip families with their help text in</span></span><br><span class="line">	<span class="comment">// MetricsStore.WriteAll().</span></span><br><span class="line">	metrics <span class="keyword">map</span>[types.UID][][]<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">// headers contains the header (TYPE and HELP) of each metric family. It is</span></span><br><span class="line">	<span class="comment">// later on zipped with with their corresponding metric families in</span></span><br><span class="line">	<span class="comment">// MetricStore.WriteAll().</span></span><br><span class="line">	headers []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// generateMetricsFunc generates metrics based on a given Kubernetes object</span></span><br><span class="line">	<span class="comment">// and returns them grouped by metric family.</span></span><br><span class="line">	generateMetricsFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> []<span class="title">metric</span>.<span class="title">FamilyInterface</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 为MetricsStore实现了Add方法，该方法会由reflector调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MetricsStore)</span> <span class="title">Add</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	o, err := meta.Accessor(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成prometheus需要的metric</span></span><br><span class="line">	<span class="comment">// 这里的generateMetricsFunc对于configmap这种资源来说,generateMetricsFunc也就是ComposeMetricGenFuncs的返回值(也是一个函数)</span></span><br><span class="line">	families := s.generateMetricsFunc(obj)</span><br><span class="line">	familyStrings := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="built_in">len</span>(families))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, f := <span class="keyword">range</span> families &#123;</span><br><span class="line">		familyStrings[i] = f.ByteSlice()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// key为k8s资源的UID</span></span><br><span class="line">	s.metrics[o.GetUID()] = familyStrings</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MetricsGenerator"><a href="#MetricsGenerator" class="headerlink" title="MetricsGenerator"></a>MetricsGenerator</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/metric_generator/generator.go</span></span><br><span class="line"><span class="comment">// 为k8s对象生成metrics</span></span><br><span class="line"><span class="keyword">type</span> FamilyGenerator <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name              <span class="keyword">string</span></span><br><span class="line">	Help              <span class="keyword">string</span></span><br><span class="line">	Type              metric.Type</span><br><span class="line">	OptIn             <span class="keyword">bool</span></span><br><span class="line">	DeprecatedVersion <span class="keyword">string</span></span><br><span class="line">	GenerateFunc      <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">metric</span>.<span class="title">Family</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewFamilyGenerator creates new FamilyGenerator instances.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFamilyGenerator</span><span class="params">(name <span class="keyword">string</span>, help <span class="keyword">string</span>, metricType metric.Type, deprecatedVersion <span class="keyword">string</span>, generateFunc <span class="keyword">func</span>(obj <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">metric</span>.<span class="title">Family</span>) *<span class="title">FamilyGenerator</span></span> &#123;</span><br><span class="line">	f := &amp;FamilyGenerator&#123;</span><br><span class="line">		Name:              name,</span><br><span class="line">		Type:              metricType,</span><br><span class="line">		Help:              help,</span><br><span class="line">		OptIn:             <span class="literal">false</span>,</span><br><span class="line">		DeprecatedVersion: deprecatedVersion,</span><br><span class="line">		GenerateFunc:      generateFunc,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> deprecatedVersion != <span class="string">""</span> &#123;</span><br><span class="line">		f.Help = fmt.Sprintf(<span class="string">"(Deprecated since %s) %s"</span>, deprecatedVersion, help)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *FamilyGenerator)</span> <span class="title">Generate</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">metric</span>.<span class="title">Family</span></span> &#123;</span><br><span class="line">	family := g.GenerateFunc(obj)</span><br><span class="line">	family.Name = g.Name</span><br><span class="line">	family.Type = g.Type</span><br><span class="line">	<span class="keyword">return</span> family</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// generateHeader 生成metrics所需的header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *FamilyGenerator)</span> <span class="title">generateHeader</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	header := strings.Builder&#123;&#125;</span><br><span class="line">	header.WriteString(<span class="string">"# HELP "</span>)</span><br><span class="line">	header.WriteString(g.Name)</span><br><span class="line">	header.WriteByte(<span class="string">' '</span>)</span><br><span class="line">	header.WriteString(g.Help)</span><br><span class="line">	header.WriteByte(<span class="string">'\n'</span>)</span><br><span class="line">	header.WriteString(<span class="string">"# TYPE "</span>)</span><br><span class="line">	header.WriteString(g.Name)</span><br><span class="line">	header.WriteByte(<span class="string">' '</span>)</span><br><span class="line">	header.WriteString(<span class="keyword">string</span>(g.Type))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> header.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExtractMetricFamilyHeaders takes in a slice of FamilyGenerator metrics and</span></span><br><span class="line"><span class="comment">// returns the extracted headers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractMetricFamilyHeaders</span><span class="params">(families []FamilyGenerator)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	headers := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(families))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, f := <span class="keyword">range</span> families &#123;</span><br><span class="line">		headers[i] = f.generateHeader()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> headers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComposeMetricGenFuncs takes a slice of metric families and returns a function</span></span><br><span class="line"><span class="comment">// that composes their metric generation functions into a single one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ComposeMetricGenFuncs</span><span class="params">(familyGens []FamilyGenerator)</span> <span class="title">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> []<span class="title">metric</span>.<span class="title">FamilyInterface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> []<span class="title">metric</span>.<span class="title">FamilyInterface</span></span> &#123;</span><br><span class="line">		families := <span class="built_in">make</span>([]metric.FamilyInterface, <span class="built_in">len</span>(familyGens))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i, gen := <span class="keyword">range</span> familyGens &#123;</span><br><span class="line">			<span class="comment">// Generate调用了GenerateFunc</span></span><br><span class="line">			<span class="comment">// 不同的object实现了不同的metric</span></span><br><span class="line">			families[i] = gen.Generate(obj)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> families</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MetricsHandler"><a href="#MetricsHandler" class="headerlink" title="MetricsHandler"></a>MetricsHandler</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/metricshandler/metrics_handler.go</span></span><br><span class="line"><span class="comment">// ServeHTTP implements the http.Handler interface. It writes all generated</span></span><br><span class="line"><span class="comment">// metrics to the response body.</span></span><br><span class="line"><span class="comment">// 实现了ServeHTTP处理/metrics请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MetricsHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	m.mtx.RLock()</span><br><span class="line">	<span class="keyword">defer</span> m.mtx.RUnlock()</span><br><span class="line">	resHeader := w.Header()</span><br><span class="line">	<span class="keyword">var</span> writer io.Writer = w</span><br><span class="line"></span><br><span class="line">	resHeader.Set(<span class="string">"Content-Type"</span>, <span class="string">`text/plain; version=`</span>+<span class="string">"0.0.4"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> m.enableGZIPEncoding &#123;</span><br><span class="line">		<span class="comment">// Gzip response if requested. Taken from</span></span><br><span class="line">		<span class="comment">// github.com/prometheus/client_golang/prometheus/promhttp.decorateWriter.</span></span><br><span class="line">		reqHeader := r.Header.Get(<span class="string">"Accept-Encoding"</span>)</span><br><span class="line">		parts := strings.Split(reqHeader, <span class="string">","</span>)</span><br><span class="line">		<span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">			part = strings.TrimSpace(part)</span><br><span class="line">			<span class="keyword">if</span> part == <span class="string">"gzip"</span> || strings.HasPrefix(part, <span class="string">"gzip;"</span>) &#123;</span><br><span class="line">				writer = gzip.NewWriter(writer)</span><br><span class="line">				resHeader.Set(<span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> m.metricsWriters &#123;</span><br><span class="line">		<span class="comment">// 调用WriteAll 生成prometheus所需的数据</span></span><br><span class="line">		w.WriteAll(writer)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// In case we gzipped the response, we have to close the writer.</span></span><br><span class="line">	<span class="keyword">if</span> closer, ok := writer.(io.Closer); ok &#123;</span><br><span class="line">		closer.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	opts := options.NewOptions()</span><br><span class="line">    <span class="comment">// 添加flag, 根据参数填充options中的值，并为一些参数提供默认值</span></span><br><span class="line">	opts.AddFlags()</span><br><span class="line"></span><br><span class="line">	promLogger := promLogger&#123;&#125;</span><br><span class="line"></span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">	err := opts.Parse()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"Error: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> opts.Version &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%s\n"</span>, version.Print(<span class="string">"kube-state-metrics"</span>))</span><br><span class="line">		os.Exit(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> opts.Help &#123;</span><br><span class="line">		opts.Usage()</span><br><span class="line">		os.Exit(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 创建一个storeBuilder, 使用很常见的builder模式一步一步构建对象</span></span><br><span class="line">	storeBuilder := store.NewBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于观测kube-state-metrics本身的性能</span></span><br><span class="line">	ksmMetricsRegistry := prometheus.NewRegistry()</span><br><span class="line">	ksmMetricsRegistry.MustRegister(version.NewCollector(<span class="string">"kube_state_metrics"</span>))</span><br><span class="line">	durationVec := promauto.With(ksmMetricsRegistry).NewHistogramVec(</span><br><span class="line">		prometheus.HistogramOpts&#123;</span><br><span class="line">			Name:        <span class="string">"http_request_duration_seconds"</span>,</span><br><span class="line">			Help:        <span class="string">"A histogram of requests for kube-state-metrics metrics handler."</span>,</span><br><span class="line">			Buckets:     prometheus.DefBuckets,</span><br><span class="line">			ConstLabels: prometheus.Labels&#123;<span class="string">"handler"</span>: <span class="string">"metrics"</span>&#125;,</span><br><span class="line">		&#125;, []<span class="keyword">string</span>&#123;<span class="string">"method"</span>&#125;,</span><br><span class="line">	)</span><br><span class="line">	storeBuilder.WithMetrics(ksmMetricsRegistry)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> resources []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(opts.Resources) == <span class="number">0</span> &#123;</span><br><span class="line">		klog.Info(<span class="string">"Using default resources"</span>)</span><br><span class="line">		resources = options.DefaultResources.AsSlice()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		klog.Infof(<span class="string">"Using resources %s"</span>, opts.Resources.String())</span><br><span class="line">		resources = opts.Resources.AsSlice()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置对应的resources</span></span><br><span class="line">	<span class="keyword">if</span> err := storeBuilder.WithEnabledResources(resources); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"Failed to set up resources: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置namespaces</span></span><br><span class="line">	namespaces := opts.Namespaces.GetNamespaces()</span><br><span class="line">	nsFieldSelector := namespaces.GetExcludeNSFieldSelector(opts.NamespacesDenylist)</span><br><span class="line">	storeBuilder.WithNamespaces(namespaces, nsFieldSelector)</span><br><span class="line"></span><br><span class="line">	allowDenyList, err := allowdenylist.New(opts.MetricAllowlist, opts.MetricDenylist)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = allowDenyList.Parse()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"error initializing the allowdeny list : %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.Infof(<span class="string">"metric allow-denylisting: %v"</span>, allowDenyList.Status())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置metric family filter, 可以过滤掉一些指标</span></span><br><span class="line">	optInMetricFamilyFilter, err := optin.NewMetricFamilyFilter(opts.MetricOptInList)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"error initializing the opt-in metric list : %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> optInMetricFamilyFilter.Count() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		klog.Infof(<span class="string">"metrics which were opted into: %v"</span>, optInMetricFamilyFilter.Status())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置family generator filter</span></span><br><span class="line">	storeBuilder.WithFamilyGeneratorFilter(generator.NewCompositeFamilyGeneratorFilter(</span><br><span class="line">		allowDenyList,</span><br><span class="line">		optInMetricFamilyFilter,</span><br><span class="line">	))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置使用的store</span></span><br><span class="line">    <span class="comment">// DefaultGenerateStoresFunc()中的startReflector,这里会启动reflector</span></span><br><span class="line">	storeBuilder.WithGenerateStoresFunc(storeBuilder.DefaultGenerateStoresFunc(), opts.UseAPIServerCache)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Linux系统中，进程ID（PID）为1的进程通常是init进程（也称为init系统）或systemd进程。</span></span><br><span class="line">    <span class="comment">// 该进程是整个系统启动过程中的第一个用户级进程，负责启动和管理其他进程。</span></span><br><span class="line">    <span class="comment">// 如果进程本身的pid=1则启动goroutine则注册SIGCHLD,获取子进程的状态信息</span></span><br><span class="line">    <span class="comment">// https://man7.org/linux/man-pages/man2/waitpid.2.html</span></span><br><span class="line">	proc.StartReaper()</span><br><span class="line"></span><br><span class="line">	kubeClient, vpaClient, userClient, err := createKubeClient(opts.Apiserver, opts.Kubeconfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"Failed to create client: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Builder结构体变量</span></span><br><span class="line">	storeBuilder.WithKubeClient(kubeClient)</span><br><span class="line">	storeBuilder.WithVPAClient(vpaClient)</span><br><span class="line">	storeBuilder.WithUserClient(userClient)</span><br><span class="line">	storeBuilder.WithSharding(opts.Shard, opts.TotalShards)</span><br><span class="line">	storeBuilder.WithAllowAnnotations(opts.AnnotationsAllowList)</span><br><span class="line">	storeBuilder.WithAllowLabels(opts.LabelsAllowList)</span><br><span class="line"></span><br><span class="line">	ksmMetricsRegistry.MustRegister(</span><br><span class="line">		collectors.NewProcessCollector(collectors.ProcessCollectorOpts&#123;&#125;),</span><br><span class="line">		collectors.NewGoCollector(),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> g run.Group</span><br><span class="line"></span><br><span class="line">	m := metricshandler.New(</span><br><span class="line">		opts,</span><br><span class="line">		kubeClient,</span><br><span class="line">		storeBuilder,</span><br><span class="line">		opts.EnableGZIPEncoding,</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// Run MetricsHandler</span></span><br><span class="line">	&#123;</span><br><span class="line">		ctxMetricsHandler, cancel := context.WithCancel(ctx)</span><br><span class="line">		g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> m.Run(ctxMetricsHandler)</span><br><span class="line">		&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line">			cancel()</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tlsConfig := opts.TLSConfig</span><br><span class="line"></span><br><span class="line">	telemetryMux := buildTelemetryServer(ksmMetricsRegistry)</span><br><span class="line">	telemetryListenAddress := net.JoinHostPort(opts.TelemetryHost, strconv.Itoa(opts.TelemetryPort))</span><br><span class="line">	telemetryServer := http.Server&#123;Handler: telemetryMux, Addr: telemetryListenAddress&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建metric server,提供接口给prometheus拉取数据</span></span><br><span class="line">	metricsMux := buildMetricsServer(m, durationVec)</span><br><span class="line">	metricsServerListenAddress := net.JoinHostPort(opts.Host, strconv.Itoa(opts.Port))</span><br><span class="line">	metricsServer := http.Server&#123;Handler: metricsMux, Addr: metricsServerListenAddress&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run Telemetry server</span></span><br><span class="line">	&#123;</span><br><span class="line">		g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			klog.Infof(<span class="string">"Starting kube-state-metrics self metrics server: %s"</span>, telemetryListenAddress)</span><br><span class="line">			<span class="keyword">return</span> web.ListenAndServe(&amp;telemetryServer, tlsConfig, promLogger)</span><br><span class="line">		&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line">			ctxShutDown, cancel := context.WithTimeout(ctx, <span class="number">3</span>*time.Second)</span><br><span class="line">			<span class="keyword">defer</span> cancel()</span><br><span class="line">			telemetryServer.Shutdown(ctxShutDown)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Run Metrics server</span></span><br><span class="line">	&#123;</span><br><span class="line">		g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			klog.Infof(<span class="string">"Starting metrics server: %s"</span>, metricsServerListenAddress)</span><br><span class="line">			<span class="keyword">return</span> web.ListenAndServe(&amp;metricsServer, tlsConfig, promLogger)</span><br><span class="line">		&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line">			ctxShutDown, cancel := context.WithTimeout(ctx, <span class="number">3</span>*time.Second)</span><br><span class="line">			<span class="keyword">defer</span> cancel()</span><br><span class="line">			metricsServer.Shutdown(ctxShutDown)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := g.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"RunGroup Error: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	klog.Info(<span class="string">"Exiting"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql之％</title>
    <url>/2019/02/23/mysql%E4%B9%8B%EF%BC%85/</url>
    <content><![CDATA[<p>mysql在创建用户时可以指定host,通配符%表示可以匹配任何host(当然localhost除外，localhost优先级大于%)</p>
<pre><code>create user &#39;hys&#39;@&#39;%&#39; identified by &#39;hello&#39;;
create user &#39;hys&#39;@&#39;localhost&#39; identified by &#39;wtf&#39;;
create user &#39;hys&#39;@&#39;127.0.0.1&#39; identified by &#39;666&#39;;
flush privileges;
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/02/mysqluser.png" alt> 使用命令进行连接<code>mysql -uhys -phello</code>,报错如下 <img src="http://img.hysyeah.top/wp-content/uploads/2019/02/mysqlacces.png" alt> 使用命令进行连接<code>mysql -uhys -pwtf</code>则可以正常连接。 使用命令进行连接<code>mysql -uhys -h127.0.0.1 -p666</code> <img src="http://img.hysyeah.top/wp-content/uploads/2019/02/mysqlacces.png" alt> 说明mysql在进行连接时把<code>127.0.0.1</code>转换成了<code>localhost</code> 删除掉<code>hys@localhost</code> 使用命令进行连接<code>mysql -uhys -h127.0.0.1 -p666</code>可正常连接</p>
<hr>
<p>结论： 1.通配符不包括<code>localhost</code> 2.当同一用户host同时存在<code>localhost</code>和<code>%</code>时，会优先匹配<code>localhost</code> 3.当同一用户host同时存在<code>localhost</code>和<code>127.0.0.1</code>时,虽然连接时指定了<code>-h127.0.0.1</code>但也会先匹配<code>localhost</code> 4.当存在<code>127.0.0.1</code>而不存在<code>localhost</code>，指定<code>-h127.0.0.1</code>可以进行连接</p>
<hr>
<p>Ref： <img src="http://img.hysyeah.top/wp-content/uploads/2019/02/mysql.png" alt> <a href="https://dev.mysql.com/doc/mysql-security-excerpt/8.0/en/problems-connecting.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/mysql-security-excerpt/8.0/en/problems-connecting.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>mysql的limit,offset分页</title>
    <url>/2017/09/15/mysql%E7%9A%84limit,offset%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<pre><code>1.SELECT * FROM br_apply_check_info LIMIT 20 OFFSET 612000; --0.769s

2.SELECT * FROM br_apply_check_info INNER JOIN (SELECT id from br_apply_check_info LIMIT 20 OFFSET 612000) AS x USING(ID);-- 0.438s
</code></pre><p>当偏移量的增加，MYSQL需要花费大量的时间来扫描需要丢弃的数据。反范式化，预先计算和缓存可能是解决这类查询的仅有策略。 优化这类索引的另一个比较好的策略是使用延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行。这样可以减少MYSQL扫描那些需要丢弃的行数。 如上：第二方法比第一种方法快一倍(当偏移量足够大的时候)</p>
<hr>
<p>Ref：&lt;&lt;高性能MYSQL&gt;&gt;</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>namedtuple映射名称到序列元素</title>
    <url>/2017/09/06/namedtuple%E6%98%A0%E5%B0%84%E5%90%8D%E7%A7%B0%E5%88%B0%E5%BA%8F%E5%88%97%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<pre><code>In [1]: from collections import namedtuple

In [2]: dt = namedtuple(&#39;s&#39;, [&#39;name&#39;, &#39;job&#39;])

In [3]: ret = dt(&#39;hys&#39;, &#39;coder&#39;)

In [4]: ret.name
Out[4]: &#39;hys&#39;

In [5]: ret.job
Out[5]: &#39;coder&#39;
</code></pre><p>将cursor.fetchall()返回的元组转换成可以通过名称来访问的元组</p>
<pre><code>In [1]: from collections import namedtuple
...:
...: def tuple_to_namedtuple(t, name_list):
...:     ret_list = []
...:     s_namedtuple = namedtuple(&#39;s_namedtuple&#39;,name_list)
...:     for item in t:
...:         ret_list.append(s_namedtuple._make(item))
...:         return ret_list
...:

In [2]: import sqlite3

In [3]: conn = sqlite3.connect(&#39;tst.sqlite3&#39;)

In [4]: cursor = conn.cursor()

In [5]: cursor.execute(&#39;select * from t&#39;)
Out[5]: &lt;sqlite3.Cursor at 0x7f48b8079500&gt;

In [6]: r = tuple_to_namedtuple(cursor.fetchall(),[&#39;id&#39;, &#39;name&#39;, &#39;value&#39;])

In [7]: r
Out[7]:
[s_namedtuple(id=1, name=&#39;hys&#39;, value=&#39;a&#39;),
s_namedtuple(id=2, name=&#39;huang&#39;, value=&#39;b&#39;)]
</code></pre><hr>
<p>通过map实现,简洁许多</p>
<pre><code>In [10]: def tuple_to_dict(seq, name_list):
...:         s_namedtuple = namedtuple(&#39;s_namedtuple&#39;,name_list)
...:         return map(s_namedtuple._make, seq)
...:

In [12]: ret = tuple_to_dict(cursor.fetchall(),[&#39;id&#39;,&#39;name&#39;,&#39;value&#39;])

In [13]: ret
Out[13]: &lt;map at 0x7f48b2fa2a90&gt;

In [14]: for elt in ret:
...:         print(elt)
...:
s_namedtuple(id=1, name=&#39;hys&#39;, value=&#39;a&#39;)
s_namedtuple(id=2, name=&#39;huang&#39;, value=&#39;b&#39;)
</code></pre>]]></content>
      <categories>
        <category>python标准库</category>
      </categories>
  </entry>
  <entry>
    <title>mysql批量导出恢复指定库中的特定表</title>
    <url>/2019/04/11/mysql%E6%89%B9%E9%87%8F%E5%AF%BC%E5%87%BA%E6%81%A2%E5%A4%8D%E6%8C%87%E5%AE%9A%E5%BA%93%E4%B8%AD%E7%9A%84%E7%89%B9%E5%AE%9A%E8%A1%A8/</url>
    <content><![CDATA[<p>目的：批量导出和恢复多个库中的特定表 1.先建立一个文件用于存储库名和表名 <code>cat databases.txt</code></p>
<pre><code># 每行第一个为库名，其余为表名，以英文逗号分隔
portal,if_zone,uc_order,ecs_instance
cdn,cdn_domain
</code></pre><p>2.编写dump脚本</p>
<pre><code>#!/bin/bash

for elt in $(cat databases.txt)
do
  echo &quot;start dump $(echo $elt|cut -d \, -f 1)&quot;
  mysqldump -hlocalhost -uroot -pxxxx --databases  $(echo $elt|cut -d \, -f 1) --tables $(echo $elt|cut -d \, -f 2- | sed &#39;s/,/ /g&#39;) &gt; $(echo $elt|cut -d \, -f 1).sql
  echo &quot;done&quot;
done

# cut -d \, -f 1       对输入字符以逗号进行切割，取第 一个
# cut -d \, -f 2-      对输入字符以逗号进行切割，取第 二个到最后一个
# sed &#39;s/,/ /g&#39;        将输入中的全部&#39;,&#39;替换为空格
</code></pre><p>3.编写restore脚本</p>
<pre><code>#!/bin/sh

for elt in $(ls *.sql)
do
  echo &quot;start restore ${elt%%.*}&quot;
  mysql -uroot -pxxxx -e &quot;create database if not exists ${elt%%.*}&quot;
  mysql -uroot -pxxxx ${elt%%.*} &lt; $elt
  echo &quot;done&quot;
done
</code></pre><h4 id="警示：在运行的系统中执行mysqldump命令，需考虑风险，因为mysqldump会有一些锁表的操作，详情详见下面Ref中的链接。"><a href="#警示：在运行的系统中执行mysqldump命令，需考虑风险，因为mysqldump会有一些锁表的操作，详情详见下面Ref中的链接。" class="headerlink" title="警示：在运行的系统中执行mysqldump命令，需考虑风险，因为mysqldump会有一些锁表的操作，详情详见下面Ref中的链接。"></a>警示：在运行的系统中执行<code>mysqldump</code>命令，需考虑风险，因为<code>mysqldump</code>会有一些锁表的操作，详情详见下面Ref中的链接。</h4><hr>
<p>Ref：<br>1.<a href="http://img.hysyeah.top/2019/04/11/linux-sed/" target="_blank" rel="noopener">linux sed</a><br>2.<a href="http://img.hysyeah.top/2019/04/11/linux-cut/" target="_blank" rel="noopener">linux cut</a><br>3.<a href="http://img.hysyeah.top/2019/04/12/mysqldump/" target="_blank" rel="noopener">mysqldump</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>neo4j安装</title>
    <url>/2018/10/14/neo4j%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Neo4j是一个高性能的,NOSQL图形数据库，它将结构化数据存储在网络上而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎，但是它将结构化数据存储在网络(从数学角度叫做图)上而不是表中。 应用场景： - 欺诈检测 - 实时推荐引擎 - Master data management(MDM) - Identity and access management(身份和访问管理-IAM) <a href="https://neo4j.com/why-graph-databases/?ref=footer" target="_blank" rel="noopener">来源</a></p>
<hr>
<p>1.安装依赖java,下载jdk 2.设置环境变量</p>
<pre><code>export JAVA_HOME=/opt/jdk1.8.0_191
export JRE_HOME=/opt/jdk1.8.0_191/jre
export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH
export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH
</code></pre><hr>
<p>1.<a href="https://neo4j.com/download-center/#releases" target="_blank" rel="noopener">下载neo4j安装包</a> 2.解压，添加环境变量</p>
<pre><code>cp neo4j-community-3.4.8-unix.tar.gz /opt
tar -xf neo4j-community-3.4.8-unix.tar.gz
export PATH=&quot;/opt/neo4j-community-3.4.8/bin:$PATH&quot;
</code></pre><p>3.修改配置文件 neo4j默认只能从本机访问，因些修改conf/neo4j.conf,改为可从其它主机访问</p>
<pre><code>dbms.connectors.default_listen_address=0.0.0.0
</code></pre><p>4.开启neo4j服务<code>neo4j console</code> 5.打开浏览器输入<code>xxx.xxx.xxx.xxx:7474</code>,即可连接neo4j服务。默认用户名密码为:neo4j/neo4j,第一次会提示修改密码 6.连接后的界面如下 <img src="http://img.hysyeah.top/wp-content/uploads/2018/10/neo4j.png" alt></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>numpy,pandas安装</title>
    <url>/2017/09/27/numpy,pandas%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<pre><code>sudo apt-get install python3-tk
pip3 install numpy
pip3 install pandas
pip3 intall matplotlib
pip3 install scipy
</code></pre>]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>numpy中的金融函数</title>
    <url>/2017/08/27/numpy%E4%B8%AD%E7%9A%84%E9%87%91%E8%9E%8D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<pre><code>fv: Futrue Value          终值

pv:Present Value          现值

npv:Net Present Value 净现值,净现值是指投资方案所产生的【现金净流量】（流入-流出）以资金成本为贴现率折现之后与原始投资额现值的差额

pmt:Payment               每次所要还的本金加利息

ppmt:Principal Payment    每期所还的本金

ipmt:Interst Payment      每期所还的利息

irr:Internal Rate of Return 内部收益率，内部收益率

mirr:Modified Internal Rate of Return 修正内部收益率

nper:Number of periodic payments 付款期数

rate: 利率


numpy.fv(rate, nper, pmt, pv, when=&#39;end&#39;)   #计算未来的值

#例子：年利率为5%,每年定期存款14000，40年为累积财富为1691196.84

In [4]: np.fv(0.05, 40-1, -14000, -14000)
Out[4]: 1691196.839394904


numpy.pv(rate, nper, pmt,fv=0.0, when=&#39;end&#39;) #计算现值

#例子：年利率5%，每月投入100，需要投入多少本金才可以在10年后的15682.93

In [8]: np.pv(0.05/12, 10*12, -100, 15692.93)
Out[8]: -100.00067131625819


numpy.pmt(rate, nper, pv, fv=0, when=&quot;end&quot;)#计算每期应还的本金加利息


#例子：贷款434000，利率4.66%,240期

In [9]: np.pmt(0.0466/12, 20*12, 434000)
Out[9]: -2783.3228668907836


numpy.ppmt(rate, per, nper, pv, fv=0.0, when=&quot;end&quot;)#计算应还本金

per:表示第几个还款日

#例子：贷款434000，利率4.66%,240期

In [3]: np.ppmt(0.0466/12, 1, 240, 434000)
Out[3]: -1097.9562002241169


numpy.ipmt(rate, per, nper, pv, fv=0.0, when=&quot;end&quot;)#每期应还利息

#例子：贷款434000，利率4.66%,240期


In [5]: np.ipmt(0.0466/12, 1, 240, 434000)
Out[5]: array(-1685.3666666666668)


numpy.nper(rate, pmt, pv, fv=0, when=&quot;end&quot;)#计算付款次数

#例子：贷款434000，利率4.66%,每月还款2782


In [9]: np.nper(0.0466/12, -2782.14, 434000)
Out[9]: 240.1684400099434


numpy.npv(rate, values)

In [3]: np.npv(0.281,[-100, 39, 59, 55, 20])
Out[3]: -0.0084785916384513271



numpy.irr(values) #返回内部收益率

In [5]: np.irr([-100, 39, 59, 55, 20])
Out[5]: 0.28094842115996066



numpy.mirr(values, finance_rate, reinvest_rate) #返回修正内部收益率

values：现金流，一个列表，正数代表&#39;收入&#39;或&#39;取款&#39;，负数代表&#39;投资&#39;或&#39;存款&#39;

In [6]: np.mirr([-1000, -4000, 5000, 2000], 0.1, 0.12)
Out[6]: 0.17908568603489283
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2017/08/mirr.png" alt="image"></p>
<hr>
<p>Ref：<br>1.<a href="http://www.jianshu.com/p/9ad131856078" target="_blank" rel="noopener">http://www.jianshu.com/p/9ad131856078</a><br>2.<a href="https://en.wikipedia.org/wiki/Modified_internal_rate_of_return#Calculation_of_the_MIRR" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Modified_internal_rate_of_return#Calculation_of_the_MIRR</a></p>
]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>numpy中矩阵元素使用分数表示</title>
    <url>/2018/05/17/numpy%E4%B8%AD%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E4%BD%BF%E7%94%A8%E5%88%86%E6%95%B0%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<pre><code>In [1]: from sympy import Rational

In [2]: a = Rational(&#39;1/3&#39;)

In [3]: p = np.array([[0,1,0,0,0],[a,a,a,0,0],[0,a,a,a,0],[0,0,a,a,a],[0,0,0,1,0]])

In [4]: p
Out[4]:
array([[0, 1, 0, 0, 0],
       [1/3, 1/3, 1/3, 0, 0],
       [0, 1/3, 1/3, 1/3, 0],
       [0, 0, 1/3, 1/3, 1/3],
       [0, 0, 0, 1, 0]], dtype=object)


# n个矩阵进行点乘
In [70]: def matric_dots(a,n):
             i = 1
             c = a
             while i&lt;n:
                 i += 1
                 c = c.dot(a)
             return c

In [75]: matric_dots(p,3) == p.dot(p).dot(p)
Out[75]:
array([[ True,  True,  True,  True,  True],
       [ True,  True,  True,  True,  True],
       [ True,  True,  True,  True,  True],
       [ True,  True,  True,  True,  True],
       [ True,  True,  True,  True,  True]])
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>numpy数据类型基本操作</title>
    <url>/2017/09/05/numpy%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>1.导入numpy包，调用array()函数创建一维数组</p>
<pre><code>In [3]: import numpy as np

In [4]: a = np.array(range(6))

In [5]: a
Out[5]: array([0, 1, 2, 3, 4, 5])

In [6]: print(a)
[0 1 2 3 4 5]
</code></pre><p>2.array的shape属性</p>
<pre><code>In [7]: a.shape
Out[7]: (6,)

In [8]: a.shape = 2, 3

In [9]: a
Out[9]:
array([[0, 1, 2],
[3, 4, 5]])
</code></pre><p>3.通过reshape()函数在a的基础上创建一个新的二维结构的数组a1,a的shape属性值不会变</p>
<pre><code>In [17]: a1 = a.reshape(3,2)

In [18]: print(a1)
[[0 1]
[2 3]
[4 5]]

In [19]: a1.shape
Out[19]: (3, 2)

In [20]: a.shape
Out[20]: (2, 3)
</code></pre><p>数组a和a1共用内存中的数据存储值，若更改其中任意一个数组中的元素值，则另一个相对应的元素也会改变。</p>
<pre><code>In [23]: print(a1)
[[0 1]
[2 3]
[4 5]]

In [24]: a[1, 2] = 88

In [25]: print(a1)
[[ 0 1]
[ 2 3]
[ 4 88]]
</code></pre><p>4.利用arange([start,] stop[, step,], dtype=None)函数生成数组</p>
<pre><code>In [2]: a = np.arange(13, 1, -1)

In [3]: print(a)
[13 12 11 10 9 8 7 6 5 4 3 2]
</code></pre><p>5.利用linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)函数生成数组</p>
<pre><code>In [9]: a = np.linspace(1, 12, 12)

In [10]: print(a)
[ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12.]

In [11]: a.dtype
Out[11]: dtype(&#39;float64&#39;)
</code></pre><p>6.常用函数</p>
<pre><code>zeros(shape, dtype=float, order=&#39;C&#39;)生成元素全部为0的数组

ones(shape, dtype=None, order=&#39;C&#39;)生成元素全部为1的数组

empty(shape, dtype=float, order=&#39;C&#39;)生成给定维度无初始值的数组
</code></pre>]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>numpy相关函数</title>
    <url>/2018/05/21/numpy%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<pre><code>import numpy as np
import scipy as sp

a = np.ones((2, 3),dtype=int)
a.sum(axis=0)#按列相加
a.sum(axis=1)#按行相加

a.ravel()#转为一维

b = a.reshape #返回一个新的修改后的数组,若修改b中的值,a中相应的值也会改变，若要真正的拷贝改为b = a.reshape().copy()
a.resize#直接修改数组本身,返回值为None
a.ndim #返回矩阵的维度
a.shape #返回矩阵的大小(行数, 列数)

np.argmax(a) #返回最大值的下标
np.isnan(a) #返回和a一样大小的矩阵，若为nan则为True,否则为False
a[~np.isnan(a)] #返回过滤nan元素后的矩阵
np.nan != np.nan is true

sp.sum(np.isnan(a)) # 返回元素值为nan的个数
np.linspace(start,stop,num) #返回在区间start--stop中的num个点
np.logspace(start, stop, num=50, endpoint=True, base=10.0) #返回在区间base**start--base**stop中的num个点
a[:,0] #取a的第0例

d = a[:,0:-1]    #除去最后一列
d.min(0)         #取每列的最小值
d.min(1)         #取每行的最大值
d[i,:]           #取第i行
d[100:1000,:]    #取[100,1000)行


np.eye            #对角矩阵,只有对角线上有非0元素的矩阵称为对角矩阵
np.identity       #同上
np.linalg.inv(a)  #求矩阵a的逆矩阵
np.trace          #矩阵的迹(即对角线元素之和)
numpy.matrix.getH #共轭转置
np.ones           #返回一个矩阵元素全为1
numpy.linalg.det  #计算矩阵的行列式

np.random.uniform(low=0.0, high=1.0, size=None) #从均匀分布中取样,size为返回array元素的个数
np.linalg.svd              #奇异值分解
np.mat             #将输入转换为矩阵对象

np.transpose       #矩阵转置,np.transpose(a)相当于a.T
np.sign(x)            #T函数返回 -1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0. nan if x is nan.
np.matmul             # 两个矩阵之间的积

numpy.random.normal       #生成高斯矩阵
numpy.random.choice       #从序列中随机选取
numpy.asarray             #将python list转换为numpy array


np.unique(a)              #返回去重后的array

rng = np.random.RandomState(0)
X = rng.rand(10, 2000)


In:np.linspace(0,10,9)       #在区间[0,10]中,返回含有9个元素的等差数组
Out:array([ 0.  ,  1.25,  2.5 ,  3.75,  5.  ,  6.25,  7.5 ,  8.75, 10.  ])

In:np.arange(0,10,9)         #返回在区间[0,10],步长为9的数组
Out: array([0, 9])


In [43]: b = np.array([[1,2,3],[4,5,6]])

In [44]: b.reshape(3,-1)   #-1会被自动识别为2
Out[44]:
array([[1, 2],
       [3, 4],
       [5, 6]])

In [45]: b.reshape(-1,3) #-1会被自动识别为2
Out[45]:
array([[1, 2, 3],
       [4, 5, 6]])



np.var                             #方差
In [126]: a = np.array([[1, 2], [3, 4]])

In [127]: np.var(a)   #求展开后所有数的方差
Out[127]: 1.25

In [128]: np.var(a, axis=0)    #按列计算方差
Out[128]: array([1., 1.])

In [129]: np.var(a, axis=1)    #按行计算方差
Out[129]: array([0.25, 0.25])


np.cov                             #协方差


np.tile(A, reps) 根据reps重复A生成一个矩阵,reps为(行数,列数),可把A看作一个元素
In [165]: a = np.array([1,2,3])
In [166]: d = np.tile(a,(3,2))

In [167]: d
Out[167]:
array([[1, 2, 3, 1, 2, 3],
       [1, 2, 3, 1, 2, 3],
       [1, 2, 3, 1, 2, 3]])


# 求矩阵a的秩
In [3]: a
Out[3]:
array([[ 2, -1,  0,  3, -2],
       [ 0,  3,  1, -2,  5],
       [ 0,  0,  0,  4, -3],
       [ 0,  0,  0,  0,  0]])

In [4]: np.linalg.matrix_rank(a)
Out[4]: 3



# nonzero 返回非零元素的下标
In [1]: a = np.array([0,2,0])

In [2]: np.nonzero(a)
Out[2]: (array([1]),)

In [3]: a[np.nonzero(a)]        # 取数组a的非零元素
Out[3]: array([2])

In [4]: x = np.array([[1, 0, 0], [0, 2, 0], [1, 1, 0]]) # 二维数组

In [5]: x
Out[5]:
array([[1, 0, 0],
       [0, 2, 0],
       [1, 1, 0]])

In [6]: np.nonzero(x)
Out[6]: (array([0, 1, 2, 2]), array([0, 1, 0, 1]))


# np.multiply(x, y) == x * y
In [120]: x = np.array([1, 2, 3])
In [121]: y = np.array([4, 5, 6])

In [122]: x *y
Out[122]: array([ 4, 10, 18])

In [123]: np.multiply(x, y)
Out[123]: array([ 4, 10, 18])


# np.mean 求均值
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])           #求所有数的均值
&gt;&gt;&gt; np.mean(a)
2.5
&gt;&gt;&gt; np.mean(a, axis=0)                      # 对列求均值
array([ 2.,  3.])

&gt;&gt;&gt; np.mean(a, axis=1)                      # 对行求均值
array([ 1.5,  3.5])


In [132]: a = np.array([[1, 2], [3, 4]])
In [132]: ma = np.mat(a)

In [133]: ma
Out[133]:
matrix([[1, 2],
        [3, 4]])

In [134]: ma.A                       # 返回array形式
Out[134]:
array([[1, 2],
       [3, 4]])
</code></pre>]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>osi模型与tcp-ip</title>
    <url>/2019/06/11/osi%E6%A8%A1%E5%9E%8B%E4%B8%8Etcp-ip/</url>
    <content><![CDATA[<p>OSI(open systems interconnection)开放系统互连。 OSI是一个七层的概念模型，提供给开发者一个必须的、通用的概念以便开发完善、可以用来解释连接不同系统的框架。 OSI模型与TCP/IP对应的关系： <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/tcp-ip-tour-1.png" alt> TCP/IP通常被认作一个四层协议系统。<br>1.链路层/网络接口层：处理底层物理接口细节<br>2.网络层：处理分组在网络中的活动<br>3.传输层：主要为两台主机上的应用程序提供端到端的通信。TCP和UDP在这一层。 4.应用层：负责处理特定的应用程序细节</p>
<p>从上层到下层涉及到数据的封装<br><img src="http://img.hysyeah.top/2019/08/10/tcp-ip-encapsulation.png" alt="image"></p>
<p><img src="http://img.hysyeah.top/2019/08/14/tcp-head.jpg" alt="image"></p>
<hr>
<p>Ref：<br>1.《TCP/IP协议详解1》</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>osm-install</title>
    <url>/2020/09/28/osm-install/</url>
    <content><![CDATA[<p>1.使用源码安装<code>osm-cli</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:hysyeah/osm.git</span><br><span class="line"></span><br><span class="line">cd osm</span><br><span class="line">git checkout v0<span class="number">.4</span><span class="number">.0</span>  <span class="comment"># tag需要和下面的--osm-image-tag对应，不然可能出现不兼容的错误</span></span><br><span class="line">make build-osm</span><br></pre></td></tr></table></figure></p>
<p>2.osm install —osm-image-tag v0.4.0<br>如果不指定tag可能会出现如下错误<br><img src="http://img.hysyeah.top/2020/9/20200928203820-osm-install-error.png" alt="image"></p>
<p>3.部署完后会创建一个命名空间<code>osm-system</code><br><img src="http://img.hysyeah.top/2020/9/20200928204438-osm-system-pod.png" alt="image"></p>
<hr>
<p>参考：  </p>
<p>1.<a href="https://github.com/openservicemesh/osm/blob/main/docs/installation_guide.md" target="_blank" rel="noopener">install guide</a><br>2.<a href="https://github.com/openservicemesh/osm/issues/1527" target="_blank" rel="noopener">issue</a></p>
]]></content>
      <tags>
        <tag>osm</tag>
        <tag>service-mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>wordpress隐藏登录入口</title>
    <url>/2017/09/04/ordpress%E9%9A%90%E8%97%8F%E7%99%BB%E5%BD%95%E5%85%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>在wordpress根目录下打开wp-login.php文件，在</p>
<pre><code>require( dirname(__FILE__) . &#39;/wp-load.php&#39; );
</code></pre><p>后面加上下面</p>
<pre><code>if($_GET[&#39;hehe&#39;] != &#39;haha&#39;){
header(&#39;Location: http://www.taobao.com/&#39;);
}
</code></pre><p>当别人访问img.hysyeah.top/wp-login.php时会被重定向到<a href="http://www.taobao.com/,只有img.hysyeah.top/wp-login.php?hehe=haha才能正常打开后台登录界面。" target="_blank" rel="noopener">http://www.taobao.com/,只有img.hysyeah.top/wp-login.php?hehe=haha才能正常打开后台登录界面。</a></p>
<hr>
<p>Ref<br>1.<a href="http://www.luoxiao123.cn/5434.html" target="_blank" rel="noopener">http://www.luoxiao123.cn/5434.html</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>pandas数据类型DataFrame及基本操作</title>
    <url>/2018/05/23/pandas%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BDataFrame%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<pre><code>import pandas as pd
df = pd.DataFrame()
df[:n] #取前n行

df.loc[行标签,列标签]
df.loc[&#39;a&#39;:&#39;b&#39;]#选取ab两行数据,ab为行名
df.loc[:,&#39;one&#39;]#选取one列的数据

df.iloc(n)    #取第n行
df.iloc[:,0]  #取第0列
df.iloc[:,[0,1]] #取第0列和第1列

df2 = df.fillna(pd.NaT)
df.to_excel(&#39;foo.xlsx&#39;, sheet_name=&#39;Sheet1&#39;) #写入Excel

df.dropna(how=&#39;any&#39;) #当有一项为NaN时，丢弃整行或整列
df.dropna(how=&#39;all&#39;) #当所有项都为NaN时，丢弃整行或整列

df.describe()        #展示df的相关信息


# 创建DataFrame
In [63]: import pandas as pd
In [64]: d ={&#39;A&#39;:[1,2,3],&#39;B&#39;:[4,5,6]}
In [65]: df = pd.DataFrame(df,index=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;])

In [67]: df
Out[67]:
   A  B
x  1  4
y  2  5
z  3  6
</code></pre>]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>pgloader的安装与使用</title>
    <url>/2018/11/13/pgloader%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>pgloader是由postgresql的作者用lisp语言编写的一个用于将数据从其它数据库迁移到postgresql数据库中的命令行工具，亦可编写简单的脚本，保存为<code>xxx.load</code>文件。</p>
<h4 id="在centos下安装pgloader"><a href="#在centos下安装pgloader" class="headerlink" title="在centos下安装pgloader"></a>在centos下安装pgloader</h4><p>1.安装依赖</p>
<pre><code>sudo yum -y install yum-utils rpmdevtools @&quot;Development Tools&quot; sqlite-devel zlib-devel  
sudo yum -y install epel-release sbcl  
sudo yum -y install freetds freetds-devel
</code></pre><p>2.<a href="https://github.com/dimitri/pgloader/releases/download/v3.5.1/pgloader-bundle-3.5.1.tgz" title="下载源码" target="_blank" rel="noopener">下载源码</a></p>
<pre><code>tar -xv pgloader-bundle-3.5.1.tgz
cd pgloader-bundle-3.5.1.tgz
make pgloader
</code></pre><p>3.编译成功后bin文件夹下会出现pgloader可执行文件，将路径添加到环境变量。</p>
<pre><code>vim ~/.bash_profile
source ~/.bash_profile
</code></pre><hr>
<h4 id="pgloader的使用-from-mysql-to-postgresql"><a href="#pgloader的使用-from-mysql-to-postgresql" class="headerlink" title="pgloader的使用 from mysql to postgresql"></a>pgloader的使用 from mysql to postgresql</h4><pre><code>load database
    from mysql://username:password@localhost/test
    into postgresql://username:password@110.110.110.110/datahub
with include drop, create tables,  create indexes,  reset sequences, disable triggers, foreign keys, workers=8, concurrency=1
   set work_mem to &#39;16MB&#39;, maintenance_work_mem to &#39;512MB&#39;

   INCLUDING ONLY TABLE NAMES MATCHING &#39;base_job_type&#39;

   CAST type timestamp when default &quot;0000-00-00 00:00:00&quot; with extra on update current timestamp to timestamptz drop default drop not nul drop extra using zero-dates-to-null,
        type smallint when unsigned to integer drop typemod

# FROM: 源数据库信息
# INTO: 目标数据库信息
# 迁移默认选项：no truncate, create schema, create tables, include drop, create indexes,reset sequences,foreign keys,downcase identifiers, uniquify index names

# include drop: 丢弃目标库的表并重新创建
# include no drop: 不做任何drop操作
# truncate: 在迁移数据之前清空表
# no truncate: 不做truncate操作
# disable triggers: 这个选项允许，迁移数据到已经存在的表并忽略外键约束和用户定义的触发器，迁移后可能会出现无效的外键约束
# create tables: 根据元数据自动创建表结构
# create no tables: 不创建表结构，当迁移数据时必须保证表存在
# create indexes: 创建索引
# create no indexes: 不创建索引
# drop indexes: 在迁移数据之前drop indexes,当数据迁移完成之后重新创建索引
# uniquify index names: 因为mysql的索引是表唯一，postgresql的索引是schema唯一，所以当从mysql到postgresql时索引名称可能会出现冲突，pgloader会通过特定规则对索引进行重新命名
# preserve index names: 保留索引名称，尽管如此 mysql primary key也会被重新命名，以保持唯一性
# drop schema: 迁移数据行 drop schema，然后重建
# foreign keys: 创建外键
# no foreign keys: 不创建外键
# reset sequences: 当数据迁移完成后，sequences会设置为当前列的最大值
# reset no sequences: 不设置sequences
# downcase identifiers: 将表名，索引名，列名改为小写
# quote identifiers: 保留大小写
# schema only: 只迁移表结构
# data only: 只复制数据
</code></pre><h4 id="pgloader转换规则中的坑"><a href="#pgloader转换规则中的坑" class="headerlink" title="pgloader转换规则中的坑"></a>pgloader转换规则中的坑</h4><p>假设mysql中有一个字段的类型为datetime,默认值为”0000-00-00 00:00:00” 如果转换规则写为<code>type datetime to timestamptz</code>此时pgloader并不会匹配上，因为pgloader必须全部匹配时，才会执行类型转换。可写为<code>cast type datetime when default &quot;0000-00-00 00:00:00&quot; to timestamptz</code>才能匹配,如果还有其它的限制也必须加上，如<code>with extra on update current timestamp</code>。这种情况和代码异常处理是不一样的。</p>
<hr>
<p>Ref： 1.<a href="https://pgloader.readthedocs.io/en/latest/ref/mysql.html" target="_blank" rel="noopener">https://pgloader.readthedocs.io/en/latest/ref/mysql.html</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>pandas数据类型Series及基本操作</title>
    <url>/2017/08/30/pandas%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BSeries%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>Series类型的数据由一列数据及与之对应的标签（索引，位于数据的左侧）两部分组成。Series对象本质上 是一个NumPy数组，因此NumPy的数组处理函数同样适用于Series对象。每个Series对象都具有index和values 两大属性。 - index:保存标签信息 - values:保存值 1.创建Series对象</p>
<pre><code>In [1]: import pandas as pd

In [2]: import numpy as np

In [3]: s1 = pd.Series()

In [4]: s1
Out[4]: Series([], dtype: float64)
</code></pre><p>2.Series对象的访问</p>
<pre><code>In [8]: s2 = pd.Series([1, 3, 5, 7, 9], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])

In [9]: s2
Out[9]: 
a    1
b    3
c    5
d    7
e    9
dtype: int64

In [10]: s2.values
Out[10]: array([1, 3, 5, 7, 9])

In [11]: s2.index
Out[11]: Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], dtype=&#39;object&#39;)

In [12]: s2[&#39;e&#39;]
Out[12]: 9
</code></pre><p>3.添加新元素</p>
<pre><code>In [13]: s2[&#39;f&#39;] = 66

In [14]: s2
Out[14]: 
a     1
b     3
c     5
d     7
e     9
f    66
dtype: int64
</code></pre><p>4.将字典对象转换为Series对象</p>
<pre><code>In [15]: pd.Series({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})
Out[15]: 
a    1
b    2
c    3
dtype: int64
</code></pre><p>5.Series对象的元素提取与切片</p>
<pre><code>obj.head(n=5) #默认查看对象的前五个数据
obj.tail(n=5) #默认查看对象最后五个数据
obj.take()    #通过传入索引值列表来提取元素

In [18]: s2.head()
Out[18]: 
a    1
b    3
c    5
d    7
e    9
dtype: int64

In [19]: s2.tail()
Out[19]: 
c     5
d     7
e     9
f    66
g    11
dtype: int64

In [20]: s2.take([2, 4, 0]) #指定索引值
Out[20]: 
c    5
e    9
a    1
dtype: int64
</code></pre><p>6.切片</p>
<pre><code>In [22]: s2[0:4] #位置切片，不包括结束位置
Out[22]: 
a    1
b    3
c    5
d    7
dtype: int64

In [23]: s2[&#39;a&#39;:&#39;d&#39;] #标签切片，包括结束位置
Out[23]: 
a    1
b    3
c    5
d    7
dtype: int64
</code></pre><p>7.时间序列 Timestamp对象由Pandas包中的Timestamp()来创建，参数可以为str类型，也可以为datetime类型。</p>
<pre><code>In [28]: date
Out[28]: datetime.datetime(2017, 9, 16, 0, 0)

In [29]: date = pd.Timestamp(date)

In [30]: date
Out[30]: Timestamp(&#39;2017-09-16 00:00:00&#39;)
</code></pre><p>通过to_datetime()将Series的index属性转换为DatetimeIndex(实际上对于datetime对象，我们可以直接 将其作为index，Pandas会自动将其转换成Timestamp对象</p>
<pre><code>In [31]: dates = [&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;]

In [32]: ts = pd.Series([1, 2, 3], index=pd.to_datetime(dates))

In [33]: ts
Out[33]: 
2017-01-01    1
2017-01-02    2
2017-01-03    3
dtype: int64

In [34]: ts.index
Out[34]: DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)
</code></pre><p>8.截取时间段数据</p>
<pre><code>In [35]: ts[&#39;20170101&#39;]
Out[35]: 1

In [36]: ts[&#39;2017-01-01&#39;]
Out[36]: 1

In [37]: ts[&#39;01/01/2017&#39;]
Out[37]: 1

In [38]: ts[&#39;2017&#39;]
Out[38]: 
2017-01-01    1
2017-01-02    2
2017-01-03    3
dtype: int64

In [39]: ts[&#39;2017-01&#39;: &#39;2017-02&#39;]
Out[39]: 
2017-01-01    1
2017-01-02    2
2017-01-03    3
dtype: int64

In [41]: ts.truncate(after=&#39;2017-01-02&#39;)
Out[41]: 
2017-01-01    1
2017-01-02    2
dtype: int64
</code></pre><p>9.滞后或者超前操作</p>
<pre><code>In [43]: ts.shift(1) #正数为滞后
Out[43]: 
2017-01-01    NaN   #2017-01-01的数据为前一项的数据，但前一项没有数据所以为NaN
2017-01-02    1.0   # 2017-01-02数据为2017-01-01的数据，所以为1
2017-01-03    2.0
dtype: float64


In [44]: ts.shift(-1)  #负数为超前
Out[44]: 
2017-01-01    2.0
2017-01-02    3.0
2017-01-03    NaN
dtype: float64
</code></pre><p>10.计算收益率</p>
<pre><code>In [45]: (ts - ts.shift(1))/ts.shift(1)
Out[45]: 
2017-01-01    NaN
2017-01-02    1.0
2017-01-03    0.5
dtype: float64


In [124]: a = pd.Series([&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])

In [125]: a.value_counts()
Out[125]:
a    2
b    1
c    1
dtype: int64
</code></pre>]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>pip3的一个bug</title>
    <url>/2019/03/11/pip3%E7%9A%84%E4%B8%80%E4%B8%AAbug/</url>
    <content><![CDATA[<p><img src="http://img.hysyeah.top/wp-content/uploads/2019/03/pip3.png" alt></p>
<pre><code>import sys

from pip import main
if __name__ == &#39;__main__&#39;:
    sys.exit(main())
</code></pre><h4 id="sudo-vim-usr-bin-pip3-将上面代码改为如下"><a href="#sudo-vim-usr-bin-pip3-将上面代码改为如下" class="headerlink" title="sudo vim /usr/bin/pip3 #将上面代码改为如下"></a>sudo vim /usr/bin/pip3 #将上面代码改为如下</h4><pre><code>import sys

from pip import __main__
if __name__ == &#39;__main__&#39;:
    sys.exit(__main__._main())
</code></pre><hr>
<p>Ref： 1.<a href="https://stackoverflow.com/questions/28210269/importerror-cannot-import-name-main-when-running-pip-version-command-in-windo" target="_blank" rel="noopener">stackoverflow</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>pg_dump和pg_restore的使用</title>
    <url>/2019/05/07/pg_dump%E5%92%8Cpg_restore%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><code>pg_dump</code>是用于<code>postgresql</code>数据备份的工具。即使数据库在并发的情况下也能保持一致性，并且不阻塞其它用户对数据库进行读和写。</p>
<pre><code>将表account和host表中数据dump到szd.dump文件中
pg_dump -n &#39;public&#39;  -Uroot --no-owner --no-privileges --host=100.2.2.1 --port=5432 --disable-triggers -d szd -t account -t host &gt; szd.dump

将数据恢复到指定的数据库中
pg_restore -n &#39;public&#39; -Uroot --no-owner --host=100.2.2.3 --port=6434 -t account -t host szd.dump
</code></pre><p>但是发再使用上述命令备份的并不包含索引，查看文档未发现可以恢复索引的选项。经实战发现如下方法可以备份索引，<br>1.通过<code>pg_dump</code>备份表的结构信息，<br>2.通过<code>psql</code>恢复表结构，<br>3.最后通过<code>pg_restore</code>恢复数据。</p>
<pre><code>1.备份表结构信息
pg_dump -n &#39;public&#39;  -Uroot --no-owner --schema-only --no-privileges --host=100.2.2.1 --port=5432 --disable-triggers -d szd -t account -t host &gt; szd2.dump

2.恢复表结构信息以及索引
psql -h100.2.2.3 -p6434 -Uroot szd &lt; szd2.dump

3.恢复数据
pg_restore -n &#39;public&#39; -Uroot --no-owner --data-only --host=100.2.2.3 --port=6434 -t account -t host szd.dump
</code></pre><hr>
<pre><code>create database ptldwh template template0; #To make an empty database without any local additions


pg_dump -Fc -v -n &#39;public&#39; --host=127.0.0.1 -p5433 --no-owner --no-privileges --username=ptldwhdata ptldwh -t host &gt;ptldwh.dump

-t &#39;t_*&#39; #指定要同步的表名

pg_restore -n &#39;public&#39; -Uroot --no-owner --no-privileges --disable-triggers -d ptldwh -t host ptldwh.dump
</code></pre><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n schema</td>
<td>指定schema,只备份schema下的数据</td>
</tr>
<tr>
<td>—data-only</td>
<td>只备份数据</td>
</tr>
<tr>
<td>—format=format</td>
<td>指定输出格式</td>
</tr>
<tr>
<td>-N schema</td>
<td>不备份此schema下的数据</td>
</tr>
<tr>
<td>—no-owner</td>
<td>不输出设置对象ownership的命令</td>
</tr>
<tr>
<td>—schema-only</td>
<td>只备份表结构信息</td>
</tr>
<tr>
<td>-t table</td>
<td>指定需要备份的表</td>
</tr>
<tr>
<td>-T table</td>
<td>不备份此表</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>Ref：<br>1.<a href="https://www.postgresql.org/docs/10/app-pgdump.html" target="_blank" rel="noopener">pg_dump</a><br>2.<a href="https://www.postgresql.org/docs/10/app-pgrestore.html" target="_blank" rel="noopener">pg_restore</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql元数据相关SQL</title>
    <url>/2019/06/01/postgresql%E5%85%83%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3SQL/</url>
    <content><![CDATA[<pre><code># 查看schemas
SELECT schema_name FROM information_schema.schemata;
SELECT nspname FROM pg_catalog.pg_namespace;


# 查看连接状态
SELECT * FROM pg_stat_activity;

# kill 连接数据库ptldwh的所有session
SELECT pg_terminate_backend(a.pid) FROM pg_stat_activity a WHERE datname=&#39;ptldwh&#39;;
</code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql中将所有的char改为varchar类型</title>
    <url>/2019/05/26/postgresql%E4%B8%AD%E5%B0%86%E6%89%80%E6%9C%89%E7%9A%84char%E6%94%B9%E4%B8%BAvarchar%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>在将<code>Postgresql</code>数据转换为<code>Neo4j</code>的过程中，<code>char</code>类型的字段的在转换成<code>Neo4j</code>的属性后会带有空格。比如<code>char(10)</code>字段的数据为<code>hello</code>在<code>Neo4j</code>属性中则会带有空格，虽然可以在查询的时候加上trim函数，但这样对于原来的查询代码改动太大。所以决定从源头将这个问题解决。 假如有一个字段为<code>char(10)</code>如果插入的数据长度未达到10,关系型数据库默认在后面添加空格，所以将<code>char</code>类型改为<code>varchar</code>可以解决这个问题。 在<code>char</code>类型改为<code>varchar</code>的过程中，会默认把<code>char</code>类型中的空格给去掉。 在<code>postgresql</code>中有一个表<code>information_schema.columns</code>记录了所有字段的信息，所以可以从这个表中提取信息进行<code>char</code>到<code>varchar</code>的转换。</p>
<pre><code># 这个语句会生成将char改为varchar的sql语句
SELECT CONCAT(&#39;alter table &#39;, table_schema, &#39;.&#39;, table_name, &#39; alter column &#39;, column_name, &#39; type &#39;, &#39;varchar &#39;, &#39;(&#39;,character_maxinum_length,&#39;);&#39;) from information_schema.columns where table_catalog=&#39;ptl&#39; and date_type=&#39;character&#39;;
</code></pre><p><code>information_schema.columns</code>中的常用字段。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>table_catalog</td>
<td>数据库名</td>
</tr>
<tr>
<td>table_schema</td>
<td>数据库的schema</td>
</tr>
<tr>
<td>table_name</td>
<td>表名</td>
</tr>
<tr>
<td>column_name</td>
<td>字段名</td>
</tr>
<tr>
<td>data_type</td>
<td>数据类型</td>
</tr>
<tr>
<td>character_maximum_length</td>
<td>如果类型为character或bit string type,则为可存储最大字符数</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>Ref：<br>1.<a href="https://www.postgresql.org/docs/10/infoschema-columns.html" target="_blank" rel="noopener">information_schema.columns</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>apue第一章:UNIX系统概览-笔记</title>
    <url>/2017/12/03/pue%E7%AC%AC%E4%B8%80%E7%AB%A0%20UNIX%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A7%88-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>1.unix架构</p>
<h6 id="狭义上说，操作系统被定义为可以利用-控制硬件资源和为程序提供运行环境。"><a href="#狭义上说，操作系统被定义为可以利用-控制硬件资源和为程序提供运行环境。" class="headerlink" title="狭义上说，操作系统被定义为可以利用,控制硬件资源和为程序提供运行环境。"></a>狭义上说，操作系统被定义为可以利用,控制硬件资源和为程序提供运行环境。</h6><h6 id="广义上说，操作系统就是通过内核和其实相关软件使电脑可以被使用和拥有其属性。"><a href="#广义上说，操作系统就是通过内核和其实相关软件使电脑可以被使用和拥有其属性。" class="headerlink" title="广义上说，操作系统就是通过内核和其实相关软件使电脑可以被使用和拥有其属性。"></a>广义上说，操作系统就是通过内核和其实相关软件使电脑可以被使用和拥有其属性。</h6><p><img src="http://img.hysyeah.top/wp-content/uploads/2017/11/QQ图片20171127185444.png" alt="image"></p>
<hr>
<p>2.用户登录</p>
<h6 id="当用户进行登录操作时，系统会从密码文件中查找用户名，通常这个文件为-etc-passwd-后面的操作系统把加密后的密码存放在-etc-shadow中-etc-shadow介绍。"><a href="#当用户进行登录操作时，系统会从密码文件中查找用户名，通常这个文件为-etc-passwd-后面的操作系统把加密后的密码存放在-etc-shadow中-etc-shadow介绍。" class="headerlink" title="当用户进行登录操作时，系统会从密码文件中查找用户名，通常这个文件为/etc/passwd,后面的操作系统把加密后的密码存放在/etc/shadow中,/etc/shadow介绍。"></a>当用户进行登录操作时，系统会从密码文件中查找用户名，通常这个文件为/etc/passwd,后面的操作系统把加密后的密码存放在/etc/shadow中,<a href="http://img.hysyeah.top/2017/11/13/etcshadow%E5%8F%8A%E7%9B%B8%E5%85%B3c%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">/etc/shadow介绍</a>。</h6><pre><code># /etc/passwd
hys:x:1000:1000:hys,,,:/home/hys:/bin/zsh
</code></pre><div class="table-container">
<table>
<thead>
<tr>
<th>用户名</th>
<th>加密后密码</th>
<th>用户ID</th>
<th>组ID</th>
<th>注释字段</th>
<th>home目录</th>
<th>shell</th>
</tr>
</thead>
<tbody>
<tr>
<td>hys</td>
<td>x</td>
<td>1000</td>
<td>1000</td>
<td>hys,,,</td>
<td>/home/hys/</td>
<td>/bin/zsh</td>
</tr>
</tbody>
</table>
</div>
<pre><code># 打印出系统中的所有用户
cat /etc/passwd | awk -F : &#39;{print $1}&#39;
</code></pre><hr>
<p>3.以’/‘开头的路径叫<strong>绝对路径</strong>，反之都是<strong>相对路径</strong>。</p>
<hr>
<p>4.输入，输出</p>
<h6 id="文件描述符，通常是一个非负数，内核用于标识被特定进程访问的文件。"><a href="#文件描述符，通常是一个非负数，内核用于标识被特定进程访问的文件。" class="headerlink" title="文件描述符，通常是一个非负数，内核用于标识被特定进程访问的文件。"></a>文件描述符，通常是一个非负数，内核用于标识被特定进程访问的文件。</h6><h6 id="无论何时运行一个程序，shell都会打开三个描述符-标准输入，标准输出，标准错误。"><a href="#无论何时运行一个程序，shell都会打开三个描述符-标准输入，标准输出，标准错误。" class="headerlink" title="无论何时运行一个程序，shell都会打开三个描述符:标准输入，标准输出，标准错误。"></a>无论何时运行一个程序，shell都会打开三个描述符:标准输入，标准输出，标准错误。</h6><h6 id="无缓冲I-O，不使用缓冲的输入-输出，如系统调用-open-read-write-lseek-close。"><a href="#无缓冲I-O，不使用缓冲的输入-输出，如系统调用-open-read-write-lseek-close。" class="headerlink" title="无缓冲I/O，不使用缓冲的输入/输出，如系统调用:open,read,write,lseek,close。"></a>无缓冲I/O，不使用缓冲的输入/输出，如系统调用:open,read,write,lseek,close。</h6><hr>
<p>5.程序和进程</p>
<h6 id="程序是指存储在磁盘中的可执行文件。"><a href="#程序是指存储在磁盘中的可执行文件。" class="headerlink" title="程序是指存储在磁盘中的可执行文件。"></a>程序是指存储在磁盘中的可执行文件。</h6><h6 id="程序的执行实例称为进程，进程ID用于标识进程的唯一非负数。"><a href="#程序的执行实例称为进程，进程ID用于标识进程的唯一非负数。" class="headerlink" title="程序的执行实例称为进程，进程ID用于标识进程的唯一非负数。"></a>程序的执行实例称为进程，进程ID用于标识进程的唯一非负数。</h6><h6 id="线程，通常一个进程只有一个线程，多线程可以提高对多核处理器的利用。在同一进程中的所有线程共享相同的地址空间，文件描述符，栈和进程相关属性。"><a href="#线程，通常一个进程只有一个线程，多线程可以提高对多核处理器的利用。在同一进程中的所有线程共享相同的地址空间，文件描述符，栈和进程相关属性。" class="headerlink" title="线程，通常一个进程只有一个线程，多线程可以提高对多核处理器的利用。在同一进程中的所有线程共享相同的地址空间，文件描述符，栈和进程相关属性。"></a>线程，通常一个进程只有一个线程，多线程可以提高对多核处理器的利用。在同一进程中的所有线程共享相同的地址空间，文件描述符，栈和进程相关属性。</h6><p><img src="http://img.hysyeah.top/wp-content/uploads/2017/12/1.png" alt="image"> 图片来源：&lt;&lt;程序员的自我修养&gt;&gt;</p>
<hr>
<p>6.用户标识</p>
<h6 id="User-ID非负数，系统用于标识用户"><a href="#User-ID非负数，系统用于标识用户" class="headerlink" title="User ID非负数，系统用于标识用户"></a>User ID非负数，系统用于标识用户</h6><h6 id="Group-ID，组ID，用于用户分组"><a href="#Group-ID，组ID，用于用户分组" class="headerlink" title="Group ID，组ID，用于用户分组"></a>Group ID，组ID，用于用户分组</h6><pre><code># /etc/group
adm:x:4:syslog,hys
</code></pre><div class="table-container">
<table>
<thead>
<tr>
<th>组名</th>
<th>口令</th>
<th>组ID</th>
<th>所属组用户(用,隔开)</th>
</tr>
</thead>
<tbody>
<tr>
<td>adm</td>
<td>x</td>
<td>4</td>
<td>syslog,hys</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>7.信号</p>
<h6 id="信号的三种处理方式：1-忽略，2-默认动作，3-提供自定义动作"><a href="#信号的三种处理方式：1-忽略，2-默认动作，3-提供自定义动作" class="headerlink" title="信号的三种处理方式：1.忽略，2.默认动作，3.提供自定义动作"></a>信号的三种处理方式：1.忽略，2.默认动作，3.提供自定义动作</h6><p>8.时间值</p>
<h6 id="Clock-time，程序运行所消耗的时间"><a href="#Clock-time，程序运行所消耗的时间" class="headerlink" title="Clock time，程序运行所消耗的时间"></a>Clock time，程序运行所消耗的时间</h6><h6 id="User-CPU-time-进程获得CPU资源后，在用户态的执行时间"><a href="#User-CPU-time-进程获得CPU资源后，在用户态的执行时间" class="headerlink" title="User CPU time,进程获得CPU资源后，在用户态的执行时间"></a>User CPU time,进程获得CPU资源后，在用户态的执行时间</h6><h6 id="System-CPU-time-进程获得CPU资源后，在内核态的执行时间"><a href="#System-CPU-time-进程获得CPU资源后，在内核态的执行时间" class="headerlink" title="System CPU time,进程获得CPU资源后，在内核态的执行时间"></a>System CPU time,进程获得CPU资源后，在内核态的执行时间</h6><hr>
<p>9.系统调用与库函数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统调用</th>
<th>库函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>数量有限</td>
<td>数量较多</td>
</tr>
<tr>
<td>直接调用内核服务</td>
<td>不能直接调用内核服务</td>
</tr>
<tr>
<td>精简高效，只提供最底层服务</td>
<td>对用户友好，属于用户层函数</td>
</tr>
<tr>
<td>c函数</td>
<td>c函数</td>
</tr>
<tr>
<td>不可替换</td>
<td>库函数可替换，而系统调用不可</td>
</tr>
</tbody>
</table>
</div>
<p><img src="http://img.hysyeah.top/wp-content/uploads/2017/12/c-library.png" alt="image"></p>
]]></content>
      <categories>
        <category>apue</category>
      </categories>
      <tags>
        <tag>apue</tag>
      </tags>
  </entry>
  <entry>
    <title>pyplot.pie</title>
    <url>/2017/11/27/pyplot-pie/</url>
    <content><![CDATA[<p>matplotlib.pyplot.pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False, hold=None, data=None) 根据数组x绘制饼图 explode:数组扇形离圆点的距离(爆炸出来的那部分) labels:标题 colors:颜色 autopct:饼图扇区面积所显示的文字 shadow:阴影 startangle: title:图标题</p>
<hr>
<pre><code>import matplotlib.pyplot as plt

# Pie chart, where the slices will be ordered and plotted counter-clockwise:
labels = &#39;Frogs&#39;, &#39;Hogs&#39;, &#39;Dogs&#39;, &#39;Logs&#39;
sizes = [15, 30, 45, 10]
explode = (0, 0.1, 0, 0)  # only &quot;explode&quot; the 2nd slice (i.e. &#39;Hogs&#39;)

fig1, ax1 = plt.subplots()
ax1.pie(sizes, explode=explode, labels=labels, autopct=&#39;%1.1f%%&#39;,
        shadow=True, startangle=90) #autopct 扇形区域显示的文字格式
ax1.axis(&quot;equal&quot;)  # Equal aspect ratio ensures that pie is drawn as a circle.

plt.show()
</code></pre><p><img src="http://matplotlib.org/mpl_examples/pie_and_polar_charts/pie_demo_features.png" alt="image"></p>
<hr>
<pre><code>#通过两个饼图绘制双层饼图
import matplotlib.pyplot as plt

vals1 = [1]
vals2 = [1, 1, 2]
vals3 = [1]
vals4 = [1]

fig, ax = plt.subplots()
labels = &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;

ax.pie(vals1, radius=1.2)
ax.pie(vals2, radius=1.0,startangle=90)
ax.pie(vals3, radius=0.8)
ax.pie(vals4, radius=0.4)
ax.set(aspect=&quot;equal&quot;)
plt.show()
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2017/11/QQ图片20171127185444.png" alt="image"></p>
<hr>
<p>Ref： 1.<a href="https://zhuanlan.zhihu.com/p/27442584" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27442584</a> 2.<a href="http://matplotlib.org/api/pyplot_api.html" target="_blank" rel="noopener">http://matplotlib.org/api/pyplot_api.html</a></p>
]]></content>
      <categories>
        <category>pyplot</category>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>postgresql设置远程连接</title>
    <url>/2019/06/03/postgresql%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h5 id="1-vim-var-lib-pgsql-10-data-pg-hba-conf-文件所在的目录可能会不一样"><a href="#1-vim-var-lib-pgsql-10-data-pg-hba-conf-文件所在的目录可能会不一样" class="headerlink" title="1.vim /var/lib/pgsql/10/data/pg_hba.conf(文件所在的目录可能会不一样)"></a>1.vim /var/lib/pgsql/10/data/pg_hba.conf(文件所在的目录可能会不一样)</h5><ul>
<li><p>添加一行</p>
<p>host    all     all     0.0.0.0/0       md5</p>
</li>
</ul>
<h5 id="2-vim-var-lib-pgsql-data-postgresql-conf"><a href="#2-vim-var-lib-pgsql-data-postgresql-conf" class="headerlink" title="2.vim /var/lib/pgsql/data/postgresql.conf"></a>2.vim /var/lib/pgsql/data/postgresql.conf</h5><p><code>listen_addresses</code>修改为如下：</p>
<pre><code>listen_addresses = &#39;*&#39;
</code></pre><h5 id="3-重启服务"><a href="#3-重启服务" class="headerlink" title="3.重启服务"></a>3.重启服务</h5><p><code>pg_ctl restart</code></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>pip使用豆瓣源</title>
    <url>/2017/09/15/pip%E4%BD%BF%E7%94%A8%E8%B1%86%E7%93%A3%E6%BA%90/</url>
    <content><![CDATA[<p>将pip源修改为豆瓣源 vim ~/.pip/pip.conf 没有则新建 添加如下内容: [global]</p>
<pre><code>index-url = http://pypi.douban.com/simple --trusted-host = pypi.douban.com
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2017/09/douban.jpg" alt="image"> 2.临时更换</p>
<pre><code>sudo pip install pudb -i http://pypi.douban.com/simple --trusted-host=pypi.douban.com
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>python GIL与线程调度</title>
    <url>/2018/08/03/python%20GIL%E4%B8%8E%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<p>GIL(Global Interpreter Lock)-全局解释锁，python使用GIL来互斥线程对python虚拟机的使用，同一时间只能并且仅有一个线程使用python虚拟机。</p>
<h4 id="为什么要使用GIL"><a href="#为什么要使用GIL" class="headerlink" title="为什么要使用GIL"></a>为什么要使用GIL</h4><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/threadab.png" alt> 假设有两个线程A、B，在两个线程中，都同时保存着对内存中同一对象obj的引用，也就是说，这时obj-&gt;ob_refcnt的值为2。如果A销毁对obj的引用，显然，A将通过Py_DECREF调整obj的引用计数值。Py_DECREF的整个 动作可以分为两个部分：</p>
<pre><code>--obj-&gt;ob_refcnt;
if(obj-&gt;ob_refcnt == 0) destory object and free memory
</code></pre><p>如果A在执行完第一个动作之后，obj-&gt;ob_refcnt的值变为1。若此时线程A被挂起，而唤醒了B线程。如果B同样也开始销毁对obj的引用。B完成第一动作之后，obj-&gt;ob_refcnt为0，若此时B没有被线程调度打断，而是顺利地完成了接下来的第二个动作，将对象销毁，内存释放。然后A又被重新唤醒，obj-&gt;ob_refcnt已经被B减少到0，而不是当初的1。此时A开始对已经销毁的对象进行对象销毁和内存释放动作。这将会发生意外。。 为了支持多线程机制，一个基本的要求就是需要实现不同线程对共享资源访问的互斥，所以引入了GIL。</p>
<hr>
<p>python线程的调度 python会在两个情况下启动线程调度机制 1.线程执行完成，释放全局锁 2.当python执行了N条指令后会立即启动线程调度机制。这个值可以通过sys.getcheckinterval()获取。</p>
<pre><code>In [3]: sys.getcheckinterval()
/usr/local/bin/ipython:1: DeprecationWarning: sys.getcheckinterval() and sys.setcheckinterval() are deprecated.  Use sys.getswitchinterval() instead.
  #!/usr/bin/python3
Out[3]: 100
</code></pre><p>从python3.2开始这个函数已经被废弃了，改用sys.getswitchinterval()，调度间隔时间改为了0.005秒。</p>
<pre><code>In [4]: sys.getswitchinterval()
Out[4]: 0.005
</code></pre><hr>
<p>Ref： 1.python源码剖析—深度探索动态语言核心技术 2.<a href="https://docs.python.org/3/library/sys.html#sys.getswitchinterval" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>pyplot.[xcorr,acorr]</title>
    <url>/2017/11/26/pyplot-xcorracorr/</url>
    <content><![CDATA[<p>自相关（英语：Autocorrelation），也叫序列相关[1]，是一个信号于其自身在不同时间点的互相关。非正式地来说，它就是两次观察之间的相似度对它们之间的时间差的函数。它是找出重复模式（如被噪声掩盖的周期信号），或识别隐含在信号谐波频率中消失的基频的数学工具。它常用于信号处理中，用来分析函数或一系列值，如时域信号。 在统计学中，互相关有时用来表示两个随机矢量X和Y之间的协方差cov（X, Y），以与矢量X的“协方差”概念相区分，矢量X的“协方差”是X的各标量成分之间的协方差矩阵。 在信号处理领域中，互相关（有时也称为“互协方差”）是用来表示两个信号之间相似性的一个度量，通常通过与已知信号比较用于寻找未知信号中的特性。它是两个信号之间相对于时间的一个函数，有时也称为滑动点积，在模式识别以及密码分析学领域都有应用。</p>
<pre><code>matplotlib.pyplot.acorr(x, hold=None, data=None, **kwargs) #x的自相关

matplotlib.pyplot.xcorr(x, y, normed=True, detrend=&lt;function detrend_none&gt;, usevlines=True, maxlags=10, hold=None, data=None, **kwargs) #画出x与y的互相关关系



import matplotlib.pyplot as plt
import numpy as np

np.random.seed(0) #用于指定随机数生成时所用算法开始的整数值，如果使用相同的seed( )值，则每次生成的随即数都相同，如果不设置这个值，则系统根据时间来自己选择这个值，此时每次生成的随机数因时间差异而不同

x, y = np.random.randn(2, 100)#返回一个二维，长度为100的数组
fig = plt.figure() #添加一个画布
ax1 = fig.add_subplot(211)#添加个子图，两行一列中的第一个图
ax1.xcorr(x, y, usevlines=True, maxlags=50, normed=True, lw=2)#互相关函数
ax1.grid(True) #添加网格
ax1.axhline(0, color=&#39;black&#39;, lw=2)

ax2 = fig.add_subplot(212, sharex=ax1)
ax2.acorr(x, usevlines=True, normed=True, maxlags=50, lw=2)#自相关函数
ax2.grid(True)
ax2.axhline(0, color=&#39;black&#39;, lw=2)

plt.show()
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2017/11/QQ图片20171118102729.png" alt="image"></p>
<hr>
<p>Ref： 1.<a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.xcorr" target="_blank" rel="noopener">http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.xcorr</a></p>
]]></content>
      <categories>
        <category>pyplot</category>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>python c  PyLongObject定义及实现1</title>
    <url>/2017/12/12/python%20c%20%20PyLongObject%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%AE%9E%E7%8E%B01/</url>
    <content><![CDATA[<pre><code>typedef PY_UINT32_T digit;
#define PyObject_VAR_HEAD               \
    PyObject_HEAD                       \
    Py_ssize_t ob_size;

struct _longobject {
    PyObject_VAR_HEAD
    digit ob_digit[1];
};
typedef struct _longobject PyLongObject;
</code></pre><p>PyLongObject对象除了引用计数ob_refcnt,*ob_type指针，与PyIntObject不同的是，通过动态改变ob_digit数组的大小，以实现任意精度的长整形。 PyLongObject对象的绝对值表示为</p>
<pre><code>SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)
</code></pre><p>当数值为0L时，ob_size = 0，不会为ob_digit数组分配内存。 当数值为负数时，ob_size &lt; 0; 当创建一个PyLongObject时，内存分配函数会为ob_digit数组分配足够的空间，所以ob_digit[0] … ob_digit[abs(ob_size)-1]是有效的。 <a href="http://img.hysyeah.top/2017/12/12/%E4%B8%BA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%A4%A7%E5%B0%8F/" target="_blank" rel="noopener">为结构体的成员数组动态分配大小</a></p>
]]></content>
      <categories>
        <category>python源码</category>
      </categories>
  </entry>
  <entry>
    <title>python c  PyLongObject定义及实现2</title>
    <url>/2017/12/17/python%20c%20%20PyLongObject%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%AE%9E%E7%8E%B02/</url>
    <content><![CDATA[<pre><code>/*根据长整型生成python PyLongObject对象*/
PyObject* PyLong_FromLong(long v) 
</code></pre><p>通过这个函数我们来了解python是怎么构造一个PyLongObject对象。 PyLong_FromLong函数源码</p>
<pre><code>/*在64位系统中PyLong_SHIFT=30,*/
#define PyLong_BASE    ((digit)1 &lt;&lt; PyLong_SHIFT)
#define PyLong_MASK    ((digit)(PyLong_BASE - 1))
PyObject *
PyLong_FromLong(long ival)
{
    PyLongObject *v;
    unsigned long abs_ival;
    unsigned long t;  /* unsigned so &gt;&gt; doesn&#39;t propagate sign bit */
    int ndigits = 0;
    int negative = 0;

    if (ival &lt; 0) {
        /* if LONG_MIN == -LONG_MAX-1 (true on most platforms) then
           ANSI C says that the result of -ival is undefined when ival
           == LONG_MIN.  Hence the following workaround. */
        abs_ival = (unsigned long)(-1-ival) + 1;
        negative = 1;
    }
    else {
        abs_ival = (unsigned long)ival;
    }

    /* Count the number of Python digits.
       We used to pick 5 (&quot;big enough for anything&quot;), but that&#39;s a
       waste of time and space given that 5*15 = 75 bits are rarely
       needed. */
    t = abs_ival;
    while (t) {
        ++ndigits;
        t &gt;&gt;= PyLong_SHIFT;
    }
    v = _PyLong_New(ndigits);//为PyLongObject对象分配内存
    if (v != NULL) {
        digit *p = v-&gt;ob_digit;
        v-&gt;ob_size = negative ? -ndigits : ndigits;
        t = abs_ival;
        while (t) {
            *p++ = (digit)(t &amp; PyLong_MASK);
            t &gt;&gt;= PyLong_SHIFT;
        }
    }
    return (PyObject *)v;
}
</code></pre><hr>
<p>转换成可以单独执行的C代码</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define base ((unsigned int)1 &lt;&lt;30)
#define mask ((unsigned int)(base-1))

int main(int argc, char *argv[]){
    unsigned int abs_ival;
    unsigned int t;
    int ndigits = 0;
    int i;
    abs_ival = (1&lt;&lt;32) - 1 ;
    t = abs_ival;
    while(t){
        ++ndigits;
        t &gt;&gt;=30;
    }
    unsigned int ob_digit[ndigits];
    unsigned int *p = ob_digit;
    t = abs_ival;
    while(t){
        *p++ = (unsigned int)(t &amp; mask);
        t &gt;&gt;= 30;
    }

    for(i=0;i&lt;ndigits;i++)
        printf(&quot;%u\t&quot;,ob_digit[i]);
    printf(&quot;\n&quot;);
   abs_ival = 0; 
   //根据数组ob_digit[]中的值，打印出原始值
   for(i=0;i&lt;ndigits;i++)
       abs_ival += ob_digit[i] * pow(2,30*i);//or:abs_ival += ob_digit[i]*(1&lt;&lt;(30*i));

   printf(&quot;%u\n&quot;,abs_ival);

   return 0;
}
gcc longo.c -lm //不加-lm则会报错
out:
1073741823  3   
4294967295
</code></pre><hr>
<p>base = 0x40000000 mask = 0x3fffffff abs_ival = 0xffffffff ob_digit中元素的最大值为(2**30)-1</p>
<hr>
<p>？PyLong_SHIFT为什么是30。 Ref：python2.7源码</p>
]]></content>
      <categories>
        <category>python源码</category>
      </categories>
  </entry>
  <entry>
    <title>python C API 迭代器</title>
    <url>/2017/12/02/python%20C%20API%20%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<pre><code>#include &lt;stdio.h&gt;
#include &quot;python3.5m/Python.h&quot;
int main(int argc, char* argv[]){
    long v;
    Py_Initialize();
    PyObject *t, *item;
    t = PyList_New(3);
    PyList_SetItem(t, 0, PyLong_FromLong(1L));
    PyList_SetItem(t, 1, PyLong_FromLong(2L));
    PyList_SetItem(t, 2, PyLong_FromLong(3L));
    PyObject *iterator = PyObject_GetIter(t);
    if (iterator == NULL){
        printf(&quot;error\n&quot;);
    }
    while (item = PyIter_Next(iterator)){
       v = PyLong_AsLong(item);
       printf(&quot;%ld\n&quot;, v);
       Py_DECREF(item);
    }
    Py_DECREF(iterator);
    Py_Finalize();
    return 0;
}

output:
1
2
3
</code></pre><hr>
<pre><code>/*返回迭代器对象*/
PyObject* PyObject_GetIter(PyObject *o)

/*获取迭代器o的下 一个值*/
PyObject* PyIter_Next(PyObject *o)

/*将python对象转换为c long*/
long PyLong_AsLong(PyObject *pylong)
</code></pre>]]></content>
      <categories>
        <category>python源码</category>
      </categories>
  </entry>
  <entry>
    <title>python c相关结构体</title>
    <url>/2017/12/09/python%20c%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<pre><code>/*object.h*/
#define PyObject_HEAD                   \
    Py_ssize_t ob_refcnt;               \
    struct _typeobject *ob_type;

typedef struct _object {
    PyObject_HEAD
} PyObject;

typedef struct {
    Py_ssize_t ob_refcnt;              
    struct _typeobject *ob_type;
    Py_ssize_t ob_size;  //容纳元素的个数
} PyVarObject;


/*intobject.h*/
typedef struct {
    PyObject_HEAD
    long ob_ival;
} PyIntObject;



/*listobject.h*/
typedef struct {
    PyObject_VAR_HEAD
    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
    PyObject **ob_item;

    /* ob_item contains space for &#39;allocated&#39; elements.  The number
     * currently in use is ob_size.
     * Invariants:
     *     0 &lt;= ob_size &lt;= allocated
     *     len(list) == ob_size
     *     ob_item == NULL implies ob_size == allocated == 0
     * list.sort() temporarily sets allocated to -1 to detect mutations.
     *
     * Items must normally not be NULL, except during construction when
     * the list is not yet visible outside the function that builds it.
     */
    Py_ssize_t allocated;
} PyListObject;


/*iterobject.c*/
typedef struct {
    PyObject_HEAD
    long      it_index;
    PyObject *it_seq; /* Set to NULL when iterator is exhausted */
} seqiterobject;



/*funcobject.h*/
typedef struct {
    PyObject_HEAD
    PyObject *func_code;  /* A code object */
    PyObject *func_globals; /* A dictionary (other mappings won&#39;t do) */
    PyObject *func_defaults;  /* NULL or a tuple */
    PyObject *func_closure; /* NULL or a tuple of cell objects */
    PyObject *func_doc;   /* The __doc__ attribute, can be anything */
    PyObject *func_name;  /* The __name__ attribute, a string object */
    PyObject *func_dict;  /* The __dict__ attribute, a dict or NULL */
    PyObject *func_weakreflist; /* List of weak references */
    PyObject *func_module;  /* The __module__ attribute, can be anything */

    /* Invariant:
     *     func_closure contains the bindings for func_code-&gt;co_freevars, so
     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)
     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).
     */
} PyFunctionObject;



/*genobject.h*/
typedef struct {
  PyObject_HEAD
  /* The gi_ prefix is intended to remind of generator-iterator. */

  /* Note: gi_frame can be NULL if the generator is &quot;finished&quot; */
  struct _frame *gi_frame;

  /* True if generator is being executed. */
  int gi_running;

  /* The code object backing the generator */
  PyObject *gi_code;

  /* List of weak reference. */
  PyObject *gi_weakreflist;
} PyGenObject;



/*fileobject.h*/
typedef struct {
    PyObject_HEAD
    FILE *f_fp;
    PyObject *f_name;
    PyObject *f_mode;
    int (*f_close)(FILE *);
    int f_softspace;            /* Flag used by &#39;print&#39; command */
    int f_binary;               /* Flag which indicates whether the file is
                               open in binary (1) or text (0) mode */
    char* f_buf;                /* Allocated readahead buffer */
    char* f_bufend;             /* Points after last occupied position */
    char* f_bufptr;             /* Current buffer position */
    char *f_setbuf;             /* Buffer for setbuf(3) and setvbuf(3) */
    int f_univ_newline;         /* Handle any newline convention */
    int f_newlinetypes;         /* Types of newlines seen */
    int f_skipnextlf;           /* Skip next \n */
    PyObject *f_encoding;
    PyObject *f_errors;
    PyObject *weakreflist; /* List of weak references */
    int unlocked_count;         /* Num. currently running sections of code
                               using f_fp with the GIL released. */
    int readable;
    int writable;
} PyFileObject;



/*floatobject.h*/
typedef struct {
    PyObject_HEAD
    double ob_fval;
} PyFloatObject;



/*frameobject.h*/
typedef struct {
    int b_type;     /* what kind of block this is */
    int b_handler;    /* where to jump to find handler */
    int b_level;    /* value stack level to pop to */
} PyTryBlock;

typedef struct _frame {
    PyObject_VAR_HEAD
    struct _frame *f_back;  /* previous frame, or NULL */
    PyCodeObject *f_code; /* code segment */
    PyObject *f_builtins; /* builtin symbol table (PyDictObject) */
    PyObject *f_globals;  /* global symbol table (PyDictObject) */
    PyObject *f_locals;   /* local symbol table (any mapping) */
    PyObject **f_valuestack;  /* points after the last local */
    /* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.
       Frame evaluation usually NULLs it, but a frame that yields sets it
       to the current stack top. */
    PyObject **f_stacktop;
    PyObject *f_trace;    /* Trace function */

    /* If an exception is raised in this frame, the next three are used to
     * record the exception info (if any) originally in the thread state.  See
     * comments before set_exc_info() -- it&#39;s not obvious.
     * Invariant:  if _type is NULL, then so are _value and _traceback.
     * Desired invariant:  all three are NULL, or all three are non-NULL.  That
     * one isn&#39;t currently true, but &quot;should be&quot;.
     */
    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;

    PyThreadState *f_tstate;
    int f_lasti;    /* Last instruction if called */
    /* Call PyFrame_GetLineNumber() instead of reading this field
       directly.  As of 2.3 f_lineno is only valid when tracing is
       active (i.e. when f_trace is set).  At other times we use
       PyCode_Addr2Line to calculate the line from the current
       bytecode index. */
    int f_lineno;   /* Current line number */
    int f_iblock;   /* index in f_blockstack */
    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */
    PyObject *f_localsplus[1];  /* locals+stack, dynamically sized */
} PyFrameObject;



/*classobject.h*/
typedef struct {
    PyObject_HEAD
    PyObject  *cl_bases;  /* A tuple of class objects */
    PyObject  *cl_dict; /* A dictionary */
    PyObject  *cl_name; /* A string */
    /* The following three are functions or NULL */
    PyObject  *cl_getattr;
    PyObject  *cl_setattr;
    PyObject  *cl_delattr;
    PyObject    *cl_weakreflist; /* List of weak references */
} PyClassObject;
typedef struct {
    PyObject_HEAD
    PyClassObject *in_class;  /* The class object */
    PyObject    *in_dict; /* A dictionary */
    PyObject    *in_weakreflist; /* List of weak references */
} PyInstanceObject;
typedef struct {
    PyObject_HEAD
    PyObject *im_func;   /* The callable object implementing the method */
    PyObject *im_self;   /* The instance it is bound to, or NULL */
    PyObject *im_class;  /* The class that asked for the method */
    PyObject *im_weakreflist; /* List of weak references */
} PyMethodObject;



/*dictobject.h*/
typedef struct {
    /* Cached hash code of me_key.  Note that hash codes are C longs.
     * We have to use Py_ssize_t instead because dict_popitem() abuses
     * me_hash to hold a search finger.
     */
    Py_ssize_t me_hash;
    PyObject *me_key;
    PyObject *me_value;
} PyDictEntry;
typedef struct _dictobject PyDictObject;
struct _dictobject {
    PyObject_HEAD
    Py_ssize_t ma_fill;  /* # Active + # Dummy */
    Py_ssize_t ma_used;  /* # Active */

    /* The table contains ma_mask + 1 slots, and that&#39;s a power of 2.
     * We store the mask instead of the size because the mask is more
     * frequently needed.
     */
    Py_ssize_t ma_mask;

    /* ma_table points to ma_smalltable for small tables, else to
     * additional malloc&#39;ed memory.  ma_table is never NULL!  This rule
     * saves repeated runtime null-tests in the workhorse getitem and
     * setitem calls.
     */
    PyDictEntry *ma_table;
    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
    PyDictEntry ma_smalltable[PyDict_MINSIZE];
};




/*funcobject.h*/
typedef struct {
    PyObject_HEAD
    PyMethodDef *m_ml; /* Description of the C function to call */
    PyObject    *m_self; /* Passed as &#39;self&#39; arg to the C func, can be NULL */
    PyObject    *m_module; /* The __module__ attribute, can be anything */
} PyCFunctionObject;


/*code.h*/
/* Bytecode object */
typedef struct {
    PyObject_HEAD
    int co_argcount;    /* #arguments, except *args */
    int co_nlocals;   /* #local variables */
    int co_stacksize;   /* #entries needed for evaluation stack */
    int co_flags;   /* CO_..., see below */
    PyObject *co_code;    /* instruction opcodes */
    PyObject *co_consts;  /* list (constants used) */
    PyObject *co_names;   /* list of strings (names used) */
    PyObject *co_varnames;  /* tuple of strings (local variable names) */
    PyObject *co_freevars;  /* tuple of strings (free variable names) */
    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */
    /* The rest doesn&#39;t count for hash/cmp */
    PyObject *co_filename;  /* string (where it was loaded from) */
    PyObject *co_name;    /* string (name, for reference) */
    int co_firstlineno;   /* first source line number */
    PyObject *co_lnotab;  /* string (encoding addr&lt;-&gt;lineno mapping) See
           Objects/lnotab_notes.txt for details. */
    void *co_zombieframe;     /* for optimization only (see frameobject.c) */
    PyObject *co_weakreflist;   /* to support weakrefs to code objects */
} PyCodeObject;


/*object.h*/
typedef struct _typeobject {
    PyObject_VAR_HEAD
    const char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */
    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

    /* Methods to implement standard operations */

    destructor tp_dealloc;
    printfunc tp_print;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    cmpfunc tp_compare;
    reprfunc tp_repr;

    /* Method suites for standard classes */

    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;

    /* More standard operations (here for binary compatibility) */

    hashfunc tp_hash;
    ternaryfunc tp_call;
    reprfunc tp_str;
    getattrofunc tp_getattro;
    setattrofunc tp_setattro;

    /* Functions to access object as input/output buffer */
    PyBufferProcs *tp_as_buffer;

    /* Flags to define presence of optional/expanded features */
    long tp_flags;

    const char *tp_doc; /* Documentation string */

    /* Assigned meaning in release 2.0 */
    /* call function for all accessible objects */
    traverseproc tp_traverse;

    /* delete references to contained objects */
    inquiry tp_clear;

    /* Assigned meaning in release 2.1 */
    /* rich comparisons */
    richcmpfunc tp_richcompare;

    /* weak reference enabler */
    Py_ssize_t tp_weaklistoffset;

    /* Added in release 2.2 */
    /* Iterators */
    getiterfunc tp_iter;
    iternextfunc tp_iternext;

    /* Attribute descriptor and subclassing stuff */
    struct PyMethodDef *tp_methods;
    struct PyMemberDef *tp_members;
    struct PyGetSetDef *tp_getset;
    struct _typeobject *tp_base;
    PyObject *tp_dict;
    descrgetfunc tp_descr_get;
    descrsetfunc tp_descr_set;
    Py_ssize_t tp_dictoffset;
    initproc tp_init;
    allocfunc tp_alloc;
    newfunc tp_new;
    freefunc tp_free; /* Low-level free-memory routine */
    inquiry tp_is_gc; /* For PyObject_IS_GC */
    PyObject *tp_bases;
    PyObject *tp_mro; /* method resolution order */
    PyObject *tp_cache;
    PyObject *tp_subclasses;
    PyObject *tp_weaklist;
    destructor tp_del;

    /* Type attribute cache version tag. Added in version 2.6 */
    unsigned int tp_version_tag;

#ifdef COUNT_ALLOCS
    /* these must be last and never explicitly initialized */
    Py_ssize_t tp_allocs;
    Py_ssize_t tp_frees;
    Py_ssize_t tp_maxalloc;
    struct _typeobject *tp_prev;
    struct _typeobject *tp_next;
#endif
} PyTypeObject;



/*longintrepr.h*/
/* Long integer representation.
   The absolute value of a number is equal to
    SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)
   Negative numbers are represented with ob_size &lt; 0;
   zero is represented by ob_size == 0.
   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant
   digit) is never zero.  Also, in all cases, for all valid i,
    0 &lt;= ob_digit[i] &lt;= MASK.
   The allocation function takes care of allocating extra memory
   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.

   CAUTION:  Generic code manipulating subtypes of PyVarObject has to
   aware that longs abuse  ob_size&#39;s sign bit.
*/

struct _longobject {
  PyObject_VAR_HEAD
  digit ob_digit[1];
};
typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */
</code></pre>]]></content>
      <categories>
        <category>python源码</category>
      </categories>
  </entry>
  <entry>
    <title>python intobject大小</title>
    <url>/2017/12/09/python%20intobject%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<pre><code># 64位系统
#python3                                        python2

In [4]: sys.getsizeof(1)                       In [4]: sys.getsizeof(1)
Out[4]: 28                                     Out[4]: 24

In [6]: sys.getsizeof(0)                       In [6]: sys.getsizeof(0)
Out[6]: 24                                     Out[6]: 24
</code></pre><p>在python2 int对象为24个字节,</p>
<pre><code>#define PyObject_HEAD                   \
    Py_ssize_t ob_refcnt;               \
    struct _typeobject *ob_type;

typedef struct {
    PyObject_HEAD
    long ob_ival;
} PyIntObject;
</code></pre><hr>
<p>python3中已不区分int,long对象，而是将python2中的long对象改名为int对象</p>
<pre><code>typedef unsigned short digit;
struct _longobject {
    PyObject_VAR_HEAD
    digit ob_digit[1];
};
</code></pre><p>python3中sys.getsizeof(0) == 24</p>
<pre><code> /*zero is represented by ob_size == 0.当int值为0时，ob_size=0，所以不会分配  
 ob_digit[1],所以大小为24Bytes.*/
</code></pre><hr>
<p>Ref：python源码</p>
]]></content>
      <categories>
        <category>python源码</category>
      </categories>
  </entry>
  <entry>
    <title>python functools wraps</title>
    <url>/2018/07/25/python-functools-wraps/</url>
    <content><![CDATA[<p>把被封装函数的<strong>name</strong>、<strong>module</strong>、<strong>doc</strong>和<strong>dict</strong>复制到封装函数中，这样在未来排错或者函数自省的进修能够获得正确的源函数的对应属性，所以使用wraps。</p>
<pre><code>In [1]: import functools

# 不加wraps
In [2]: def deco(f):
   ...:     def wrapper(*args, **kwargs):
   ...:         return f(*args, **kwargs)
   ...:     return wrapper
   ...:

In [3]: @deco
   ...: def func():
   ...:     return 1
   ...:

In [4]: func.__name__
Out[4]: &#39;wrapper&#39;

# 加wraps
In [5]: def deco2(f):
   ...:     @functools.wraps(f)
   ...:     def wrapper(*args, **kwargs):
   ...:         return f(*args, **kwargs)
   ...:     return wrapper
   ...:

In [6]: @deco2
   ...: def func():
   ...:     return 1
   ...:

In [7]: func.__name__
Out[7]: &#39;func&#39;
</code></pre><hr>
<p>Ref： 1.python web开发实战</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python-rocksdb的基本使用</title>
    <url>/2018/10/14/python-rocksdb%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>1.打开一个数据库</p>
<pre><code>import rocksdb
db = rocksdb.DB(&quot;test.db&quot;,rocksdb.Options(create_if_missing=True))

# create_if_missing=True 如果不存在则创建名为&#39;test.db&#39;的数据库
</code></pre><p>2.设置键值对和获取值</p>
<pre><code># RocksDB中存储的是byte strings。在python2中为str类型，在python3中为bytes类型。
db.put(b&quot;key&quot;,b&quot;value&quot;) #设置一个键值对，key =&gt; value

db.get(b&quot;key&quot;)          #获取键为key的值，如果不在则返回为空
b&#39;value&#39;

db.delete(b&quot;key&quot;)       #删除键为key为的键值对

# 将几个操作合并为一个操作
batch = rocksdb.WriteBatch()
batch.put(b&quot;key&quot;, b&quot;v1&quot;)
batch.delete(b&quot;key&quot;)
batch.put(b&quot;key&quot;, b&quot;v2&quot;)
batch.put(b&quot;key&quot;, b&quot;v3&quot;)

db.write(batch)

# 一次获取多个键值对
&gt;&gt;&gt; db.put(b&quot;key1&quot;,b&quot;v1&quot;)
&gt;&gt;&gt; ret = db.multi_get([b&quot;key&quot;,b&quot;key1&quot;])
&gt;&gt;&gt; ret
{b&#39;key&#39;: b&#39;v3&#39;, b&#39;key1&#39;: b&#39;v1&#39;}
</code></pre><p>3.迭代</p>
<pre><code>&gt;&gt;&gt; it = db.iterkeys()  # 默认是无效的，先得调用seek方法
&gt;&gt;&gt; it.seek_to_first()
&gt;&gt;&gt; print(list(it))
[b&#39;a&#39;, b&#39;key&#39;, b&#39;key1&#39;]

&gt;&gt;&gt; it.seek_to_last()
&gt;&gt;&gt; print(list(it))
[b&#39;key1&#39;]


&gt;&gt;&gt; it = db.itervalues()   #对值进行迭代
&gt;&gt;&gt; it.seek_to_first()
&gt;&gt;&gt; print(list(it))
[b&#39;b&#39;, b&#39;v3&#39;, b&#39;v1&#39;]

&gt;&gt;&gt; it = db.iteritems()   #对键值对进行迭代
&gt;&gt;&gt; it.seek_to_first()
&gt;&gt;&gt; print(list(it))
[(b&#39;a&#39;, b&#39;b&#39;), (b&#39;key&#39;, b&#39;v3&#39;), (b&#39;key1&#39;, b&#39;v1&#39;)]

# 反向迭代
&gt;&gt;&gt; it.seek_to_last()
&gt;&gt;&gt; print(list(reversed(it)))
[(b&#39;key1&#39;, b&#39;v1&#39;), (b&#39;key&#39;, b&#39;v3&#39;), (b&#39;a&#39;, b&#39;b&#39;)]
</code></pre><p>4.快照</p>
<pre><code>&gt;&gt;&gt; snapshot = db.snapshot()
&gt;&gt;&gt; it = db.iteritems(snapshot=snapshot)
&gt;&gt;&gt; it
&lt;rocksdb._rocksdb.ItemsIterator object at 0x7f77ae179608&gt;
&gt;&gt;&gt; it.seek_to_first()
&gt;&gt;&gt; print(dict(it))
{b&#39;a&#39;: b&#39;b&#39;, b&#39;key&#39;: b&#39;v3&#39;, b&#39;key1&#39;: b&#39;v1&#39;}
</code></pre><p>5.备份和恢复</p>
<pre><code># 备份
backup = rocksdb.BackupEngine(&quot;test.db/backups&quot;)
backup.create_backup(db, flush_before_backup=True)

# 恢复
backup = rocksdb.BackupEngine(&quot;test.db/backups&quot;)
backup.restore_latest_backup(&quot;test.db&quot;, &quot;test.db&quot;)
</code></pre><hr>
<p>Ref：<br>1.<a href="https://python-rocksdb.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://python-rocksdb.readthedocs.io/en/latest/</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>python3类型注释</title>
    <url>/2019/08/11/python3%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<p>python是一门动态语言,若编码不规范会出现很多运行时错误。为了提高代码可读性，减少运行时bug,python提供了类型注释可以对函数参数，返回值，变量等进行标注。通过静态检查就可以发现一些常见的问题。类型注释的代码在python运行时并不会触发，所以没有性能影响。</p>
<p>1.类型注释的好处，看如下这个例子。<br><img src="http://img.hysyeah.top/2019/08/11/type-hint-gretting.png" alt="image"></p>
<p>这两种方法在python3.5之后都是正确的写法，一点问题都没有。但是看左边的代码就会遇到的问题，因为python是动态语言，函数参数<code>name</code>的类型只有在运行时才知道。如果我们这样调用左边的函数<code>gretting([&quot;world&quot;])</code>，这很明显字符串不能和列表相加，这在运行时就会发生异常。<br>如果我们使用右边的写法通过静态检查器就可以提前检查出错误。右边提示了参数<code>name</code>的类型为str,函数的返回值为str。</p>
<p>通过<code>mypy</code>对代码进行类型检查,可以看到参数传递错误被检查出来了。<br><img src="http://img.hysyeah.top/2019/08/11/type-hint-gretting-err.png" alt="image"></p>
<p>2.python提供的类型注释<br>python从3.5版本开始将类型注释并入了标准库中。可通过如下方式引用<br><code>from typing import List, Dict</code></p>
<ul>
<li><p>对变量进行注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: x: int = 1                            # 表示变量x为int类型                                                                                     </span><br><span class="line">In [2]: x: float = 0.1                        # 表示变量x为float类型                                                                                    </span><br><span class="line">In [3]: x: bool = True                        # 表示变量x为bool类型                                                                                    </span><br><span class="line">In [4]: x: str = &quot;test&quot;                       # 表示变量x为str类型                                                                         </span><br><span class="line">In [5]: x: bytes = b&quot;test&quot;                    # 表示变量x为bytes类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [8]: from typing import List,Dict,Sequence,Tuple,Set</span><br><span class="line">In [9]: x: Dict[str, float] = &#123;&apos;field&apos;: 2.0&#125;            # x是一个字典key为str类型,值为float类型                                                                           </span><br><span class="line">In [10]: x: Tuple[int, str, float] = (3, &quot;yes&quot;, 7.5)    # x是一个元组，元素类型可以为int, str, float                                                                             </span><br><span class="line">In [11]: x: List[int] = [1]                             # x是一个列表，元素类型为int                                                                             </span><br><span class="line">In [12]: x: Set[int] = &#123;6, 7&#125;                           # x是一个集合，元素类型为int</span><br><span class="line"></span><br><span class="line">In [16]: x: Union[int,str] = 1                         # x类型可以为int或者str         </span><br><span class="line"></span><br><span class="line">In [17]: x: Union[int, None] = 1                       # x类型可以为int或者None,等同于Optional[int]          </span><br><span class="line"></span><br><span class="line">In [18]: x: Optional[int] = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def gretting(name: str) -&gt; str:</span><br><span class="line">    return &quot;Hello &quot; + name</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对一个可调用的函数进行注释</span><br><span class="line">x: Callable[[int, float], float] = f                  # x是一个可调用的函数，有两个参数，类型分别为int,float,返回值为float类型</span><br></pre></td></tr></table></figure>
<ul>
<li>类变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Car:</span><br><span class="line">    seats: ClassVar[int] = 4                         # seats是一个类变量，类型为int</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f(x: &apos;A&apos;) -&gt; None:  # OK                         # 表示函数f的参数x的类型为A的实例</span><br><span class="line">    ...</span><br><span class="line">class A:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">x: A = A()                                          # 表示x的类型为A的实例，若想表示x的类型为类对象，请看下面</span><br><span class="line">x: Type[A] = A</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>typing模块中的协议类</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>协议</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Iterable[T]</code></td>
<td><code>def __iter__(self) -&gt; Iterator[T]</code></td>
</tr>
<tr>
<td><code>Iterator[T]</code></td>
<td><code>def __next__(self) -&gt; T</code>  <code>def __iter__(self) -&gt; Iterator[T]</code></td>
</tr>
<tr>
<td><code>Sized</code></td>
<td><code>def __len__(self) -&gt; int</code></td>
</tr>
<tr>
<td><code>Container[T]</code></td>
<td><code>def __contains__(self, x: object) -&gt; bool</code></td>
</tr>
<tr>
<td><code>Collection[T]</code></td>
<td><code>def __len__(self) -&gt; int</code> <code>def __iter__(self) -&gt; Iterator[T]</code> <code>def __contains__(self, x: object) -&gt; bool</code></td>
</tr>
<tr>
<td><code>Awaitable[T]</code></td>
<td><code>def __await__(self) -&gt; Generator[Any, None, T]</code></td>
</tr>
<tr>
<td><code>AsyncIterable[T]</code></td>
<td><code>def __aiter__(self) -&gt; AsyncIterator[T]</code></td>
</tr>
<tr>
<td><code>AsyncIterator[T]</code></td>
<td><code>def __anext__(self) -&gt; Awaitable[T]</code> <code>def __aiter__(self) -&gt; AsyncIterator[T]</code></td>
</tr>
<tr>
<td><code>ContextManager[T]</code></td>
<td><code>def __enter__(self) -&gt; T</code> <code>def __exit__(self,exc_type: Optional[Type[BaseException]],exc_value: Optional[BaseException],traceback: Optional[TracebackType]) -&gt; Optional[bool]</code></td>
</tr>
<tr>
<td><code>AsyncContextManager[T]</code></td>
<td><code>def __aenter__(self) -&gt; Awaitable[T]</code> <code>def __aexit__(self,exc_type:Optional[Type[BaseException]],exc_value: Optional[BaseException],traceback: Optional[TracebackType]) -&gt; Awaitable[Optional[bool]]</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>cast 将静态类型值强制转换为子类型,并不是像其它静态语言真正的进行类型转换，在运行时并不生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from typing import cast, List</span><br><span class="line"></span><br><span class="line">o: object = [1]</span><br><span class="line">x = cast(List[int], o)  # OK</span><br><span class="line">y = cast(List[str], o)  # OK (cast performs no actual runtime check)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Generics</p>
</li>
</ul>
<p>python内置的<code>collection classes</code>都是<code>generic classes</code>。Generic types拥有一个或多个类型参数。如<code>Dict[int, str]</code> <code>List[int]</code>。</p>
<p>自定义一个原生类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from typing import TypeVar, Generic</span><br><span class="line"></span><br><span class="line">T = TypeVar(&apos;T&apos;)</span><br><span class="line"></span><br><span class="line">class Stack(Generic[T]):</span><br><span class="line">    def __init__(self) -&gt; None:</span><br><span class="line">        # Create an empty list with items of type T</span><br><span class="line">        self.items: List[T] = []</span><br><span class="line"></span><br><span class="line">    def push(self, item: T) -&gt; None:</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    def pop(self) -&gt; T:</span><br><span class="line">        return self.items.pop()</span><br><span class="line"></span><br><span class="line">    def empty(self) -&gt; bool:</span><br><span class="line">        return not self.items</span><br></pre></td></tr></table></figure></p>
<p>现在<code>Stack</code>类可以用于表示拥有任务类型的<code>stack</code>,如<code>Stack[int],Stack[str],Stack[Tuple[int, str]]</code>等。<br>可以像使用内置容器类型一样使用类<code>Stack</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Construct an empty Stack[int] instance</span><br><span class="line">stack = Stack[int]()</span><br><span class="line">stack.push(2)</span><br><span class="line">stack.pop()</span><br><span class="line">stack.push(&apos;x&apos;)        # Type error</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Variance of generic types<br>关于它们之间的子类型关系，存在三种主要类型的通用类型：<code>invariant</code>(不变的),<code>covariant</code>(协变的),<code>contravariant</code>(逆变的)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如上,<code>Animal</code>有子类型<code>Cat</code>,<code>Cat</code><strong>可能</strong>可以使用<code>Animal</code>中的某些方法，这个<strong>可能</strong>取决于类型是<code>covariant</code>或者<code>contravariant</code>。</p>
<p>如果<code>Cat</code>可以使用它的超类型<code>Animal</code>中的一些方法，这种情况被称为<code>convariant</code>;如果超类型<code>Animal</code>可以使用子类型<code>Cat</code>中的某些方法，则被称为<code>contravariant</code>。<br>如果<code>convariant</code>和<code>contravariant</code>都不成立，则被称作<code>invariant</code>,即<code>Cat</code>不能使用<code>Animal</code>中的方法，<code>Animal</code> 也不能使用<code>Cat</code>中的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from typing import TypeVar, Generic, Iterable, Iterator</span><br><span class="line"></span><br><span class="line">List_co = TypeVar(&apos;List_co&apos;, contravariant=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ImmutableList(Generic[List_co]):</span><br><span class="line">    def __init__(self, items: Iterable[List_co]) -&gt; None:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def __iter__(self) -&gt; Iterator[List_co]:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Employee:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Manager(Employee):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def list_employees(employees: ImmutableList[Employee]) -&gt; None:</span><br><span class="line">    for employee in employees:</span><br><span class="line">        print(employee)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">managers = ImmutableList([Manager()])</span><br><span class="line">list_employees(managers)</span><br></pre></td></tr></table></figure>
<p>当<code>contravariant=True</code>时，使用命令<code>mypy co.py</code>,出现如下错误：<br><img src="http://img.hysyeah.top/2019/10/13/convariant.png" alt="image"></p>
<p>默认情况下<code>mypy</code>认为所有用户自定义的原生类型都是<code>invariant</code>的。</p>
<p>请试下当<code>convariant=True</code>时又是怎样的结果</p>
<hr>
<p>Ref：<br>1.<a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener">pep484</a><br>2.<a href="https://www.python.org/dev/peps/pep-0526/" target="_blank" rel="noopener">pep526</a><br>3.<a href="https://mypy.readthedocs.io/en/latest/" target="_blank" rel="noopener">mypy</a><br>4.<a href="https://blog.magrathealabs.com/pythons-covariance-and-contravariance-b422c63f57ac" target="_blank" rel="noopener">https://blog.magrathealabs.com/pythons-covariance-and-contravariance-b422c63f57ac</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python property</title>
    <url>/2018/08/05/python-property/</url>
    <content><![CDATA[<pre><code>class property([fget[, fset[, fdel[, doc]]]])
# fget是用于获取属性值的函数
# fset是用于设置属性值的函数
# fdel是用于删除属性值的函数
# doc是文档字符串
</code></pre><p>下面是官方文档上的一个例子：</p>
<pre><code>In [2]: class C:
        def __init__(self):
            print(&quot;invoke __init__&quot;)
            self._x = None

        def getx(self):
            print(&quot;invoke getx&quot;)
            return self._x

        def setx(self, value):
            print(&quot;invoke setx&quot;)
            self._x = value

        def delx(self):
            print(&quot;invoke delx&quot;)
            del self._x

        x = property(getx, setx, delx, &quot;I&#39;m the &#39;x&#39; property.&quot;)
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/property.png" alt> 当访问c.x时会调用getx方法，当为c.x设置值时会调用setx方法，删除c.x时会调用delx方法。</p>
<hr>
<p>在对实例属性的获取和设定上，我们希望增加一些额外的处理过程(比如类型检查或者验证)。要自定义对属性的访问，一种简单的方式是将其定义为property。比如下面的代码定义了一个property，增加了对属性的类型检查。</p>
<pre><code>In [9]: class Person:
        def __init__(self, first_name):
            self.first_name = first_name
            print(&quot;invoke __init__&quot;)
        @property
        def first_name(self):
            print(&quot;invoke get first_name&quot;)
            return self._first_name
        @first_name.setter
        def first_name(self, value):
            print(&quot;invoke set first_name&quot;)
            if not isinstance(value, str):
                raise TypeError(&quot;Expected a string&quot;)
            self._first_name = value
        @first_name.deleter
        def first_name(self):
            raise AttributeError(&quot;Can&#39;t delete attribute&quot;)
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/property1.png" alt> 你可能会问为什么在<strong>init</strong>方法中设定的是self.first_name而 不是self._first_name?在这个例子中，property的全部意义就在于我们设置属性时可以执行类型检查。因此，你也想让这种类型检查在初始化的时候也可以进行。所以，在<strong>init</strong>中设置self.first_name,实际上会调用到setter方法(因此就会跳过self.first_name而去访问self._first_name)。 property使用场景： 只有当确定需要在访问属性必完成一些额外的处理任务时，才应该使用property.</p>
<hr>
<p>Ref： 1.<a href="https://docs.python.org/3/library/functions.html#property" target="_blank" rel="noopener">官方文档</a> 2.python cookbook</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之Queue</title>
    <url>/2018/09/05/python%E4%B9%8BQueue/</url>
    <content><![CDATA[<p>当必须在多个线程之间安全地交换信息时，它在线程编程中特别有用。此模块中的Queue类实现了所有必需的锁定原语。 如果数据共享时可能被修改，就需要加锁来保护它，以确保同一时刻只能有一个线程访问这个数据。线程模块提供了许多同步原语，包括锁(Lock)、信号量(Semaphore)、条件变量(Condition)和事件(Event)。但最好的做法是使用Queue模块。Queue是线程安全的，使用它可以降低程序的复杂度，代码清晰，可读性更强。</p>
<pre><code># queue定义了三种类型的队列,maxsize为队列元素最大值，默认为无限大
# 定义一个先进先出的队列
class queue.Queue(maxsize=0)
# 定义一个后进先出的队列
class queue.LifoQueue(maxsize=0) 
# 定义一个优先级队列，元素通常为(priority_number,data),值越小优先级越高
class queue.PriorityQueue(maxsize=0) 
</code></pre><p>队列对象方法</p>
<pre><code>Queue.qsize()
qsize（）&gt; 0不保证后续的get（）不会阻塞，qsize（）&lt;maxsize也不保证put（）不会阻塞??

Queue.empty() 
如果队列为空,返回True,否则返回False。

Queue.full()
如果队列已满，返回True,否则返回False，如果返回True不保证get()不会阻塞，如果返回False也不保证put()不会阻塞。

Queue.put(item, block=True, timeout=None)
将元素插入到队列中。如果block=True和timeout等于None,将会发生阻塞直到有空闲的空间。如果timeout大于0,将会阻塞timeout秒，如果还是没有多余空间将会触发Full异常。如果block=False,如果队列不是满的直接放入队列，否则触发Full异常(timeout会被忽略)

Queue.put_nowait(item)
等于put(item, False).

Queue.get(block=True, timeout=None) 
移除和返回队列中的元素。如果block=True和timeout等于None,将会发生阻塞直到队列不为空。如果timeout大于0,将会阻塞timeout秒，如果队列还是为空将会触发Empty异常。如果block=False,如果队列不为空返回元素，否则触发Empty异常(timeout会被忽略)

Queue.get_nowait() 
等于get(False)

Queue.task_done() 
表时以前排队的任务已经完成。用于队列消费者线程。对于用于获取任务的每个get()，对task_done()的后续调用会告知队列任务的处理已完成。

Queue.join() 
阻塞直到队列中所有元素都被处理了。



import Queue
import threading

def print_url(queue):
    while True:
        url = queue.get()
        print(url)
        queue.task_done()

def use_queue():
    queue = Queue.Queue()
    for i in range(5):
        t = threading.Thread(target=print_url,args=(queue,))
        t.setDaemon(True)
        t.start()
    for url in [&#39;baidu.com&#39;,&#39;xina.com&#39;,&#39;weibo.com&#39;,&#39;qq.com&#39;,&#39;hysky.com&#39;,&#39;hehe.com&#39;]:
        queue.put(url)

    queue.join()


if __name__ == &quot;__main__&quot;:
    use_queue()


# 输出：
baidu.com
 weibo.com
xina.com
qq.com
hysky.com
hehe.com
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之dict与set</title>
    <url>/2018/09/01/python%E4%B9%8Bdict%E4%B8%8Eset/</url>
    <content><![CDATA[<pre><code>In [5]: def f(a,*args,**kwargs):
            print(a)
            print(args)
            print(kwargs)

In [6]: keys =[1, 2, 3]
In [7]: kwargs = {&#39;a&#39;,&#39;b&#39;}

In [8]: f(&#39;b&#39;,*keys,**kwargs)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-8-5ffd5def4f0f&gt; in &lt;module&gt;()
----&gt; 1 f(&#39;b&#39;,*keys,**kwargs)

TypeError: f() argument after ** must be a mapping, not set

# 这里报错，这里传入的参数必须是字典，而不能是集合，当定义一个字典时，若只有键没有值，那这是一个集合，而不是字典，这应该看作两种完全不一样的数据



In [9]: k = {&#39;a&#39;:&#39;b&#39;,&#39;c&#39;:&#39;d&#39;}

In [10]: f(&#39;b&#39;,*keys,**k) # *表示可选参数列表，**表示可选参数字典
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-10-8147c79d6830&gt; in &lt;module&gt;()
----&gt; 1 f(&#39;b&#39;,*keys,**k)

TypeError: f() got multiple values for argument &#39;a&#39;

# 若k中有把&#39;a&#39;作为键的键值对，则会报错

In [13]: f(&#39;a&#39;,*keys,{&#39;b&#39;:&#39;c&#39;}) # 没加**会把{&#39;a&#39;:&#39;c&#39;}当作可参数列表中的一部分
a
(1, 2, 3, {&#39;b&#39;: &#39;c&#39;})
{}

In [14]: f(&#39;a&#39;,*keys,**{&#39;b&#39;:&#39;c&#39;})
a
(1, 2, 3)
{&#39;b&#39;: &#39;c&#39;}
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python中的native string</title>
    <url>/2018/03/26/python%E4%B8%AD%E7%9A%84native%20string/</url>
    <content><![CDATA[<pre><code># 将给定的字符串对象转换为native string
def to_native_string(string, encoding=&#39;ascii&#39;):
    if isinstance(string, builtin_str):
        out = string
    else:
        if is_py2:
            out = string.encode(encoding)
        else:
            out = string.decode(encoding)

    return out
</code></pre><hr>
<p>1.”Native” strings(指那些类型名为str的字符串类型)，用于请求/响应头和元数据。 2.”Bytestring”(在python3中类型名为bytes,python2中为str),用于请求/响应中的body。</p>
<hr>
<p>Ref：<br>1.<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">pep3333</a><br>2.<a href="https://github.com/requests/requests/blob/v2.8.0/requests/utils.py#L665" target="_blank" rel="noopener">requests源码</a><br>3.<a href="http://img.hysyeah.top/2017/10/02/python%E7%BC%96%E7%A0%81/" target="_blank" rel="noopener">http://img.hysyeah.top/2017/10/02/python%E7%BC%96%E7%A0%81/</a></p>
]]></content>
      <categories>
        <category>requests</category>
      </categories>
  </entry>
  <entry>
    <title>python之ipaddress</title>
    <url>/2018/09/26/python%E4%B9%8Bipaddress/</url>
    <content><![CDATA[<p>ip地址一共32位阿,20的掩码表示使用20位作为网络地址选项,那么就还剩下12位来做主机地址了。粗略就是2^12个主机ip了。 我们通过ipaddress模块，生成类似于”123.45.67.89/27”这样的CIDR(Classless InterDomain Routing)网络地址可表示的全部IP地址范围。</p>
<pre><code>In [1]: import ipaddress

In [2]: net = ipaddress.ip_network(&#39;123.45.67.64/27&#39;)

In [3]: net
Out[3]: IPv4Network(&#39;123.45.67.64/27&#39;)

In [4]: for elt in net:
   ...:     print(elt)
   ...:
123.45.67.64
123.45.67.65
123.45.67.66
123.45.67.67
123.45.67.68
123.45.67.69
123.45.67.70
123.45.67.71
123.45.67.72
123.45.67.73
123.45.67.74
123.45.67.75
123.45.67.76
123.45.67.77
123.45.67.78
123.45.67.79
123.45.67.80
123.45.67.81
123.45.67.82
123.45.67.83
123.45.67.84
123.45.67.85
123.45.67.86
123.45.67.87
123.45.67.88
123.45.67.89
123.45.67.90
123.45.67.91
123.45.67.92
123.45.67.93
123.45.67.94
123.45.67.95

In [5]: net.num_addresses
Out[5]: 32

In [6]: net[0]
Out[6]: IPv4Address(&#39;123.45.67.64&#39;)

In [7]: a = ipaddress.ip_address(&#39;123.45.67.69&#39;)

In [8]: a in net           #判断ip是否在CIDR中
Out[8]: True
</code></pre><p>ipaddress模块同其他网络相关的模块比如socket库之间的交互是有局限性的。通常不能用IPv4Address的实例作为地址字符串的替代。必须显式的通过str()将其转换为字符串。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之copy,deepcopy</title>
    <url>/2018/09/11/python%E4%B9%8Bcopy,deepcopy/</url>
    <content><![CDATA[<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><pre><code># c与a指向同一对象
In [71]: a = [0, [1, 2], 3]


In [75]: c = a

In [76]: id(c)
Out[76]: 140506513737928

In [77]: id(a)
Out[77]: 140506513737928
</code></pre><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><pre><code># 只拷贝对象的引用
In [71]: a = [0, [1, 2], 3]

In [72]: b = a[:]

In [73]: id(a)
Out[73]: 140506513737928

In [74]: id(b)
Out[74]: 140506514004104

In [78]: b[1].append(3)

In [79]: b
Out[79]: [0, [1, 2, 3], 3]

In [80]: a
Out[80]: [0, [1, 2, 3], 3]
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/09/copy.jpg" alt>图片来源于网络</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><pre><code># 复制真实的对象
In [81]: import copy

In [82]: a = [0, [1, 2], 3]

In [83]: b = copy.deepcopy(a)

In [84]: b
Out[84]: [0, [1, 2], 3]

In [85]: id(b[1])
Out[85]: 140506534178056

In [86]: id(a[1])
Out[86]: 140506522688136

In [87]: b[1].append(3)

In [88]: b
Out[88]: [0, [1, 2, 3], 3]

In [89]: a
Out[89]: [0, [1, 2], 3]
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/09/deepcopy.jpg" alt>图片来源于网络</p>
<hr>
<p>浅拷贝和深拷贝的不同之处是对于可变对象来说的，因为对于不可变对象复制对象的引用和复制对象是一样的(因为当要改变值时，会重新创建个对象)。当使用浅拷贝时，对于嵌套的列表只会拷贝其引用，而深拷贝则会复制真实的对象。切片也属于浅拷贝。</p>
<hr>
<p>Ref：<br>1.<a href="https://my.oschina.net/leejun2005/blog/145911" target="_blank" rel="noopener">https://my.oschina.net/leejun2005/blog/145911</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之不要在函数中定义可变对象作为默认值</title>
    <url>/2018/09/03/python%E4%B9%8B%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
    <content><![CDATA[<pre><code>def f(a=[]):
    a.append(len(a)+1)
    print(a)
    print(id(a))


f()
f()


# output:
[1]
140542070277688
[1, 2]
140542070277688

# 参数的默认值只会函数定义的时候初始化一次。
# 函数中的默认值为一个可变对象，对它的操作就和定位了指针地址一样,在内存里进行修改。而如果是不可变对象则会复制一份新的对象。
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之else</title>
    <url>/2018/08/24/python%E4%B9%8Belse/</url>
    <content><![CDATA[<pre><code>In [1]: def print_prime(n):
   ...:     for i in range(2, n):
   ...:         for j in range(2, i):
   ...:             if i % j == 0:
   ...:                 break
   ...:         else:
   ...:             print(&quot;%d is a prime number&quot; %i)
   ...:

In [2]: print_prime(10)
2 is a prime number
3 is a prime number
5 is a prime number
7 is a prime number
</code></pre><p>当循环自然结束时(循环条件为假)时else从句会被执行一次，而当循环是由<code>break</code>语句中断时，<code>else</code>子句不会被执行。与<code>for</code>语句相似，<code>while</code>语句中的<code>else</code>子句的语意是一样的：<code>else</code>块在循环正常结束和循环条件不成立时被执行。</p>
<hr>
<p>异常处理中的<code>else</code><br><code>try</code>块没有抛出任何异常时，执行<code>else</code>块</p>
<pre><code>def save(db, obj):
    try:
        db.execute(&quot;a sql&quot;, obj.attr1)
    except DBErrror:
        db.rollback()
    else:
        db.commit()    # 未发生异常时执行
</code></pre><hr>
<p>Ref：<br>1.编写高质量代码-改善Python程序的91个建议</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之在匿名函数中绑定变量的值</title>
    <url>/2018/09/05/python%E4%B9%8B%E5%9C%A8%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%AD%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<pre><code>In [17]: [x(2) for x in mu()]
Out[17]: [0, 2, 4, 6]

In [18]: x = 10

In [19]: a = lambda y: x + y

In [20]: x = 20

In [21]: b = lambda y: x + y

In [22]: a(10)
Out[22]: 30

In [23]: b(10)
Out[23]: 30

# lambda表达式中用到的x是一个自由变量，在运行进才进行绑定而不是定义的时候进行绑定。因此，lambda表达式中的x是在执行的时候确定的。
</code></pre><p>再来看这么一个例子：</p>
<pre><code>In [27]: def multipliers():
    ...:     return [lambda x: i*x for i in range(4)]
In [28 print([m(2) for m in multipliers()])
[6, 6, 6, 6]

# 因为i值是在运行的时候确定的，当调用lambda函数时，for循环已经结束，所以i都是3


# 可以把添加一个默认参数绑定变量，默认值只会函数定义的时候初始化一次
In [33]: def multipliers():
    ...:     return [lambda x, i=i: i*x for i in range(4)]
    ...:
    ...:

In [34]: print([m(2) for m in multipliers()])
[0, 2, 4, 6]

# 或者可以通过如下方式实现
In [16]: from functools import partial
In [17]: from operator import mul
In [35]: def multipliers():
    ...:     return [partial(mul, i) for i in range(4)]
    ...:
    ...:

In [36]: print([m(2) for m in multipliers()])
[0, 2, 4, 6]
</code></pre><hr>
<p>Ref：<br>1.python cookbook</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之鸭子类型(Duck typing)</title>
    <url>/2018/09/08/python%E4%B9%8B%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B(Duck%20typing)/</url>
    <content><![CDATA[<p>“如果它像鸭子一样走路，它像鸭子一样呱呱叫，那它一定是鸭子” - 以确定一个物体是否可以用于特定目的。 在duck typing中，对象的适用性取决于某些方法和属性的存在，而不是对象本身的类型。我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。</p>
<pre><code>class Duck:
    def fly(self):
        print(&quot;Duck flying&quot;)

class Airplane:
    def fly(self):
        print(&quot;Airplane flying&quot;)

class Whale:
    def swim(self):
        print(&quot;Whale swimming&quot;)

def lift_off(entity):
    entity.fly()

duck = Duck()
airplane = Airplane()
whale = Whale()

lift_off(duck) # prints `Duck flying`
lift_off(airplane) # prints `Airplane flying`
lift_off(whale) # Throws the error `&#39;Whale&#39; object has no attribute &#39;fly&#39;

# 在lift_off函数中我们并不关心传入的参数是什么类型，只关心这个对象拥有什么方法。
</code></pre><p>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。 再如只要一个类实现了<code>__iter__</code>方法，我们就说这个对象是可迭代的。</p>
<pre><code>In [1]: class A:
   ...:     def __iter__(self):
   ...:         pass
   ...:

In [2]: a = A()

In [3]: from collections import Iterable

In [4]: isinstance(a, Iterable)
Out[4]: True
</code></pre><hr>
<p>Ref：<br>1.<a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="noopener">wikipedia</a><br>2.<a href="https://blog.csdn.net/handsomekang/article/details/40270009" target="_blank" rel="noopener">csdn</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python之属性继承</title>
    <url>/2018/09/03/python%E4%B9%8B%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<pre><code>class A:
    a = 1

a, b, c = A(), A(),A()

print(a.a, b.a, c.a)

a.a = 2
A.a = 3
print(a.a, A.a, c.a)   # 未对实例c.a赋值，则会继承类属性a的值

print(a.__dict__, A.__dict__, c.__dict__)

# output:

(1, 1, 1)
(2, 3, 3)
({&#39;a&#39;: 2}, {&#39;a&#39;: 3, &#39;__module__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}, {}) # 实例c的__dict__为空
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python使用最小二乘法求拟合曲线</title>
    <url>/2018/04/23/python%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E6%B1%82%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<p>1.<a href="https://blog.csdn.net/yauphy1/article/details/43735763" target="_blank" rel="noopener">最小二乘法</a><br> 2.假设4个数据点为：(1, 6),(2, 5),(3, 7),(4, 10),求最佳匹配直线。</p>
<pre><code>import numpy as np
x = [1, 2, 3, 4]
y = [6, 5, 7, 10]
r = np.polyfit(x, y, deg=1) # 对(x,y)拟合多项式p(x) = p[0] * x**deg + ... + p[deg]
f = np.poly1d(r) #f为拟合函数
</code></pre><p>求出的拟合直线为$ y = r[0]x+r[1] $, $y = 1.4x+3.5 $<br>3.画出拟合直线和数据点</p>
<pre><code>import matplotlib.pyplot as plt
fig = plt.subplots()
plt.plot(1,6,&#39;*-&#39;)
plt.plot(2,5,&#39;*-&#39;)
plt.plot(3,7,&#39;*-&#39;)
plt.plot(4,10,&#39;*-&#39;)
f = lambda x: 1.4*x + 3.5
x = [1, 2, 3, 4]
y = [f(e) for e in x]
plt.plot(x,y)
plt.show()
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/04/fit.png" alt="image"></p>
<hr>
<h4 id="使用scikit-learn"><a href="#使用scikit-learn" class="headerlink" title="使用scikit-learn"></a>使用scikit-learn</h4><pre><code># -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression


x = np.array([ 6,  8, 10, 14, 18])
y = np.array([ 7. ,  9. , 13. , 17.5, 18. ])

plt.plot(x, y, &#39;k.&#39;)
plt.axis([0, 25, 0, 25])


model = LinearRegression()
model.fit(x.reshape(-1,1),y.reshape(-1,1))

e = [item[0] for item in model.predict(x.reshape(-1,1))]


X = list(zip(x,x))
Y = list(zip(y,e))
for i in range(len(X)):
    plt.plot(X[i],Y[i],&#39;r&#39;)

plt.title(&quot;Linear regression use least square method&quot;)
plt.xlabel(r&#39;$x$&#39;, horizontalalignment=&#39;right&#39;, x=1.0)
plt.ylabel(r&#39;$y$&#39;, horizontalalignment=&#39;right&#39;, y=1.0, rotation=0)

plt.plot(x, e)
plt.grid(True)
plt.show()
</code></pre><p><a href="https://github.com/hys20151008/7788/blob/master/least_square.py" target="_blank" rel="noopener">代码</a> <img src="http://img.hysyeah.top/wp-content/uploads/2018/04/least_square.png" alt></p>
<hr>
<p>选择最小二乘的原因：<br>1.平方能将正残差与负残差都变成正数<br>2.平方相当于给残差赋予了一个权重，越大的残差(绝对值)被赋予的权重越大。但是并不是所有情况下大的残差都应该被赋予大的权重，因为这样拟合方程就很容易受到异常值的影响<br>3.在残差服从均值为0，方差为$ \sigma ^2 $ (未知，但为常数)的正态分布，且在残差与x独立的假设下，参数的最小二乘估计结果与极大似然估计量相同。<br>4.最小二乘估计的计算简单 在数理统计中,残差是指实际观察值与估计值(拟合值)之间的差。</p>
<hr>
<p>Ref：<br>1.<a href="http://greenteapress.com/thinkstats/" target="_blank" rel="noopener">Think Stats Probability and Statistics for Programmers</a><br>2.<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html" target="_blank" rel="noopener">numpy</a><br>3.<a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html" target="_blank" rel="noopener">scikit-learn</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>python之round</title>
    <url>/2018/09/10/python%E4%B9%8Bround/</url>
    <content><![CDATA[<p>round(number[, ndigits]) Return number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None, it returns the nearest integer to its input. For the built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0, and round(1.5) is 2). Any integer value is valid for ndigits (positive, zero, or negative). The return value is an integer if called with one argument, otherwise of the same type as number.</p>
<pre><code># 如果小数部分为0.5,```round```向最近的偶数取整
In [5]: round(10.5)
Out[5]: 10

In [6]: round(11.5)
Out[6]: 12

In [7]: round(10.4)
Out[7]: 10

In [8]: round(10.6)
Out[8]: 11

In [9]: round(-1.5)
Out[9]: -2

In [10]:  round(2.678, 2)
Out[10]: 2.68

In [11]:  round(2.676, 2)
Out[11]: 2.68

In [12]:  round(2.686, 2)
Out[12]: 2.69


# 当末位小数为5时，如果前一位也是小数而且是奇数，则返回指定位数;  
# 如果前一位也是小数而且是偶数，则返回进1后的指定位数
In [13]:  round(2.675, 2)
Out[13]: 2.67

In [14]:  round(2.685, 2)
Out[14]: 2.69
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python各时间段获取和时间类型的转换</title>
    <url>/2017/09/15/python%E5%90%84%E6%97%B6%E9%97%B4%E6%AE%B5%E8%8E%B7%E5%8F%96%E5%92%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="python获取各时段起始时间和各种类型时间的相互转换"><a href="#python获取各时段起始时间和各种类型时间的相互转换" class="headerlink" title="python获取各时段起始时间和各种类型时间的相互转换"></a>python获取各时段起始时间和各种类型时间的相互转换</h3><pre><code>In [1]: import datetime

In [2]: from datetime import timedelta
</code></pre><p>1.获取今天时间</p>
<pre><code>In [3]: now = datetime.datetime.now()

In [4]: now
Out[4]: datetime.datetime(2017, 9, 14, 9, 38, 44, 878801)
</code></pre><p>2.获取明天，昨天的时间</p>
<pre><code>In [5]: tomorrow = now + timedelta(days=1)

In [6]: tomorrow
Out[6]: datetime.datetime(2017, 9, 15, 9, 38, 44, 878801)

In [7]: yesterday = now - timedelta(days=1)

In [8]: yesterday
Out[8]: datetime.datetime(2017, 9, 13, 9, 38, 44, 878801)
</code></pre><p>3.获取本月时间</p>
<pre><code>In [9]: this_month_start = datetime.datetime(now.year, now.month, 1)

In [10]: this_month_start
Out[10]: datetime.datetime(2017, 9, 1, 0, 0)

In [11]: this_month_end = datetime.datetime(now.year, now.month+1, 1) - timedelta(days=1)

In [12]: this_month_end
Out[12]: datetime.datetime(2017, 9, 30, 0, 0)
</code></pre><p>4.获取上月时间</p>
<pre><code>In [13]: last_month_end = this_month_start - timedelta(days=1)

In [14]: last_month_start = datetime.datetime(last_month_end.year, last_month_end.month, 1)

In [15]: last_month_start
Out[15]: datetime.datetime(2017, 8, 1, 0, 0)

In [16]: last_month_end
Out[16]: datetime.datetime(2017, 8, 31, 0, 0)
</code></pre><p>5.获取近30天时间</p>
<pre><code>In [17]: last_thirty_days = now - timedelta(days=30)

In [18]: last_thirty_days
Out[18]: datetime.datetime(2017, 8, 15, 9, 38, 44, 878801)
</code></pre><p>6.获取本季起始时间(可通过本季起始时间获取上季开始时间，从而获取上季起始时间)</p>
<pre><code>In [19]: m = (now.month -1) - (now.month - 1)%3 +1

In [20]: m
Out[20]: 7

In [21]: this_quarter_satart = datetime.datetime(now.year, m, 1)
In [23]: this_quarter_end = datetime.datetime(now.year, m+3, 1) - timedelta(days=1)

In [24]: this_month_start
Out[24]: datetime.datetime(2017, 9, 1, 0, 0)

In [25]: this_month_end
Out[25]: datetime.datetime(2017, 9, 30, 0, 0)

In [26]: this_quarter_satart
Out[26]: datetime.datetime(2017, 7, 1, 0, 0)

In [27]: this_quarter_end
Out[27]: datetime.datetime(2017, 9, 30, 0, 0)
</code></pre><p>7.本周起始时间</p>
<pre><code>In [29]: this_week_start = now - timedelta(days=now.weekday())

In [30]: this_week_end = now + timedelta(days=6-now.weekday())

In [31]: this_week_start
Out[31]: datetime.datetime(2017, 9, 11, 9, 38, 44, 878801)

In [32]: this_week_end
Out[32]: datetime.datetime(2017, 9, 17, 9, 38, 44, 878801)
</code></pre><p>8.上周起始时间</p>
<pre><code>In [33]: last_week_start = now - timedelta(days=now.weekday()+7)

In [34]: last_week_end = now - timedelta(days=now.weekday()+1)

In [35]: last_week_start
Out[35]: datetime.datetime(2017, 9, 4, 9, 38, 44, 878801)

In [36]: last_week_end
Out[36]: datetime.datetime(2017, 9, 10, 9, 38, 44, 878801)
</code></pre><p>9.字符串时间和datetime的相互转换</p>
<pre><code>In [37]: str_time = now.strftime(&quot;%Y-%m-%d %H:%m:%s&quot;)

In [38]: str_time
Out[38]: &#39;2017-09-14 09:09:1505396324&#39;

In [41]: dt = datetime.datetime.strptime(&#39;2017-09-14&#39;,&quot;%Y-%m-%d&quot;)

In [42]: dt
Out[42]: datetime.datetime(2017, 9, 14, 0, 0)
</code></pre><p>10.date转换为时间戳</p>
<pre><code>In [16]: dt = datetime.date(2017, 8, 8)

In [17]: dt
Out[17]: datetime.date(2017, 8, 8)

In [18]: timestamp = time.mktime(dt.timetuple())

In [19]: timestamp
Out[19]: 1502121600.0
</code></pre><p>11.</p>
<pre><code>时间戳到--字符串时间
datetime.datetime.fromtimestamp(psutil.boot_time()).strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)

字符串到时间戳
s = time.mktime(time.strptime(&#39;2016-06-06 10:00:00&#39;,&#39;%Y-%m-%d %H:%M:%S&#39;))
</code></pre><hr>
<p>Ref：<br>1.<a href="http://www.cnblogs.com/prolifes/articles/5195528.html" target="_blank" rel="noopener">http://www.cnblogs.com/prolifes/articles/5195528.html</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>python标准库</category>
      </categories>
  </entry>
  <entry>
    <title>python对函数求导</title>
    <url>/2018/05/16/python%E5%AF%B9%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC/</url>
    <content><![CDATA[<p>假设函数[latex]f(x) = x^3+2x[/latex],求[latex]f’(x)[/latex]在x=1的值. 1.通过numpy多项式求导</p>
<pre><code>import numpy as np
y = np.poly1d([1,0,2,0])


print(y)         # 3*x**2 + 2*x       


dy = y.deriv()
dy(1)                         # 5
</code></pre><p>2.通过sympy对函数求导,通过命令pip3 install sympy安装</p>
<pre><code>from sympy import symbols
from sympy import diff as diff
from npmath import diff as diff2

x = symbols(&#39;x&#39;)
f = x**3 + 2*x
f1 = diff(f)
print(f1)              # 3*x**2 + 2

diff2(lambda x: x**3+2*x,1)         # 5
</code></pre><hr>
<p>Ref：<br>1.<a href="http://docs.sympy.org/latest/tutorial/calculus.html" target="_blank" rel="noopener">sympy文档</a><br>2.<a href="http://mpmath.org/doc/1.0.0/calculus/differentiation.html?highlight=diff#mpmath.diff" target="_blank" rel="noopener">mpmath文档</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>python异常处理</title>
    <url>/2017/10/02/python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h4 id="python提供了一个异常类，来处理代码中可能出现的异常"><a href="#python提供了一个异常类，来处理代码中可能出现的异常" class="headerlink" title="python提供了一个异常类，来处理代码中可能出现的异常"></a>python提供了一个异常类，来处理代码中可能出现的异常</h4><p>class BaseException BaseException是所有内建异常都继承于这个类。但用户自定义的异常类用不继承这个类，而是继承自Exception。 class Exception Exception <strong>traceback</strong> 当异常发生时python会自动创建traceback对象，并关联到<strong>traceback</strong>属性中，你可以使用with_traceback()创建异常和设置你自己的traceback。(Python3) raise python2到python3</p>
<pre><code>raise E, V 改为raise E(V),raise E, V, T 改为raise E(V).with_traceback(T)
</code></pre><p>兼容python2和python3的写法</p>
<pre><code>peewee
PY3:
def reraise(tp, value, tb=None):#type,value,traceback
    if value.__traceback__ is not tb:
        raise value.with_traceback(tb)
    raise value
PY2:
exec(&#39;def reraise(tp, value, tb=None): raise tp, value, tb&#39;) #在python3下会报语法错误，通过exec绕过检查

bottle
PY3:
def _raise(*a):
    raise a[0](a[1]).with_traceback(a[2])
PY2:
exec(compile(&#39;def _raise(*a): raise a[0], a[1], a[2]&#39;, &#39;&lt;py3fix&gt;&#39;, &#39;exec&#39;))
</code></pre><p>Ref： 1.<a href="https://mozillazg.github.io/2016/08/python-the-right-way-to-catch-exception-then-reraise-another-exception.html" target="_blank" rel="noopener">https://mozillazg.github.io/2016/08/python-the-right-way-to-catch-exception-then-reraise-another-exception.html</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python排列组合，范数, 中位数相关函数</title>
    <url>/2018/05/06/python%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%EF%BC%8C%E8%8C%83%E6%95%B0,%20%E4%B8%AD%E4%BD%8D%E6%95%B0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<pre><code>import numpy as np
a = np.array([1, 2, 3])
np.linalg.norm(a, 1) #1-范数
np.linalg.norm(a, 2) #2-范数

x = np.array([1, 2])
y = np.array([1, 4])
dist = np.linalg.norm(x-y, 2) # x,y之间的欧里几德距离
</code></pre><p>[latex]C_{5}^2[/latex]</p>
<pre><code>from scipy.special import comb
comb(5, 2) # output: 10
</code></pre><p>[latex]A_{5}^2[/latex]</p>
<pre><code>from scipy.special import perm
perm(5, 2) # output: 20
</code></pre><p>中位数</p>
<pre><code>x = np.array([1, 2, 5, 4, 9, 0, 6])
np.median(x)  # 4
</code></pre><p>阶乘[latex]k![/latex]</p>
<pre><code>from scipy.special import factorial
factorial(6) # out :array(720.0)
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>python标准库之OrderedDict</title>
    <url>/2018/04/02/python%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8BOrderedDict/</url>
    <content><![CDATA[<h5 id="OrderedDict继承于dict-当插入key时顺序就已经确定了。如插入一个key存在的项，key的顺序不会改变。如果先删除再插入，则会移动到右边。"><a href="#OrderedDict继承于dict-当插入key时顺序就已经确定了。如插入一个key存在的项，key的顺序不会改变。如果先删除再插入，则会移动到右边。" class="headerlink" title="OrderedDict继承于dict,当插入key时顺序就已经确定了。如插入一个key存在的项，key的顺序不会改变。如果先删除再插入，则会移动到右边。"></a>OrderedDict继承于dict,当插入key时顺序就已经确定了。如插入一个key存在的项，key的顺序不会改变。如果先删除再插入，则会移动到右边。</h5><pre><code>In [5]: d = OrderedDict({&#39;banana&#39;: 3, &#39;apple&#39;: 4, &#39;pear&#39;: 1, &#39;orange&#39;: 2})

In [6]: d
Out[6]: OrderedDict([(&#39;pear&#39;, 1), (&#39;banana&#39;, 3), (&#39;apple&#39;, 4), (&#39;orange&#39;, 2)])

In [7]: d.update({&#39;d&#39;:1})

In [8]: d
Out[8]: 
OrderedDict([(&#39;pear&#39;, 1),
             (&#39;banana&#39;, 3),
             (&#39;apple&#39;, 4),
             (&#39;orange&#39;, 2),
             (&#39;d&#39;, 1)])

In [12]: d.update({&quot;pear&quot;:99})

# 顺序没有改变
In [13]: d
Out[13]: 
OrderedDict([(&#39;pear&#39;, 99),
             (&#39;banana&#39;, 3),
             (&#39;apple&#39;, 4),
             (&#39;orange&#39;, 2),
             (&#39;d&#39;, 1)])

In [15]: del d[&#39;pear&#39;]

In [16]: d
Out[16]: OrderedDict([(&#39;banana&#39;, 3), (&#39;apple&#39;, 4), (&#39;orange&#39;, 2), (&#39;d&#39;, 1)])

In [17]: d.update({&#39;pear&#39;: 99})

# 移动到右边
In [18]: d
Out[18]: 
OrderedDict([(&#39;banana&#39;, 3),
             (&#39;apple&#39;, 4),
             (&#39;orange&#39;, 2),
             (&#39;d&#39;, 1),
             (&#39;pear&#39;, 99)])

In [22]: d.move_to_end(&#39;apple&#39;)
In [22]: &quot; &quot;.join(d.keys())
Out[22]: &#39;banana orange d pear apple&#39;

# 当last=False时，将移动到最左边
In [23]: d.move_to_end(&#39;apple&#39;, last=False)

In [24]: &quot; &quot;.join(d.keys())
Out[24]: &#39;apple banana orange d pear&#39;
</code></pre>]]></content>
      <categories>
        <category>python标准库</category>
      </categories>
  </entry>
  <entry>
    <title>python描述器</title>
    <url>/2018/08/04/python%E6%8F%8F%E8%BF%B0%E5%99%A8/</url>
    <content><![CDATA[<p>通常，描述器是具有“绑定行为”的对象属性，其属性访问已被描述器协议中的方法覆盖。这些方法是<strong>get __（），</strong> set <em>_（）和\</em>_delete __（）。如果为对象定义了任何这些方法，则称其为描述器.</p>
<pre><code>descr.__get__(self, obj, type=None) --&gt; value

descr.__set__(self, obj, value) --&gt; None

descr.__delete__(self, obj) --&gt; None
</code></pre><p>如果你想创建一个全新的实例属性，可以通过一个描述器类的形式来定义它的功 能。下面是一个例子：</p>
<pre><code>class Integer:
    def __init__(self, name):
        self.name = name
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]
    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise TypeError(&#39;Expected an int&#39;)
        instance.__dict__[self.name] = value
    def __delete__(self, instance):
        del instance.__dict__[self.name]


class Point:
    x = Integer(&#39;x&#39;)
    y = Integer(&#39;y&#39;)
    def __init__(self, x, y):
        self.x = x
        self.y = y
</code></pre><p>当你这样做后，所有对描述器属性(比如x 或y) 的访问会被get () 、set () 和delete () 方法捕获到. <img src="http://img.hysyeah.top/wp-content/uploads/2018/08/descriptor.png" alt> 描述器只能在类 级别被定义，而不能为每个实例单独定义。</p>
<hr>
<pre><code># 定义一个带__get__,__set__方法的描述符
In [5]: class D:
            def __init__(self):
                pass
            def __get__(self, instance, cls):
                print(&quot;D get...&quot;)
            def __set__(self, instance, val):
                self.value = val


In [6]: class TD:
            x = D()
            def __init__(self,x):
                self.x = x


In [11]: t = TD(1)
In [12]: t.x
D get...                #这里调用了描述符的__get__方法


# 去掉描述中的__set__方法
In [5]: class D:
            def __init__(self):
                pass
            def __get__(self, instance, cls):
                print(&quot;D get...&quot;)


In [6]: class TD:
            x = D()
            def __init__(self,x):
                self.x = x


In [11]: t = TD(1)
In [12]: t.x             #去掉__set__方法后并没调用描述符中的__get__方法
1
</code></pre><p>一个类，如果只定义了 <strong>get</strong>() 方法，而没有定义 <strong>set</strong>(), <strong>delete</strong>() 方法，则认为是非数据描述符； 反之，则成为数据描述符。 而非数据描述符的优先级是低于实例属性的。 python中的属性访问优先级： 1.<strong>getattribute</strong>()方法无条件调用 2.数据描述符（由1触发调用，若改写了<strong>getattribute</strong>(),可能会导致无法调用描述符) 3.实例对象的字典（若与描述符对象同名，会被覆盖) 4.类的字典 5.非数据描述符 6.父类的字典 7.<strong>getattr</strong>()方法</p>
<hr>
<p>使用一个描述器类定义一个延迟计算属性</p>
<pre><code>class lazyproperty:
    def __init__(self, func):
        self.func = func
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            value = self.func(instance)
            setattr(instance, self.func.__name__, value)
            return value

import math
class Circle:
    def __init__(self, radius):
        self.radius = radius
    @lazyproperty
    def area(self):
        print(&#39;Computing area&#39;)
        return math.pi * self.radius ** 2
    @lazyproperty
    def perimeter(self):
        print(&#39;Computing perimeter&#39;)
        return 2 * math.pi * self.radius
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/lazy.png" alt> 很多时候构建延迟计算属性的主要目的是为了提升性能，只有在真正需要的时候才进行计算。 上例中访问c.area只计算一次，当第一次计算后，c.area的值会存在实例的字典中，而只定义了一个<strong>get</strong>方法的非数据描述器的优先级是小于实例属性的,所以会直接访问实例属性。</p>
<pre><code>vars(...)
    vars([object]) -&gt; dictionary

    Without arguments, equivalent to locals().
    With an argument, equivalent to object.__dict__.
</code></pre><hr>
<p>Ref： 1.<a href="https://docs.python.org/3/howto/descriptor.html" target="_blank" rel="noopener">官方文档</a> 2.python cookbook 3.<a href="https://www.cnblogs.com/Jimmy1988/p/6808237.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jimmy1988/p/6808237.html</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python标准库之ast</title>
    <url>/2018/04/01/python%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8Bast/</url>
    <content><![CDATA[<h5 id="ast-Abstract-Syntax-Trees"><a href="#ast-Abstract-Syntax-Trees" class="headerlink" title="ast-Abstract Syntax Trees"></a>ast-Abstract Syntax Trees</h5><h5 id="用于帮助python应用处理抽象语法树"><a href="#用于帮助python应用处理抽象语法树" class="headerlink" title="用于帮助python应用处理抽象语法树"></a>用于帮助python应用处理抽象语法树</h5><pre><code>#　ast.literal_eval()将包含在字符串中的python结构转换为python结构，这些结构包含：strings, bytes, numbers, tuples, lists, dicts, sets, booleans, and None
In [33]: s = &#39;[1, 2, 3]&#39;

In [34]: lst = ast.literal_eval(s)

In [35]: lst
Out[35]: [1, 2, 3]

In [39]: s2 = &quot;{&#39;a&#39;: 1, &#39;b&#39;: 2}&quot;

In [40]: s2
Out[40]: &quot;{&#39;a&#39;: 1, &#39;b&#39;: 2}&quot;

In [41]: ast.literal_eval(s2)
Out[41]: {&#39;a&#39;: 1, &#39;b&#39;: 2}
</code></pre>]]></content>
      <categories>
        <category>python标准库</category>
      </categories>
  </entry>
  <entry>
    <title>python注释样本</title>
    <url>/2018/07/10/python%E6%B3%A8%E9%87%8A%E6%A0%B7%E6%9C%AC/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def select_proxy(url, proxies):</span><br><span class="line">    &quot;&quot;&quot;Select a proxy for the url, if applicable.</span><br><span class="line"></span><br><span class="line">    :param url: The url being for the request  #参数</span><br><span class="line">    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs</span><br><span class="line"></span><br><span class="line">    :rtype: dict   #返回值</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def twoSum(self, nums, target):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :type nums: List[int]</span><br><span class="line">    :type target: int</span><br><span class="line">    :rtype: List[int]</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>proxy protocol</title>
    <url>/2024/03/31/proxy-protocol/</url>
    <content><![CDATA[<h3 id="什么是Proxy-Protocol？"><a href="#什么是Proxy-Protocol？" class="headerlink" title="什么是Proxy Protocol？"></a>什么是Proxy Protocol？</h3><p>Proxy Protocol是一种用于在代理服务器和目标服务器之间传递连接信息的协议。在传统的网络通信中，当客户端连接通过代理服务器时，代理服务器会在转发连接之前修改源IP和端口等连接信息。这导致目标服务器无法正确识别客户端的真实IP和端口。<br>Proxy Protocol的出现解决了这个问题，它允许代理服务器在转发连接之前，将原始客户端连接的相关信息封装在特殊的协议头部中传递给目标服务器。目标服务器可以解析该头部信息，获取客户端的真实IP和端口等连接信息。</p>
<h3 id="Proxy-Protocol的工作原理"><a href="#Proxy-Protocol的工作原理" class="headerlink" title="Proxy Protocol的工作原理"></a>Proxy Protocol的工作原理</h3><p>Proxy Protocol使用一种简单而有效的协议头部格式来传递连接信息。协议头部被插入到原始客户端数据之前，以确保目标服务器能够正确解析它。</p>
<p>Proxy Protocol v1的协议头部格式如下：<br><code>PROXY &lt;TCP4|TCP6&gt; &lt;SOURCE_IP&gt; &lt;DESTINATION_IP&gt; &lt;SOURCE_PORT&gt; &lt;DESTINATION_PORT&gt;\r\n</code><br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">&lt;TCP4|TCP6&gt; 表示使用IPv4或IPv6协议</span><br><span class="line">&lt;SOURCE_IP&gt; 是原始客户端的IP地址</span><br><span class="line">&lt;DESTINATION_IP&gt; 是目标服务器的IP地址</span><br><span class="line">&lt;SOURCE_PORT&gt; 是原始客户端的端口号</span><br><span class="line">&lt;DESTINATION_PORT&gt; 是目标服务器的端口号</span><br><span class="line">协议头部以字符串形式表示，并以\r\n作为结束符</span><br></pre></td></tr></table></figure></p>
<p>如：<br><code>PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\r\n</code></p>
<p>当代理服务器收到客户端连接后，它会在转发连接之前将Proxy Protocol头部插入到客户端数据之前。目标服务器在接收连接时会检查是否存在Proxy Protocol头部，并解析其中的连接信息以确定客户端的真实来源。</p>
<h3 id="Proxy-Protocol的使用场景"><a href="#Proxy-Protocol的使用场景" class="headerlink" title="Proxy Protocol的使用场景"></a>Proxy Protocol的使用场景</h3><p>Proxy Protocol在以下场景中非常有用：</p>
<p>透明代理：当代理服务器处于透明模式时，Proxy Protocol可以确保目标服务器能够获得客户端的真实IP和端口信息。<br>负载均衡：当使用负载均衡器时，Proxy Protocol允许负载均衡器将客户端的连接信息传递给后端服务器，以便后端服务器能够正确处理请求。<br>反向代理：当反向代理服务器将请求转发给后端服务器时，Proxy Protocol可以确保后端服务器获得客户端的真实连接信息，以便进行合适的处理和记录</p>
<h3 id="使用golang简单模拟proxy-protocol"><a href="#使用golang简单模拟proxy-protocol" class="headerlink" title="使用golang简单模拟proxy protocol"></a>使用golang简单模拟proxy protocol</h3><h4 id="client-go"><a href="#client-go" class="headerlink" title="client.go"></a>client.go</h4><p>发送请求给proxy<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立 TCP 连接</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:40010"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	fmt.Println(<span class="string">"LocalAddr: "</span>, conn.LocalAddr())</span><br><span class="line"></span><br><span class="line">	_, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">"GET / HTTP/1.0\r\n\r\n"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读取响应</span></span><br><span class="line">	response := bufio.NewReader(conn)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line, err := response.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(line)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> line == <span class="string">"\r\n"</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取响应内容</span></span><br><span class="line">	<span class="keyword">var</span> body []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">		n, err := response.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		body = <span class="built_in">append</span>(body, buf[:n]...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印响应内容</span></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="proxy-go"><a href="#proxy-go" class="headerlink" title="proxy.go"></a>proxy.go</h4><p>接收客户端的请求，将<code>PROXY</code>写入连接中，并将请求转发给真实Server<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:40010"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> l.Close()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"proxy server listening on 127.0.0.1:40010..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := l.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleProxyConnectionProtocol(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleProxyConnectionProtocol</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	newConn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"Proxy NewConn Addr: "</span>, newConn.LocalAddr())</span><br><span class="line">	<span class="keyword">defer</span> newConn.Close()</span><br><span class="line">	<span class="comment">// 对于proxy来说，这里的RemotAddr()其实就是客户端的IP</span></span><br><span class="line">	remoteAddr := strings.Split(conn.RemoteAddr().String(), <span class="string">":"</span>)</span><br><span class="line">	localHost, localPort := remoteAddr[<span class="number">0</span>], remoteAddr[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	forwardAddr := strings.Split(newConn.LocalAddr().String(), <span class="string">":"</span>)</span><br><span class="line">	remoteHost, remotePort := forwardAddr[<span class="number">0</span>], forwardAddr[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	proxy := fmt.Sprintf(<span class="string">"PROXY TCP4 %s %s %s %s\r\n"</span>, localHost, remoteHost, localPort, remotePort)</span><br><span class="line"></span><br><span class="line">	n, err := newConn.Write([]<span class="keyword">byte</span>(proxy + <span class="string">"GET / HTTP/1.0\r\n\r\n"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"write %d bytes to newConn\n"</span>, n)</span><br><span class="line"></span><br><span class="line">	response := bufio.NewReader(newConn)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line, err := response.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		_, err = conn.Write([]<span class="keyword">byte</span>(line))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> line == <span class="string">"\r\n"</span> &#123;</span><br><span class="line">			_, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">"\r\n\r\n"</span>))</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatal(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取响应内容</span></span><br><span class="line">	<span class="keyword">var</span> body []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">		n, err := response.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		body = <span class="built_in">append</span>(body, buf[:n]...)</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = conn.Write(body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="server-go"><a href="#server-go" class="headerlink" title="server.go"></a>server.go</h4><p>处理来自客户端的请求<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> l.Close()</span><br><span class="line">	fmt.Println(<span class="string">"server protocol listening on 127.0.0.1:8080..."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := l.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> handleServerConnectionProtocol(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleServerConnectionProtocol</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	resp := bufio.NewReader(conn)</span><br><span class="line">	line, err := resp.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(line)</span><br><span class="line">	s := strings.Split(line, <span class="string">" "</span>)</span><br><span class="line">	fmt.Println(<span class="string">"Client Addr: "</span>, s[<span class="number">2</span>]+<span class="string">":"</span>+s[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	response := <span class="string">"HTTP/1.1 200 OK\r\n"</span> +</span><br><span class="line">		<span class="string">"Content-Length: 13\r\n"</span> +</span><br><span class="line">		<span class="string">"Content-Type: text/plain\r\n"</span> +</span><br><span class="line">		<span class="string">"\r\n"</span> +</span><br><span class="line">		<span class="string">"Hello, world!"</span></span><br><span class="line">	_, err = conn.Write([]<span class="keyword">byte</span>(response))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="模拟运行"><a href="#模拟运行" class="headerlink" title="模拟运行"></a>模拟运行</h4><p><code>go run server.go</code><br><code>go run proxy.go</code><br><code>go run client.go</code><br>可以发现<code>server</code>中打印的是<code>client</code>的IP和端口。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上代码是对<code>proxy protocol</code>的一个简单模拟，只是为了更好的理解<code>proxy protocol</code>本身。</p>
<hr>
<p>REF:</p>
<ol>
<li><p><a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt" target="_blank" rel="noopener">https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt</a></p>
</li>
<li><p><a href="https://inkel.github.io/posts/proxy-protocol/" target="_blank" rel="noopener">https://inkel.github.io/posts/proxy-protocol/</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>protocol</tag>
      </tags>
  </entry>
  <entry>
    <title>python求明氏距离</title>
    <url>/2018/05/16/python%E6%B1%82%E6%98%8E%E6%B0%8F%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h5 id="何为明式距离"><a href="#何为明式距离" class="headerlink" title="何为明式距离"></a><a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%B0%8F%E8%B7%9D%E7%A6%BB" target="_blank" rel="noopener">何为明式距离</a></h5><p>$ P = (x<em>{1},x</em>{2},\cdot \cdot \cdot,x<em>{n}) and Q=(y</em>{1},y<em>{2},\cdot \cdot \cdot,y</em>{n}) \in R^n $  </p>
<p>$ D(X,Y) = \bigg( \sum<em>{i=1}^n |x</em>{i} - y_{i}|^p\bigg)^{1/p} $  </p>
<p>假设P = (0,4),Q=(3,0),求P,Q两点的明氏距离。</p>
<pre><code>import numpy as np
from scipy.spatial import minkowski_distance
a = np.array([[0,4]])
a = np.array([[3,0]])
dist = minkowski_distance(a,b,1) #array([7])
dist = minkowski_distance(a,b,2) #array([5.])
dist = minkowski_distance(a,b,3) #array([4.49794145])
</code></pre><p>$ \lim<em>{p \to \infty} \bigg( \sum</em>{i=1}^n |x<em>{i}-y</em>{i}|^p\bigg)^{1/p} = \max<em>{i=1}^n |x</em>{i}-y_{i}| $  ,当p—&gt;oo时，P,Q两点的距离等于4</p>
<pre><code>from sympy import symbols, limit
p = symbols(&#39;p&#39;)
f = (3**p + 4**p)**(1/p) 
limit(f,p,oo)           # 4
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>python编码</title>
    <url>/2017/10/02/python%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h4 id="python2中的默认编码为ASCII-在python3改为了unicode。"><a href="#python2中的默认编码为ASCII-在python3改为了unicode。" class="headerlink" title="python2中的默认编码为ASCII,在python3改为了unicode。"></a>python2中的默认编码为ASCII,在python3改为了unicode。</h4><p><img src="http://img.hysyeah.top/wp-content/uploads/2017/10/u.jpg" alt="image"> <img src="http://img.hysyeah.top/wp-content/uploads/2017/10/u-1.jpg" alt="image"></p>
<h4 id="python2中-python3中已经没有-unicode-basestring"><a href="#python2中-python3中已经没有-unicode-basestring" class="headerlink" title="python2中,python3中已经没有(unicode,basestring)"></a>python2中,python3中已经没有(unicode,basestring)</h4><pre><code>unicode_type = unicode

string_type = basestring
</code></pre><p>python3中</p>
<pre><code>unicode_type = str

string_type = bytes
</code></pre><hr>
<p>Ref： 1.<a href="http://www.jianshu.com/p/2bb8a1300bfd" target="_blank" rel="noopener">http://www.jianshu.com/p/2bb8a1300bfd</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python迭代器与生成器</title>
    <url>/2017/08/30/python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>Iterable—可迭代 可迭代的序列类型包括，list,str,tuple,非序列类型包括dict,file,任何类只是你定义了<strong>iter</strong>方法就会被看作为可迭代对象。</p>
<pre><code>In [3]: from collections import Iterable, Iterator

In [4]: class A:
...:        def __init__(self):
...:            self.n = 0
...:        def __iter__(self):
...:            return self
...:

In [5]: a = A()

In [6]: isinstance(a, Iterable)
Out[6]: True
</code></pre><p>Iterator—迭代器 Iterator必须实现<strong>iter</strong>()和<strong>next</strong>()(python3)或next()(python2)两个方法，组成了迭代器协议。</p>
<pre><code>In [13]: class yrange:
...:         def __init__(self, n):
...:             self.i = 0
...:             self.n = n
...:
...:         def __iter__(self):
...:             return self
...:
...:         def __next__(self):
...:             if self.i &lt; self.n:
...:                 i = self.i
...:                 self.i += 1
...:                 return i
...:             else:
...:                 raise StopIteration()
...:

In [14]: it = yrange(3)

In [15]: it.__next__()
Out[15]: 0

In [16]: it.__next__()
Out[16]: 1

In [17]: it.__next__()
Out[17]: 2

In [18]: it.__next__()
---------------------------------------------------------------------------
StopIteration Traceback (most recent call last)
&lt;ipython-input-18-a1cc91b7bc73&gt; in &lt;module&gt;()
----&gt; 1 it.__next__()

&lt;ipython-input-13-55955e9c2cc7&gt; in __next__(self)
13 return i
14 else:
---&gt; 15 raise StopIteration()
16

StopIteration:
</code></pre><p>反向迭代一个序列，使用内置的reversed()函数，可以通过在自定义类上实现reversed () 方法来实现反向 迭代。</p>
<pre><code>In [19]: class yrange:
...:         def __init__(self, n):
...:             self.i = 0
...:             self.n = n
...:
...:         def __iter__(self):
...:             return self
...:
...:         def __next__(self):
...:             if self.i &lt; self.n:
...:                 i = self.i
...:                 self.i += 1
...:                 return i
...:             else:
...:                 raise StopIteration()
...:         def __reversed__(self):
...:             index = self.n - 1
...:             while index &gt;= 0:
...:                 yield index
...:                 index -= 1
...:

In [20]: it = reversed(yrange(3))

In [21]: it.__next__()
Out[21]: 2

In [22]: it.__next__()
Out[22]: 1

In [23]: it.__next__()
Out[23]: 0
</code></pre><p>generator—生成器 生成器是一个返回迭代器对象的函数。它和普通函数看起来一样，除了它包含了yield语句，产生可以通过for循环访问的值，或者可以通过调用<strong>next</strong>方法一次访问一个值。 生成的<strong>iter</strong>()和<strong>next</strong>()方法是自动创建的。。每次next()调用时，生成器再恢复它离开的位置（它记忆语句最 后一次执行的位置和所有的数据值）</p>
<pre><code>In [25]: def integer():
...:         i = 1
...:         while True:
...:             yield i
...:             i += 1
...:

In [26]: i = integer()

In [27]: i
Out[27]: &lt;generator object integer at 0x7fb940696fc0&gt;

In [29]: i.__next__()
Out[29]: 1
</code></pre><p>生成器—send方法,调用send()方法前，必须先调用<strong>next</strong>()方法（pep342)</p>
<pre><code>In [37]: def double_input():
...:         while True:
...:             x = yield
...:             yield x * 2

In [59]: gen = double_input()

In [60]: gen.__next__()

In [61]: gen.send(4)
Out[61]: 8

In [62]: gen.send(4)

In [63]: gen.send(4)
Out[63]: 8

In [64]: gen.__next__()

In [65]: gen.send(5)
Out[65]: 10
</code></pre><p>Ref： 1.<a href="http://anandology.com/python-practice-book/iterators.html" target="_blank" rel="noopener">http://anandology.com/python-practice-book/iterators.html</a> 2.官方文档</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python阶乘</title>
    <url>/2017/09/27/python%E9%98%B6%E4%B9%98/</url>
    <content><![CDATA[<pre><code>fact = lambda n:1 if n == 0 else n * fact(n-1)


&gt;&gt;&gt; fact(6)
720
&gt;&gt;&gt; reduce(lambda x,y:x*y, range(1, 7))
720
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>你真的了解python tuple不可变吗</title>
    <url>/2018/08/20/python%E9%9D%A2%E8%AF%95%E4%B9%8Btuple%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    <content><![CDATA[<p>最近遇到个有关tuple的面试题，挺有意思的。</p>
<pre><code># 下面会输出什么？为什么
In [18]: tu = (1, [1, 2])
In [19]: tu[1].append(3)
In [20]: print(tu)
(1, [1, 2, 3])
</code></pre><p>tupple不可变是指对象不可变，不可以对tuple中的元素进行赋值操作。它所包含的元素的可变性取决于该元素的属性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    In [22]: tu[1] = [1,2,3,4]</span><br><span class="line">    ---------------------------------------------------------------------------</span><br><span class="line">    TypeError                                 Traceback (most recent call last)</span><br><span class="line">    &lt;ipython-input-22-1e2059dd0201&gt; in &lt;module&gt;()</span><br><span class="line">    ----&gt; 1 tu[1] = [1,2,3,4]</span><br><span class="line">    </span><br><span class="line">    TypeError: &apos;tuple&apos; object does not support item assignment</span><br><span class="line"></span><br><span class="line">    In [23]: print(tu)           #报错，赋值操作未成功</span><br><span class="line">    (1, [1, 2, 3])</span><br><span class="line"></span><br><span class="line">    In [24]: tu[1] += [1,2,3,4]                                                     </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-6-e1dc81ae6e45&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 tu[1] += [1,2,3,4]</span><br><span class="line"></span><br><span class="line">TypeError: &apos;tuple&apos; object does not support item assignment</span><br><span class="line"></span><br><span class="line">In [25]: tu                          # 报错,虽然报错,但操作成功了                                             </span><br><span class="line">Out[26]: (1, [1, 2, 3, 1, 2, 3, 4])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    In [27]: class A:</span><br><span class="line">        ...:     a = 1</span><br><span class="line">        ...:</span><br><span class="line">    </span><br><span class="line">    In [28]: a = A()</span><br><span class="line">    In [29]: t = (1, a)</span><br><span class="line">    </span><br><span class="line">    In [30]: t[1].a = 2</span><br><span class="line">    </span><br><span class="line">    In [31]: print(t[1].a)</span><br><span class="line">    2</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python面试之名称修饰(name-mangling)</title>
    <url>/2018/08/21/python%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%90%8D%E7%A7%B0%E4%BF%AE%E9%A5%B0(name-mangling)/</url>
    <content><![CDATA[<pre><code>&gt;&gt;&gt; class MyClass():
... def __init__(self):
... self.__superprivate = &quot;Hello&quot;
... self._semiprivate = &quot;, world!&quot;
...
&gt;&gt;&gt; mc = MyClass()
&gt;&gt;&gt; print mc.__superprivate
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: myClass instance has no attribute &#39;__superprivate&#39;
&gt;&gt;&gt; print mc._semiprivate
, world!
&gt;&gt;&gt; print mc.__dict__
{&#39;_MyClass__superprivate&#39;: &#39;Hello&#39;, &#39;_semiprivate&#39;: &#39;, world!&#39;}
</code></pre><p><strong>foo</strong> :一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突. _foo :一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式. __foo :这个有真正的意义:解析器用 _classname__foo 来代替这个名字,以区别和其他类相同的命名.</p>
<hr>
<pre><code>In [1]: class A:
   ...:     __p = 1
   ...:

In [2]: A.__p
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-2-f532f70a0839&gt; in &lt;module&gt;()
----&gt; 1 A.__p

AttributeError: type object &#39;A&#39; has no attribute &#39;__p&#39;

In [6]: A._A__p
Out[6]: 1


In [7]: print(A.__dict__)
{&#39;__module__&#39;: &#39;__main__&#39;, &#39;_A__p&#39;: 1, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;A&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;A&#39; objects&gt;, &#39;__doc__&#39;: None}


# 在python中名称修饰用于私有成员，当一个成员名称以双下划线开头和不超过一个下划线结尾，  
# 它会在运行时被解释器重命名，以避免与任何子类中的方法产生命名冲突。重命名规则为&quot;_类名+变量&quot;,如_A__p。
</code></pre><hr>
<p>Ref： 1.<a href="https://en.wikipedia.org/wiki/Name_mangling#Python" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Name_mangling#Python</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>python面试之类变量访问顺序</title>
    <url>/2018/08/20/python%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%B1%BB%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<pre><code>class A:
    a = 1

a, b, c = A(), A(),A()

print(a.a, b.a, c.a)

a.a = 2
A.a = 3
print(a.a, A.a, c.a)

print(a.__dict__, A.__dict__, c.__dict__)

# 输出
(1, 1, 1)           #实例对象字典为空，从类的字典寻找变量，所以输出都为1
(2, 3, 3)           #实例a有了自己的字典，c没有自己的字典，从类的字典寻找变量，所以为3
({&#39;a&#39;: 2}, {&#39;a&#39;: 3, &#39;__module__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}, {})
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python魔法变量之__getattribute__,__getattr__</title>
    <url>/2017/09/20/python%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E4%B9%8B__getattribute__,__getattr__/</url>
    <content><![CDATA[<p>object.<strong>getattribute</strong>(self, name) 无条件调用，通过实例访问。如果类同时定义了<strong>getattr</strong>()，不会调用<strong>getattr</strong>()除非显式调用或产生了AttributeError。 object.<strong>getattr(self, name) 当未查找到访问的属性时，将会调用<strong>getattr</strong></strong>()方法</p>
<pre><code>In [49]: class T(object):
    ...:     a = &#39;hello&#39;
    ...:     def __getattribute__(self, *args, **kwargs):
    ...:         print(&quot;called __getattribute__&quot;)
    ...:         return object.__getattribute__(self, *args, **kwargs)
    ...:     def __getattr__(self, name):
    ...:         print(&quot;called __getattr__&quot;)
    ...:         return name


In [50]: t = T()

In [51]: t.a
called __getattribute__
Out[51]: &#39;hello&#39;

In [52]: t.b
called __getattribute__
called __getattr__
Out[52]: &#39;b&#39;
</code></pre><p>Ref： 1.<a href="https://docs.python.org/3/reference/datamodel.html?highlight=__getattr__#object.__getattr__" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>python面试之装饰器</title>
    <url>/2018/08/20/python%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<pre><code>import functools

def a(f):
    print(&#39;a&#39;)

    @functools.wraps(f)
    def wraps(*args, **kwargs):
        print(&#39;wraps&#39;)
        return f(*args, **kwargs)
    return wraps

@a
def b():
    print(&#39;b&#39;)

b()
b()
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/doc.png" alt> 第二次调用b()函数，并没有输出’a’,其实调用b(),b()相当于</p>
<pre><code>import functools

def a(f):
    print(&#39;a&#39;)

    @functools.wraps(f)
    def wraps(*args, **kwargs):
        print(&#39;wraps&#39;)
        return f(*args, **kwargs)
    return wraps

def b():
    print(&#39;b&#39;)


b = a(b)                 //此时打印&#39;a&#39;
b()
b()



# 当导入b的时候装饰器已经运行，而不是自己原以为的调用b时装饰器才运行
In [1]: from t1 import b
a
</code></pre><hr>
<p>update_wrapper是wraps的主要功能提供者，它负责考贝原函数的属性，默认是：’<strong>module</strong>‘, ‘<strong>name</strong>‘, ‘<strong>doc</strong>‘， ‘<strong>dict</strong>‘</p>
<pre><code>functools.update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES) 


# 通过wraps和update_wrapper实现结果是一致的
In [28]: from functools import wraps, update_wrapper

In [29]: def time1(func):
    ...:     @wraps(func)
    ...:     def wrapper(*args, **kwargs):
    ...:         start = time.time()
    ...:         func(*args, **kwargs)
    ...:         end = time.time()
    ...:         print(func.__name__, end-start)
    ...:     return wrapper
    ...: 

In [30]: def time2(func):
    ...:     
    ...:     def wrapper(*args, **kwargs):
    ...:         start = time.time()
    ...:         func(*args, **kwargs)
    ...:         end = time.time()
    ...:         print(func.__name__, end-start)
    ...:     return update_wrapper(wrapper,func)
    ...: 
    ...: 

In [31]: @time1
    ...: def fori():
    ...:     for i in range(1000):
    ...:         pass
    ...:     

In [32]: fori()
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python魔法变量之__init__,__del__</title>
    <url>/2017/10/02/python%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E4%B9%8B__init__,__del__/</url>
    <content><![CDATA[<p><strong>init</strong>相当于构造函数，<strong>del</strong>相当于析构函数,而事实上<strong>new</strong>才是构造函数，<strong>new</strong>返回一个实例，而<strong>init</strong>则进行一些初始化工作。</p>
<pre><code>In [3]: class A(object):
...:        def __init__(self):
...:            print(&quot;init&quot;)
...:        def __del__(self):
...:            print(&quot;del&quot;)
...:

In [4]: a = A()
init

In [5]: del a
del
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python魔法变量之__class__,__bases__,__mro__</title>
    <url>/2017/09/20/python%E9%AD%94%E6%B3%95%E5%8F%98%E9%87%8F%E4%B9%8B__class__,__bases__,__mro__/</url>
    <content><![CDATA[<p><strong>bases</strong>:一个类的基类</p>
<pre><code>In [4]: class B:
   ...:     pass
   ...: 

In [5]: class A(B):
   ...:     pass
   ...: 

In [6]: A.__bases__
Out[6]: (&lt;class __main__.B at 0x7fdafd3f89a8&gt;,)
</code></pre><p><strong>class</strong>:实例所对应的类（仅新式类中）</p>
<pre><code>In [12]: class T(object): #新式类
    ...:     pass
    ...: 

In [13]: t = T()

In [14]: type(t)
Out[14]: __main__.T

In [15]: t.__class__
Out[15]: __main__.T

In [21]: type(t) is t.__class__
Out[21]: True

In [29]: T.__class__
Out[29]: type

In [30]: T.__bases__
Out[30]: (object,)

In [31]: t.__bases__
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-28-92db851817a5&gt; in &lt;module&gt;()
----&gt; 1 t.__bases__

AttributeError: &#39;T&#39; object has no attribute &#39;__bases__&#39;


In [16]: class T1: # 旧式类,type(t)为instance,而新式类为class
    ...:     pass
    ...: 

In [17]: t = T1()

In [18]: type(t)
Out[18]: instance

In [24]: type(t) is  t.__class__
Out[24]: False


In [44]: class Base(object):
...: pass
...:

In [45]: class A(Base):
...: pass
...:

In [46]: A.__class__
Out[46]: type

In [47]: A.__mro__ #返回值一个元素为class元组，相当于js的原型链，在方法解析时会用到(作为查找路径)
Out[47]: (__main__.A, __main__.Base, object)

In [48]: Base.__subclasses__() #子类
Out[48]: [__main__.A]
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python魔法变量之__all__</title>
    <url>/2017/08/30/python%E9%AD%94%E6%B3%95%E5%8F%98%E9%87%8F%E4%B9%8B__all__/</url>
    <content><![CDATA[<p>如果用户写成</p>
<pre><code>from sound.effects import *
</code></pre><p>将会发生什么？理想情况下，你是希望到文件系统寻找这个包下的所有的模块，并导入它们。这可能要花费较长的时间，而且可能产生意想不到的副作用，这些作用本应该只有当子模块是显式导入时才会发生。 唯一的解决办法是包的作者为包提供显式的索引。import语句采用以下约定：如果包中的<strong>init</strong>.py代码定义了一个名为<strong>all</strong>的列表，那么在遇到</p>
<pre><code>from package import *
</code></pre><p>语句时，会把列表中的所有模块导入。 例如，文件sound/effects/<strong>init</strong>.py可以包含以下代码：</p>
<pre><code>__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre><p>这意味着</p>
<pre><code>from sound.effects import *
</code></pre><p>将导入sound包的三个子模块。 如果<strong>all</strong>没有定义，</p>
<pre><code>from sound.effects import *
</code></pre><p>不会从sound.effects包中导入所有的子模块到当前命名空间，它只保证sound.effects包已经被导入(可能会运行<strong>init</strong>.py中任何初始化 的代码)，然后导入包中定义的任何名称。这包括 由<strong>init</strong>.py定义的任何的名称（以及显式加载的子模块）。还包括这个包中已经由前面的import 语句显式加载的子模块。 例：</p>
<pre><code>import sound.effects.echo

import sound.effects.surround

from sound.effects import *
</code></pre><p>当执行from … import语句时，echo和surround模块被导入当前命名空间，因为前面已经通过import语句显式加载。 Ref：官方文档</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python魔法变量之__slots__</title>
    <url>/2017/09/08/python%E9%AD%94%E6%B3%95%E5%8F%98%E9%87%8F%E4%B9%8B__slots__/</url>
    <content><![CDATA[<p><strong>slots</strong>变量，用来限制类能添加的属性。由于’score’没有被放到<strong>slots</strong>中，所以不能绑定score属性，所以报错。 使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类起作用，对继承的子类是不起作用的： 除非在子类中也定义<strong>slots</strong>这样，子类允许定义的属性就是自身的<strong>slots</strong>加上父类的<strong>slots</strong>.</p>
<pre><code>In [1]: class Fruit(object):
...:        __slots__ = (&#39;name&#39;, &#39;age&#39;)
...:

In [2]: f = Fruit()

In [3]: f.name = &#39;hys&#39;

In [4]: f.age = 18

In [5]: f.score = 33
---------------------------------------------------------------------------
AttributeError Traceback (most recent call last)
&lt;ipython-input-5-f65d994e4176&gt; in &lt;module&gt;()
----&gt; 1 f.score = 33

AttributeError: &#39;Fruit&#39; object has no attribute &#39;score&#39;

In [6]: class Apple(Fruit):
...:        pass
...:

In [7]: a = Apple()

In [8]: a.name = &#39;hys&#39;

In [9]: a.score = 44

In [10]: class Bnana(Fruit):
...:         __slots__ = ()
...:

In [11]: b = Bnana()

In [12]: b.name = &#39;hys&#39;

In [13]: b.age = 33

In [14]: b.socre = 6
---------------------------------------------------------------------------
AttributeError Traceback (most recent call last)
&lt;ipython-input-14-140c427ae185&gt; in &lt;module&gt;()
----&gt; 1 b.socre = 6

AttributeError: &#39;Bnana&#39; object has no attribute &#39;socre&#39;
</code></pre><p>当定义了<strong>slots</strong>属性，Python会针对实例采用一种更加紧凑的内部表示。不再让每个实例都创建一个<strong>dict</strong>字典，现在的实例是围绕着一个固定长度的小型数组来构建的，这和一个元组或者列表很相似。在<strong>slots</strong>中列出的属性名会在内部映射到这个数组的索引下。使用<strong>slots</strong>节省下来的内存根据创建实例数量以及保存的属性类型而有所不同。 优点：节省内存 缺点：Python中有许多部分都依赖于传统的基于字典的实现。定义了<strong>slots</strong>属性的类不支持某些特定的功能，比如多重继承。就大部分情况而言，我们应该只针对那些在程序中被当做数据结构而频繁使用的类上采用<strong>slots</strong>。</p>
<hr>
<p>Ref： 1.<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868200605560b1bd3c660bf494282ede59fee17e781000&quot;" target="_blank" rel="noopener">博客</a> 2.python cookbook</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>racket list类型</title>
    <url>/2018/07/11/racket%20list%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="创建一个list-并赋值给变量lst"><a href="#创建一个list-并赋值给变量lst" class="headerlink" title="创建一个list,并赋值给变量lst"></a>创建一个list,并赋值给变量lst</h4><pre><code>&gt; (define lst (list 1 2 3 4))
&gt; lst
&#39;(1 2 3 4)
</code></pre><h4 id="list内置方法"><a href="#list内置方法" class="headerlink" title="list内置方法"></a>list内置方法</h4><pre><code>&gt; (length lst)                      ;列表长度
4
&gt; (list-ref lst 0)                  ;根据下标取值
1
&gt; (append lst (list 5 6 7))         ;连接两个列表
&#39;(1 2 3 4 5 6 7)
&gt; (reverse lst)                     ;反转列表
&#39;(4 3 2 1)
&gt; (member 5 (list 1 2 3))           ;判断元素是否存在于列表中
#f
&gt; (map sqrt (list 1 4 9 16))        ;依次对列表中的每个元素求算术平方根
&#39;(1 2 3 4)

&gt; (andmap string? (list &quot;a&quot; &quot;b&quot; 6)) ;判断列表中元素是否全部为string,
#f
&gt; (ormap number? (list &quot;a&quot; &quot;b&quot; 6))  ;判断列表中元素是否存在number

&gt; (filter string? (list &quot;a&quot; &quot;b&quot; 6)) ;对列表元素进行过滤
&#39;(&quot;a&quot; &quot;b&quot;)

&gt; (first (list 1 2 3))              ;返回列表中的第一个元素
1
&gt; (rest (list 1 2 3))               ;返回除第一个元素的剩余元素
&#39;(2 3)
</code></pre><hr>
<p>Ref： 1.<a href="https://docs.racket-lang.org/guide/Lists__Iteration__and_Recursion.html" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>Racket</category>
      </categories>
  </entry>
  <entry>
    <title>racket Characters类型</title>
    <url>/2018/07/20/racket%20Characters%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<pre><code>&gt; (char? #\a)                                            ;判断是否是字符
#t

&gt; (char-&gt;integer #\λ)                                    ;返回字符的整数
955
&gt; (char-&gt;integer #\A)
65

&gt; (integer-&gt;char 65)                                     ;将整数转换为整数
#\A


&gt; (char=? #\a #\a #\a)                                   ;判断多个字符是否相等
#t

&gt; (char&lt;? #\A #\a)                                       ;根据(char-&gt;integer v)返回的整数值进行比较
#t
&gt; (char&lt;? #\A #\λ)
#t

&gt; (char&lt;=? #\a #\b #\b)
#t

&gt; (char&gt;? #\a #\A)
#t

&gt; (char&gt;=? #\a #\A)
#t

;生成与Unicode定义的1对1映射一致的字符。如果字符没有大写映射，则char-upcase会生成char
&gt; (char-upcase #\a)
#\A
&gt; (char-upcase #\λ)
#\Λ

&gt; (char-downcase #\A)
#\a
&gt; (char-downcase #\Λ)
#\λ

;和char-upcase类似，但对对应于Unicode case-folding mapping
&gt; (char-foldcase #\A)
#\a
&gt; (char-foldcase #\Σ)
#\σ

&gt; (char-ci&lt;? #\A #\a)
#f
&gt; (char-ci&lt;? #\a #\b)
#t
&gt; (char-ci&lt;? #\a #\b #\c)
#t
</code></pre><hr>
<p>Ref： 1.<a href="http://docs.racket-lang.org/reference/characters.html#%28def._%28%28quote._~23~25kernel%29._char-upcase%29%29" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>Racket</category>
      </categories>
  </entry>
  <entry>
    <title>racket number类型</title>
    <url>/2018/07/16/racket%20number%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<pre><code>&gt; (number? 1)                         ;判断是否是number类型
#t

&gt; (complex? 1+2i)                     ;判断是否是complex类型
#t
&gt; (complex? 1)                        ;所有number都是complex类型，1==1+0i
#t

&gt; (real? 1)                           ;判断是否是实数
#t
&gt; (real? 1+i)
#f

&gt; (rational? 0.3)                     ;判断是否是有理数
#t

&gt; (integer? 1)                        ;判断是否是整数
#t
&gt; (integer? 1.0)
#t
&gt; (integer? 2.3)
#f

&gt; (exact? 1)                           ;判断是否是精确值
#t
&gt; (exact? 1.0)
#f

&gt; (inexact? 1)                         ;判断是否是非精确数
#f
&gt; (inexact? 1.0)
#t

&gt; (exact-integer? 1)                   ;相当于 (and (integer? v) (exact? v))
#t
&gt; (exact-integer? 4.0)
#f

&gt; (negative? -10)                      ;判断是否是负数，返回(&gt; x 0)
#t
&gt; (negative? -0.0)
#f

&gt; (positive? 10)                       ;判断是否是正数，返回(&gt; x 0)
#t
&gt; (positive? 0.0)
#f

&gt; (even? 2)                            ;判断是否是偶数，0属于偶数
#t
&gt; (even? 0)
#t

&gt; (odd? 11)                            ;判断是否是奇数
#t

&gt; (exact-nonnegative-integer? 0)       ;相当于(and (exact-integer? v) (not (negative? v)))
#t

&gt; (exact-positive-integer? 1)          ;相关于(and (exact-integer? v) (positive? v))
#t

&gt; (inexact-real? 1)                    ;相当于(and (real? v) (inexact? v))
#f

&gt; (flonum? 0)                          ;判断是否是浮点数，等同于(double-flonum? v)
#f
&gt; (flonum? 0.0)
#t

&gt; (single-flonum? 1.0)                  ;判断是否是单精度浮点数
#f

&gt; (zero? 0)                             ;判断是否等于0
#t
&gt; (zero? -0.0)
#t

&gt; (truncate 2.5)                        ;对数进行截断
2.0
&gt; (truncate -2.5)
-2.0

&gt; (numerator 3)                         ;返回数的分子
3
&gt; (numerator 14/3)
14

&gt; (denominator 5)                       ;返回数的分母
1
&gt; (denominator 17/4)
4

&gt; (expt 2 3)                            ;等于2**3
8
</code></pre><hr>
<p>Ref： 1.<a href="https://docs.racket-lang.org/reference/number-types.html" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>Racket</category>
      </categories>
  </entry>
  <entry>
    <title>racket string类型</title>
    <url>/2017/11/09/racket%20string%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<pre><code>(string-ref str k) → char? ;通过下标获取字符串元素
  str : string?
  k : exact-nonnegative-integer?&lt;/pre&gt;



&gt;(string-ref &quot;hello&quot; 0)
#\h



(make-string k [char]) → string?
  k : exact-nonnegative-integer?
  char : char? = #\nul
通过给定一个字符串长度，和一个默认填充字符串，返回一个可改变的字符串





&gt;(define s (make-string 5 #\z))
&gt;s
&quot;zzzzz&quot;



(string-set! str k char) → void?
  str : (and/c string? (not/c immutable?))
  k : exact-nonnegative-integer?
  char : char?
修改可变字符串str的第k个字符串为char&lt;/pre&gt;



&gt;(string-set! s 2 #\&amp;)
&gt;s
&quot;zz&amp;zz&quot;


(string&lt;? str1 str2 ...+) → boolean?
  str1 : string?
  str2 : string?
字符串比较，如果str1&lt;str2 ...+,刚返回#t,

(string&lt;=? str1 str2 ...+) → boolean?
  str1 : string?
  str2 : string?
(string=? str1 str2 ...+) → boolean?
  str1 : string?
  str2 : string?
判断str1,str2 ...+是否相等
(string&gt;? str1 str2 ...+) → boolean?
  str1 : string?
  str2 : string?&lt;/pre&gt;



(string-copy! dest  ;目标字符串  
    dest-start      ;目标字符串起始下标
    src             ;源字符串
    [src-start      ;源字符串起始下标
     src-end]) → void?  ;源字符串结束下标
    dest : (and/c string? (not/c immutable?))  
    dest-start : exact-nonnegative-integer?  
    src : string?  
    src-start : exact-nonnegative-integer? = 0  
    src-end : exact-nonnegative-integer? = (string-length src)


&gt;(string-copy! s 0 &quot;hello&quot; 0 5)
&gt;s
&quot;hello&quot;


(string-fill! dest char) → void?
  dest : (and/c string? (not/c immutable?))
  char : char?
  填充字符串&lt;/pre&gt;


&gt;(string-fill! s #\q)
&gt;s
&quot;qqqqq&quot;


(string-append str ...) → string?
  str : string?
返回一个新的拼接的字符串&lt;/pre&gt;


&gt;(string-append &quot;Apple&quot; &quot;Banana&quot;)
&quot;AppleBanana&quot;


(string-length str) → exact-nonnegative-integer?
  str : string?
  返回字符串长度&lt;/pre&gt;


&gt;(string-length &quot;Hello&quot;)
5


(substring str start [end]) → string?
  str : string?
  start : exact-nonnegative-integer?
  end : exact-nonnegative-integer? = (string-length str)
  获取子字符串&lt;/pre&gt;


&gt;(substring &quot;hello&quot; 0 4)
&quot;hell&quot;


(string-&gt;list str) → (listof char?)
  str : string?
  将字符串转换为列表&lt;/pre&gt;


&gt;(string-&gt;list &quot;Apple&quot;)
&#39;(#\A #\p #\p #\l #\e)


(list-&gt;string lst) → string?
  lst : (listof char?)
  将列表转换为string&lt;/pre&gt;


&gt;(list-&gt;string (list #\A #\p #\p #\l #\e))
&quot;Apple&quot;


(build-string n proc) → string?
  n : exact-nonnegative-integer?
  proc : (exact-nonnegative-integer? . -&gt;. char?)
  通过proc以0-n的顺序创建一个长度为n的字符串&lt;/pre&gt;


&gt;(build-string 5 (lambda (i) (integer-&gt;char (+ i 97))))
&quot;abcde&quot;


(string-ci=? str1 str2 ...+) → boolean?
  str1 : string?
  str2 : string?
  当参数str1,str2 ...+经过函数string-foldcase处理，若str1,str2 ...+相等则返回true
(string-ci&lt;? str1 str2 ...+) → boolean? 
  str1 : string? 
  str2 : string? 
(string-ci&lt;=? str1 str2 ...+) → boolean? 
  str1 : string? 
  str2 : string? 
(string-ci&gt;? str1 str2 ...+) → boolean? 
  str1 : string? 
  str2 : string?&lt;/pre&gt;


&gt;(string-ci=? &quot;Apple&quot; &quot;apple&quot;)
#t


(string-upcase str) → string?
  str : string?
  将字符串转换为大写
(string-downcase string) → string?
  string : string?
  将字符串转换为小写
(string-titlecase string) → string?
  string : string?
  将单词的第一个字母进行大写
(string-foldcase string) → string?
  string : string?
  将字符串转换为小写，特殊字符存在某种转换&lt;/pre&gt;


&gt;(string-foldcase &quot;Straße&quot;)
&quot;strasse&quot;
&gt;(string-downcase &quot;Straße&quot;)
&quot;straße&quot;


(string-join strs    ;以指定分隔符连接字符串
   [sep    
   #:before-first before-first    
   #:before-last before-last    
   #:after-last after-last]) → string?  
  strs : (listof string?)  
  sep : string? = &quot; &quot;  
  before-first : string? = &quot;&quot;  
  before-last : string? = sep  
  after-last : string? = &quot;&quot;)


&gt;(string-join &#39;(&quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot;) &quot;;&quot;)
&quot;one;two;three;four&quot;


 (string-split str   ;切分字符串，返回一个列表
    [sep    
     #:trim? trim?    
     #:repeat? repeat?]) → (listof string?)  
    str : string?  
    sep : (or/c string? regexp?) = #px&quot;\\s+&quot;  
    trim? : any/c = #t  
    repeat? : any/c = #f)&lt;/pre&gt;


&gt;(string-split &quot; foo bar baz \r\n\t&quot;)
&#39;(&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;)


(string-trim str    ;去掉字符串前后的sep
   [sep    
    #:left? left?    
    #:right? right?    
    #:repeat? repeat?]) → string?  
   str : string?  
   sep : (or/c string? regexp?) = #px&quot;\\s+&quot;  
   left? : any/c = #t  
   right? : any/c = #t  repeat? : any/c = #f&lt;/pre&gt;


&gt;(string-trim &quot;  foo bar  baz \r\n\t&quot;)
&quot;foo bar  baz&quot;


(non-empty-string? x) → boolean?
  x : any/c
当x是字符串且不为空时，返回#t，否则返回#f&lt;/pre&gt;


&gt;(non-empty-string? &quot;&quot;)
#f


(string-contains? s contained) → boolean?
  s : string?
  contained : string?
判断containde是否存在于s中&lt;/pre&gt;


&gt;(string-contains? &quot;ab&quot; &quot;a&quot;)
#t


(string-prefix? s prefix) → boolean?
  s : string?
  prefix : string?
  判断是否是开头
(string-suffix? s suffix) → boolean?
  s : string?
  suffix : string?
  判断是否是结尾&lt;/pre&gt;


&gt;(string-prefix? &quot;hello&quot; &quot;he&quot;)
#t


&gt;(string-suffix? &quot;hello&quot; &quot;lo&quot;)
#t
</code></pre><p>Ref： 1.<a href="https://docs.racket-lang.org/reference/strings.html?q=string#%28def._%28%28quote._~23~25kernel%29._string%29%29" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>Racket</category>
      </categories>
  </entry>
  <entry>
    <title>racket安装</title>
    <url>/2017/09/25/racket%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>系统ubuntu16.04，64位 1.<a href="https://download.racket-lang.org/" target="_blank" rel="noopener">从官网根据系统下载安装包</a> 2.安装，如下图 <img src="http://img.hysyeah.top/wp-content/uploads/2017/09/1.png" alt="image"> 3.添加环境变量 在~/.bashrc添加</p>
<pre><code>export PATH=&amp;quot;/usr/local/racket/bin:$PATH&amp;quot;

source ~/.bashrc
</code></pre><p>4.racket,进入REPL环境</p>
]]></content>
      <categories>
        <category>Racket</category>
      </categories>
  </entry>
  <entry>
    <title>racket条件语句</title>
    <url>/2018/07/11/racket%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h4 id="if-‹expr›-‹expr›-‹expr›"><a href="#if-‹expr›-‹expr›-‹expr›" class="headerlink" title="( if ‹expr› ‹expr› ‹expr› )"></a>( if ‹expr› ‹expr› ‹expr› )</h4><h4 id="if语句，若2-gt-3输出”bigger”-否则输出”smaller”"><a href="#if语句，若2-gt-3输出”bigger”-否则输出”smaller”" class="headerlink" title="if语句，若2&gt;3输出”bigger”,否则输出”smaller”"></a>if语句，若2&gt;3输出”bigger”,否则输出”smaller”</h4><pre><code>&gt; (if (&gt; 2 3)
      &quot;bigger&quot;
      &quot;smaller&quot;)
</code></pre><h4 id="cond-‹expr›-‹expr›-相当于C中的switch-else相当于c中的default"><a href="#cond-‹expr›-‹expr›-相当于C中的switch-else相当于c中的default" class="headerlink" title="( cond {[ ‹expr› ‹expr› ]} )(相当于C中的switch,else相当于c中的default)"></a>( cond {[ ‹expr› ‹expr›<em> ]}</em> )(相当于C中的switch,else相当于c中的default)</h4><pre><code>&gt; (define (reply-more s)
    (cond
      [(equal? &quot;hello&quot; (substring s 0 5))
       (string-append &quot;this is &quot; s)]
      [(equal? &quot;goodbye&quot; (substring s 0 7))
       (string-append &quot;this is &quot; s)]
      [else &quot;hehe&quot;]))

&gt; (reply-more &quot;hello&quot;)
&quot;this is hello&quot;
&gt; (reply-more &quot;dfdfllfd&quot;)
&quot;hehe&quot;
</code></pre><h4 id="and-‹expr›-当所有表达式为真时，返回真"><a href="#and-‹expr›-当所有表达式为真时，返回真" class="headerlink" title="( and ‹expr›* )(当所有表达式为真时，返回真)"></a>( and ‹expr›* )(当所有表达式为真时，返回真)</h4><pre><code>&gt; (define (is-digit v)
    (if (and (number? v) (&gt; v 0) (&lt; v 10))
        &quot;v is a number and value is between 1-9&quot;
        &quot;v is not a number&quot;))
&gt; (is-digit 5)
&quot;v is a number and value is between 1-9&quot;
</code></pre><h4 id="or-‹expr›-当任一表达式为真时，返回真"><a href="#or-‹expr›-当任一表达式为真时，返回真" class="headerlink" title="( or ‹expr›* )(当任一表达式为真时，返回真)"></a>( or ‹expr›* )(当任一表达式为真时，返回真)</h4><pre><code>&gt; (define (str-num v)
    (if (or (string? v) (number? v))
        &quot;v is string or number&quot;
        &quot;v is not string or number&quot;))
</code></pre><hr>
<p>Ref： 1.<a href="https://docs.racket-lang.org/guide/syntax-overview.html" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>Racket</category>
      </categories>
  </entry>
  <entry>
    <title>racket自定义数据类型</title>
    <url>/2017/11/08/racket%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>racket的自定义数据类型可以 看作C语言的结构体</p>
<pre><code>&gt;(struct posn (x y)) ;定义个结构体，成员为x,y,默认是不透明结构体

&gt;(define p1 (posn 1 2));定义了p1变量

&gt; (define p2 (struct-copy posn p1 [x 3]));拷贝posn p1 将p1.x修改为3,并将这个变量赋值给p2
&gt; (list (posn-x p2) (posn-y p2));p2.x=3
&#39;(3 2)
&gt; (list (posn-x p1) (posn-x p2));而p1.x=1,使用struct-copy并不会改变p1.x的值
&#39;(1 3)



&gt;(struct posn (x y))
&gt;(struct 3d-posn posn (z)); 这两行相当于如下C语言：

struct posn {

int x;

int y;

}

struct 3d-posn {

struct posn;

int z;

}

&gt;(define p (3d-posn 1 2 3))

&gt; (3d-posn-z p)

3

;3d-posn并不包含x,y变量直接访问报错
&gt; (3-posn-x p)
. . 3-posn-x: undefined;
cannot reference an identifier before its definition
可以这样访问
&gt; (posn-x p)
1
</code></pre><p>透明结构体，会显示成员变量的值，结构体默认是不透明的</p>
<pre><code>&gt; (struct posn (x y)
#:transparent)
&gt; (posn 1 2)
(posn 1 2)

结构体的比较
&gt; (struct posn(x y))
&gt; (struct tr (x y) #:transparent)
&gt; (equal? (tr 1 2) (tr 1 2))
#t
&gt; (struct op (x y))
&gt; (equal? (op 1 2) (op 1 2));要比较不透明结构体，可通过#:methods,gen:equal+hash实现三种方法
#f
</code></pre><p>未完</p>
<hr>
<p>Ref：<br>1.<a href="https://docs.racket-lang.org/guide/define-struct.html#%28part._.Simple_.Structure_.Types__struct%29" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>Racket</category>
      </categories>
  </entry>
  <entry>
    <title>racket lambda和let</title>
    <url>/2017/11/09/racket%20lambda%E5%92%8Clet/</url>
    <content><![CDATA[<p><strong>lambda</strong></p>
<pre><code>(lambda kw-formals body ...+);kw-formals：参数，body：表达式
&gt; ((lambda (x y) (+ x y)) 1 2);参数为x,y,表达式(+ x y),实参1,2
&gt; 3

&gt; (define add (lambda (x y) (+ x y)))
&gt; (add 1 2)
3

&gt; ((lambda (x [y 5]) (list y x)) 1 2);参数y有一个默认值5,若没有提供参数，则y输出5
&#39;(2 1)
</code></pre><p><strong>let</strong> location和top-level变量类似，location产生的时候使用一个从未使用过的名称，不能被重新生成和直接访问， 这里top-level变量应该指的是其它语言的全局变量。</p>
<pre><code>(let ([id val-expr] ...) body ...+)
(let proc-id ([id init-expr] ...) body ...+)

从左到执行表达式，为每个id创建一个location,并将值赋给这个location，然后执行body中的语句。

&gt; (let ([x 5] [y 5]) (+ x y));
10
&gt; (let fac ([n 10])
    (if (zero? n)
        1
        (* n (fac (sub1 n)))))
3628800


(let* ([id val-expr] ...) body ...+)
和let相像，一个一个执行val-expr,为每个id创建location,绑定ids到val-exprS和bodyS中。
&gt;(let* ([x 1]
       [y (+ x 1)])
   (list y x))
&#39;(2 1)
如果此处将let*改为let,则会报错(x未定义,因为x为绑定到var-exprS中)



(letrec ([id val-expr] ...) body ...+)
和let相似，从左到右执行val-exprS，但所有idS的location是先创建的，当执行val-expr后，
idS马上被初始化，绑定到val-exprS和bodyS命名空间中。


(let-values ([(id ...) val-expr] ...) body ...+)
和let相似，val-expr中返回的变量必须和id中的数量一致，绑定到body中，

&gt; (let-values ([(x y) (quotient/remainder 10 3)])
    (list y x))
&#39;(1 3)
(let*-values ([(id ...) val-expr] ...) body ...+);和let-values相似，但会把location绑定到val-exprS中。

(letrec-values ([(id ...) val-expr] ...) body ...+);和letrec相似，对id赋值的方式不一样
</code></pre><hr>
<p>Ref： 1.<a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29&quot;" target="_blank" rel="noopener">官方文档lambda</a> 2.<a href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29" target="_blank" rel="noopener">官方文档let</a></p>
]]></content>
      <categories>
        <category>Racket</category>
      </categories>
  </entry>
  <entry>
    <title>redis之链表实现</title>
    <url>/2018/08/11/redis%E4%B9%8B%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Redis链表的实现代码在src/[adlist.h, adlist.c]</p>
<pre><code>typedef struct listNode {
    // 指向前节点的指针
    struct listNode *prev;

    // 指向后节点的指针
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/dualist.png" alt></p>
<pre><code>typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

    // 链表所包含的节点数量
    unsigned long len;

} list;
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/adlist.png" alt></p>
<pre><code>// 返回给定链表所包含的节点数量
// T = O(1)
#define listLength(l) ((l)-&gt;len)
// 返回给定链表的表头节点
// T = O(1)
#define listFirst(l) ((l)-&gt;head)
// 返回给定链表的表尾节点
// T = O(1)
#define listLast(l) ((l)-&gt;tail)
// 返回给定节点的前置节点
// T = O(1)
#define listPrevNode(n) ((n)-&gt;prev)
// 返回给定节点的后置节点
// T = O(1)
#define listNextNode(n) ((n)-&gt;next)
// 返回给定节点的值
// T = O(1)
#define listNodeValue(n) ((n)-&gt;value)

// 将链表 l 的值复制函数设置为 m
// T = O(1)
#define listSetDupMethod(l,m) ((l)-&gt;dup = (m))
// 将链表 l 的值释放函数设置为 m
// T = O(1)
#define listSetFreeMethod(l,m) ((l)-&gt;free = (m))
// 将链表的对比函数设置为 m
// T = O(1)
#define listSetMatchMethod(l,m) ((l)-&gt;match = (m))

// 返回给定链表的值复制函数
// T = O(1)
#define listGetDupMethod(l) ((l)-&gt;dup)
// 返回给定链表的值释放函数
// T = O(1)
#define listGetFree(l) ((l)-&gt;free)
// 返回给定链表的值对比函数
// T = O(1)
#define listGetMatchMethod(l) ((l)-&gt;match)


// 创建一个新的链表
list *listCreate(void)
{
    struct list *list;

    // 分配内存
    if ((list = zmalloc(sizeof(*list))) == NULL)
        return NULL;

    // 初始化属性
    list-&gt;head = list-&gt;tail = NULL;
    list-&gt;len = 0;
    list-&gt;dup = NULL;
    list-&gt;free = NULL;
    list-&gt;match = NULL;

    return list;
}


/*
 * 释放整个链表，以及链表中所有节点
 *
 * T = O(N)
 */
void listRelease(list *list)
{
    unsigned long len;
    listNode *current, *next;

    // 指向头指针
    current = list-&gt;head;
    // 遍历整个链表
    len = list-&gt;len;
    while(len--) {
        next = current-&gt;next;

        // 如果有设置值释放函数，那么调用它
        if (list-&gt;free) list-&gt;free(current-&gt;value);

        // 释放节点结构
        zfree(current);

        current = next;
    }

    // 释放链表结构
    zfree(list);
}


/*
 * 将一个包含有给定值指针 value 的新节点添加到链表的表头
 *
 * 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL
 *
 * 如果执行成功，返回传入的链表指针
 *
 * T = O(1)
 */
list *listAddNodeHead(list *list, void *value)
{
    listNode *node;

    // 为节点分配内存
    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;

    // 保存值指针
    node-&gt;value = value;

    // 添加节点到空链表
    if (list-&gt;len == 0) {
        list-&gt;head = list-&gt;tail = node;
        node-&gt;prev = node-&gt;next = NULL;
    // 添加节点到非空链表
    } else {
        node-&gt;prev = NULL;          //新节点前驱置为NULL
        node-&gt;next = list-&gt;head;    //新节点的后驱置为头节点
        list-&gt;head-&gt;prev = node;    //头结点的前驱更新为node节点
        list-&gt;head = node;          //头结点更新为node节点
    }

    // 更新链表节点数
    list-&gt;len++;

    return list;
}


/*
 * 将一个包含有给定值指针 value 的新节点添加到链表的表尾
 *
 * 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL
 *
 * 如果执行成功，返回传入的链表指针
 *
 * T = O(1)
 */
list *listAddNodeTail(list *list, void *value)
{
    listNode *node;

    // 为新节点分配内存
    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;

    // 保存值指针
    node-&gt;value = value;

    // 目标链表为空
    if (list-&gt;len == 0) {
        list-&gt;head = list-&gt;tail = node;
        node-&gt;prev = node-&gt;next = NULL;
    // 目标链表非空
    } else {
        node-&gt;prev = list-&gt;tail;    //node节点前驱为尾结点
        node-&gt;next = NULL;          //node节点后驱置为NULL
        list-&gt;tail-&gt;next = node;    //尾结点的后驱更新为node结点
        list-&gt;tail = node;          //尾结点更新为node结点
    }

    // 更新链表节点数
    list-&gt;len++;

    return list;
}


/*
 * 创建一个包含值 value 的新节点，并将它插入到 old_node 的之前或之后
 *
 * 如果 after 为 0 ，将新节点插入到 old_node 之前。
 * 如果 after 为 1 ，将新节点插入到 old_node 之后。
 *
 * T = O(1)
 */
list *listInsertNode(list *list, listNode *old_node, void *value, int after) {
    listNode *node;

    // 创建新节点
    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;

    // 保存值
    node-&gt;value = value;

    // 将新节点添加到给定节点之后
    if (after) {
        node-&gt;prev = old_node;
        node-&gt;next = old_node-&gt;next;
        // 给定节点是原表尾节点
        if (list-&gt;tail == old_node) {
            list-&gt;tail = node;
        }
    // 将新节点添加到给定节点之前
    } else {
        node-&gt;next = old_node;
        node-&gt;prev = old_node-&gt;prev;
        // 给定节点是原表头节点
        if (list-&gt;head == old_node) {
            list-&gt;head = node;
        }
    }

    // 更新新节点的前置指针
    if (node-&gt;prev != NULL) {
        node-&gt;prev-&gt;next = node;
    }
    // 更新新节点的后置指针
    if (node-&gt;next != NULL) {
        node-&gt;next-&gt;prev = node;
    }

    // 更新链表节点数
    list-&gt;len++;

    return list;
}


/*
 * 取出链表的表尾节点，并将它移动到表头，成为新的表头节点。
 *
 * T = O(1)
 */
void listRotate(list *list) {
    listNode *tail = list-&gt;tail;// 取出表尾节点

    if (listLength(list) &lt;= 1) return;

    /* Detach current tail */

    list-&gt;tail = tail-&gt;prev; //尾结点为先尾结点的前一个结点
    list-&gt;tail-&gt;next = NULL; //新尾结点指向NULL

    /* Move it as head */
    // 插入到表头
    list-&gt;head-&gt;prev = tail; //旧头结点的前驱变为旧尾结点
    tail-&gt;prev = NULL;       //旧尾结点的前驱置为NULL
    tail-&gt;next = list-&gt;head; //旧尾结点的后驱置为头结点
    list-&gt;head = tail;       //新头结点置为旧尾结点
}


/*
 * 从链表 list 中删除给定节点 node 
 * 
 * 对节点私有值(private value of the node)的释放工作由调用者进行。
 *
 * T = O(1)
 */
void listDelNode(list *list, listNode *node)
{
    // 调整前置节点的指针
    if (node-&gt;prev)
        node-&gt;prev-&gt;next = node-&gt;next;
    else
        list-&gt;head = node-&gt;next;

    // 调整后置节点的指针
    if (node-&gt;next)
        node-&gt;next-&gt;prev = node-&gt;prev;
    else
        list-&gt;tail = node-&gt;prev;

    // 释放值
    if (list-&gt;free) list-&gt;free(node-&gt;value);

    // 释放节点
    zfree(node);

    // 链表数减一
    list-&gt;len--;
}


// 为给定链表创建一个迭代器，之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点
listIter *listGetIterator(list *list, int direction)
{
    // 为迭代器分配内存
    listIter *iter;
    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;

    // 根据迭代方向，设置迭代器的起始节点
    if (direction == AL_START_HEAD)
        iter-&gt;next = list-&gt;head;
    else
        iter-&gt;next = list-&gt;tail;

    // 记录迭代方向
    iter-&gt;direction = direction;

    return iter;
}


// 返回迭代器当前所指向的节点
listNode *listNext(listIter *iter)
{
    listNode *current = iter-&gt;next;

    if (current != NULL) {
        // 根据方向选择下一个节点
        if (iter-&gt;direction == AL_START_HEAD)
            // 保存下一个节点，防止当前节点被删除而造成指针丢失
            iter-&gt;next = current-&gt;next;
        else
            // 保存下一个节点，防止当前节点被删除而造成指针丢失
            iter-&gt;next = current-&gt;prev;
    }

    return current;
}


listNode *listSearchKey(list *list, void *key)
{
    listIter *iter;
    listNode *node;

    // 迭代整个链表
    iter = listGetIterator(list, AL_START_HEAD);
    while((node = listNext(iter)) != NULL) {

        // 对比
        if (list-&gt;match) {
            if (list-&gt;match(node-&gt;value, key)) {
                listReleaseIterator(iter);
                // 找到
                return node;
            }
        } else {
            if (key == node-&gt;value) {
                listReleaseIterator(iter);
                // 找到
                return node;
            }
        }
    }

    listReleaseIterator(iter);

    // 未找到
    return NULL;
}
</code></pre><p><a href="https://github.com/hys20151008/datastructures/blob/master/adlist.c" target="_blank" rel="noopener">测试代码</a></p>
<hr>
<p>Ref： 1.Redis设计与实现 2.Redis源码</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>redis之简单字符串SDS</title>
    <url>/2018/08/08/redis%E4%B9%8B%E7%AE%80%E5%8D%95%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/</url>
    <content><![CDATA[<h4 id="redis并没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串-simple-dynamic-string-SDS-的抽象类型，并将SDS用作Redis的默认字符串表示。"><a href="#redis并没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串-simple-dynamic-string-SDS-的抽象类型，并将SDS用作Redis的默认字符串表示。" class="headerlink" title="redis并没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串(simple dynamic string,SDS)的抽象类型，并将SDS用作Redis的默认字符串表示。"></a>redis并没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串(simple dynamic string,SDS)的抽象类型，并将SDS用作Redis的默认字符串表示。</h4><pre><code>struct sdshdr {
    // buf 中已占用空间的长度
    int len;
    // buf 中剩余可用空间的长度
    int free;
    // 数据空间，char类型的数组，以空字符&#39;\0&#39;结尾，空字符不计算在SDS中的len属性里
    char buf[];
};
</code></pre><p>SDS与C字符串的区别: 1.SDS中len属性记录了SDS的长度，所以获取一个SDS长度的复杂度仅为O(1)，而为了获取C字符串的长度必须对C字符串进行遍历，直到遇到代表字符串结尾的空字符串为止，复杂度为O(N)。 2.SDS的空间分配策略完全杜绝了发生缓冲溢出的可能性：当SDS API需要对SDS进行修改时，API会首先检查SDS的空间是否满足修改所需要的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题。 3.减少修改字符串带来的内存重分配次数 3.1空间预分配 - 如果对SDS进行修改之后，SDS的长度将小于1MB，那么将程序分配两倍所需长度的空间。 - 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配所需长度加上SDS_MAX_PREALLOC(默认为1M)。 通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。<br>3.2 惰性空间释放 - 惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不会立即使用内存分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。 4.<a href="https://en.wikipedia.org/wiki/Binary-safe" target="_blank" rel="noopener">二进制安全</a> C字符串中的字符必须符合某种编码(如ASCII),并且除了字符串的末的尾之外，字符串里不能包含空字符，否则会被认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。SDS的API都是二进制安全的，所有SDS API都会以处理二进制的方式处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入的时候是什么样的，它被读取时就是什么样的。 C字符串与SDS之间的区别</p>
<p>C字符串</p>
<p>SDS</p>
<p>获取字符串长度的复杂度为O(N)</p>
<p>获取字符串长度的复杂度为O(1)</p>
<p>API不安全，可能会造成缓冲区溢出</p>
<p>API是安全的，不会造成缓冲区溢出</p>
<p>修改字符串长度N次必然需要执行N次内存分配</p>
<p>修改字符串长度N次最多需要执行N次内存分配</p>
<p>只能保存文本</p>
<p>可以保存文本或者二进制数据</p>
<p>可以使用所有<string.h>库中的函数</string.h></p>
<p>可以使用部分<string.h>中的函数</string.h></p>
<hr>
<pre><code>// 创建一个包含给定C字符串的SDS
sds sdsnewlen(const void *init, size_t initlen) {

    struct sdshdr *sh;

    // 根据是否有初始化内容，选择适当的内存分配方式
    // T = O(N)
    if (init) {
        // zmalloc 不初始化所分配的内存
        sh = zmalloc(sizeof(struct sdshdr)+initlen+1);
    } else {
        // zcalloc 将分配的内存全部初始化为 0
        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);
    }

    // 内存分配失败，返回
    if (sh == NULL) return NULL;

    // 设置初始化长度
    sh-&gt;len = initlen;
    // 新 sds 不预留任何空间
    sh-&gt;free = 0;
    // 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中
    // T = O(N)
    if (initlen &amp;&amp; init)
        memcpy(sh-&gt;buf, init, initlen);
    // 以 \0 结尾
    sh-&gt;buf[initlen] = &#39;\0&#39;;

    // 返回 buf 部分，而不是整个 sdshdr
    return (char*)sh-&gt;buf;
}



// 创建一个包含给定C字符串的SDS,在sdsnewlen基础上添加的对char *init的判断
sds sdsnew(const char *init) {
    size_t initlen = (init == NULL) ? 0 : strlen(init);
    return sdsnewlen(init, initlen);
}


/*
 * 返回 sds 实际保存的字符串的长度
 *
 * T = O(1)
 */
 // 因为创建SDS时返回的是指向buf部分的指针，所以通过指针运算取得指向sdshdr的指针
static inline size_t sdslen(const sds s) {
    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
    return sh-&gt;len;
}


/*
 * 返回 sds 可用空间的长度
 *
 * T = O(1)
 */
static inline size_t sdsavail(const sds s) {
    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
    return sh-&gt;free;
}


// 创建并返回一个只保存了空字符串&quot;&quot;的sds
sds sdsempty(void) {
    return sdsnewlen(&quot;&quot;,0);
}


// 复制给定sds的副本
sds sdsdup(const sds s) {
    return sdsnewlen(s, sdslen(s));
}


// 释放sds
void sdsfree(sds s) {
    if (s == NULL) return;
    zfree(s-sizeof(struct sdshdr));
}


// 清空SDS保存的字符串为空字符串，并没有释放内存
void sdsclear(sds s) {

    // 取出 sdshdr
    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));

    // 重新计算属性
    sh-&gt;free += sh-&gt;len;
    sh-&gt;len = 0;

    // 将结束符放到最前面（相当于惰性地删除 buf 中的内容）
    sh-&gt;buf[0] = &#39;\0&#39;;
}


/* 扩展sds大小，先判断空余长度是否大于需要扩展的长度，如果是直接返回sds。然后再判断，如果对SDS进行修改之后，SDS的长度将小于1MB，那么将程序分配两倍所需长度的空间。
如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配所需长度加上SDS_MAX_PREALLOC(默认为1M)
*/
sds sdsMakeRoomFor(sds s, size_t addlen) {

    struct sdshdr *sh, *newsh;

    // 获取 s 目前的空余空间长度
    size_t free = sdsavail(s);

    size_t len, newlen;

    // s 目前的空余空间已经足够，无须再进行扩展，直接返回
    if (free &gt;= addlen) return s;

    // 获取 s 目前已占用空间的长度
    len = sdslen(s);
    sh = (void*) (s-(sizeof(struct sdshdr)));

    // s 最少需要的长度
    newlen = (len+addlen);

    // 根据新长度，为 s 分配新空间所需的大小
    if (newlen &lt; SDS_MAX_PREALLOC)
        // 如果新长度小于 SDS_MAX_PREALLOC 
        // 那么为它分配两倍于所需长度的空间
        newlen *= 2;
    else
        // 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC
        newlen += SDS_MAX_PREALLOC;
    // T = O(N)
    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);

    // 内存不足，分配失败，返回
    if (newsh == NULL) return NULL;

    // 更新 sds 的空余长度
    newsh-&gt;free = newlen - len;

    // 返回 sds
    return newsh-&gt;buf;
}


// 回收sds中的空闲空间
sds sdsRemoveFreeSpace(sds s) {
    struct sdshdr *sh;

    sh = (void*) (s-(sizeof(struct sdshdr)));

    // 进行内存重分配，让 buf 的长度仅仅足够保存字符串内容
    // T = O(N)
    sh = zrealloc(sh, sizeof(struct sdshdr)+sh-&gt;len+1);

    // 空余空间为 0
    sh-&gt;free = 0;

    return sh-&gt;buf;
}


// 返回给定sds分配的内存字节数
size_t sdsAllocSize(sds s) {
    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));

    return sizeof(*sh)+sh-&gt;len+sh-&gt;free+1;
}


// 增加sds的长度，缩减空余空间，并将 \0 放到新字符串的尾端
void sdsIncrLen(sds s, int incr) {
    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));

    // 确保 sds 空间足够
    assert(sh-&gt;free &gt;= incr);

    // 更新属性
    sh-&gt;len += incr;
    sh-&gt;free -= incr;

    // 这个 assert 其实可以忽略
    // 因为前一个 assert 已经确保 sh-&gt;free - incr &gt;= 0 了
    assert(sh-&gt;free &gt;= 0);

    // 放置新的结尾符号
    s[sh-&gt;len] = &#39;\0&#39;;
}


// 将长度为 len 的字符串 t 追加到 sds 的字符串末尾
sds sdscatlen(sds s, const void *t, size_t len) {

    struct sdshdr *sh;

    // 原有字符串长度
    size_t curlen = sdslen(s);

    // 扩展 sds 空间
    // T = O(N)
    s = sdsMakeRoomFor(s,len);

    // 内存不足？直接返回
    if (s == NULL) return NULL;

    // 复制 t 中的内容到字符串后部
    // T = O(N)
    sh = (void*) (s-(sizeof(struct sdshdr)));
    memcpy(s+curlen, t, len);

    // 更新属性
    sh-&gt;len = curlen+len;
    sh-&gt;free = sh-&gt;free-len;

    // 添加新结尾符号
    s[curlen+len] = &#39;\0&#39;;

    // 返回新 sds
    return s;
}

// 将给定字符串 t 追加到 sds 的末尾
sds sdscat(sds s, const char *t) {
    return sdscatlen(s, t, strlen(t));
}

// 将另一个 sds 追加到一个 sds 的末尾
sds sdscatsds(sds s, const sds t) {
    return sdscatlen(s, t, sdslen(t));
}


// 把数组转换为sds
sds sdsjoin(char **argv, int argc, char *sep) {
    sds join = sdsempty();
    int j;

    for (j = 0; j &lt; argc; j++) {
        join = sdscat(join, argv[j]);
        if (j != argc-1) join = sdscat(join,sep);
    }
    return join;
}
</code></pre><hr>
<pre><code>typedef int int_t; // declares int_t to be an alias for the type int
typedef char char_t, *char_p, (*fp)(void); // declares char_t to be an alias for char
                                           // char_p to be an alias for char*
                                           // fp to be an alias for char(*)(void)
</code></pre><p>在计算机科学中，内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要特别注意的是对递归函数的内联扩展可能引起部分编译器的无穷编译。<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">内联函数</a> static inline,使用static修饰符，函数仅在文件内部可见，不会污染命名空间</p>
<pre><code>void *memset( void *dest, int ch, size_t count );

Copies the value ch (after conversion to unsigned char as if by (unsigned char)ch) into each of the first count characters of the object pointed to by dest.
 The behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if dest is a null pointer
</code></pre><hr>
<p>Ref： 1.Redis设计与实现 2.Redis源码</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>redis之字典实现</title>
    <url>/2018/08/11/redis%E4%B9%8B%E5%AD%97%E5%85%B8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p>
<pre><code>/* key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数
*/
typedef struct dictEntry {
       void *key;

       union {
          void *val;
          uint64_t u64;
          int64_t s64;
       } v;

      struct dictEntry *next;
   } dictEntry;
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/dictEntry.png" alt></p>
<pre><code>typedef struct dictht {

    // 哈希表数组
    dictEntry **table;

    // 哈希表大小
    unsigned long size;

    // 哈希表大小掩码，用于计算索引值
    // 总是等于 size - 1
    unsigned long sizemask;

    // 该哈希表已有节点的数量
    unsigned long used;

} dictht;
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/dictht.png" alt> <a href="http://redisbook.com/preview/dict/datastruct.html" target="_blank" rel="noopener">图片来源</a></p>
<pre><code>typedef struct dict {

    // 类型特定函数
    dictType *type;

    // 私有数据
    void *privdata;

    // 哈希表
    dictht ht[2];

    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */
    // 目前正在运行的安全迭代器的数量
    int iterators; /* number of iterators currently running */

} dict;
</code></pre><ul>
<li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</li>
<li>而privdata属性则保存了需要传给那些类型特定函数的哥选参数。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/08/dict.png" alt> <a href="http://redisbook.com/preview/dict/datastruct.html" target="_blank" rel="noopener">图片来源</a></li>
</ul>
<hr>
<p>当要将一个新的键值对添加到字典里面时，程度需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。 Redis计算哈希值和索引值的方法如下：</p>
<pre><code>hash = dict-&gt;type-&gt;hashFunction(key);
index = hash &amp; dict-&gt;ht[x].sizemask;
</code></pre><p>Redis哈希表使用链接地址法来解决键冲突，当多个哈希表节点在一个索引上时，多个哈希表节点可以用next指针构成一个单向链表。</p>
<hr>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。 扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下： 为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）： 如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）； 如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。 将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。 当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备.</p>
<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。 这样做的原因在于， 如果 ht[0] 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。 因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。 以下是哈希表渐进式 rehash 的详细步骤： 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。 渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量.</p>
<hr>
<p><a href="https://github.com/hys20151008/redis-related-code/blob/master/dict.c" target="_blank" rel="noopener">简单代码</a></p>
<hr>
<p>Ref：<br>1.Redis设计与实现<br>2.Redis源码</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>requests中的公共函数utils.py</title>
    <url>/2018/07/10/requests%E4%B8%AD%E7%9A%84%E5%85%AC%E5%85%B1%E5%87%BD%E6%95%B0utils.py/</url>
    <content><![CDATA[<pre><code># 将字典转换为元素为(key, val)的列表
In [1]: def dict_to_sequnce(d):
             if hasattr(d, &#39;items&#39;):
                 d = d.items()
             return d
In [2]: d = {&#39;a&#39;: 1, &#39;b&#39;: 2}

In [3]: dict_to_sequnce(d)
Out[3]: dict_items([(&#39;a&#39;, 1), (&#39;b&#39;, 2)])


# 获取各种对象的长度，如str,BytesIO,文件
# 通过hasattr(o, &#39;getvalue&#39;)判断对象是是否是BytesIO,StringIO
# 通过hasattr(o, &#39;fileno&#39;)判断是否是文件对象
# 文件和标准输入都有tell方法，而标准输入调用tell()方法则会产生异常，当遇到类似情况会把对象长度置为0,交给请求来获取它的长度。
def super_len(o):
    total_length = 0
    current_position = 0

    if hasattr(o, &#39;__len__&#39;):
        total_length = len(o)

    elif hasattr(o, &#39;len&#39;):
        total_length = o.len

    elif hasattr(o, &#39;getvalue&#39;):
        # e.g. BytesIO, cStringIO.StringIO
        total_length = len(o.getvalue())

    elif hasattr(o, &#39;fileno&#39;):
        try:
            fileno = o.fileno()
        except io.UnsupportedOperation:
            pass
        else:
            total_length = os.fstat(fileno).st_size

            # Having used fstat to determine the file length, we need to
            # confirm that this file was opened up in binary mode.
            if &#39;b&#39; not in o.mode:
                warnings.warn((
                    &quot;Requests has determined the content-length for this &quot;
                    &quot;request using the binary size of the file: however, the &quot;
                    &quot;file has been opened in text mode (i.e. without the &#39;b&#39; &quot;
                    &quot;flag in the mode). This may lead to an incorrect &quot;
                    &quot;content-length. In Requests 3.0, support will be removed &quot;
                    &quot;for files in text mode.&quot;),
                    FileModeWarning
                )

    if hasattr(o, &#39;tell&#39;):
        try:
            current_position = o.tell()
        except (OSError, IOError):
            # This can happen in some weird situations, such as when the file
            # is actually a special file descriptor like stdin. In this
            # instance, we don&#39;t know what the length is, so set it to zero and
            # let requests chunk it instead.
            current_position = total_length

    return max(0, total_length - current_position)


# 如果提供的url中没有scheme,则将new_scheme作为url的scheme,如果有则不改变
def prepend_scheme_if_needed(url, new_scheme):
    scheme, netloc, path, params, query, fragment = urlparse(url, new_scheme)

    if not netloc:
        netloc, path = path, netloc #应对netloc为空的特殊情况

    return urlunparse((scheme, netloc, path, params, query, fragment))

# 去掉url中的用户名和密码部分
# 如http://root:root@www.baidu.com/,返回为http://www.baidu.com/
def urldefragauth(url):
    scheme, netloc, path, params, query, fragment = urlparse(url)

    if not netloc:
        netloc, path = path, netloc
    netloc = netloc.rsplit(&#39;@&#39;, 1)[-1]

    return urlunparse((scheme, netloc, path, params, query, &#39;&#39;))


_CLEAN_HEADER_REGEX_BYTE = re.compile(b&#39;^\\S[^\\r\\n]*$|^$&#39;) #\S匹配任意非空格字符,--
_CLEAN_HEADER_REGEX_STR = re.compile(r&#39;^\S[^\r\n]*$|^$&#39;) # 匹配以非空开头，非\r\n结尾或者空白字符串
# 检验头的有效性防止header injection
def check_header_validity(header):
    name, value = header

    if isinstance(value, bytes):
        pat = _CLEAN_HEADER_REGEX_BYTE
    else:
        pat = _CLEAN_HEADER_REGEX_STR
    try:
        if not pat.match(value):
            raise InvalidHeader(&quot;Invalid return character or leading space in header: %s&quot; % name)
    except TypeError:
        raise InvalidHeader(&quot;Header value %s must be of type str or bytes, &quot;
                            &quot;not %s&quot; % (value, type(value)))


def get_auth_from_url(url):
    parsed = urlparse(url)

    try:
        auth = (unquote(parsed.username), unquote(parsed.password))
    except (AttributeError, TypeError):
        auth = (&#39;&#39;, &#39;&#39;)

    return auth      

def is_ipv4_address(string_ip):
    try:
        socket.inet_aton(string_ip)
    except socket.error:
        return False
    return True 


def is_valid_cidr(string_network):
    &quot;&quot;&quot;
    判断是否是类似192.168.2.1/16的地址
    &quot;&quot;&quot;
    if string_network.count(&#39;/&#39;) == 1:
        try:
            mask = int(string_network.split(&#39;/&#39;)[1])
        except ValueError:
            return False

        if mask &lt; 1 or mask &gt; 32:
            return False

        try:
            socket.inet_aton(string_network.split(&#39;/&#39;)[0])
        except socket.error:
            return False
    else:
        return False
    return True


# native string 指类型为str的字符串，python2与python3中str是不一样的(http://img.hysyeah.top/2017/10/02/python%E7%BC%96%E7%A0%81/)
# Http请求/响应头和元数据要求数据为str类型。
def to_native_string(string, encoding=&#39;ascii&#39;):
    if isinstance(string, builtin_str):
        out = string
    else:
        if is_py2:
            out = string.encode(encoding)
        else:
            out = string.decode(encoding)

    return out



# 将(key,val)为元素的列表转换为OrderedDict
def from_key_val_list(value):
    if value is None:
        return None

    if isinstance(value, (str, bytes, bool, int)):
        raise ValueError(&#39;cannot encode objects that are not 2-tuples&#39;)

    return OrderedDict(value)


# 将dict转换为list
def to_key_val_list(value):
    if value is None:
        return None

    if isinstance(value, (str, bytes, bool, int)):
        raise ValueError(&#39;cannot encode objects that are not 2-tuples&#39;)

    if isinstance(value, collections.Mapping):
        value = value.items()

    return list(value)
</code></pre><hr>
<p>Ref：<br>1.<a href="https://www.gracefulsecurity.com/http-header-injection/" target="_blank" rel="noopener">header injection</a><br>2.<a href="https://github.com/requests/requests/blob/v2.11.0/requests/utils.py" target="_blank" rel="noopener">requests/utils.py</a></p>
]]></content>
      <categories>
        <category>requests</category>
      </categories>
  </entry>
  <entry>
    <title>request中之自定义的结构体</title>
    <url>/2018/04/01/request%E4%B8%AD%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<pre><code># 通过LookupDict构建个可以根据多个value查找key的字典
class LookupDict(dict):
    &quot;&quot;&quot;Dictionary lookup object.&quot;&quot;&quot;

    def __init__(self, name=None):
        self.name = name
        super(LookupDict, self).__init__()

    def __repr__(self):
        return &#39;&lt;lookup \&#39;%s\&#39;&gt;&#39; % (self.name)

    def __getitem__(self, key):
        # We allow fall-through here, so values default to None

        return self.__dict__.get(key, None)

    def get(self, key, default=None):
        return self.__dict__.get(key, default)


In [2]: _codes = {
   ...: 
   ...:     # Informational.
   ...:     100: (&#39;continue&#39;,),
   ...:     101: (&#39;switching_protocols&#39;,),
   ...:     102: (&#39;processing&#39;,),
   ...:     103: (&#39;checkpoint&#39;,),
   ...:     122: (&#39;uri_too_long&#39;, &#39;request_uri_too_long&#39;)
   ...: }

In [3]: codes = LookupDict(name=&#39;status_codes&#39;)

In [4]: for code, titles in _codes.items():
   ...:     for title in titles:
   ...:         setattr(codes, title, code)
   ...:         if not title.startswith(&#39;\\&#39;):
   ...:             setattr(codes, title.upper(), code)
   ...:             

In [5]: codes
Out[5]: &lt;lookup &#39;status_codes&#39;&gt;

In [6]: codes.processing
Out[6]: 102

In [7]: codes.checkpoint
Out[7]: 103

# codes的__dict__如下
In [8]: codes.__dict__
Out[8]: 
{&#39;CHECKPOINT&#39;: 103,
 &#39;CONTINUE&#39;: 100,
 &#39;PROCESSING&#39;: 102,
 &#39;REQUEST_URI_TOO_LONG&#39;: 122,
 &#39;SWITCHING_PROTOCOLS&#39;: 101,
 &#39;URI_TOO_LONG&#39;: 122,
 &#39;checkpoint&#39;: 103,
 &#39;continue&#39;: 100,
 &#39;name&#39;: &#39;status_codes&#39;,
 &#39;processing&#39;: 102,
 &#39;request_uri_too_long&#39;: 122,
 &#39;switching_protocols&#39;: 101,
 &#39;uri_too_long&#39;: 122}
</code></pre><hr>
<pre><code># CaseInsensitiveDict定义了大小不敏感的字典
class CaseInsensitiveDict(collections.MutableMapping):
    &quot;&quot;&quot;
        cid = CaseInsensitiveDict()
        cid[&#39;Accept&#39;] = &#39;application/json&#39;
        cid[&#39;aCCEPT&#39;] == &#39;application/json&#39;  # True
        list(cid) == [&#39;Accept&#39;]  # True&quot;&quot;&quot;

    def __init__(self, data=None, **kwargs):
        self._store = OrderedDict()
        if data is None:
            data = {}
        self.update(data, **kwargs)

    def __setitem__(self, key, value):
        # Use the lowercased key for lookups, but store the actual
        # key alongside the value.
        self._store[key.lower()] = (key, value)

    def __getitem__(self, key):
        return self._store[key.lower()][1]

    def __delitem__(self, key):
        del self._store[key.lower()]

    def __iter__(self):
        return (casedkey for casedkey, mappedvalue in self._store.values())

    def __len__(self):
        return len(self._store)

    def lower_items(self):
        &quot;&quot;&quot;Like iteritems(), but with all lowercase keys.&quot;&quot;&quot;
        return (
            (lowerkey, keyval[1])
            for (lowerkey, keyval)
            in self._store.items()
        )

    def __eq__(self, other):
        if isinstance(other, collections.Mapping):
            other = CaseInsensitiveDict(other)
        else:
            return NotImplemented
        # Compare insensitively
        return dict(self.lower_items()) == dict(other.lower_items())

    # Copy is required
    def copy(self):
        return CaseInsensitiveDict(self._store.values())

    def __repr__(self):
        return str(dict(self.items()))


MutableMapping的定义是实现__getitem__,__setitem__,__delitem__,__iter__,__len__方法的对象。
CaseInsensitiveDict通过将key转换为小写进行查找，在字典值中以元组的形式存储了原始键和值。
lower_items()返回小写的key,和原始的value。

In [13]: cid = CaseInsensitiveDict()

In [16]: cid
Out[16]: {&#39;Accept&#39;: &#39;application/json&#39;}

In [19]: cid.__dict__
Out[19]: {&#39;_store&#39;: OrderedDict([(&#39;accept&#39;, (&#39;aCCEPT&#39;, &#39;application/json&#39;))])}

In [30]: list(cid.lower_items())
Out[30]: [(&#39;accept&#39;, &#39;application/json&#39;), (&#39;ab&#39;, &#39;Cd&#39;)]

In [31]: cid._store.items()
Out[31]: odict_items([(&#39;accept&#39;, (&#39;aCCEPT&#39;, &#39;application/json&#39;)), (&#39;ab&#39;, (&#39;Ab&#39;, &#39;Cd&#39;))])
</code></pre>]]></content>
      <categories>
        <category>requests</category>
      </categories>
  </entry>
  <entry>
    <title>rocksdb的编译安装</title>
    <url>/2018/10/14/rocksdb%E7%9A%84%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>rocksdb是一个基于level-db开发的高性能本地型键值对数据库。 系统环境：centos 7.6</p>
<pre><code>git clone https://github.com/gflags/gflags.git
cd gflags
git checkout v2.0
./configure &amp;&amp; make &amp;&amp; sudo make install

# export LD_LIBRARY_PATH=/usr/lib

yum install snappy snappy-devel
yum install zlib zlib-devel
yum install bzip2 bzip2-devel
yum install lz4-devel


wget https://github.com/facebook/zstd/archive/v1.1.3.tar.gz
mv v1.1.3.tar.gz zstd-1.1.3.tar.gz
tar zxvf zstd-1.1.3.tar.gz
cd zstd-1.1.3
make &amp;&amp; sudo make install


# 将共享库安装在/usr/lib/目录下，头文件在/usr/include/rocksdb
wget https://codeload.github.com/facebook/rocksdb/tar.gz/v5.14.3
tar -xf rocksdb-5.14.3.tar.gz
cd rocksdb-5.14.3
make install-shared INSTALL_PATH=/usr

# 安装python-rocksdb
pip3 install python-rocksdb
</code></pre><p>测试是否安装好</p>
<pre><code>import rocksdb
db = rocksdb.DB(&quot;test.db&quot;, rocksdb.Options(create_if_missing=True))
db.put(b&quot;a&quot;, b&quot;b&quot;)
print(db.get(b&quot;a&quot;))

# 如果未出错表示rocksdb已安装好
</code></pre><hr>
<p>Ref：<br>1.<a href="https://github.com/facebook/rocksdb/blob/master/INSTALL.md" target="_blank" rel="noopener">https://github.com/facebook/rocksdb/blob/master/INSTALL.md</a><br>2.<a href="https://python-rocksdb.readthedocs.io/en/latest/installation.html" target="_blank" rel="noopener">https://python-rocksdb.readthedocs.io/en/latest/installation.html</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>rsync的使用</title>
    <url>/2022/04/05/rsync%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在进行大文件／多文件拷贝的时候如果使用<code>cp</code>命令的话会看不到进度，可以使用<code>rsync</code>，可以显示过程进度。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync -av --times --stats  --checksum --human-readable --itemize-changes --progress --out-format=&quot;[%t] [%i] %&apos;&apos;&apos;b %-100n&quot; /mnt/share/Datasets /mnt/cephfs &gt; /tmp/dataset.log &amp;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>REF:<br>1.<a href="http://www.jb51.cc/linux/402267.html" target="_blank" rel="noopener">http://www.jb51.cc/linux/402267.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>sbt简介,scala项目hello,world</title>
    <url>/2019/04/09/sbt%E7%AE%80%E4%BB%8B,scala%E9%A1%B9%E7%9B%AEhello,world/</url>
    <content><![CDATA[<p>sbt(Simple Build Tool)是官方推荐的Scala项目构建工具,为你的项目提供编译，运行，测试等各种功能。 １.sbt安装 - 依赖jdk8,如没安装，需要先安装jdk8</p>
<pre><code>echo &quot;deb https://dl.bintray.com/sbt/debian /&quot; | sudo tee -a /etc/apt/sources.list.d/sbt.list
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2EE0EA64E40A89B84B2DF73499E82A75642AC823
sudo apt-get update
sudo apt-get install sbt
</code></pre><p>2.启动sbt,第一次启动需要下载一些包速度会比较慢,更换源请Ref<a href="http://img.hysyeah.top/2019/04/09/sbt%e8%ae%be%e7%bd%ae%e5%9b%bd%e5%86%85%e6%ba%90/" target="_blank" rel="noopener">更换国内源</a> 3.新建一个简单的项目，结构如下,<a href="http://img.hysyeah.top/2019/04/09/shell%e5%88%9b%e5%bb%ba%e7%9b%ae%e5%bd%95/" target="_blank" rel="noopener">创建目录脚本</a> <img src="http://img.hysyeah.top/wp-content/uploads/2019/04/tree_right.png" alt> ４.在目录<code>src/main/scala</code>下，新建一个文件<code>hello.scala</code></p>
<pre><code>hys@hys:~/code/scala/helloscala/src/main/scala$ cat hello.scala 
package foo.bar.baz

object Main extends App {
  println(&quot;Hello, Scala&quot;)
}
</code></pre><p>5.编译，运行 <img src="http://img.hysyeah.top/wp-content/uploads/2019/04/sbt_hello.png" alt> 6.sbt命令</p>
<h2 id><a href="#" class="headerlink" title></a><img src="http://img.hysyeah.top/wp-content/uploads/2019/04/sbt_command.jpg" alt></h2><p>Ref： １.<a href="https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Linux.html" target="_blank" rel="noopener">https://www.scala-sbt.org/1.x/docs/Installing-sbt-on-Linux.html</a> 2.scala编程实战</p>
]]></content>
      <categories>
        <category>Scala</category>
      </categories>
  </entry>
  <entry>
    <title>sbt设置国内源</title>
    <url>/2019/04/09/sbt%E8%AE%BE%E7%BD%AE%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    <content><![CDATA[<p>sbt默认使用的是国外的源，速度太慢，因此改为国内的源。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/04/sbt_source.png" alt> 1.修改下面两个文件，在末尾添加<code>-Dsbt.override.build.repos=true</code></p>
<pre><code>/usr/share/sbt/conf/sbtconfig.txt
/usr/share/sbt/conf/sbtopts
</code></pre><p>2.<code>vim ~/.sbt/repositories</code>如果不存在则创建</p>
<pre><code>hys@hys:~$ cat ~/.sbt/repositories 
[repositories]
  local
  aliyun-nexus: http://maven.aliyun.com/nexus/content/groups/public/
  typesafe: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly
sonatype-oss-releases
maven-central
sonatype-oss-snapshots
</code></pre><p>3.生效。</p>
<hr>
<p>Ref： １.<a href="https://www.jianshu.com/p/a867b2a7c3c8" target="_blank" rel="noopener">https://www.jianshu.com/p/a867b2a7c3c8</a></p>
]]></content>
      <categories>
        <category>Scala</category>
      </categories>
  </entry>
  <entry>
    <title>scala REPL安装</title>
    <url>/2019/04/09/scala%20REPL%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>1.直接使用<code>apt-get</code>命令安装 <code>sudo apt-get install scala</code> 安装<code>scala</code>版本为<code>2.11.12</code>，却发现进入REPL后，不能输入。<br>2.直接<a href="https://www.scala-lang.org/download/" target="_blank" rel="noopener">下载</a>最新版本<code>2.12.8</code>二进制文件进行安装,解压，然后设置环境变量。 ３.输入<code>scala</code>,直接进入REPL。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/04/scala_repl.png" alt></p>
]]></content>
      <categories>
        <category>Scala</category>
      </categories>
  </entry>
  <entry>
    <title>scipy entropy求熵</title>
    <url>/2018/05/23/scipy%20entropy%E6%B1%82%E7%86%B5/</url>
    <content><![CDATA[<p>熵(entropy)是表示随机变量不确定性的度量,熵越大,随机变量的不确定性就越大。 设X是一个取有限个值的离散随机变量，其概率分布为 [latex]P(X=x<em>{i}) = p</em>{i}, i=1,2,\cdot \cdot \cdot,n[/latex] 则随机变量X的熵定义为 [latex]H(X) = -\sum<em>{i=1}^n p</em>{i}\log {p_{i}}[/latex] 对数以2或e为底</p>
<pre><code>scipy.stats.entropy(pk, qk=None,base=None)
计算给定概率值的分布的熵


In [213]: from scipy import stats

In [215]: stats.entropy([9/15,6/15],base=2)
Out[215]: 0.9709505944546688
</code></pre><hr>
<p>Ref：<br>1.<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.entropy.html" target="_blank" rel="noopener">scipy文档</a><br>2.统计学习方法</p>
]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>spark,zeppelin环境的配置</title>
    <url>/2017/09/04/spark,zeppelin%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>系统环境为Ubuntu16.04 1.安装java,从官网下载java包，放下/opt目录下，解压，往~/.zshrc文件添加环境变量，如下</p>
<pre><code>export JAVA_HOME=/opt/jdk1.8.0_144
export JRE_HOME=$JAVA_HOME/jre
export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib
export PATH=&quot;/opt/jdk1.8.0_144/bin:$PATH&quot;
</code></pre><p>2.scala安装，下载安装包，解压到/opt/目录下，往~/.zshrc文件添加环境变量，如下</p>
<pre><code>export SCALA_HOME=/opt/scala-2.11.11
export PATH=&quot;/opt/scala-2.11.11/bin:$PATH&quot;
</code></pre><p>3.下载spark(<a href="http://spark.apache.org/downloads.html),解压到/opt/，往~/.zshrc文件添加环境变量，如下" target="_blank" rel="noopener">http://spark.apache.org/downloads.html),解压到/opt/，往~/.zshrc文件添加环境变量，如下</a></p>
<pre><code>export SPARK_HOME=/opt/spark-2.1.0-bin-hadoop2.7
export PATH=&quot;/opt/spark-2.1.0-bin-hadoop2.7/bin:$PATH&quot;
export PYSPARK_PYTHON=python3 //表示使用python3
export PYSPARK_DRIVER_PYTHON=ipython3
</code></pre><p>4.<a href="http://zeppelin.apache.org/download.html" target="_blank" rel="noopener">下载zeppelin</a>,解压到/opt/，往~/.zshrc文件添加环境变量，如下</p>
<pre><code>export PATH=&quot;/opt/zeppelin-0.7.2-bin-all/bin:$PATH&quot;
</code></pre><p>5.运行zeppelin,</p>
<pre><code>sudo chown -R hys:hys zeppelin-0.7.2-bin-all

zeppelin-daemon.sh start
</code></pre><p>6.访问<a href="http://127.0.0.1:8080出现如下界面则表示安装成功。" target="_blank" rel="noopener">http://127.0.0.1:8080出现如下界面则表示安装成功。</a> <img src="http://img.hysyeah.top/wp-content/uploads/2017/09/和.png" alt="image"></p>
]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>shell创建目录</title>
    <url>/2019/04/09/shell%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>在使用shell脚本创建目录的过程中发现一个现象 当解释器为<code>#!/bin/sh</code>时，结果如下 <img src="http://img.hysyeah.top/wp-content/uploads/2019/04/Screenshot-from-2019-04-09-07-05-42.png" alt> 当解释器为<code>!/bin/bash</code>时，结果如下 <img src="http://img.hysyeah.top/wp-content/uploads/2019/04/tree_right.png" alt> 原因可能是sh解释器不支持{}语法。</p>
<pre><code>#!/bin/bash

mkdir -p src/{main,test}/{java,resources,scala}
mkdir lib project target

echo &#39;name := &quot;myproject&quot;
version := &quot;1.0&quot;
scalaVersion := &quot;2.12.0&quot;&#39; &gt; build.sbt
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>sizeof</title>
    <url>/2017/11/14/sizeof/</url>
    <content><![CDATA[<p>sizeof是C语言的关键字，返回数据类型长度</p>
<pre><code>32位系统中返回值类型为 unsigned int

64位系统中返回值类型为 long unsigned int



#include&lt;stdio&gt;

int main(void){
    printf(&quot;char_size=%lu\n&quot;, sizeof(char));//32位系统中需改为%u
    printf(&quot;unsigned_char=%lu\n&quot;, sizeof(unsigned char));
    printf(&quot;signed_char=%lu\n&quot;, sizeof(signed char));

    printf(&quot;\n\n&quot;);
    printf(&quot;int_size=%lu\n&quot;, sizeof(int));
    printf(&quot;short_int_size=%lu\n&quot;, sizeof(short int));
    printf(&quot;long_int_size=%lu\n&quot;, sizeof(long int));
    printf(&quot;unsigned_long_size=%lu\n&quot;, sizeof(unsigned long));
    printf(&quot;float_size=%lu\n&quot;, sizeof(float));
    printf(&quot;double_size=%lu\n&quot;, sizeof(double));
    printf(&quot;long_double_size=%lu\n&quot;, sizeof(long double));
    return 0;
}
</code></pre><p>输出</p>
<pre><code>//32位                                //64位
char_size=1                           char_size=1
unsigned_char=1                       unsigned_char=1
signed_char=1                         signed_char=1


int_size=4                            int_size=4
unsigned_int_size=4                   unsigned_int_size=4
short_int_size=2                      short_int_size=2
long_int_size=4                       long_int_size=8
unsigned_long_size=4                  unsigned_long_size=8
float_size=4                          float_size=4
double_size=8                         double_size=8
long_double_size=12                   long_double_size=16
</code></pre>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>scipy相关函数</title>
    <url>/2018/06/25/scipy-e7-9b-b8-e5-85-b3-e5-87-bd-e6-95-b0/</url>
    <content><![CDATA[<pre><code>scipy.special.expit                    # expit(x) = 1/(1+exp(-x))
scipy.misc.derivative
import scipy.integrate as integrate
r = integrate.quad(lambda x: 2*x, 0,2) #函数f(x) = 2*x在区间[0,2]内的积分
</code></pre>]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>sqlacodegen</title>
    <url>/2019/02/17/sqlacodegen/</url>
    <content><![CDATA[<pre><code>Generates SQLAlchemy model code from an existing database.

positional arguments:
  url                SQLAlchemy url to the database

optional arguments:
  -h, --help         show this help message and exit
  --version          print the version number and exit
  --schema SCHEMA    load tables from an alternate schema(指定schema)
  --tables TABLES    tables to process (comma-separated, default: all)
  --noviews          ignore views
  --noindexes        ignore indexes
  --noconstraints    ignore constraints(忽略外键)
  --nojoined         don&#39;t autodetect joined table inheritance
  --noinflect        don&#39;t try to convert tables names to singular form
  --noclasses        don&#39;t generate classes, only tables
  --outfile OUTFILE  file to write output to (default: stdout)
</code></pre><p>例：</p>
<pre><code>sqlacodegen mysql+pymysql://root:root@127.0.0.1/cloud --noviews --noconstraints --tables host,vpn --outfile out.txt
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>spark-shell使用mysql存储元数据</title>
    <url>/2018/02/07/spark-shell%E4%BD%BF%E7%94%A8mysql%E5%AD%98%E5%82%A8%E5%85%83%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>1.hive安装(依赖于hadoop) - 下载<a href="http://hive.apache.org/downloads.html" target="_blank" rel="noopener">hive</a> - 解压到/opt目录下 - 添加环境变量到~/.bashrc <code>export HIVE_HOME=/opt/apache-hive-2.2.0-bin export PATH=$HIVE_HOME/bin:$PATH</code> 2.hive-env.sh添加</p>
<pre><code>HADOOP_HOME=/opt/hadoop-2.7.4
</code></pre><p>3.hive-site.xml添加[server端，hive目录下]</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;
&lt;configuration&gt;
&lt;property&gt;
    &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;
    &lt;value&gt;jdbc:mysql://10.68.2.55:3307/hivedb?createDatabaseIfNotExist=true&amp;characterEncoding=utf8&amp;useSSL=false&lt;/value&gt; #mysql连接信息
    &lt;description&gt;
      JDBC connect string for a JDBC metastore.
      To use SSL to encrypt/authenticate the connection, provide database-specific SSL flag in the connection URL.
      For example, jdbc:postgresql://myhost/db?ssl=true for postgres database.
    &lt;/description&gt;
  &lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;
    &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
    &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;
    &lt;value&gt;root&lt;/value&gt;
    &lt;description&gt;Username to use against metastore database&lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;
    &lt;value&gt;hello&lt;/value&gt;
    &lt;description&gt;password to use against metastore database&lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;
    &lt;value&gt;hdfs://10.68.2.55:9000/user/hive/warehouse&lt;/value&gt;
    &lt;description&gt;location of default database for the warehouse&lt;/description&gt;
  &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>4.hive-site.xml[client端，spark目录下]</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;
&lt;configuration&gt;
&lt;property&gt;
    &lt;name&gt;hive.metastore.uris&lt;/name&gt;
    &lt;value&gt;thrift://10.68.2.55:8000&lt;/value&gt;
    &lt;description&gt;Thrift URI for the remote metastore. Used by metastore client to connect to remote metastore.&lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
  &lt;name&gt;spark.sql.warehouse.dir&lt;/name&gt;
  &lt;value&gt;/user/hive/warehouse&lt;/value&gt; #hdfs dfs -mkdir -p /usr/hive/warehouse
&lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>5.下载mysql-connector-java-5.1.44-bin.jar，放到/opt/apache-hive-2.2.0-bin/lib目录下 6.</p>
<pre><code>schematool -dbType mysql -initSchema #初始化
hive --service metastore -p &lt;port&gt;  #启动服务
启动spark-shell将会将元数据存储到mysql
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>super(Entity,self).__init__()</title>
    <url>/2017/10/02/superentityself-init/</url>
    <content><![CDATA[<pre><code>super(Entity,self).__init__()
</code></pre><p>这是对继承自父类的属性进行初始化。而且是用父类的初始化方法来初始化继承的属性。 也就是说，子类继承了父类的所有属性和方法，父类属性自然会用父类方法来进行初始化。当然，如果初始化的逻辑与父类的不同，不使用父类的方法，自己重新初始化也是可以的 和php中的parent::__construct()的作用应该是一样的。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>supervisor can not find &#39;uwsgi&#39; command</title>
    <url>/2017/11/04/supervisor-can-not-find-uwsgi-command/</url>
    <content><![CDATA[<p>在一次关掉supervisor控制的进程，再进行开启的时候，报supervisor can not find ‘uwsgi’ command错误，而[program:uwsgi]是存在于配置文件中的。此时杀死[program:uwsgi]中command所执行的命令的进程，再将配置文件中的autorestart=True注释掉，reload后重新启动进程即可。</p>
<hr>
<p>1.<a href="http://m.blog.csdn.net/lf8289/article/details/45478639" target="_blank" rel="noopener">http://m.blog.csdn.net/lf8289/article/details/45478639</a> 2.<a href="https://www.v2ex.com/t/326059" target="_blank" rel="noopener">https://www.v2ex.com/t/326059</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>tcp之拥塞控制</title>
    <url>/2019/08/10/tcp%E4%B9%8B%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>要了解拥塞控制可以先了解下<a href="http://hysyeah.top/2019/08/05/TCP%E4%B9%8B%E5%9C%A8%E9%80%94%E5%AD%97%E8%8A%82%E6%95%B0/" target="_blank" rel="noopener">在途字节数</a>这一概念。</p>
<p>关于TCP拥塞控制的一些术语：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SMSS--SENDER MAXIMUM SEGMENT SIZE       发送端可发送的最大分节大小</span><br><span class="line">RMSS--RECEIVER MAXIMUM SEGMENT SIZE     接收端可接收的最大分节大小</span><br><span class="line">FULL-SIZED SEGMENT                      一个包含了SMSS字节数据的分节</span><br><span class="line"></span><br><span class="line">RECEIVER WINDOW--rwnd                   推荐的接收窗口</span><br><span class="line">CONGESTION WINDOW--cwnd:                限制TCP可以发送多少数据的状态变量。在任何时刻TCP不能发送序号大于最大确认序号加上rwnd,cwnd中的的较小值的数据。</span><br><span class="line">INITIAL WINDOW--IW:                     初始窗口。三次握手之后的拥塞窗口大小</span><br><span class="line">LOSS WINDOW--LW:                        丢失窗口。丢失窗口是在一个TCP根据它的重传定时器检测到了数据丢失之后，拥塞窗口的尺寸</span><br><span class="line">RESTART WINDOW-RW:                     重启窗口。重启窗口是TCP在一段闲置期之后重新开始传送后拥塞窗口的尺寸。</span><br><span class="line">FLIGHT SIZE:                           在途字节数。已经发送但未确认的数大小</span><br></pre></td></tr></table></figure></p>
<p>1.拥塞控制的目的<br>为什么要进行拥塞控制? 假如把网络路径想象成一条河流,发送方是水源,接收方是入海口,那在途字节数就是河里的水量。当水源的流速超过了入海口的流速,河里的水就会越来越多,直到溢出。发生拥塞时的在途字节数就是该时刻的网络拥塞点。发生拥塞时TCP的表现为丢包。当发送方发送数据过慢时,网络等资源就会造成一定的浪费，当发送过快时，就是造成网络拥塞(出现丢包),拥塞控制就是为了找到最合适的发送速度。</p>
<p>2.拥塞控制算法<br>拥塞控制算法包括4个部分：慢启动,拥塞避免,快速重传,快速恢复。</p>
<ul>
<li>慢启动与拥塞避免<br>慢启动与拥塞避免算法用于控制发送方，避免一下发送过多的数据到网络中。为了实现这些算法，对于每个TCP连接加入这两个变量，<code>cwnd rwnd</code>。另一个状态变量，<code>ssthresh</code>用于标识此时应该使用慢启动(cwnd &lt; ssthresh)还是拥塞避免(cwnd &gt; ssthresh)。</li>
</ul>
<p>当开始传输数据时，TCP并不知道网络可用的容量，为了避免拥塞，这个阶段TCP会逐渐数据的发送量。慢启动算法为了避免注入过多的数据到网络中会应用于开始传输数据和重传定时器修复丢包之后。</p>
<p>数据传输开始时，<code>IW</code>的大小设置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If SMSS &gt; 2190 bytes:</span><br><span class="line">IW = 2 * SMSS bytes and MUST NOT be more than 2 segments</span><br><span class="line">If (SMSS &gt; 1095 bytes) and (SMSS &lt;= 2190 bytes):</span><br><span class="line">IW = 3 * SMSS bytes and MUST NOT be more than 3 segments</span><br><span class="line">if SMSS &lt;= 1095 bytes:</span><br><span class="line">IW = 4 * SMSS bytes and MUST NOT be more than 4 segments</span><br></pre></td></tr></table></figure>
<p>在慢启动阶段，TCP通过如下规则在每接收一个<code>ACK</code>时增加<code>cwnd</code>,每次都会增加前一个`cwnd```的一倍大小。</p>
<p>当出现丢包，或者当接收者提示<code>rwnd</code>是受限因素时，或者<code>cwnd &gt; ssthresh</code>时，会进入拥塞避免阶段。</p>
<p>在拥塞避免阶段，在每一个RTT时间，<code>cwnd</code>增加<code>FULL-SIZED SEGMENT</code>大小。</p>
<p>当TCP发送者通过重传定时器意识到丢包时，会重新设置<code>ssthresh</code>的大小。<br><code>ssthresh = max (FlightSize / 2, 2*SMSS)</code></p>
<ul>
<li>快速重传与快速恢复<br>快速重传是为减少丢包重传等待时间的一种机制。如果发送方接收到3个或3个以上的重复ACK,发送方就会重传丢失的数据报,而无需等待超时定时器溢出。<br>(1)当收到第3个重复的<code>ACK</code>时，将<code>ssthresh</code>设置为当前拥塞窗口<code>cwnd</code>的一半<br>(2)每次收到另一个重复的<code>ACK</code>时，<code>cwnd</code>增加1个报文段大小并发送1个分组（如果新的<br><code>cwnd</code>允许发送）<br>(3)当下一个确认新数据的<code>ACK</code>到达时，设置<code>cwnd</code>为<code>ssthresh</code>（在第1步中设置的值）。这个<code>ACK</code>应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个<code>ACK</code>也应该是对丢失的分组和收到的第1个重复的<code>ACK</code>之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半</li>
</ul>
<p><img src="http://img.hysyeah.top/2019/08/10/TCP_Slow-Start_and_Congestion_Avoidance.svg" alt="image"><br>[图片来源网络]</p>
<hr>
<p>Ref：<br>1.<a href="https://en.wikipedia.org/wiki/TCP_congestion_control" target="_blank" rel="noopener">TCP congestion control</a><br>2.<a href="https://tools.ietf.org/html/rfc2581" target="_blank" rel="noopener">RFC2581</a><br>3.《TCP/IP协议详解1》</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp/ip中常见的术语</title>
    <url>/2019/06/12/tcp-ip%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<pre><code>MSS--maximum segment size       最大分节大小
MTU--maximum transmission unit  最大传输单元  # MSS通常被设置为MTU送去IP和TCP首部的固定长度，IPv4和TCP的首部都是20字节
PDU--protocol data unit         协议数据单元 # 网络各层对等实体间交换的单位信息
SDU--Service data uni           服务数据单元 # N层的PDU就是N-1层的SDU
MSL--maximum segment lifetime   最长分节生命期
listening socket                监听套接字
connected socket                已连接套接字
local area networks(LANs)       局域网
wide area networks(WANs)        广域网

SMSS--SENDER MAXIMUM SEGMENT SIZE       发送端可发送的最大分节大小
RMSS--RECEIVER MAXIMUM SEGMENT SIZE     接收端可接收的最大分节大小
FULL-SIZED SEGMENT                      一个包含了SMSS字节数据的分节

RECEIVER WINDOW--rwnd                   推荐的接收窗口
CONGESTION WINDOW--cwnd:                限制TCP可以发送多少数据的状态变量。在任何时刻TCP不能发送序号大于最大确认序号加上rwnd,cwnd中的的较小值的数据。
INITIAL WINDOW--IW:                     初始窗口。三次握手之后的拥塞窗口大小
LOSS WINDOW--LW:                        丢失窗口。丢失窗口是在一个TCP根据它的重传定时器检测到了数据丢失之后，拥塞窗口的尺寸
RESTART WINDOW-RW:                     重启窗口。重启窗口是TCP在一段闲置期之后重新开始传送后拥塞窗口的尺寸。
FLIGHT SIZE:                           在途字节数。已经发送但未确认的数大小。 可Ref [在途字节数](http://hysyeah.top/2019/08/05/TCP%E4%B9%8B%E5%9C%A8%E9%80%94%E5%AD%97%E8%8A%82%E6%95%B0/) 



RTT--round-trip time                  表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延

RTO-Retransmission Timeout           重传超时
</code></pre><p>未完</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp端口与并发服务器</title>
    <url>/2019/06/12/tcp%E7%AB%AF%E5%8F%A3%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>一、端口的作用是什么？ 在一台服务器中可能有多个进程同时使用TCP,UDP这两种协议中的一种，端口就是用来区分这些进程的。 二、套接字对 一个TCP连接的套接字对是一个定义该连接的两个端点的四元组:本地IP地址、本地TCP端口号、外地IP地址、外地TCP端口号。套接字对唯一标识一个网络上的每个TCP连接。 三、并发服务器 并发服务器中主服务器循环通过派生一个子进程来处理每个新的链接。 我们通过如下代码来理解socket如何处理多个请求。</p>
<pre><code>import socket
import threading

bind_ip =&quot;0.0.0.0&quot;
bind_port = 8080

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((bind_ip, bind_port))

server.listen(3)


def handle_client(client_socket):
    request = client_socket.recv(1024)
    print(&quot;[*] Received: %s&quot; % request)

    client_socket.close()


while True:
    client, addr = server.accept()
    print(f&quot;client is {client}, addr is {addr}&quot;)

    client_handler = threading.Thread(target=handle_client, args=(client,))
    client_handler.start()
</code></pre><p>1.<code>python3 server.py</code>启动服务器，此时服务器的状态如下图，等待客户端的连接。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/concurrency_socket_1.png" alt> 我们使用{0.0.0.0:8080, <em>:</em>}指出服务器的套接字对。服务器在本地端口8080上等待连接请求。外地IP和外地端口号都没有指定，我们称它为监听套接字(listening socket) 2.在同一台主机上启动一个客户端连接服务器. <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/concurrency_socket_2.png" alt> 客户端会随机生成一个端口与服务端进行连接，在进行连接时的状态如下图: <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/concurrency_socket_3.png" alt> 当三次握手后，客户端与服务端建立连接后 <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/concurrency_socket_4.png" alt> 3.我再启动一个客户端 <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/concurrency_socket_5.png" alt> 连接状态如下： <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/concurrency_socket_6.png" alt></p>
<hr>
<p>总结: TCP必须通过查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。如一个分节来自127.0.0.1端口52822,目的地为127.0.0.1端口8080，它就会被传递给子进程2进行处理。</p>
<hr>
<p>Ref： 1.《UNIX网络编程》</p>
]]></content>
      <categories>
        <category>unp</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu20.04开发开境配置</title>
    <url>/2020/05/30/ubuntu20-04%E5%BC%80%E5%8F%91%E5%BC%80%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>记录下新系统下开发必须安装的工具</p>
<p>1.小飞机<a href="https://github.com/qingshuisiyuan/electron-ssr-backup/releases" target="_blank" rel="noopener">安装</a><br>注意事项:需要安装python2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install python</span><br></pre></td></tr></table></figure></p>
<p>2.vscode<a href="https://code.visualstudio.com/docs/setup/linux" target="_blank" rel="noopener">安装</a>，直接下载deb包进行安装，不要使用snap命令进行安装，否则会出现不能输入中文的问题。<br>3.安装截图工具flameshot,并设置快捷键<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install flameshot</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.hysyeah.top/2020/5/29/20200530161024-flameshot.png" alt="image"><br>4.安装chrome,配置插件<code>SwitchyOmega</code>.<br><img src="http://img.hysyeah.top/2020/5/29/20200530170251-switch-omega.png" alt="image"><br>5.安装polipo,终端使用代理<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;&gt; /etc/apt/sources.list</span><br><span class="line">deb http://cz.archive.ubuntu.com/ubuntu xenial main universe</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install polipo</span><br></pre></td></tr></table></figure></p>
<p>修改配置<code>/etc/polipo/config</code>,加入如下内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxyAddress = &quot;0.0.0.0&quot;</span><br><span class="line"></span><br><span class="line">socksParentProxy = &quot;127.0.0.1:1080&quot;</span><br><span class="line">socksProxyType = socks5</span><br><span class="line"></span><br><span class="line">chunkHighMark = 50331648</span><br><span class="line">objectHighMark = 16384</span><br><span class="line"></span><br><span class="line">serverMaxSlots = 64</span><br><span class="line">serverSlots = 16</span><br><span class="line">serverSlots1 = 32</span><br></pre></td></tr></table></figure></p>
<p>重启服务<code>sudo systemctl restart polipo</code><br>配置代理<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:8123</span><br><span class="line">export https_proxy=http://127.0.0.1:8123</span><br></pre></td></tr></table></figure></p>
<p>6.使用系统自带的五笔输入法<br>7.安装GoLand,PyCharm<br>8.安装<code>golang1.13.6</code><br>9.安装<code>terminator</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install terminator</span><br></pre></td></tr></table></figure></p>
<p>10.安装<code>git</code>,<code>zsh</code>,<code>oh-my-zsh</code>，<code>autojump</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">sudo apt install zsh</span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt;&gt; ~/.zshrc</span><br><span class="line">. /usr/share/autojump/autojump.sh</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></p>
<p>11.安装<code>qshell</code>,用于同步文件到七牛云，下载<a href="https://developer.qiniu.com/kodo/tools/1302/qshell" target="_blank" rel="noopener">qshell</a><br>  设置帐户空间<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qshell account [&lt;AccessKey&gt; &lt;SecretKey&gt; &lt;Name&gt;] [flags]</span><br></pre></td></tr></table></figure></p>
<p>  设置文件上传策略,<code>vim ~/.qshell/upload.conf</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;src_dir&quot;: &quot;/media/hys/65F33762C14D581B/hysyeah_qiniu&quot;,</span><br><span class="line">    &quot;bucket&quot;: &quot;hysyeah&quot;,</span><br><span class="line">    &quot;check_exists&quot;: true,</span><br><span class="line">    &quot;check_hash&quot;: true,</span><br><span class="line">    &quot;rescan_local&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置快捷上传命令e<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;&gt; ~/.zshrc</span><br><span class="line">alias qsupload=&quot;qs qupload ~/.qshell/upleeeeoad.conf&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p>
<ol>
<li>设置镜像源,ubuntu20.04可以在界面上设置<br><img src="http://img.hysyeah.top/2020/5/29/20200530172121-image-server.png" alt="image"></li>
</ol>
<p>问题：<br>    解决双系统时间不一致的问题,在ubuntu终端输入如下命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timedatectl set-local-rtc 1 --adjust-system-clock</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Ref:<br>1.<a href="https://packages.ubuntu.com/xenial/amd64/polipo-dbg/download" target="_blank" rel="noopener">ubuntu package</a><br>2.<a href="https://developer.qiniu.com/kodo/tools/1302/qshell" target="_blank" rel="noopener">qshell</a></p>
]]></content>
  </entry>
  <entry>
    <title>ubuntu安装readelf</title>
    <url>/2017/12/19/ubuntu%E5%AE%89%E8%A3%85readelf/</url>
    <content><![CDATA[<pre><code>sudo apt-get install binutils


Usage: readelf &lt;option(s)&gt; elf-file(s)
 Display information about the contents of ELF format files
 Options are:
  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I
  -h --file-header       Display the ELF file header
  -l --program-headers   Display the program headers
     --segments          An alias for --program-headers
  -S --section-headers   Display the sections&#39; header
     --sections          An alias for --section-headers
  -g --section-groups    Display the section groups
  -t --section-details   Display the section details
  -e --headers           Equivalent to: -h -l -S
  -s --syms              Display the symbol table
     --symbols           An alias for --syms
  --dyn-syms             Display the dynamic symbol table
  -n --notes             Display the core notes (if present)
  -r --relocs            Display the relocations (if present)
  -u --unwind            Display the unwind info (if present)
  -d --dynamic           Display the dynamic section (if present)
  -V --version-info      Display the version sections (if present)
  -A --arch-specific     Display architecture specific information (if any)
  -c --archive-index     Display the symbol/file index in an archive
  -D --use-dynamic       Use the dynamic section info when displaying symbols
  -x --hex-dump=&lt;number|name&gt;
                         Dump the contents of section &lt;number|name&gt; as bytes
  -p --string-dump=&lt;number|name&gt;
                         Dump the contents of section &lt;number|name&gt; as strings
  -R --relocated-dump=&lt;number|name&gt;
                         Dump the contents of section &lt;number|name&gt; as relocated bytes
  -z --decompress        Decompress section before dumping it
  -w[lLiaprmfFsoRt] or
  --debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,
               =frames-interp,=str,=loc,=Ranges,=pubtypes,
               =gdb_index,=trace_info,=trace_abbrev,=trace_aranges,
               =addr,=cu_index]
                         Display the contents of DWARF2 debug sections
  --dwarf-depth=N        Do not display DIEs at depth N or greater
  --dwarf-start=N        Display DIEs starting with N, at the same depth
                         or deeper
  -I --histogram         Display histogram of bucket list lengths
  -W --wide              Allow output width to exceed 80 characters
  @&lt;file&gt;                Read options from &lt;file&gt;
  -H --help              Display this information
  -v --version           Display the version number of readelf
</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu安装五笔</title>
    <url>/2017/09/22/ubuntu%E5%AE%89%E8%A3%85%E4%BA%94%E7%AC%94/</url>
    <content><![CDATA[<pre><code>1.sudo apt-get install ibus-table-wubi

2.reboot

3.Text Entry添加输入法
</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu未发现Python.h文件</title>
    <url>/2017/11/30/ubuntu%E6%9C%AA%E5%8F%91%E7%8E%B0Python.h%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h5 id="usr-include-python3-5m下没有Python-h头文件"><a href="#usr-include-python3-5m下没有Python-h头文件" class="headerlink" title="/usr/include/python3.5m下没有Python.h头文件"></a>/usr/include/python3.5m下没有Python.h头文件</h5><pre><code>sudo apt-get install python3-dev
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>wordpress屏蔽更新提示</title>
    <url>/2017/09/15/wordpress%E5%B1%8F%E8%94%BD%E6%9B%B4%E6%96%B0%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<p>wordpress/wp-includes/update.php 在最后面添加</p>
<pre><code>add_filter(&#39;pre_site_transient_update_core&#39;, create_function(&#39;$a&#39;, &quot;return null;&quot;));//关闭核心提示
add_filter(&#39;pre_site_transient_update_plugins&#39;, create_function(&#39;$a&#39;, &quot;return null;&quot;));//关闭插件提示
add_filter(&#39;pre_site_transient_update_themes&#39;, create_function(&#39;$a&#39;, &quot;return null;&quot;));//关闭主题提示
</code></pre><p>并注释掉</p>
<pre><code>//add_action( &#39;admin_init&#39;, &#39;_maybe_update_plugins&#39; );

//add_action( &#39;admin_init&#39;, &#39;_maybe_update_themes&#39; );
</code></pre><p>重启php-fpm即可。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>x86相关寄存器</title>
    <url>/2018/01/06/x86%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<pre><code>IP-Instruction Pointer--指令指针寄存器
CS-Code Segment--段寄存器
DS-Data Segment--数据段寄存器

%rax-%eax-%ax-%al---返回值
%rbx-%ebx-%bx-%bl---被调用者保存
%rcx-%ecx-%cx-%cl---第4个参数
%rdx-%edx-%dx-%dl---第3个参数
%rsi-%esi-%si-%sil---第2个参数
%rdi-%edi-%di-%dil---第1个参数
%rbp-%ebp-%bp-%bpl---基址寄存器(stack pointer),一般在函数中用来保存进入函数时的sp的栈顶基址(被调用者保存)
%rsp-%esp-%sp-%spl---栈指针
%r8-%r8d-%r8w-%r8b---第5个参数
%r9-%r9d-%r9w-%r9b---第6个参数

%r10-%r10d-%r10w-%r10b---调用者保存
%r11-%r11d-%r11w-%r11b---调用者保存
%r12-%r12d-%r12w-%r12b---被调用者保存
%r13-%r13d-%r13w-%r13b---被调用者保存
%r14-%r14d-%r14w-%r14b---被调用者保存
%r15-%r15d-%r15w-%r15b---被调用者保存
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/01/register.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>x86-architecture gcc calling convention</title>
    <url>/2019/10/26/x86-architecture-gcc-calling-convention/</url>
    <content><![CDATA[<h4 id="x86架构常见寄存器"><a href="#x86架构常见寄存器" class="headerlink" title="x86架构常见寄存器"></a>x86架构常见寄存器</h4><div class="table-container">
<table>
<thead>
<tr>
<th>register</th>
<th>8 bit</th>
<th>16 bit</th>
<th>32 bit</th>
<th>64 bit</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accumulator register</td>
<td>AH:AL</td>
<td>AX</td>
<td>EAX</td>
<td>RAX</td>
<td></td>
</tr>
<tr>
<td>Base register</td>
<td>BH:BL</td>
<td>BX</td>
<td>EBX</td>
<td>RBX</td>
<td></td>
</tr>
<tr>
<td>Counter register</td>
<td>CH:CL</td>
<td>CX</td>
<td>ECX</td>
<td>RCX</td>
<td></td>
</tr>
<tr>
<td>Data register</td>
<td>DH:DL</td>
<td>DX</td>
<td>EDX</td>
<td>RDX</td>
<td></td>
</tr>
<tr>
<td>Stack Pointer register</td>
<td></td>
<td>SP</td>
<td>ESP</td>
<td>RSP</td>
<td>栈顶指针,始终指向栈顶元素</td>
</tr>
<tr>
<td>Stack Base Pointer register</td>
<td></td>
<td>BP</td>
<td>EBP</td>
<td>RBP</td>
<td>栈基指针,用于维护一个栈帧,在Intel的术语中叫帧指针,表示一个栈帧的开始地址</td>
</tr>
<tr>
<td>Source Index register</td>
<td></td>
<td>SI</td>
<td>ESI</td>
<td>RSI</td>
<td></td>
</tr>
<tr>
<td>Destination Index register</td>
<td></td>
<td>DI</td>
<td>EDI</td>
<td>RDI</td>
<td></td>
</tr>
<tr>
<td>Instruction Pointer</td>
<td>IP</td>
<td>EIP</td>
<td>RIP</td>
<td></td>
</tr>
<tr>
<td>64位新增</td>
<td></td>
<td></td>
<td></td>
<td>R8-R15</td>
</tr>
</tbody>
</table>
</div>
<p>段寄存器</p>
<ul>
<li>Stack Segment(SS)：指向栈的指针</li>
<li>Code Segment(CS):指向代码的指针</li>
<li>Data Segment(DS):指向数据的指针</li>
</ul>
<p>常见组合：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>register</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CS:IP</td>
<td>(CS is Code Segment, IP is Instruction Pointer) points to the address where the processor will fetch the next byte of code.</td>
</tr>
<tr>
<td>SS:SP</td>
<td>(SS is Stack Segment, SP is Stack Pointer) points to the address of the top of the stack, i.e. the most recently pushed byte.</td>
</tr>
<tr>
<td>DS:SI</td>
<td>(DS is Data Segment, SI is Source Index) is often used to point to string data that is about to be copied to ES:DI.</td>
</tr>
<tr>
<td>ES:DI</td>
<td>(ES is Extra Segment, DI is Destination Index) is typically used to point to the destination for a string copy, as mentioned above.</td>
</tr>
</tbody>
</table>
</div>
<p>当我们调用一个函数和一个函数被调用，它们之间的参数和返回值是怎样传递的？gcc是怎样使用x86中的寄存器？</p>
<h4 id="调用规范"><a href="#调用规范" class="headerlink" title="　调用规范"></a>　调用规范</h4><p>为了允许单独的程序员共享代码并开发供许多程序使用的库，并简化子例程的使用，程序员通常采用通用的调用约定。调用约定其实就是约定函数间如何调用和返回。例如，给定一组调用约定规则，程序员无需检查子例程的定义来确定应如何将参数传递给该子例程。 此外，给定一组调用约定规则，可以使高级语言编译器遵循这些规则，从而允许手动编码的汇编语言例程和高级语言例程相互调用。</p>
<p>下面我们会描述下C语言的调用约定。C调用约定非常依赖CPU硬件实现的栈结构，基于如下汇编指令push,pop,call,ret。</p>
<h6 id="调用者约定"><a href="#调用者约定" class="headerlink" title="调用者约定"></a>调用者约定</h6><ul>
<li>在调用子例程这前,调用者应该保存一些特定寄存器的内容,这些内容称为<code>caller-saved</code>。被调用者<code>callee</code>允许对这些寄存器进行修改,如果调用者<code>caller</code>在子例程返回之后依然要使用这些值，<code>caller</code>必须把这些值push到栈中。</li>
<li>为了把参数传递给子例程,在调用它们之前需先把参数入栈(现在的CPU设计并不是所有参数都得入栈,x86-64位在参数超过6个的情况下才会将6个之外的参数入栈),参数的入栈顺序为从右到左。</li>
<li>使用<code>call</code>指令调用子例程。这个指令将返回地址压入栈中(在所参数之上)<br>当子例程返回后,<code>caller</code>可从寄存器<code>EAX</code>中取得子例程的返回值,为了恢复调用前的状态，调用者应该做如下处理：</li>
<li>移除栈中的参数。</li>
<li>从栈中恢复<code>caller-saved</code>的寄存器内容。</li>
</ul>
<h6 id="被调用者-callee-约定"><a href="#被调用者-callee-约定" class="headerlink" title="被调用者(callee)约定"></a>被调用者(<code>callee</code>)约定</h6><ul>
<li>将%rbp入栈,并将%rsp 赋值给%rbp<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushq   %rbp             # 将调用者的rbp入栈</span><br><span class="line">movq    %rsp, %rbp       # 初始化一个新的栈帧</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个初始化操作维护了<code>base pointer</code>,rbp。rbp用于直接在栈中根据偏移量获取参数和局部变量。</p>
<ul>
<li>然后,将局部变量入栈,同时修改rsp寄存器的值。</li>
<li>保存<code>callee-saved</code>的寄存器值,将这些值做入栈操作。<br>当子例程执行完毕进行返回时,必须做如下操作：</li>
<li>将返回值放在<code>rax</code>寄存器中</li>
<li>恢复<code>callee-saved</code>寄存器的值</li>
<li>销毁局部变量,一般通过修改栈指针的值来进行</li>
<li>恢复调用者的rbp值,从栈中弹出rbp</li>
<li>最后执行<code>ret</code>指令,这条指令会将<code>return address</code>从栈中移除</li>
</ul>
<p>我们先来看一段代码，保存为<code>cdecl.c</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int callee(int a, int b, int c,int d, int d, int f, int g)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int caller(void)</span><br><span class="line">&#123;</span><br><span class="line">    return callee(1, 2, 3, 4, 5, 6, 7) +5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将上面这段代码编译为汇编代码，使用命令<code>gcc -S cdecl.c</code>,会生成一个名称为cdecl.s的文件。下面是调用者部分的汇编代码，采用AT&amp;T格式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">callee:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    movl    %edi, -4(%rbp)</span><br><span class="line">    movl    %esi, -8(%rbp)</span><br><span class="line">    movl    %edx, -12(%rbp)</span><br><span class="line">    movl    %ecx, -16(%rbp)</span><br><span class="line">    movl    %r8d, -20(%rbp)</span><br><span class="line">    movl    %r9d, -24(%rbp)</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">caller:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    pushq   $7</span><br><span class="line">    movl    $6, %r9d</span><br><span class="line">    movl    $5, %r8d</span><br><span class="line">    movl    $4, %ecx</span><br><span class="line">    movl    $3, %edx</span><br><span class="line">    movl    $2, %esi</span><br><span class="line">    movl    $1, %edi</span><br><span class="line">    call    callee</span><br><span class="line">    addq    $8, %rsp</span><br><span class="line">    addl    $5, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure></p>
<p>由上汇编代码可以看到第一个参数放入到了寄存器edi,第二个参放入到了寄存器esi,第三个参数放入寄存器edx,依此类推。</p>
<h6 id="gcc对x86寄存器的调用规则"><a href="#gcc对x86寄存器的调用规则" class="headerlink" title="gcc对x86寄存器的调用规则"></a>gcc对x86寄存器的调用规则</h6><div class="table-container">
<table>
<thead>
<tr>
<th>Register</th>
<th>Purpose    Saved across calls</th>
<th>Saved across calls</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rax</td>
<td>temp register; return value</td>
<td>No</td>
</tr>
<tr>
<td>%rbx</td>
<td>callee-saved</td>
<td>Yes</td>
</tr>
<tr>
<td>%rcx</td>
<td>used to pass 4th argument to functions</td>
<td>No</td>
</tr>
<tr>
<td>%rdx</td>
<td>used to pass 3rd argument to functions</td>
<td>No</td>
</tr>
<tr>
<td>%rsp</td>
<td>stack pointer</td>
<td>Yes</td>
</tr>
<tr>
<td>%rbp</td>
<td>callee-saved; base pointer</td>
<td>Yes</td>
</tr>
<tr>
<td>%rsi</td>
<td>used to pass 2nd argument to functions</td>
<td>No</td>
</tr>
<tr>
<td>%rdi</td>
<td>used to pass 1st argument to functions</td>
<td>No</td>
</tr>
<tr>
<td>%r8</td>
<td>used to pass 5th argument to functions</td>
<td>No</td>
</tr>
<tr>
<td>%r9</td>
<td>used to pass 6th argument to functions</td>
<td>No</td>
</tr>
<tr>
<td>%r10-r11</td>
<td>temporary</td>
<td>No</td>
</tr>
<tr>
<td>%r12-r15</td>
<td>callee-saved registers</td>
<td>Yes</td>
</tr>
</tbody>
</table>
</div>
<h6 id="函数调用时栈中的内容"><a href="#函数调用时栈中的内容" class="headerlink" title="函数调用时栈中的内容"></a>函数调用时栈中的内容</h6><div class="table-container">
<table>
<thead>
<tr>
<th>栈地址</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>16(%ebp)</td>
<td>- third function parameter</td>
</tr>
<tr>
<td>12(%ebp)</td>
<td>- second function parameter</td>
</tr>
<tr>
<td>8(%ebp)</td>
<td>- first function parameter</td>
</tr>
<tr>
<td>4(%ebp)</td>
<td>- old %EIP (the function’s “return address”)</td>
</tr>
<tr>
<td>0(%ebp)</td>
<td>- old %EBP (previous function’s base pointer)</td>
</tr>
<tr>
<td>-4(%ebp)</td>
<td>- first local variable</td>
</tr>
<tr>
<td>-8(%ebp)</td>
<td>- second local variable</td>
</tr>
<tr>
<td>-12(%ebp)</td>
<td>- third local variable</td>
</tr>
</tbody>
</table>
</div>
<p><img src="http://img.hysyeah.top/2019/10/26/stackframe-cdecl.gif" alt="image"></p>
<h4 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h4><p>push ax;将一个寄存器中的数据入栈<br>pop ax; 出栈，用一个寄存器接收出栈的数据.<br>ret指令用栈中数据，修改IP的内容，从而实现近转移。CPU执行ret指令时，进行下面两步操作：<br>(1)(IP) = ((ss)*16+(sp)) (2)(sp) = (sp) + 2   #16位cpu<br>call 标号;将当前的IP压栈后，转到标号处执行指令</p>
<hr>
<p>Ref：<br>1.<a href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture" target="_blank" rel="noopener">X86_Assembly-X86_Architecture</a><br>2.<a href="https://en.wikibooks.org/wiki/X86_Assembly/16,_32,_and_64_Bits" target="_blank" rel="noopener">X86 Assembly/16, 32, and 64 Bits</a><br>3.<a href="http://unixwiz.net/techtips/win32-callconv-asm.html" target="_blank" rel="noopener">http://unixwiz.net/techtips/win32-callconv-asm.html</a><br>4.<a href="http://unixwiz.net/techtips/win32-callconv.html" target="_blank" rel="noopener">http://unixwiz.net/techtips/win32-callconv.html</a><br>5.<a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="noopener">X86_calling_conventions</a><br>6.<a href="http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html#calling" target="_blank" rel="noopener">http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html#calling</a><br>7.<a href="http://6.s081.scripts.mit.edu/sp18/x86-64-architecture-guide.html" target="_blank" rel="noopener">X86-64 Architecture Guide</a><br>8.<a href="https://en.wikipedia.org/wiki/X86_assembly_language#Segmented_addressing" target="_blank" rel="noopener">X86_assembly_language</a><br>9.<a href="https://pages.hep.wisc.edu/~pinghc/x86AssmTutorial.htm" target="_blank" rel="noopener">https://pages.hep.wisc.edu/~pinghc/x86AssmTutorial.htm</a></p>
]]></content>
  </entry>
  <entry>
    <title>unp之datetime</title>
    <url>/2019/10/30/unp%E4%B9%8Bdatetime/</url>
    <content><![CDATA[<p>一.配置unp.h<br>1.从<a href="www.unpbook.com">www.unpbook.com</a>下载源码<br>2.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xzvf unpv13e.tar.gz</span><br><span class="line">cd unpv13e</span><br><span class="line">./configure</span><br><span class="line">cp config.h /usr/include</span><br><span class="line">cp libunp.a /usr/lib</span><br><span class="line">cp key/unp.h /usr/include</span><br></pre></td></tr></table></figure></p>
<p>将<code>/usr/include/unp.h</code>中的<code>#include &quot;../config.h&quot;</code>改为<code>#include &quot;config.h&quot;</code><br>3.编译如果遇到如下错误,请将<code>unp.h</code>中的<code>struct in_pktinfo</code>定义删除。<br><img src="http://img.hysyeah.top/2019/10/30/unp-error.png" alt="image"></p>
<hr>
<h5 id="datetimecli-c"><a href="#datetimecli-c" class="headerlink" title="datetimecli.c"></a>datetimecli.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>                 sockfd, n;</span><br><span class="line">    <span class="keyword">char</span>                recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        err_quit(<span class="string">"usage: a.out &lt;IPaddress&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个字节流套接字,并返回一个描述符</span></span><br><span class="line">    <span class="keyword">if</span> ( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"socket error"</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)); <span class="comment">//对网络套接字结构清零</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port   = htons(<span class="number">13</span>); <span class="comment">// 端口号必须使用特定格式,所以需要通过htons函数进行转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把ASCII命令行参数转换为合适的格式</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)</span><br><span class="line">        err_quit(<span class="string">"inet_pton error for %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (SA *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"connect error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( (n = read(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        recvline[n] = <span class="number">0</span>;    <span class="comment">/* null terminate */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">            err_sys(<span class="string">"fputs error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"read error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="datetimesrv-c"><a href="#datetimesrv-c" class="headerlink" title="datetimesrv.c"></a>datetimesrv.c</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">"unp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>                 listenfd, connfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span>                buff[MAXLINE];</span><br><span class="line">    <span class="keyword">time_t</span>              ticks;</span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">// Socket是经过封装的socket函数,增加了错误处理</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family      = AF_INET;</span><br><span class="line">    <span class="comment">// 指定IP地址为INADDR_ANY,这样要服务器主机有多信网络接口,服务器进程就可以在任意网络接口上接受客户连接</span></span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port        = htons(<span class="number">13</span>);   <span class="comment">/* daytime server */</span></span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (SA *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把该套接字转换为一个监听套接字,这样来自客户的外来连接就可在该套接字上由内核接受</span></span><br><span class="line">    Listen(listenfd, LISTENQ); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="comment">// 服务器进程在accept调用中被投入睡眠,等待某个客户连接的到来并被内核接受。TCP连接所使用的三路握手来建立连接。握手完毕时accept返回,其返回值是一个称为已连接描述符的新描述符。该描述符用于与新连接的那个客户通信。accept为每个连接到本服务器的客户返回一个新的描述符。</span></span><br><span class="line">        connfd = Accept(listenfd, (SA *) <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">"%.24s\r\n"</span>, ctime(&amp;ticks));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往已连接描述符中写入数据</span></span><br><span class="line">        Write(connfd, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器通过调用close关闭与客户端的连接</span></span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.测试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc daytimetcpcli.c -o daytimetcpcli -lunp</span><br><span class="line">gcc daytimetcpsrv.c -o daytimetcpsrv -lunp</span><br></pre></td></tr></table></figure></p>
<p>先运行<code>daytimetcpsrv</code>,再运行<code>daytimetcpcli</code><br><img src="http://img.hysyeah.top/2019/11/03/unp-intro1.png" alt="image"></p>
<hr>
<p>Ref：<br>1.unix网络编程-volume1</p>
]]></content>
      <categories>
        <category>unp</category>
      </categories>
      <tags>
        <tag>unp</tag>
      </tags>
  </entry>
  <entry>
    <title>zeppelin创建mysql解析器,连接mysql</title>
    <url>/2017/09/04/zeppelin%E5%88%9B%E5%BB%BAmysql%E8%A7%A3%E6%9E%90%E5%99%A8,%E8%BF%9E%E6%8E%A5mysql/</url>
    <content><![CDATA[<p><a href="http://img.hysyeah.top/2017/09/04/sparkzeppelin%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">zeppelin环境的配置</a> 1.创建mysql解析器 <img src="http://img.hysyeah.top/wp-content/uploads/2017/09/2.png" alt="image"> <img src="http://img.hysyeah.top/wp-content/uploads/2017/09/3.png" alt="image"> <img src="http://img.hysyeah.top/wp-content/uploads/2017/09/4.png" alt="image"> <img src="http://img.hysyeah.top/wp-content/uploads/2017/09/5.png" alt="image"> 2.根据上图填写配置 3.创建Note <img src="http://img.hysyeah.top/wp-content/uploads/2017/09/6.png" alt="image"> 4.编写sql语句，执行后生成下图 <img src="http://img.hysyeah.top/wp-content/uploads/2017/09/9.png" alt="image"></p>
<hr>
<p>Ref： 1.<a href="https://zeppelin.apache.org/docs/0.7.0/interpreter/jdbc.html" target="_blank" rel="noopener">https://zeppelin.apache.org/docs/0.7.0/interpreter/jdbc.html</a></p>
]]></content>
      <categories>
        <category>python科学计算</category>
      </categories>
  </entry>
  <entry>
    <title>zero-copy</title>
    <url>/2019/03/20/zero-copy/</url>
    <content><![CDATA[<p>在许多web应用中需要从磁盘中读取数据然后再将数据发送到socket中，而数据复制这一操作是非常消耗资源的。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/03/cp.png" alt> 当执行<code>content_to_write = content[1024:]</code>时，这个操作是复制从1024字节后的所有数据到变量<code>content_to_write</code>中，这个过程中增加了9.789MB内存。 有没有方法可以在这种操作中不复制数据呢，在实现了<code>buffer protocol</code>的对象中是可以实现的。当一个对象实现了这个协议，你可以使用<code>memoryview</code>构造一个<code>memoryview</code>对象，实现对源对象内存数据的引用。 使用<code>memoryview</code> 并没有产生多余的内存。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/03/cp_memoryview.png" alt> 在web应用中将数据从磁盘复制，然后发送到socket中。 普通的复制操作是这样的</p>
<pre><code>file.read(fileDesc, buf, len);
socket.send(socket, buf, len);
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/03/copy_traditional.png" alt> 用户请求向web应用请求数据，数据复制的过程如下： 1.web应用调用系统调用<code>read()</code>方法，此处从用户态切换到内核态。1过程使用DMA从磁盘中复制数据到<code>Read buffer</code>中。 2.当<code>read()</code>返回时，此处从内核态切换到用户态，将数据复制到应用缓存中。 3.web应用调用<code>send()</code>方法，此处从用户态切换到内核态，将数据复制到内核空间的内存中。 4. 4过程使用DMA方法从内核空间的缓存中复制数据到<code>socket</code>中。 当数据量很大时，这一过程是极其缓慢的。</p>
<hr>
<p>零拷贝方法:直接将数据从源端拷贝到目标端</p>
<pre><code>os.sendfile(out, in, offset, count, [headers, ][trailers, ]flags=0) 
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/03/copy_zero.png" alt> 传统拷贝方法所消耗的时间： <img src="http://img.hysyeah.top/wp-content/uploads/2019/03/normal_time.png" alt> 零拷贝方法所消耗的时间： <img src="http://img.hysyeah.top/wp-content/uploads/2019/03/zero_time.png" alt> 使用传统方法的客户端： <img src="http://img.hysyeah.top/wp-content/uploads/2019/03/normal_client.png" alt> 使用零拷贝方法的客户端：没产生大内存 <img src="http://img.hysyeah.top/wp-content/uploads/2019/03/zero_client.png" alt></p>
<pre><code>pip3 install memory_profiler
pip3 install line_profiler
</code></pre><hr>
<p>Ref:<br>1.<a href="https://developer.ibm.com/articles/j-zerocopy/" target="_blank" rel="noopener">Efficient data transfer through zero copy</a><br>2.<a href="https://julien.danjou.info/high-performance-in-python-with-zero-copy-and-the-buffer-protocol/" target="_blank" rel="noopener">high-performance-in-python-with-zero-copy-and-the-buffer-protocol/</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>zipfile乱码问题</title>
    <url>/2018/05/31/zipfile%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>python3.5使用zipfile.ZipFile(“xx.zip”)读取压缩文件为中文的文件时出现乱码 zipfile检测文件编码，如果是’utf-8’编码则解码为’utf-8’,否则解码为’cp437’,修改zipfile.py将’cp437’改为’gbk’即可。</p>
<pre><code>import zipfile
import os
os.path.dirname(zipfile.__file__)  #查看zipfile.py文件所在路径

if flags &amp; 0x800:
    # UTF-8 file names extension
    filename = filename.decode(&#39;utf-8&#39;)
else:
    # Historical ZIP filename encoding
    filename = filename.decode(&#39;cp437&#39;)  #改为filename = filename.decode(&#39;gbk&#39;)

if zinfo.flag_bits &amp; 0x800:
    # UTF-8 filename
    fname_str = fname.decode(&quot;utf-8&quot;)
 else:
    fname_str = fname.decode(&quot;cp437&quot;)   #改为fname_str = fname.decode(&quot;gbk&quot;)
</code></pre><hr>
<p>Ref 1.<a href="https://blog.csdn.net/tian544556/article/details/78635840" target="_blank" rel="noopener">https://blog.csdn.net/tian544556/article/details/78635840</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>一个操作系统的实现中使用的命令和工具</title>
    <url>/2020/01/20/%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E5%92%8C%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>对书中所使用到的工具和命令进行记录,方便查看！</p>
<p>ndisasmv</p>
<p>bximage</p>
<p>dd</p>
<p>xxd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo losetup -f</span><br><span class="line"></span><br><span class="line">mkdir /mnt/floppy</span><br><span class="line"></span><br><span class="line">losetup /dev/loop5 pm.img</span><br><span class="line"></span><br><span class="line">sudo mount /dev/loop5 /mnt/floppy</span><br><span class="line">sudo cp pmtest3.com /mnt/floppy</span><br><span class="line">umount /mnt/floppy</span><br><span class="line"></span><br><span class="line">sudo mount -t msdos -o loop pm.img /mnt/floppy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x/4xw 0x7c14</span><br><span class="line"></span><br><span class="line">qemu-system-i386 -hda /home/hys/code/6828/src/orange/ch1/a.img -gdb tcp::26000 -S</span><br></pre></td></tr></table></figure>
<hr>
<p>错误集锦：<br>hys@hys:~/code/6828/src/orange/ch3/b$ sudo mount -t msdos -o loop pm.img /mnt/floppy<br>mount: /mnt/floppy: wrong fs type, bad option, bad superblock on /dev/loop22, missing codepage or helper program, or other error.</p>
<p>需启动bochs<br>然后进行初始化: format b:<br>然后再执行mount命令</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>一个deployment是怎么创建的</title>
    <url>/2023/04/01/%E4%B8%80%E4%B8%AAdeployment%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%9A%84/</url>
    <content><![CDATA[<p>从一个deployment到创建对应的资源(如Replicat,pod)主要包括这几个主件kubee-apiserver,kube-controller-manager(deployment-controller,replicaset-controller),kubelet,kube-schedule。</p>
<p>k8s中kube-apiserver负责接收请求，kube-controller-manager负责监听资源变化并作出相应动作，kube-schedule负责调度，kubelet负责把容器拉起来。</p>
<h6 id="当你使用kubectl-create-命令创建deploy会发生如下请求。"><a href="#当你使用kubectl-create-命令创建deploy会发生如下请求。" class="headerlink" title="当你使用kubectl create 命令创建deploy会发生如下请求。"></a>当你使用kubectl create 命令创建deploy会发生如下请求。</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ ✗ k create -f tt.yaml --v=6</span><br><span class="line">I0401 14:30:30.064130 1625050 loader.go:374] Config loaded from file:  /home/xxxx/.kube/config</span><br><span class="line">I0401 14:30:30.094255 1625050 round_trippers.go:553] GET https://192.168.3.112:6443/openapi/v2?timeout=32s 200 OK in 29 milliseconds</span><br><span class="line">I0401 14:30:30.203951 1625050 round_trippers.go:553] POST https://192.168.3.112:6443/apis/apps/v1/namespaces/default/deployments?fieldManager=kubectl-create&amp;fieldValidation=Strict 201 Created in 5 milliseconds</span><br><span class="line">deployment.apps/use created</span><br></pre></td></tr></table></figure>
<p>从日志中可以发现kubectl调用了接口<code>/apis/aapps/v1/namespaces/default/deployments</code></p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在这里会创建一个新的对象</span></span><br><span class="line">staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.<span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">Create</span><span class="params">(ctx context.Context, obj runtime.Object, createValidation rest.ValidateObjectFunc, options *metav1.CreateOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> objectMeta, err := meta.Accessor(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rest.FillObjectMetaSystemFields(objectMeta)</span><br><span class="line">        <span class="comment">// 根据GenerateName设置对象名称</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(objectMeta.GetGenerateName()) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(objectMeta.GetName()) == <span class="number">0</span> &#123;</span><br><span class="line">			objectMeta.SetName(e.CreateStrategy.GenerateName(objectMeta.GetGenerateName()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 执行对应的deployment strategy,比如一些验证</span></span><br><span class="line">    <span class="keyword">if</span> err := rest.BeforeCreate(e.CreateStrategy, ctx, obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取对象的名称，在这里是deployment name</span></span><br><span class="line">    name, err := e.ObjectNameFunc(obj)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取资源对象对应的路径,因为我是在default命名空间下创建的，所以key = "/deployments/default/use"</span></span><br><span class="line">    key, err := e.KeyFunc(ctx, name)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建一个空的deployment对象</span></span><br><span class="line">    out := e.NewFunc()</span><br><span class="line">    <span class="comment">// 创建对象，最终是往etcd中写入了对应的数据,此时对应的replicaset,pod并没有被创建</span></span><br><span class="line">    <span class="keyword">if</span> err := e.Storage.Create(ctx, key, obj, out, ttl, dryrun.IsDryRun(options.DryRun)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>deployment</code>创建成功后(可以通过<code>kubectl get deploy</code>进行查看)，<code>deployment controller</code>就要开始干活了，那<code>deployment controller</code>是怎么知道有活干了呢？</p>
<p><code>deployment controller</code>通过<code>informer</code>机制可以监听到事件变化，当创建一个<code>deployment</code>后，<code>kube-apiserver</code>会通过http分块传输将输给客户,在这里<code>deployment controller</code>可以看作是<code>apiserver</code>的客户端</p>
<h6 id="deployment创建完成后，deployment就要开始工作创建对应的replicaset"><a href="#deployment创建完成后，deployment就要开始工作创建对应的replicaset" class="headerlink" title="deployment创建完成后，deployment就要开始工作创建对应的replicaset"></a>deployment创建完成后，deployment就要开始工作创建对应的replicaset</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/deployment/deployment_controller.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, workers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start events processing pipeline.</span></span><br><span class="line">	dc.eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">	dc.eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: dc.client.CoreV1().Events(<span class="string">""</span>)&#125;)</span><br><span class="line">	<span class="keyword">defer</span> dc.eventBroadcaster.Shutdown()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> dc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	logger.Info(<span class="string">"Starting controller"</span>, <span class="string">"controller"</span>, <span class="string">"deployment"</span>)</span><br><span class="line">	<span class="keyword">defer</span> logger.Info(<span class="string">"Shutting down controller"</span>, <span class="string">"controller"</span>, <span class="string">"deployment"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"deployment"</span>, ctx.Done(), dc.dListerSynced, dc.rsListerSynced, dc.podListerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.UntilWithContext(ctx, dc.worker, time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> dc.processNextWorkItem(ctx) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">processNextWorkItem</span><span class="params">(ctx context.Context)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	key, quit := dc.queue.Get()</span><br><span class="line">	<span class="keyword">if</span> quit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> dc.queue.Done(key)</span><br><span class="line"></span><br><span class="line">	err := dc.syncHandler(ctx, key.(<span class="keyword">string</span>))</span><br><span class="line">	dc.handleErr(ctx, err, key)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="真正执行逻辑的函数是"><a href="#真正执行逻辑的函数是" class="headerlink" title="真正执行逻辑的函数是"></a>真正执行逻辑的函数是</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">syncDeployment</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	logger := klog.FromContext(ctx)</span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">"Failed to split meta namespace cache key"</span>, <span class="string">"cacheKey"</span>, key)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	logger.V(<span class="number">4</span>).Info(<span class="string">"Started syncing deployment"</span>, <span class="string">"deployment"</span>, klog.KRef(namespace, name), <span class="string">"startTime"</span>, startTime)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		logger.V(<span class="number">4</span>).Info(<span class="string">"Finished syncing deployment"</span>, <span class="string">"deployment"</span>, klog.KRef(namespace, name), <span class="string">"duration"</span>, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	deployment, err := dc.dLister.Deployments(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		logger.V(<span class="number">2</span>).Info(<span class="string">"Deployment has been deleted"</span>, <span class="string">"deployment"</span>, klog.KRef(namespace, name))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Deep-copy otherwise we are mutating our cache.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Deep-copy only when needed.</span></span><br><span class="line">	d := deployment.DeepCopy()</span><br><span class="line"></span><br><span class="line">	everything := metav1.LabelSelector&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> reflect.DeepEqual(d.Spec.Selector, &amp;everything) &#123;</span><br><span class="line">		dc.eventRecorder.Eventf(d, v1.EventTypeWarning, <span class="string">"SelectingAll"</span>, <span class="string">"This deployment is selecting all pods. A non-empty selector is required."</span>)</span><br><span class="line">		<span class="keyword">if</span> d.Status.ObservedGeneration &lt; d.Generation &#123;</span><br><span class="line">			d.Status.ObservedGeneration = d.Generation</span><br><span class="line">			dc.client.AppsV1().Deployments(d.Namespace).UpdateStatus(ctx, d, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// List ReplicaSets owned by this Deployment, while reconciling ControllerRef</span></span><br><span class="line">	<span class="comment">// through adoption/orphaning.</span></span><br><span class="line">	rsList, err := dc.getReplicaSetsForDeployment(ctx, d)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// List all Pods owned by this Deployment, grouped by their ReplicaSet.</span></span><br><span class="line">	<span class="comment">// Current uses of the podMap are:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// * check if a Pod is labeled correctly with the pod-template-hash label.</span></span><br><span class="line">	<span class="comment">// * check that no old Pods are running in the middle of Recreate Deployments.</span></span><br><span class="line">	podMap, err := dc.getPodMapForDeployment(d, rsList)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> d.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.syncStatusOnly(ctx, d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update deployment conditions with an Unknown condition when pausing/resuming</span></span><br><span class="line">	<span class="comment">// a deployment. In this way, we can be sure that we won't timeout when a user</span></span><br><span class="line">	<span class="comment">// resumes a Deployment with a set progressDeadlineSeconds.</span></span><br><span class="line">	<span class="keyword">if</span> err = dc.checkPausedConditions(ctx, d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> d.Spec.Paused &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.sync(ctx, d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rollback is not re-entrant in case the underlying replica sets are updated with a new</span></span><br><span class="line">	<span class="comment">// revision so we should ensure that we won't proceed to update replica sets until we</span></span><br><span class="line">	<span class="comment">// make sure that the deployment has cleaned up its rollback spec in subsequent enqueues.</span></span><br><span class="line">	<span class="keyword">if</span> getRollbackTo(d) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.rollback(ctx, d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scalingEvent, err := dc.isScalingEvent(ctx, d, rsList)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> scalingEvent &#123;</span><br><span class="line">		<span class="keyword">return</span> dc.sync(ctx, d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> d.Spec.Strategy.Type &#123;</span><br><span class="line">	<span class="keyword">case</span> apps.RecreateDeploymentStrategyType:</span><br><span class="line">		<span class="keyword">return</span> dc.rolloutRecreate(ctx, d, rsList, podMap)</span><br><span class="line">	<span class="comment">// 新建一个deployment会执行到这个逻辑，创建对应的ReplicaSet</span></span><br><span class="line">	<span class="keyword">case</span> apps.RollingUpdateDeploymentStrategyType:</span><br><span class="line">		<span class="keyword">return</span> dc.rolloutRolling(ctx, d, rsList)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"unexpected deployment strategy type: %s"</span>, d.Spec.Strategy.Type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rolloutRolling会创建对应的ReplicaSet</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">rolloutRolling</span><span class="params">(ctx context.Context, d *apps.Deployment, rsList []*apps.ReplicaSet)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	newRS, oldRSs, err := dc.getAllReplicaSetsAndSyncRevision(ctx, d, rsList, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	allRSs := <span class="built_in">append</span>(oldRSs, newRS)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scale up, if we can.</span></span><br><span class="line">	scaledUp, err := dc.reconcileNewReplicaSet(ctx, allRSs, newRS, d)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> scaledUp &#123;</span><br><span class="line">		<span class="comment">// Update DeploymentStatus</span></span><br><span class="line">		<span class="keyword">return</span> dc.syncRolloutStatus(ctx, allRSs, newRS, d)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scale down, if we can.</span></span><br><span class="line">	scaledDown, err := dc.reconcileOldReplicaSets(ctx, allRSs, controller.FilterActiveReplicaSets(oldRSs), newRS, d)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> scaledDown &#123;</span><br><span class="line">		<span class="comment">// Update DeploymentStatus</span></span><br><span class="line">		<span class="keyword">return</span> dc.syncRolloutStatus(ctx, allRSs, newRS, d)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> deploymentutil.DeploymentComplete(d, &amp;d.Status) &#123;</span><br><span class="line">		<span class="keyword">if</span> err := dc.cleanupDeployment(ctx, oldRSs, d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sync deployment status</span></span><br><span class="line">	<span class="keyword">return</span> dc.syncRolloutStatus(ctx, allRSs, newRS, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="创建完对应的replicaset之后，replicaset-controller也会监听到相应的对象变化信息。现在来到replicaset-controller"><a href="#创建完对应的replicaset之后，replicaset-controller也会监听到相应的对象变化信息。现在来到replicaset-controller" class="headerlink" title="创建完对应的replicaset之后，replicaset controller也会监听到相应的对象变化信息。现在来到replicaset controller"></a>创建完对应的replicaset之后，replicaset controller也会监听到相应的对象变化信息。现在来到replicaset controller</h6><p> 主要看syncReplicaSet函数</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/controller/replicaset/replica_set.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rsc *ReplicaSetController)</span> <span class="title">syncReplicaSet</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		klog.FromContext(ctx).V(<span class="number">4</span>).Info(<span class="string">"Finished syncing"</span>, <span class="string">"kind"</span>, rsc.Kind, <span class="string">"key"</span>, key, <span class="string">"duration"</span>, time.Since(startTime))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	rs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">		klog.FromContext(ctx).V(<span class="number">4</span>).Info(<span class="string">"deleted"</span>, <span class="string">"kind"</span>, rsc.Kind, <span class="string">"key"</span>, key)</span><br><span class="line">		rsc.expectations.DeleteExpectations(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rsNeedsSync := rsc.expectations.SatisfiedExpectations(key)</span><br><span class="line">	selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		utilruntime.HandleError(fmt.Errorf(<span class="string">"error converting pod selector to selector for rs %v/%v: %v"</span>, namespace, name, err))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// list all pods to include the pods that don't match the rs`s selector</span></span><br><span class="line">	<span class="comment">// anymore but has the stale controller ref.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Do the List and Filter in a single pass, or use an index.</span></span><br><span class="line">	allPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Ignore inactive pods.</span></span><br><span class="line">	filteredPods := controller.FilterActivePods(allPods)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> filteredPods are pointing to objects from cache - if you need to</span></span><br><span class="line">	<span class="comment">// modify them, you need to copy it first.</span></span><br><span class="line">	filteredPods, err = rsc.claimPods(ctx, rs, selector, filteredPods)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> manageReplicasErr error</span><br><span class="line">	<span class="keyword">if</span> rsNeedsSync &amp;&amp; rs.DeletionTimestamp == <span class="literal">nil</span> &#123;</span><br><span class="line">		manageReplicasErr = rsc.manageReplicas(ctx, filteredPods, rs)</span><br><span class="line">	&#125;</span><br><span class="line">	rs = rs.DeepCopy()</span><br><span class="line">	newStatus := calculateStatus(rs, filteredPods, manageReplicasErr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Always updates status as pods come up or die.</span></span><br><span class="line">	updatedRS, err := updateReplicaSetStatus(klog.FromContext(ctx), rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Multiple things could lead to this update failing. Requeuing the replica set ensures</span></span><br><span class="line">		<span class="comment">// Returning an error causes a requeue without forcing a hotloop</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Resync the ReplicaSet after MinReadySeconds as a last line of defense to guard against clock-skew.</span></span><br><span class="line">	<span class="keyword">if</span> manageReplicasErr == <span class="literal">nil</span> &amp;&amp; updatedRS.Spec.MinReadySeconds &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">		updatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &amp;&amp;</span><br><span class="line">		updatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) &#123;</span><br><span class="line">		rsc.queue.AddAfter(key, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> manageReplicasErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="在manageReplicas中会调用-rsc-podControl-CreatePods-…-向apiserver发送一个请求创建对应的pod-接下来就是经过kube-scheduler调度，然后由kubelet将容器拉起"><a href="#在manageReplicas中会调用-rsc-podControl-CreatePods-…-向apiserver发送一个请求创建对应的pod-接下来就是经过kube-scheduler调度，然后由kubelet将容器拉起" class="headerlink" title="在manageReplicas中会调用　rsc.podControl.CreatePods(…)向apiserver发送一个请求创建对应的pod,接下来就是经过kube-scheduler调度，然后由kubelet将容器拉起"></a>在manageReplicas中会调用　rsc.podControl.CreatePods(…)向apiserver发送一个请求创建对应的pod,接下来就是经过kube-scheduler调度，然后由kubelet将容器拉起</h6><hr>
<h6 id="此外省略kube-schedule调度过程，跳至kubelet如何拉取一个容器"><a href="#此外省略kube-schedule调度过程，跳至kubelet如何拉取一个容器" class="headerlink" title="此外省略kube-schedule调度过程，跳至kubelet如何拉取一个容器"></a>此外省略<code>kube-schedule</code>调度过程，跳至<code>kubelet</code>如何拉取一个容器</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/kubelet.go</span></span><br><span class="line"><span class="comment">// 从多个通道读取变化然后分发给对应的handler,因为是新建pod所以执行handler.HandlePodAdditions(u.Pods)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoopIteration</span><span class="params">(ctx context.Context, configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line">		<span class="comment">// Update from a config source; dispatch it to the right handler</span></span><br><span class="line">		<span class="comment">// callback.</span></span><br><span class="line">		<span class="keyword">if</span> !open &#123;</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">"Update channel is closed, exiting the sync loop"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> u.Op &#123;</span><br><span class="line">		<span class="keyword">case</span> kubetypes.ADD:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">"SyncLoop ADD"</span>, <span class="string">"source"</span>, u.Source, <span class="string">"pods"</span>, klog.KObjSlice(u.Pods))</span><br><span class="line">			<span class="comment">// After restarting, kubelet will get all existing pods through</span></span><br><span class="line">			<span class="comment">// ADD as if they are new pods. These pods will then go through the</span></span><br><span class="line">			<span class="comment">// admission process and *may* be rejected. This can be resolved</span></span><br><span class="line">			<span class="comment">// once we have checkpointing.</span></span><br><span class="line">			handler.HandlePodAdditions(u.Pods)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="进入到HandlePodAdditions"><a href="#进入到HandlePodAdditions" class="headerlink" title="进入到HandlePodAdditions"></a>进入到HandlePodAdditions</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/kubelet.go</span></span><br><span class="line"><span class="comment">// 删减了一些不重要的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">HandlePodAdditions</span><span class="params">(pods []*v1.Pod)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 对pod根据创建时间排序</span></span><br><span class="line">	sort.Sort(sliceutils.PodsByCreationTime(pods))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		existingPods := kl.podManager.GetPods()</span><br><span class="line">		<span class="comment">// 将pod加入podManager</span></span><br><span class="line">		kl.podManager.AddPod(pod)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果是mirrorpod则进入mirrorpod的处理逻辑</span></span><br><span class="line">		<span class="keyword">if</span> kubetypes.IsMirrorPod(pod) &#123;</span><br><span class="line">			kl.handleMirrorPod(pod, start)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Only go through the admission process if the pod is not requested</span></span><br><span class="line">		<span class="comment">// for termination by another part of the kubelet. If the pod is already</span></span><br><span class="line">		<span class="comment">// using resources (previously admitted), the pod worker is going to be</span></span><br><span class="line">		<span class="comment">// shutting it down. If the pod hasn't started yet, we know that when</span></span><br><span class="line">		<span class="comment">// the pod worker is invoked it will also avoid setting up the pod, so</span></span><br><span class="line">		<span class="comment">// we simply avoid doing any work.</span></span><br><span class="line">		<span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">			<span class="comment">// We failed pods that we rejected, so activePods include all admitted</span></span><br><span class="line">			<span class="comment">// pods that are alive.</span></span><br><span class="line">			activePods := kl.filterOutInactivePods(existingPods)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.InPlacePodVerticalScaling) &#123;</span><br><span class="line">				<span class="comment">// To handle kubelet restarts, test pod admissibility using AllocatedResources values</span></span><br><span class="line">				<span class="comment">// (for cpu &amp; memory) from checkpoint store. If found, that is the source of truth.</span></span><br><span class="line">				podCopy := pod.DeepCopy()</span><br><span class="line">				<span class="keyword">for</span> _, c := <span class="keyword">range</span> podCopy.Spec.Containers &#123;</span><br><span class="line">					allocatedResources, found := kl.statusManager.GetContainerResourceAllocation(<span class="keyword">string</span>(pod.UID), c.Name)</span><br><span class="line">					<span class="keyword">if</span> c.Resources.Requests != <span class="literal">nil</span> &amp;&amp; found &#123;</span><br><span class="line">						c.Resources.Requests[v1.ResourceCPU] = allocatedResources[v1.ResourceCPU]</span><br><span class="line">						c.Resources.Requests[v1.ResourceMemory] = allocatedResources[v1.ResourceMemory]</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Check if we can admit the pod; if not, reject it.</span></span><br><span class="line">				<span class="keyword">if</span> ok, reason, message := kl.canAdmitPod(activePods, podCopy); !ok &#123;</span><br><span class="line">					kl.rejectPod(pod, reason, message)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// For new pod, checkpoint the resource values at which the Pod has been admitted</span></span><br><span class="line">				<span class="keyword">if</span> err := kl.statusManager.SetPodAllocation(podCopy); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="comment">//TODO(vinaykul,InPlacePodVerticalScaling): Can we recover from this in some way? Investigate</span></span><br><span class="line">					klog.ErrorS(err, <span class="string">"SetPodAllocation failed"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Check if we can admit the pod; if not, reject it.</span></span><br><span class="line">				<span class="keyword">if</span> ok, reason, message := kl.canAdmitPod(activePods, pod); !ok &#123;</span><br><span class="line">					kl.rejectPod(pod, reason, message)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)</span><br><span class="line">		kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="进入到dispatchWork"><a href="#进入到dispatchWork" class="headerlink" title="进入到dispatchWork"></a>进入到dispatchWork</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/kubelet.go</span></span><br><span class="line"><span class="comment">// 开始在pod worker中进行异步更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">dispatchWork</span><span class="params">(pod *v1.Pod, syncType kubetypes.SyncPodType, mirrorPod *v1.Pod, start time.Time)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Run the sync in an async worker.</span></span><br><span class="line">	kl.podWorkers.UpdatePod(UpdatePodOptions&#123;</span><br><span class="line">		Pod:        pod,</span><br><span class="line">		MirrorPod:  mirrorPod,</span><br><span class="line">		UpdateType: syncType,</span><br><span class="line">		StartTime:  start,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// Note the number of containers for new pods.</span></span><br><span class="line">	<span class="keyword">if</span> syncType == kubetypes.SyncPodCreate &#123;</span><br><span class="line">		metrics.ContainersPerPodCount.Observe(<span class="keyword">float64</span>(<span class="built_in">len</span>(pod.Spec.Containers)))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="进入到UpdatePod"><a href="#进入到UpdatePod" class="headerlink" title="进入到UpdatePod"></a>进入到UpdatePod</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/pod_workers.go</span></span><br><span class="line"><span class="comment">// 这里会更新pod的一些状态，并开启一个协程进入podWorkerLoop</span></span><br><span class="line"><span class="comment">// 上面说的异步更新就是指这里会开启一个新的协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span> <span class="title">UpdatePod</span><span class="params">(options UpdatePodOptions)</span></span> &#123;</span><br><span class="line">			<span class="comment">// spawn a pod worker</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line">			<span class="keyword">defer</span> klog.V(<span class="number">3</span>).InfoS(<span class="string">"Pod worker has stopped"</span>, <span class="string">"podUID"</span>, uid)</span><br><span class="line">			p.podWorkerLoop(uid, outCh)</span><br><span class="line">		&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="进入podWorkerLoop"><a href="#进入podWorkerLoop" class="headerlink" title="进入podWorkerLoop"></a>进入podWorkerLoop</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/pod_workers.go</span></span><br><span class="line"><span class="comment">// 最终会进入到SyncPod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span> <span class="title">podWorkerLoop</span><span class="params">(podUID types.UID, podUpdates &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> lastSyncTime time.Time</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> podUpdates &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">var</span> isTerminal <span class="keyword">bool</span></span><br><span class="line">		err := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="comment">// The worker is responsible for ensuring the sync method sees the appropriate</span></span><br><span class="line">			<span class="comment">// status updates on resyncs (the result of the last sync), transitions to</span></span><br><span class="line">			<span class="comment">// terminating (no wait), or on terminated (whatever the most recent state is).</span></span><br><span class="line">			<span class="comment">// Only syncing and terminating can generate pod status changes, while terminated</span></span><br><span class="line">			<span class="comment">// pods ensure the most recent status makes it to the api server.</span></span><br><span class="line">			<span class="keyword">var</span> status *kubecontainer.PodStatus</span><br><span class="line">			<span class="keyword">var</span> err error</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update.Options.RunningPod != <span class="literal">nil</span>:</span><br><span class="line">				<span class="comment">// when we receive a running pod, we don't need status at all because we are</span></span><br><span class="line">				<span class="comment">// guaranteed to be terminating and we skip updates to the pod</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// wait until we see the next refresh from the PLEG via the cache (max 2s)</span></span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> this adds ~1s of latency on all transitions from sync to terminating</span></span><br><span class="line">				<span class="comment">//  to terminated, and on all termination retries (including evictions). We should</span></span><br><span class="line">				<span class="comment">//  improve latency by making the pleg continuous and by allowing pod status</span></span><br><span class="line">				<span class="comment">//  changes to be refreshed when key events happen (killPod, sync-&gt;terminating).</span></span><br><span class="line">				<span class="comment">//  Improving this latency also reduces the possibility that a terminated</span></span><br><span class="line">				<span class="comment">//  container's status is garbage collected before we have a chance to update the</span></span><br><span class="line">				<span class="comment">//  API server (thus losing the exit code).</span></span><br><span class="line">				status, err = p.podCache.GetNewerThan(update.Options.Pod.UID, lastSyncTime)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="comment">// This is the legacy event thrown by manage pod loop all other events are now dispatched</span></span><br><span class="line">					<span class="comment">// from syncPodFn</span></span><br><span class="line">					p.recorder.Eventf(update.Options.Pod, v1.EventTypeWarning, events.FailedSync, <span class="string">"error determining status: %v"</span>, err)</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Take the appropriate action (illegal phases are prevented by UpdatePod)</span></span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update.WorkType == TerminatedPod:</span><br><span class="line">				err = p.podSyncer.SyncTerminatedPod(ctx, update.Options.Pod, status)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> update.WorkType == TerminatingPod:</span><br><span class="line">				<span class="keyword">var</span> gracePeriod *<span class="keyword">int64</span></span><br><span class="line">				<span class="keyword">if</span> opt := update.Options.KillPodOptions; opt != <span class="literal">nil</span> &#123;</span><br><span class="line">					gracePeriod = opt.PodTerminationGracePeriodSecondsOverride</span><br><span class="line">				&#125;</span><br><span class="line">				podStatusFn := p.acknowledgeTerminating(podUID)</span><br><span class="line"></span><br><span class="line">				<span class="comment">// if we only have a running pod, terminate it directly</span></span><br><span class="line">				<span class="keyword">if</span> update.Options.RunningPod != <span class="literal">nil</span> &#123;</span><br><span class="line">					err = p.podSyncer.SyncTerminatingRuntimePod(ctx, update.Options.RunningPod)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					err = p.podSyncer.SyncTerminatingPod(ctx, update.Options.Pod, status, gracePeriod, podStatusFn)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				isTerminal, err = p.podSyncer.SyncPod(ctx, update.Options.UpdateType, update.Options.Pod, update.Options.MirrorPod, status)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			lastSyncTime = p.clock.Now()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="syncPod"><a href="#syncPod" class="headerlink" title="syncPod"></a>syncPod</h6><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/kubelet.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">SyncPod</span><span class="params">(_ context.Context, updateType kubetypes.SyncPodType, pod, mirrorPod *v1.Pod, podStatus *kubecontainer.PodStatus)</span> <span class="params">(isTerminal <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	result := kl.containerRuntime.SyncPod(ctx, pod, podStatus, pullSecrets, kl.backOff)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>kl.containerRuntime.SyncPod<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/kubelet/kuberuntime/kuberuntime_manager.go</span></span><br><span class="line"><span class="comment">// 在这里会调用CRI创建对应的容器,CNI由CRI负责调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">SyncPod</span><span class="params">(ctx context.Context, pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff)</span> <span class="params">(result kubecontainer.PodSyncResult)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Step 1: Compute sandbox and container changes.</span></span><br><span class="line">	podContainerChanges := m.computePodActions(ctx, pod, podStatus)</span><br><span class="line">	klog.V(<span class="number">3</span>).InfoS(<span class="string">"computePodActions got for pod"</span>, <span class="string">"podActions"</span>, podContainerChanges, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">		ref, err := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.ErrorS(err, <span class="string">"Couldn't make a ref to pod"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> podContainerChanges.SandboxID != <span class="string">""</span> &#123;</span><br><span class="line">			m.recorder.Eventf(ref, v1.EventTypeNormal, events.SandboxChanged, <span class="string">"Pod sandbox changed, it will be killed and re-created."</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">"SyncPod received new pod, will create a sandbox for it"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Kill the pod if the sandbox has changed.</span></span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.KillPod &#123;</span><br><span class="line">		<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">"Stopping PodSandbox for pod, will start new one"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">"Stopping PodSandbox for pod, because all other containers are dead"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		killResult := m.killPodWithSyncResult(ctx, pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), <span class="literal">nil</span>)</span><br><span class="line">		result.AddPodSyncResult(killResult)</span><br><span class="line">		<span class="keyword">if</span> killResult.Error() != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.ErrorS(killResult.Error(), <span class="string">"killPodWithSyncResult failed"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">			m.purgeInitContainers(ctx, pod, podStatus)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Step 3: kill any running containers in this pod which are not to keep.</span></span><br><span class="line">		<span class="keyword">for</span> containerID, containerInfo := <span class="keyword">range</span> podContainerChanges.ContainersToKill &#123;</span><br><span class="line">			klog.V(<span class="number">3</span>).InfoS(<span class="string">"Killing unwanted container for pod"</span>, <span class="string">"containerName"</span>, containerInfo.name, <span class="string">"containerID"</span>, containerID, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">			killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, containerInfo.name)</span><br><span class="line">			result.AddSyncResult(killContainerResult)</span><br><span class="line">			<span class="keyword">if</span> err := m.killContainer(ctx, pod, containerID, containerInfo.name, containerInfo.message, containerInfo.reason, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				killContainerResult.Fail(kubecontainer.ErrKillContainer, err.Error())</span><br><span class="line">				klog.ErrorS(err, <span class="string">"killContainer for pod failed"</span>, <span class="string">"containerName"</span>, containerInfo.name, <span class="string">"containerID"</span>, containerID, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Keep terminated init containers fairly aggressively controlled</span></span><br><span class="line">	<span class="comment">// This is an optimization because container removals are typically handled</span></span><br><span class="line">	<span class="comment">// by container garbage collector.</span></span><br><span class="line">	m.pruneInitContainersBeforeStart(ctx, pod, podStatus)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We pass the value of the PRIMARY podIP and list of podIPs down to</span></span><br><span class="line">	<span class="comment">// generatePodSandboxConfig and generateContainerConfig, which in turn</span></span><br><span class="line">	<span class="comment">// passes it to various other functions, in order to facilitate functionality</span></span><br><span class="line">	<span class="comment">// that requires this value (hosts file and downward API) and avoid races determining</span></span><br><span class="line">	<span class="comment">// the pod IP in cases where a container requires restart but the</span></span><br><span class="line">	<span class="comment">// podIP isn't in the status manager yet. The list of podIPs is used to</span></span><br><span class="line">	<span class="comment">// generate the hosts file.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// We default to the IPs in the passed-in pod status, and overwrite them if the</span></span><br><span class="line">	<span class="comment">// sandbox needs to be (re)started.</span></span><br><span class="line">	<span class="keyword">var</span> podIPs []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">if</span> podStatus != <span class="literal">nil</span> &#123;</span><br><span class="line">		podIPs = podStatus.IPs</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: Create a sandbox for the pod if necessary.</span></span><br><span class="line">	podSandboxID := podContainerChanges.SandboxID</span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">		<span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">"Creating PodSandbox for pod"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">		metrics.StartedPodsTotal.Inc()</span><br><span class="line">		createSandboxResult := kubecontainer.NewSyncResult(kubecontainer.CreatePodSandbox, format.Pod(pod))</span><br><span class="line">		result.AddSyncResult(createSandboxResult)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ConvertPodSysctlsVariableToDotsSeparator converts sysctl variable</span></span><br><span class="line">		<span class="comment">// in the Pod.Spec.SecurityContext.Sysctls slice into a dot as a separator.</span></span><br><span class="line">		<span class="comment">// runc uses the dot as the separator to verify whether the sysctl variable</span></span><br><span class="line">		<span class="comment">// is correct in a separate namespace, so when using the slash as the sysctl</span></span><br><span class="line">		<span class="comment">// variable separator, runc returns an error: "sysctl is not in a separate kernel namespace"</span></span><br><span class="line">		<span class="comment">// and the podSandBox cannot be successfully created. Therefore, before calling runc,</span></span><br><span class="line">		<span class="comment">// we need to convert the sysctl variable, the dot is used as a separator to separate the kernel namespace.</span></span><br><span class="line">		<span class="comment">// When runc supports slash as sysctl separator, this function can no longer be used.</span></span><br><span class="line">		sysctl.ConvertPodSysctlsVariableToDotsSeparator(pod.Spec.SecurityContext)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare resources allocated by the Dynammic Resource Allocation feature for the pod</span></span><br><span class="line">		<span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.DynamicResourceAllocation) &#123;</span><br><span class="line">			<span class="keyword">if</span> m.runtimeHelper.PrepareDynamicResources(pod) != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		podSandboxID, msg, err = m.createPodSandbox(ctx, pod, podContainerChanges.Attempt)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// createPodSandbox can return an error from CNI, CSI,</span></span><br><span class="line">			<span class="comment">// or CRI if the Pod has been deleted while the POD is</span></span><br><span class="line">			<span class="comment">// being created. If the pod has been deleted then it's</span></span><br><span class="line">			<span class="comment">// not a real error.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// SyncPod can still be running when we get here, which</span></span><br><span class="line">			<span class="comment">// means the PodWorker has not acked the deletion.</span></span><br><span class="line">			<span class="keyword">if</span> m.podStateProvider.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">				klog.V(<span class="number">4</span>).InfoS(<span class="string">"Pod was deleted and sandbox failed to be created"</span>, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"podUID"</span>, pod.UID)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			metrics.StartedPodsErrorsTotal.Inc()</span><br><span class="line">			createSandboxResult.Fail(kubecontainer.ErrCreatePodSandbox, msg)</span><br><span class="line">			klog.ErrorS(err, <span class="string">"CreatePodSandbox for pod failed"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">			ref, referr := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line">			<span class="keyword">if</span> referr != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(referr, <span class="string">"Couldn't make a ref to pod"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">			&#125;</span><br><span class="line">			m.recorder.Eventf(ref, v1.EventTypeWarning, events.FailedCreatePodSandBox, <span class="string">"Failed to create pod sandbox: %v"</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">"Created PodSandbox for pod"</span>, <span class="string">"podSandboxID"</span>, podSandboxID, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line"></span><br><span class="line">		resp, err := m.runtimeService.PodSandboxStatus(ctx, podSandboxID, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ref, referr := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line">			<span class="keyword">if</span> referr != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(referr, <span class="string">"Couldn't make a ref to pod"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">			&#125;</span><br><span class="line">			m.recorder.Eventf(ref, v1.EventTypeWarning, events.FailedStatusPodSandBox, <span class="string">"Unable to get pod sandbox status: %v"</span>, err)</span><br><span class="line">			klog.ErrorS(err, <span class="string">"Failed to get pod sandbox status; Skipping pod"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">			result.Fail(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> resp.GetStatus() == <span class="literal">nil</span> &#123;</span><br><span class="line">			result.Fail(errors.New(<span class="string">"pod sandbox status is nil"</span>))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If we ever allow updating a pod from non-host-network to</span></span><br><span class="line">		<span class="comment">// host-network, we may use a stale IP.</span></span><br><span class="line">		<span class="keyword">if</span> !kubecontainer.IsHostNetworkPod(pod) &#123;</span><br><span class="line">			<span class="comment">// Overwrite the podIPs passed in the pod status, since we just started the pod sandbox.</span></span><br><span class="line">			podIPs = m.determinePodSandboxIPs(pod.Namespace, pod.Name, resp.GetStatus())</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">"Determined the ip for pod after sandbox changed"</span>, <span class="string">"IPs"</span>, podIPs, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the start containers routines depend on pod ip(as in primary pod ip)</span></span><br><span class="line">	<span class="comment">// instead of trying to figure out if we have 0 &lt; len(podIPs)</span></span><br><span class="line">	<span class="comment">// everytime, we short circuit it here</span></span><br><span class="line">	podIP := <span class="string">""</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(podIPs) != <span class="number">0</span> &#123;</span><br><span class="line">		podIP = podIPs[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get podSandboxConfig for containers to start.</span></span><br><span class="line">	configPodSandboxResult := kubecontainer.NewSyncResult(kubecontainer.ConfigPodSandbox, podSandboxID)</span><br><span class="line">	result.AddSyncResult(configPodSandboxResult)</span><br><span class="line">	podSandboxConfig, err := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		message := fmt.Sprintf(<span class="string">"GeneratePodSandboxConfig for pod %q failed: %v"</span>, format.Pod(pod), err)</span><br><span class="line">		klog.ErrorS(err, <span class="string">"GeneratePodSandboxConfig for pod failed"</span>, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">		configPodSandboxResult.Fail(kubecontainer.ErrConfigPodSandbox, message)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Helper containing boilerplate common to starting all types of containers.</span></span><br><span class="line">	<span class="comment">// typeName is a description used to describe this type of container in log messages,</span></span><br><span class="line">	<span class="comment">// currently: "container", "init container" or "ephemeral container"</span></span><br><span class="line">	<span class="comment">// metricLabel is the label used to describe this type of container in monitoring metrics.</span></span><br><span class="line">	<span class="comment">// currently: "container", "init_container" or "ephemeral_container"</span></span><br><span class="line">	start := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, typeName, metricLabel <span class="keyword">string</span>, spec *startSpec)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		startContainerResult := kubecontainer.NewSyncResult(kubecontainer.StartContainer, spec.container.Name)</span><br><span class="line">		result.AddSyncResult(startContainerResult)</span><br><span class="line"></span><br><span class="line">		isInBackOff, msg, err := m.doBackOff(pod, spec.container, podStatus, backOff)</span><br><span class="line">		<span class="keyword">if</span> isInBackOff &#123;</span><br><span class="line">			startContainerResult.Fail(err, msg)</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">"Backing Off restarting container in pod"</span>, <span class="string">"containerType"</span>, typeName, <span class="string">"container"</span>, spec.container, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		metrics.StartedContainersTotal.WithLabelValues(metricLabel).Inc()</span><br><span class="line">		<span class="keyword">if</span> sc.HasWindowsHostProcessRequest(pod, spec.container) &#123;</span><br><span class="line">			metrics.StartedHostProcessContainersTotal.WithLabelValues(metricLabel).Inc()</span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">"Creating container in pod"</span>, <span class="string">"containerType"</span>, typeName, <span class="string">"container"</span>, spec.container, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">		<span class="comment">// NOTE (aramase) podIPs are populated for single stack and dual stack clusters. Send only podIPs.</span></span><br><span class="line">		<span class="keyword">if</span> msg, err := m.startContainer(ctx, podSandboxID, podSandboxConfig, spec, pod, podStatus, pullSecrets, podIP, podIPs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// startContainer() returns well-defined error codes that have reasonable cardinality for metrics and are</span></span><br><span class="line">			<span class="comment">// useful to cluster administrators to distinguish "server errors" from "user errors".</span></span><br><span class="line">			metrics.StartedContainersErrorsTotal.WithLabelValues(metricLabel, err.Error()).Inc()</span><br><span class="line">			<span class="keyword">if</span> sc.HasWindowsHostProcessRequest(pod, spec.container) &#123;</span><br><span class="line">				metrics.StartedHostProcessContainersErrorsTotal.WithLabelValues(metricLabel, err.Error()).Inc()</span><br><span class="line">			&#125;</span><br><span class="line">			startContainerResult.Fail(err, msg)</span><br><span class="line">			<span class="comment">// known errors that are logged in other places are logged at higher levels here to avoid</span></span><br><span class="line">			<span class="comment">// repetitive log spam</span></span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> err == images.ErrImagePullBackOff:</span><br><span class="line">				klog.V(<span class="number">3</span>).InfoS(<span class="string">"Container start failed in pod"</span>, <span class="string">"containerType"</span>, typeName, <span class="string">"container"</span>, spec.container, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"containerMessage"</span>, msg, <span class="string">"err"</span>, err)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">"%v %+v start failed in pod %v: %v: %s"</span>, typeName, spec.container, format.Pod(pod), err, msg))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5: start ephemeral containers</span></span><br><span class="line">	<span class="comment">// These are started "prior" to init containers to allow running ephemeral containers even when there</span></span><br><span class="line">	<span class="comment">// are errors starting an init container. In practice init containers will start first since ephemeral</span></span><br><span class="line">	<span class="comment">// containers cannot be specified on pod creation.</span></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.EphemeralContainersToStart &#123;</span><br><span class="line">		start(ctx, <span class="string">"ephemeral container"</span>, metrics.EphemeralContainer, ephemeralContainerStartSpec(&amp;pod.Spec.EphemeralContainers[idx]))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 6: start the init container.</span></span><br><span class="line">	<span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Start the next init container.</span></span><br><span class="line">		<span class="keyword">if</span> err := start(ctx, <span class="string">"init container"</span>, metrics.InitContainer, containerStartSpec(container)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Successfully started the container; clear the entry in the failure</span></span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">"Completed init container for pod"</span>, <span class="string">"containerName"</span>, container.Name, <span class="string">"pod"</span>, klog.KObj(pod))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 7: For containers in podContainerChanges.ContainersToUpdate[CPU,Memory] list, invoke UpdateContainerResources</span></span><br><span class="line">	<span class="keyword">if</span> isInPlacePodVerticalScalingAllowed(pod) &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(podContainerChanges.ContainersToUpdate) &gt; <span class="number">0</span> || podContainerChanges.UpdatePodResources &#123;</span><br><span class="line">			m.doPodResizeAction(pod, podStatus, podContainerChanges, result)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 8: start containers in podContainerChanges.ContainersToStart.</span></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">		start(ctx, <span class="string">"container"</span>, metrics.Container, containerStartSpec(&amp;pod.Spec.Containers[idx]))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deployment conroller　入口</span><br><span class="line">pkg/controller/deployment/deployment_controller.go:157</span><br><span class="line">func (dc *DeploymentController) Run(ctx context.Context, workers int)</span><br><span class="line"></span><br><span class="line">replicaset controller</span><br><span class="line">pkg/controller/replicaset/replica_set.go:190</span><br><span class="line">func (rsc *ReplicaSetController) Run(ctx context.Context, workers int)</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>一个pod的正常终止流程</title>
    <url>/2023/04/18/%E4%B8%80%E4%B8%AApod%E7%9A%84%E6%AD%A3%E5%B8%B8%E7%BB%88%E6%AD%A2%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>当你使用命令<code>kubectl delete pod pod_name</code>来删除一个<code>pod</code>,你有了解过整个流程是怎么样的吗?<code>pod</code>是如何被删除的，<code>kubelet</code>做了什么，<code>容器运行时</code>又做了什么?今天就来分析一下一个<code>pod</code>正常的终止流程。</p>
<h5 id="新建一个pod"><a href="#新建一个pod" class="headerlink" title="新建一个pod"></a>新建一个pod</h5><p>你可以执行命令<code>kubectl apply -f mycurl.yaml</code>创建一个<code>pod</code><br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-curl</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-curl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-curl</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">hysyeah/my-curl:v1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>pod</code>已经运行起来<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ k get pod</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">my-curl               1/1     Running   0          3s</span><br></pre></td></tr></table></figure></p>
<h5 id="删除pod"><a href="#删除pod" class="headerlink" title="删除pod"></a>删除pod</h5><p>执行命令<code>kubectl delete pod my-curl --v=6</code>,从日志中可以看到<code>kubectl</code>发送了一个<code>DELETE</code>请求给<code>apiserver</code>,请求路径为<code>api/v1/namespaces/default/pods/my-curl</code>。然后输出日志表示<code>pod</code>已经被删除,<br>看似只发送了一个请求就把<code>pod</code>删除了，但删除一个其实是需要多个组件的协作的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I0418 round_trippers.go:553] DELETE https://192.168.2.123:6443/api/v1/namespaces/default/pods/my-curl 200 OK in 12 milliseconds</span><br><span class="line">pod &quot;my-curl&quot; deleted</span><br></pre></td></tr></table></figure></p>
<h6 id="apiserver删除pod"><a href="#apiserver删除pod" class="headerlink" title="apiserver删除pod"></a>apiserver删除pod</h6><p><code>kubectl</code>发送<code>DELETE</code>请求给<code>apiserver</code>,<code>apiserver</code>调用<code>etcd</code>接口删除对应的记录。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go</span></span><br><span class="line"><span class="comment">// 对etcd接口的一层封装，比如会执行删除前的一些策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Store)</span> <span class="title">Delete</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>, deleteValidation rest.ValidateObjectFunc, options *metav1.DeleteOptions)</span> <span class="params">(runtime.Object, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	key, err := e.KeyFunc(ctx, name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	obj := e.NewFunc()</span><br><span class="line">	qualifiedResource := e.qualifiedResourceFromContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> err = e.Storage.Get(ctx, key, storage.GetOptions&#123;&#125;, obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, storeerr.InterpretDeleteError(err, qualifiedResource, name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// support older consumers of delete by treating "nil" as delete immediately</span></span><br><span class="line">	<span class="keyword">if</span> options == <span class="literal">nil</span> &#123;</span><br><span class="line">		options = metav1.NewDeleteOptions(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> preconditions storage.Preconditions</span><br><span class="line">	<span class="keyword">if</span> options.Preconditions != <span class="literal">nil</span> &#123;</span><br><span class="line">		preconditions.UID = options.Preconditions.UID</span><br><span class="line">		preconditions.ResourceVersion = options.Preconditions.ResourceVersion</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// BeforeDelete函数用于测试对象是否可以进行优雅删除。</span></span><br><span class="line">	<span class="comment">// 如果设置了graceful参数，表示对象应该进行优雅删除。如果设置了gracefulPending参数，表示对象已经被优雅删除。</span></span><br><span class="line">	<span class="comment">// BeforeDelete会设置对象的DeletionTimestamp</span></span><br><span class="line">	graceful, pendingGraceful, err := rest.BeforeDelete(e.DeleteStrategy, ctx, obj, options)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// this means finalizers cannot be updated via DeleteOptions if a deletion is already pending</span></span><br><span class="line">	<span class="keyword">if</span> pendingGraceful &#123;</span><br><span class="line">		out, err := e.finalizeDelete(ctx, obj, <span class="literal">false</span>, options)</span><br><span class="line">		<span class="keyword">return</span> out, <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// check if obj has pending finalizers</span></span><br><span class="line">	accessor, err := meta.Accessor(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, apierrors.NewInternalError(err)</span><br><span class="line">	&#125;</span><br><span class="line">	pendingFinalizers := <span class="built_in">len</span>(accessor.GetFinalizers()) != <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> ignoreNotFound <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> deleteImmediately <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">var</span> lastExisting, out runtime.Object</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle combinations of graceful deletion and finalization by issuing</span></span><br><span class="line">	<span class="comment">// the correct updates.</span></span><br><span class="line">	shouldUpdateFinalizers, _ := deletionFinalizersForGarbageCollection(ctx, e, accessor, options)</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> remove the check, because we support no-op updates now.</span></span><br><span class="line">	<span class="keyword">if</span> graceful || pendingFinalizers || shouldUpdateFinalizers &#123;</span><br><span class="line">		err, ignoreNotFound, deleteImmediately, out, lastExisting = e.updateForGracefulDeletionAndFinalizers(ctx, name, key, options, preconditions, deleteValidation, obj)</span><br><span class="line">		<span class="comment">// Update the preconditions.ResourceVersion if set since we updated the object.</span></span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; deleteImmediately &amp;&amp; preconditions.ResourceVersion != <span class="literal">nil</span> &#123;</span><br><span class="line">			accessor, err = meta.Accessor(out)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> out, <span class="literal">false</span>, apierrors.NewInternalError(err)</span><br><span class="line">			&#125;</span><br><span class="line">			resourceVersion := accessor.GetResourceVersion()</span><br><span class="line">			preconditions.ResourceVersion = &amp;resourceVersion</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// !deleteImmediately covers all cases where err != nil. We keep both to be future-proof.</span></span><br><span class="line">	<span class="keyword">if</span> !deleteImmediately || err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> out, <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Going further in this function is not useful when we are</span></span><br><span class="line">	<span class="comment">// performing a dry-run request. Worse, it will actually</span></span><br><span class="line">	<span class="comment">// override "out" with the version of the object in database</span></span><br><span class="line">	<span class="comment">// that doesn't have the finalizer and deletiontimestamp set</span></span><br><span class="line">	<span class="comment">// (because the update above was dry-run too). If we already</span></span><br><span class="line">	<span class="comment">// have that version available, let's just return it now,</span></span><br><span class="line">	<span class="comment">// otherwise, we can call dry-run delete that will get us the</span></span><br><span class="line">	<span class="comment">// latest version of the object.</span></span><br><span class="line">	<span class="keyword">if</span> dryrun.IsDryRun(options.DryRun) &amp;&amp; out != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> out, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// delete immediately, or no graceful deletion supported</span></span><br><span class="line">	klog.V(<span class="number">6</span>).InfoS(<span class="string">"Going to delete object from registry"</span>, <span class="string">"object"</span>, klog.KRef(genericapirequest.NamespaceValue(ctx), name))</span><br><span class="line">	out = e.NewFunc()</span><br><span class="line">	<span class="comment">// 只有能立即删除的情况下才会直接删除etcd中的数据</span></span><br><span class="line">	<span class="keyword">if</span> err := e.Storage.Delete(ctx, key, out, &amp;preconditions, storage.ValidateObjectFunc(deleteValidation), dryrun.IsDryRun(options.DryRun), <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Please refer to the place where we set ignoreNotFound for the reason</span></span><br><span class="line">		<span class="comment">// why we ignore the NotFound error .</span></span><br><span class="line">		<span class="keyword">if</span> storage.IsNotFound(err) &amp;&amp; ignoreNotFound &amp;&amp; lastExisting != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// The lastExisting object may not be the last state of the object</span></span><br><span class="line">			<span class="comment">// before its deletion, but it's the best approximation.</span></span><br><span class="line">			out, err := e.finalizeDelete(ctx, lastExisting, <span class="literal">true</span>, options)</span><br><span class="line">			<span class="keyword">return</span> out, <span class="literal">true</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, storeerr.InterpretDeleteError(err, qualifiedResource, name)</span><br><span class="line">	&#125;</span><br><span class="line">	out, err = e.finalizeDelete(ctx, out, <span class="literal">true</span>, options)</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">true</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// staging/src/k8s.io/apiserver/pkg/registry/rest/delete.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BeforeDelete</span><span class="params">(strategy RESTDeleteStrategy, ctx context.Context, obj runtime.Object, options *metav1.DeleteOptions)</span> <span class="params">(graceful, gracefulPending <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	objectMeta, gvk, kerr := objectMetaAndKind(strategy, obj)</span><br><span class="line">	<span class="keyword">if</span> kerr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span>, kerr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> errs := validation.ValidateDeleteOptions(options); <span class="built_in">len</span>(errs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span>, errors.NewInvalid(schema.GroupKind&#123;Group: metav1.GroupName, Kind: <span class="string">"DeleteOptions"</span>&#125;, <span class="string">""</span>, errs)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Checking the Preconditions here to fail early. They'll be enforced later on when we actually do the deletion, too.</span></span><br><span class="line">	<span class="keyword">if</span> options.Preconditions != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> options.Preconditions.UID != <span class="literal">nil</span> &amp;&amp; *options.Preconditions.UID != objectMeta.GetUID() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span>, errors.NewConflict(schema.GroupResource&#123;Group: gvk.Group, Resource: gvk.Kind&#125;, objectMeta.GetName(), fmt.Errorf(<span class="string">"the UID in the precondition (%s) does not match the UID in record (%s). The object might have been deleted and then recreated"</span>, *options.Preconditions.UID, objectMeta.GetUID()))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> options.Preconditions.ResourceVersion != <span class="literal">nil</span> &amp;&amp; *options.Preconditions.ResourceVersion != objectMeta.GetResourceVersion() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span>, errors.NewConflict(schema.GroupResource&#123;Group: gvk.Group, Resource: gvk.Kind&#125;, objectMeta.GetName(), fmt.Errorf(<span class="string">"the ResourceVersion in the precondition (%s) does not match the ResourceVersion in record (%s). The object might have been modified"</span>, *options.Preconditions.ResourceVersion, objectMeta.GetResourceVersion()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Negative values will be treated as the value `1s` on the delete path.</span></span><br><span class="line">	<span class="keyword">if</span> gracePeriodSeconds := options.GracePeriodSeconds; gracePeriodSeconds != <span class="literal">nil</span> &amp;&amp; *gracePeriodSeconds &lt; <span class="number">0</span> &#123;</span><br><span class="line">		options.GracePeriodSeconds = utilpointer.Int64(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> deletionGracePeriodSeconds := objectMeta.GetDeletionGracePeriodSeconds(); deletionGracePeriodSeconds != <span class="literal">nil</span> &amp;&amp; *deletionGracePeriodSeconds &lt; <span class="number">0</span> &#123;</span><br><span class="line">		objectMeta.SetDeletionGracePeriodSeconds(utilpointer.Int64(<span class="number">1</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gracefulStrategy, ok := strategy.(RESTGracefulDeleteStrategy)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="comment">// If we're not deleting gracefully there's no point in updating Generation, as we won't update</span></span><br><span class="line">		<span class="comment">// the obcject before deleting it.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if the object is already being deleted, no need to update generation.</span></span><br><span class="line">	<span class="keyword">if</span> objectMeta.GetDeletionTimestamp() != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// if we are already being deleted, we may only shorten the deletion grace period</span></span><br><span class="line">		<span class="comment">// this means the object was gracefully deleted previously but deletionGracePeriodSeconds was not set,</span></span><br><span class="line">		<span class="comment">// so we force deletion immediately</span></span><br><span class="line">		<span class="comment">// IMPORTANT:</span></span><br><span class="line">		<span class="comment">// The deletion operation happens in two phases.</span></span><br><span class="line">		<span class="comment">// 1. Update to set DeletionGracePeriodSeconds and DeletionTimestamp</span></span><br><span class="line">		<span class="comment">// 2. Delete the object from storage.</span></span><br><span class="line">		<span class="comment">// If the update succeeds, but the delete fails (network error, internal storage error, etc.),</span></span><br><span class="line">		<span class="comment">// a resource was previously left in a state that was non-recoverable.  We</span></span><br><span class="line">		<span class="comment">// check if the existing stored resource has a grace period as 0 and if so</span></span><br><span class="line">		<span class="comment">// attempt to delete immediately in order to recover from this scenario.</span></span><br><span class="line">		<span class="keyword">if</span> objectMeta.GetDeletionGracePeriodSeconds() == <span class="literal">nil</span> || *objectMeta.GetDeletionGracePeriodSeconds() == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// only a shorter grace period may be provided by a user</span></span><br><span class="line">		<span class="keyword">if</span> options.GracePeriodSeconds != <span class="literal">nil</span> &#123;</span><br><span class="line">			period := <span class="keyword">int64</span>(*options.GracePeriodSeconds)</span><br><span class="line">			<span class="keyword">if</span> period &gt;= *objectMeta.GetDeletionGracePeriodSeconds() &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			newDeletionTimestamp := metav1.NewTime(</span><br><span class="line">				objectMeta.GetDeletionTimestamp().Add(-time.Second * time.Duration(*objectMeta.GetDeletionGracePeriodSeconds())).</span><br><span class="line">					Add(time.Second * time.Duration(*options.GracePeriodSeconds)))</span><br><span class="line">			objectMeta.SetDeletionTimestamp(&amp;newDeletionTimestamp)</span><br><span class="line">			objectMeta.SetDeletionGracePeriodSeconds(&amp;period)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// graceful deletion is pending, do nothing</span></span><br><span class="line">		options.GracePeriodSeconds = objectMeta.GetDeletionGracePeriodSeconds()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// `CheckGracefulDelete` will be implemented by specific strategy</span></span><br><span class="line">	<span class="keyword">if</span> !gracefulStrategy.CheckGracefulDelete(ctx, obj, options) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> options.GracePeriodSeconds == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span>, errors.NewInternalError(fmt.Errorf(<span class="string">"options.GracePeriodSeconds should not be nil"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	now := metav1.NewTime(metav1.Now().Add(time.Second * time.Duration(*options.GracePeriodSeconds)))</span><br><span class="line">	objectMeta.SetDeletionTimestamp(&amp;now)</span><br><span class="line">	objectMeta.SetDeletionGracePeriodSeconds(options.GracePeriodSeconds)</span><br><span class="line">	<span class="comment">// If it's the first graceful deletion we are going to set the DeletionTimestamp to non-nil.</span></span><br><span class="line">	<span class="comment">// Controllers of the object that's being deleted shouldn't take any nontrivial actions, hence its behavior changes.</span></span><br><span class="line">	<span class="comment">// Thus we need to bump object's Generation (if set). This handles generation bump during graceful deletion.</span></span><br><span class="line">	<span class="comment">// The bump for objects that don't support graceful deletion is handled in pkg/registry/generic/registry/store.go.</span></span><br><span class="line">	<span class="keyword">if</span> objectMeta.GetGeneration() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		objectMeta.SetGeneration(objectMeta.GetGeneration() + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="kubelet开始工作"><a href="#kubelet开始工作" class="headerlink" title="kubelet开始工作"></a>kubelet开始工作</h6><p>当<code>apiserver</code>删除<code>pod</code>后，因为<code>kubelet</code>对<code>pod</code>资源进行了监听，所以当<code>pod</code>被删除后，<code>kubelet</code>可以获得<code>pod</code>删除的事件。<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会进入kubetypes.DELETE分支</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">syncLoopIteration</span><span class="params">(ctx context.Context, configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line">		<span class="comment">// Update from a config source; dispatch it to the right handler</span></span><br><span class="line">		<span class="comment">// callback.</span></span><br><span class="line">		<span class="keyword">if</span> !open &#123;</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">"Update channel is closed, exiting the sync loop"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> u.Op &#123;</span><br><span class="line">		<span class="keyword">case</span> kubetypes.ADD:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">"SyncLoop ADD"</span>, <span class="string">"source"</span>, u.Source, <span class="string">"pods"</span>, klog.KObjSlice(u.Pods))</span><br><span class="line">			<span class="comment">// After restarting, kubelet will get all existing pods through</span></span><br><span class="line">			<span class="comment">// ADD as if they are new pods. These pods will then go through the</span></span><br><span class="line">			<span class="comment">// admission process and *may* be rejected. This can be resolved</span></span><br><span class="line">			<span class="comment">// once we have checkpointing.</span></span><br><span class="line">			handler.HandlePodAdditions(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.UPDATE:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">"SyncLoop UPDATE"</span>, <span class="string">"source"</span>, u.Source, <span class="string">"pods"</span>, klog.KObjSlice(u.Pods))</span><br><span class="line">			handler.HandlePodUpdates(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.REMOVE:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">"SyncLoop REMOVE"</span>, <span class="string">"source"</span>, u.Source, <span class="string">"pods"</span>, klog.KObjSlice(u.Pods))</span><br><span class="line">			handler.HandlePodRemoves(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.RECONCILE:</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">"SyncLoop RECONCILE"</span>, <span class="string">"source"</span>, u.Source, <span class="string">"pods"</span>, klog.KObjSlice(u.Pods))</span><br><span class="line">			handler.HandlePodReconcile(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.DELETE:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">"SyncLoop DELETE"</span>, <span class="string">"source"</span>, u.Source, <span class="string">"pods"</span>, klog.KObjSlice(u.Pods))</span><br><span class="line">			<span class="comment">// DELETE is treated as a UPDATE because of graceful deletion.</span></span><br><span class="line">			handler.HandlePodUpdates(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.SET:</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> Do we want to support this?</span></span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">"Kubelet does not support snapshot update"</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">"Invalid operation type received"</span>, <span class="string">"operation"</span>, u.Op)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后会进入到容器删除流程(这里是进入了另一个goroutine里)，函数调用流程如下<br><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// killPod instructs the container runtime to kill the pod. This method requires that</span></span><br><span class="line"><span class="comment">// the pod status contains the result of the last syncPod, otherwise it may fail to</span></span><br><span class="line"><span class="comment">// terminate newly created containers and sandboxes.</span></span><br><span class="line"><span class="comment">// 调用容器运行删除对应的容器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span> <span class="title">killPod</span><span class="params">(ctx context.Context, pod *v1.Pod, p kubecontainer.Pod, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Call the container runtime KillPod method which stops all known running containers of the pod</span></span><br><span class="line">	<span class="keyword">if</span> err := kl.containerRuntime.KillPod(ctx, pod, p, gracePeriodOverride); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := kl.containerManager.UpdateQOSCgroups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).InfoS(<span class="string">"Failed to update QoS cgroups while killing pod"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除pod内的所有容器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">KillPod</span><span class="params">(ctx context.Context, pod *v1.Pod, runningPod kubecontainer.Pod, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := m.killPodWithSyncResult(ctx, pod, runningPod, gracePeriodOverride)</span><br><span class="line">	<span class="keyword">return</span> err.Error()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个Runing状态的pod</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">killPodWithSyncResult</span><span class="params">(ctx context.Context, pod *v1.Pod, runningPod kubecontainer.Pod, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="params">(result kubecontainer.PodSyncResult)</span></span> &#123;</span><br><span class="line">	killContainerResults := m.killContainersWithSyncResult(ctx, pod, runningPod, gracePeriodOverride)</span><br><span class="line">	<span class="keyword">for</span> _, containerResult := <span class="keyword">range</span> killContainerResults &#123;</span><br><span class="line">		result.AddSyncResult(containerResult)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// stop sandbox, the sandbox will be removed in GarbageCollect</span></span><br><span class="line">	killSandboxResult := kubecontainer.NewSyncResult(kubecontainer.KillPodSandbox, runningPod.ID)</span><br><span class="line">	result.AddSyncResult(killSandboxResult)</span><br><span class="line">	<span class="comment">// Stop all sandboxes belongs to same pod</span></span><br><span class="line">	<span class="keyword">for</span> _, podSandbox := <span class="keyword">range</span> runningPod.Sandboxes &#123;</span><br><span class="line">		<span class="keyword">if</span> err := m.runtimeService.StopPodSandbox(ctx, podSandbox.ID.ID); err != <span class="literal">nil</span> &amp;&amp; !crierror.IsNotFound(err) &#123;</span><br><span class="line">			killSandboxResult.Fail(kubecontainer.ErrKillPodSandbox, err.Error())</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">"Failed to stop sandbox"</span>, <span class="string">"podSandboxID"</span>, podSandbox.ID)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// killContainersWithSyncResult kills all pod's containers with sync results.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">killContainersWithSyncResult</span><span class="params">(ctx context.Context, pod *v1.Pod, runningPod kubecontainer.Pod, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="params">(syncResults []*kubecontainer.SyncResult)</span></span> &#123;</span><br><span class="line">	containerResults := <span class="built_in">make</span>(<span class="keyword">chan</span> *kubecontainer.SyncResult, <span class="built_in">len</span>(runningPod.Containers))</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="built_in">len</span>(runningPod.Containers))</span><br><span class="line">	<span class="keyword">for</span> _, container := <span class="keyword">range</span> runningPod.Containers &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(container *kubecontainer.Container)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">			killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, container.Name)</span><br><span class="line">			<span class="keyword">if</span> err := m.killContainer(ctx, pod, container.ID, container.Name, <span class="string">""</span>, reasonUnknown, gracePeriodOverride); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				killContainerResult.Fail(kubecontainer.ErrKillContainer, err.Error())</span><br><span class="line">				<span class="comment">// Use runningPod for logging as the pod passed in could be *nil*.</span></span><br><span class="line">				klog.ErrorS(err, <span class="string">"Kill container failed"</span>, <span class="string">"pod"</span>, klog.KRef(runningPod.Namespace, runningPod.Name), <span class="string">"podUID"</span>, runningPod.ID,</span><br><span class="line">					<span class="string">"containerName"</span>, container.Name, <span class="string">"containerID"</span>, container.ID)</span><br><span class="line">			&#125;</span><br><span class="line">			containerResults &lt;- killContainerResult</span><br><span class="line">		&#125;(container)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(containerResults)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> containerResult := <span class="keyword">range</span> containerResults &#123;</span><br><span class="line">		syncResults = <span class="built_in">append</span>(syncResults, containerResult)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kill一个容器</span></span><br><span class="line"><span class="comment">// 如果设置了pre-stop则执行对应的hooks</span></span><br><span class="line"><span class="comment">// 调用cri停止容器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">killContainer</span><span class="params">(ctx context.Context, pod *v1.Pod, containerID kubecontainer.ContainerID, containerName <span class="keyword">string</span>, message <span class="keyword">string</span>, reason containerKillReason, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> containerSpec *v1.Container</span><br><span class="line">	<span class="keyword">if</span> pod != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> containerSpec = kubecontainer.GetContainerSpec(pod, containerName); containerSpec == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get containerSpec %q (id=%q) in pod %q when killing container for reason %q"</span>,</span><br><span class="line">				containerName, containerID.String(), format.Pod(pod), message)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Restore necessary information if one of the specs is nil.</span></span><br><span class="line">		restoredPod, restoredContainer, err := m.restoreSpecsFromContainerLabels(ctx, containerID)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		pod, containerSpec = restoredPod, restoredContainer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// From this point, pod and container must be non-nil.</span></span><br><span class="line">    <span class="comment">// gracePeriod默认为30s</span></span><br><span class="line">	gracePeriod := setTerminationGracePeriod(pod, containerSpec, containerName, containerID, reason)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(message) == <span class="number">0</span> &#123;</span><br><span class="line">		message = fmt.Sprintf(<span class="string">"Stopping container %s"</span>, containerSpec.Name)</span><br><span class="line">	&#125;</span><br><span class="line">	m.recordContainerEvent(pod, containerSpec, containerID.ID, v1.EventTypeNormal, events.KillingContainer, message)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run the pre-stop lifecycle hooks if applicable and if there is enough time to run it</span></span><br><span class="line">    <span class="comment">// 执行pre-stop hooks并更新gracePeriod,gracePeriod会作为超时参数传递给cri</span></span><br><span class="line">	<span class="keyword">if</span> containerSpec.Lifecycle != <span class="literal">nil</span> &amp;&amp; containerSpec.Lifecycle.PreStop != <span class="literal">nil</span> &amp;&amp; gracePeriod &gt; <span class="number">0</span> &#123;</span><br><span class="line">		gracePeriod = gracePeriod - m.executePreStopHook(ctx, pod, containerID, containerSpec, gracePeriod)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// always give containers a minimal shutdown window to avoid unnecessary SIGKILLs</span></span><br><span class="line">	<span class="keyword">if</span> gracePeriod &lt; minimumGracePeriodInSeconds &#123;</span><br><span class="line">		gracePeriod = minimumGracePeriodInSeconds</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gracePeriodOverride != <span class="literal">nil</span> &#123;</span><br><span class="line">		gracePeriod = *gracePeriodOverride</span><br><span class="line">		klog.V(<span class="number">3</span>).InfoS(<span class="string">"Killing container with a grace period override"</span>, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"podUID"</span>, pod.UID,</span><br><span class="line">			<span class="string">"containerName"</span>, containerName, <span class="string">"containerID"</span>, containerID.String(), <span class="string">"gracePeriod"</span>, gracePeriod)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">2</span>).InfoS(<span class="string">"Killing container with a grace period"</span>, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"podUID"</span>, pod.UID,</span><br><span class="line">		<span class="string">"containerName"</span>, containerName, <span class="string">"containerID"</span>, containerID.String(), <span class="string">"gracePeriod"</span>, gracePeriod)</span><br><span class="line">    <span class="comment">// 真正进行cri调用的地方,如果要看StopContainer具体做了什么需要查看对应cri的代码</span></span><br><span class="line">    <span class="comment">// 因为使用的是containerd,因此可以在containerd项目中查看对应的源码</span></span><br><span class="line">    <span class="comment">// 如果没有设置pre-stop hooks，gracePeriod默认为30s(这其实也就是stopContainer的超时时间)</span></span><br><span class="line">    <span class="comment">// 如果你的应用没有设置处理SIGTERM信号的话，一般来说进程会马上退出(也就是容器会被删除)</span></span><br><span class="line">	err := m.runtimeService.StopContainer(ctx, containerID.ID, gracePeriod)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !crierror.IsNotFound(err) &#123;</span><br><span class="line">		klog.ErrorS(err, <span class="string">"Container termination failed with gracePeriod"</span>, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"podUID"</span>, pod.UID,</span><br><span class="line">			<span class="string">"containerName"</span>, containerName, <span class="string">"containerID"</span>, containerID.String(), <span class="string">"gracePeriod"</span>, gracePeriod)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	klog.V(<span class="number">3</span>).InfoS(<span class="string">"Container exited normally"</span>, <span class="string">"pod"</span>, klog.KObj(pod), <span class="string">"podUID"</span>, pod.UID,</span><br><span class="line">		<span class="string">"containerName"</span>, containerName, <span class="string">"containerID"</span>, containerID.String())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>Containerd</code>接口</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pkg/cri/sbserver/container_stop.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *criService)</span> <span class="title">StopContainer</span><span class="params">(ctx context.Context, r *runtime.StopContainerRequest)</span> <span class="params">(*runtime.StopContainerResponse, error)</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="comment">// Get container config from container store.</span></span><br><span class="line">	container, err := c.containerStore.Get(r.GetContainerId())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"an error occurred when try to find container %q: %w"</span>, r.GetContainerId(), err)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 停止一个容器，可以直接看这个函数</span></span><br><span class="line">	<span class="keyword">if</span> err := c.stopContainer(ctx, container, time.Duration(r.GetTimeout())*time.Second); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sandbox, err := c.sandboxStore.Get(container.SandboxID)</span><br><span class="line">    <span class="comment">// 删除对应的sandbox</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = c.nri.StopContainer(ctx, <span class="literal">nil</span>, &amp;container)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = c.nri.StopContainer(ctx, &amp;sandbox, &amp;container)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.G(ctx).WithError(err).Error(<span class="string">"NRI failed to stop container"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i, err := container.Container.Info(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"get container info: %w"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	containerStopTimer.WithValues(i.Runtime.Name).UpdateSince(start)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;runtime.StopContainerResponse&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *criService)</span> <span class="title">stopContainer</span><span class="params">(ctx context.Context, container containerstore.Container, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	id := container.ID</span><br><span class="line">	sandboxID := container.SandboxID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	state := container.Status.Get().State()</span><br><span class="line">	<span class="keyword">if</span> state != runtime.ContainerState_CONTAINER_RUNNING &amp;&amp;</span><br><span class="line">		state != runtime.ContainerState_CONTAINER_UNKNOWN &#123;</span><br><span class="line">		log.G(ctx).Infof(<span class="string">"Container to stop %q must be in running or unknown state, current state %q"</span>,</span><br><span class="line">			id, criContainerStateToString(state))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	task, err := container.Container.Task(ctx, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !errdefs.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get task for container %q: %w"</span>, id, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Don't return for unknown state, some cleanup needs to be done.</span></span><br><span class="line">		<span class="keyword">if</span> state == runtime.ContainerState_CONTAINER_UNKNOWN &#123;</span><br><span class="line">			<span class="keyword">return</span> cleanupUnknownContainer(ctx, id, container, sandboxID, c)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle unknown state.</span></span><br><span class="line">	<span class="keyword">if</span> state == runtime.ContainerState_CONTAINER_UNKNOWN &#123;</span><br><span class="line">		<span class="comment">// Start an exit handler for containers in unknown state.</span></span><br><span class="line">		waitCtx, waitCancel := context.WithCancel(ctrdutil.NamespacedContext())</span><br><span class="line">		<span class="keyword">defer</span> waitCancel()</span><br><span class="line">		exitCh, err := task.Wait(waitCtx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> !errdefs.IsNotFound(err) &#123;</span><br><span class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to wait for task for %q: %w"</span>, id, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> cleanupUnknownContainer(ctx, id, container, sandboxID, c)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		exitCtx, exitCancel := context.WithCancel(context.Background())</span><br><span class="line">		stopCh := c.eventMonitor.startContainerExitMonitor(exitCtx, id, task.Pid(), exitCh)</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			exitCancel()</span><br><span class="line">			<span class="comment">// This ensures that exit monitor is stopped before</span></span><br><span class="line">			<span class="comment">// `Wait` is cancelled, so no exit event is generated</span></span><br><span class="line">			<span class="comment">// because of the `Wait` cancellation.</span></span><br><span class="line">			&lt;-stopCh</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We only need to kill the task. The event handler will Delete the</span></span><br><span class="line">	<span class="comment">// task from containerd after it handles the Exited event.</span></span><br><span class="line">	<span class="keyword">if</span> timeout &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果timeout &gt; 0 相当于是执行SIGTERM命令</span></span><br><span class="line">		stopSignal := <span class="string">"SIGTERM"</span></span><br><span class="line">		<span class="keyword">if</span> container.StopSignal != <span class="string">""</span> &#123;</span><br><span class="line">			stopSignal = container.StopSignal</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// The image may have been deleted, and the `StopSignal` field is</span></span><br><span class="line">			<span class="comment">// just introduced to handle that.</span></span><br><span class="line">			<span class="comment">// However, for containers created before the `StopSignal` field is</span></span><br><span class="line">			<span class="comment">// introduced, still try to get the stop signal from the image config.</span></span><br><span class="line">			<span class="comment">// If the image has been deleted, logging an error and using the</span></span><br><span class="line">			<span class="comment">// default SIGTERM is still better than returning error and leaving</span></span><br><span class="line">			<span class="comment">// the container unstoppable. (See issue #990)</span></span><br><span class="line">			<span class="comment">// TODO(random-liu): Remove this logic when containerd 1.2 is deprecated.</span></span><br><span class="line">			image, err := c.GetImage(container.ImageRef)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> !errdefs.IsNotFound(err) &#123;</span><br><span class="line">					<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to get image %q: %w"</span>, container.ImageRef, err)</span><br><span class="line">				&#125;</span><br><span class="line">				log.G(ctx).Warningf(<span class="string">"Image %q not found, stop container with signal %q"</span>, container.ImageRef, stopSignal)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> image.ImageSpec.Config.StopSignal != <span class="string">""</span> &#123;</span><br><span class="line">					stopSignal = image.ImageSpec.Config.StopSignal</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sig, err := signal.ParseSignal(stopSignal)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to parse stop signal %q: %w"</span>, stopSignal, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> sswt <span class="keyword">bool</span></span><br><span class="line">		<span class="keyword">if</span> container.IsStopSignaledWithTimeout == <span class="literal">nil</span> &#123;</span><br><span class="line">			log.G(ctx).Infof(<span class="string">"unable to ensure stop signal %v was not sent twice to container %v"</span>, sig, id)</span><br><span class="line">			sswt = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sswt = atomic.CompareAndSwapUint32(container.IsStopSignaledWithTimeout, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> sswt &#123;</span><br><span class="line">			log.G(ctx).Infof(<span class="string">"Stop container %q with signal %v"</span>, id, sig)</span><br><span class="line">            <span class="comment">// 执行kill操作，这里其实就是发送一个信号给对应的进程</span></span><br><span class="line">			<span class="keyword">if</span> err = task.Kill(ctx, sig); err != <span class="literal">nil</span> &amp;&amp; !errdefs.IsNotFound(err) &#123;</span><br><span class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to stop container %q: %w"</span>, id, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			log.G(ctx).Infof(<span class="string">"Skipping the sending of signal %v to container %q because a prior stop with timeout&gt;0 request already sent the signal"</span>, sig, id)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sigTermCtx, sigTermCtxCancel := context.WithTimeout(ctx, timeout)</span><br><span class="line">		<span class="keyword">defer</span> sigTermCtxCancel()</span><br><span class="line">        <span class="comment">// 等待进程退出直到超时，如果超时了也会直接执行下面SIGKILL操作，直接kill进程</span></span><br><span class="line">		err = c.waitContainerStop(sigTermCtx, container)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Container stopped on first signal no need for SIGKILL</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If the parent context was cancelled or exceeded return immediately</span></span><br><span class="line">		<span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ctx.Err()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// sigTermCtx was exceeded. Send SIGKILL</span></span><br><span class="line">		log.G(ctx).Debugf(<span class="string">"Stop container %q with signal %v timed out"</span>, id, sig)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.G(ctx).Infof(<span class="string">"Kill container %q"</span>, id)</span><br><span class="line">    <span class="comment">// 如果timeout&lt;=0,则发送SIGKILL信号，强制退出</span></span><br><span class="line">	<span class="keyword">if</span> err = task.Kill(ctx, syscall.SIGKILL); err != <span class="literal">nil</span> &amp;&amp; !errdefs.IsNotFound(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to kill container %q: %w"</span>, id, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for a fixed timeout until container stop is observed by event monitor.</span></span><br><span class="line">	err = c.waitContainerStop(ctx, container)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"an error occurs during waiting for container %q to be killed: %w"</span>, id, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器终止后，<code>kubelet</code>会将<code>pod</code>的信息从缓存中删除，至此整个删除流程就走完了。</p>
<hr>
<p>小结:</p>
<ul>
<li><code>kubectl</code>发送请求给<code>apiserver</code></li>
<li><code>kubelet</code>执行<code>pre-stop hook</code>,调用<code>cri</code>删除容器</li>
<li><code>kubelet</code>将<code>pod</code>信息从缓存的删除</li>
</ul>
<p>从上面的内容中我们可以得到如何使<code>pod</code>如何进行优雅退出</p>
<ul>
<li>设置<code>pre-stop hook</code></li>
<li>在应用中处理<code>SIGTERM</code>信号</li>
</ul>
<p>以上两种方法都能实现优雅退出但都不能超过最大退出时间(默认30s)，否则进程将会被强制kill。</p>
<hr>
<p>REF:<br>1.<a href="https://github.com/containerd/containerd/blob/main/pkg/cri/sbserver/container_stop.go" target="_blank" rel="noopener">pkg/cri/sbserver/container_stop.go</a><br>2.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet.go" target="_blank" rel="noopener">pkg/kubelet/kubelet.go</a><br>3.<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet_pods.go" target="_blank" rel="noopener">pkg/kubelet/kubelet_pods.go</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>一行把tuple转换为list</title>
    <url>/2017/09/06/%E4%B8%80%E8%A1%8C%E6%8A%8Atuple%E8%BD%AC%E6%8D%A2%E4%B8%BAlist/</url>
    <content><![CDATA[<pre><code>In [16]: tup = ((1, 2, 3), (4, 5, 6))

In [17]: list(map(list,tup))
Out[17]: [[1, 2, 3], [4, 5, 6]]
</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>不排序找出前2个最大值</title>
    <url>/2018/09/11/%E4%B8%8D%E6%8E%92%E5%BA%8F%E6%89%BE%E5%87%BA%E5%89%8D2%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<pre><code>In [90]: lst = [1,2,3,6,3,4,5,4]
    ...:
    ...: max = -9999
    ...: secMax = -99999
    ...: for x in lst:
    ...:
    ...:     if x &gt; max:
    ...:         max = x
    ...:     if x &gt; secMax and x &lt; max:
    ...:         secMax = x
    ...:

In [91]: print(max)
6

In [92]: print(secMax)
5
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>为结构体的成员数组动态分配大小</title>
    <url>/2017/12/12/%E4%B8%BA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<pre><code>struct _longobject {
    Py_ssize_t ob_refcnt;               
    struct _typeobject *ob_type;
    Py_ssize_t ob_size;
    digit ob_digit[1];
}PyLongObject;


PyLongObject *p;
/*为结构体动态分配内存*/
p = (PyLongObject*)malloc(sizeof(PyLongObject)+sizeof(digit)*abs(ob_size))
for(int i = 0; i &lt; ob_size; i++){
    p-&gt;ob_digit[i] = 1;
}
这就是PyLongObject对象的内存分配，只不过python源码由内存管理模块进行内存的分配，不那么好理解。
</code></pre><hr>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct T
{
    int a;
    int b;
    char c[0];
}T;//大小为8字节，在32位操作系统

int main(int argc, char *argv[]){
    T *t = (T*)malloc(sizeof(T)+sizeof(char)*6);
    printf(&quot;%lu,%lu,%lu\n&quot;,sizeof(T),sizeof(int),sizeof(t-&gt;c));
    t-&gt;a = 1;
    t-&gt;b = 1;
    strcpy(t-&gt;c, &quot;hello&quot;);
    printf(&quot;%s\n&quot;,t-&gt;c);
    return 0;
}
输出：
8,4,0
hello
</code></pre><hr>
<p>Ref：<br>1.<a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM33-C.++Allocate+and+copy+structures+containing+a+flexible+array+member+dynamically" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/c/MEM33-C.++Allocate+and+copy+structures+containing+a+flexible+array+member+dynamically</a></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>不同的进程可以同时绑定同一个端口吗</title>
    <url>/2023/03/01/%E4%B8%8D%E5%90%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97/</url>
    <content><![CDATA[<p>不同的进程可以同时绑定同一个端口吗?<br>当听到这个问题的时候，你的第一反应是不是肯定不行啊(如果你在工作中遇到过address already in use的情况)。大家都知道tcp通过四元组来确定一个唯一的连接，所以说理论上说不同的进程应该不能使用同一个端口。</p>
<p>其实在Linux3.9内核中引入了一个socket选项<code>SO_REUSEPORT</code>,如果在创建socket的时候添加了这个选项，就允许多个进程绑定到同一个端口。</p>
<p>多个进程监听同一个端口，那服务端是怎么处理客户端连接呢？<br>内核将以<code>round-robin</code>的方式在进程之间分配传入的连接，这意味着每个进程将依次接收相等数量的连接。</p>
<p>可以使用如下的代码，分别在不同的终端运行下面的代码对上面提出的问题进行验证。<br>如果在不同的终端都可以运行这段代码说明不同的进程可以占用同一个端口；然后可以在客户端curl服务端,观察日志输出就知道连接了哪个进程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># create a socket</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"># set the SO_REUSEPORT option</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)</span><br><span class="line"></span><br><span class="line"># bind the socket to the port</span><br><span class="line">sock.bind((&apos;localhost&apos;, 12345))</span><br><span class="line"></span><br><span class="line"># listen for incoming connections</span><br><span class="line">sock.listen()</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    # accept incoming connections</span><br><span class="line">    conn, addr = sock.accept()</span><br><span class="line">    print(f&quot;Connection from &#123;addr&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # receive data from the client</span><br><span class="line">    data = conn.recv(1024)</span><br><span class="line">    print(f&quot;Received data: &#123;data.decode()&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # send a response back to the client</span><br><span class="line">    response = &quot;Hello, client!&quot;</span><br><span class="line">    conn.send(response.encode())</span><br><span class="line"></span><br><span class="line">    # close the connection</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2018/07/31/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://github.com/hys20151008/datastructures/blob/master/binarytree.py" title="代码实现" target="_blank" rel="noopener">代码实现</a> <img src="http://img.hysyeah.top/wp-content/uploads/2018/07/binarytree.jpg" alt></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>你真的知道子网的作用吗</title>
    <url>/2020/12/26/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E5%AD%90%E7%BD%91%E7%9A%84%E4%BD%9C%E7%94%A8%E5%90%97/</url>
    <content><![CDATA[<h4 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h4><p>我们肯定使用过<code>ifconfig</code>命令来查询计算机中的网络设备。不知道你有没有注意过其中的<code>netmask</code>(子网掩码),但你真的知道它的来龙去脉吗?今天我们就来重新认识一下<code>netmask</code>。<br><img src="http://img.hysyeah.top/2020/12/26/20201226075950-ifconfig-netmask.png" alt="image"></p>
<p>在进入主题内容前我们先来回顾一些关于<code>IP</code>的知识点。每一个需要使用互联网的设备都必须具有一个唯一标识,而这个唯一标识就是<code>IP</code>地址。就像在生活中你要打电话别个时,你必须知道这个人的手机号码不然你就无法联系到他，可以说<code>IP</code>地址就类似于你的手机号码。</p>
<p><code>IP</code>地址采用分层设计,并可以将其分为如下五类。不同种类的<code>IP</code>地址网络号和主机号都是不一样的。<br><img src="http://img.hysyeah.top/2020/12/26/ip-catagory.png" alt="image"></p>
<p>各类<code>IP</code>的地址范围如下,方便记忆:</p>
<p><img src="http://img.hysyeah.top/2020/12/26/ip-address-scope.png" alt="image"></p>
<hr>
<h4 id="子网掩码的由来-为什么需要子网掩码"><a href="#子网掩码的由来-为什么需要子网掩码" class="headerlink" title="子网掩码的由来,为什么需要子网掩码"></a>子网掩码的由来,为什么需要子网掩码</h4><p><code>IP</code>地址结构设计之初是两层结构,将<code>IP</code>地址分为<code>网络号</code>和<code>主机号</code>,不同的<code>网络号</code>下包含一系列的主机(网络设备)。在这种结构下大量的主机连接在同一个网络下，当主机数量少的网络还能正常的工作，然而这种方式缺乏弹性,当主机数量过多的时候会带来一系列的问题。举个例子,当一个公司规模较小的时候，分为两个层级<br>部门—&gt;员工。当有消息要传达到一个部门时只需要把消息一个个传达给指定部门的人员即可，当一个部门人员较少时这样不会有太大的问题。随着公司的快速发展，各个部门的人员越来越多，此时如果有消息传达给一个部门，只能把消息一个一个的发给部门里的员工;部门里并不是所有的员工都需要知道这个消息，但我们没有其它的信息来对员工进行分类，所以只能把消息发给部门里的所有员工。这样做的缺点显而易见，不仅管理不太方便，而且有些员工会收到自己不需要的消息。为了解决这个问题，公司往往会在目前的基础上新增一个层级：组。<br>部门—&gt;分组—&gt;员工<br>在部门的下面设置组，将对应的员工分配在对应的组，不仅可以方便管理还可以避免消息(资源)的浪费。</p>
<p>软件设计也是来源于生活。为了更好的适应于更大的网络和更好更方便的管理网络设备，于是提出了子网这个设计。</p>
<p>增加了子网相对以前的二层<code>IP</code>地址有哪些优点呢？</p>
<ul>
<li>弹性，可以自定义子网和子网中的主机数</li>
<li>对公网的不可见性，对于子网的划分只存在于组织(可以认为是局域网)内。还是上面的例子，不管公司的组织架构怎么调整在公外面看来你还是那个公司</li>
<li>通过子网可以对网络进行分组，不同分组的主机进行广播只有本组的主机才可以收到消息</li>
<li>子网掩码将大的网络域，分为更小的子网。较小的网络会创建较小的广播，从而产生较少的广播流量。 此外，子网还通过将网络问题隔离到特定的存在来简化故障排除</li>
</ul>
<p><code>IP</code>地址是固定的32位，那如何在原来二层结构的<code>IP</code>地址进行的子网的划分呢？ 此时就是轮到子网掩码上场了。</p>
<p>为了在不改变<code>IP</code>地址结构的前提下,于是人们提出了子网掩码。<br>但是用哪几位数据来表示子网呢，答案是从主机号中借位来充当子网。</p>
<p>FOR EXAMPLE：<br>B类地址:154.71.0.0, 如果不使用子网的话，154.71这个网络号可以容纳65534(pow(2,10)-2)个主机。然而你可以通过子网掩码对这个网络进行子网划分。你可以使用1位来表示子网，则剩余的15位来表示主机号；如果使用2位来表示子网，则剩余的14位来表示主机号，以此类推。你使用越多的位数来表示子网，相应的用来表示主机号的位数也就越好。最少要使用2位来表示主机号，因为减去主机后全为0和全为1的两个<code>IP</code>地址。</p>
<p><img src="http://img.hysyeah.top/2020/12/26/subnet0.png" alt="image"></p>
<p>假如你要使用5位来作子网，则<code>subnet id</code>这5位在子网掩码中必须为1，表示这5位用于子网。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># RFC950</span><br><span class="line">Special Addresses:</span><br><span class="line"></span><br><span class="line">    From the Assigned Numbers memo [9]:</span><br><span class="line">        &quot;In certain contexts, it is useful to have fixed addresses with functional significance rather than as identifiers of specific hosts. When such usage is called for,   </span><br><span class="line">        the address zero is to be interpreted as meaning &quot;this&quot;, as in &quot;this network&quot;. The address of all ones are to be interpreted as meaning &quot;all&quot;, as in &quot;all hosts&quot;.   </span><br><span class="line">        For example, the address 128.9.255.255 could be interpreted as meaning all hosts on the network 128.9. Or, the address 0.0.0.37 could be interpreted as meaning host 37 on this network.&quot;</span><br><span class="line"></span><br><span class="line">    It is useful to preserve and extend the interpretation of these special addresses in subnetted networks.   </span><br><span class="line">    This means the values of all zeros and all ones in the subnet field should not be assigned to actual (physical) subnets.</span><br></pre></td></tr></table></figure></p>
<p>上面这段话的大致意思是在<code>IP</code>地址中全为0或全为1的有特殊的含义或特殊的用途。比如<code>IP</code>地址<code>128.9.255.255</code>是网络号为<code>128.9</code>的文播地址，发往<code>128.9.255.255</code>的网络包会广播至该网络的所有主机。地址<code>128.9.0.0</code>会被解释为此网络，也不建议使用。<br>因此上面<code>5-bit</code>的子网建议使用除0和31以外的子网。<br><a href="https://subnet.ninja/" target="_blank" rel="noopener">子网计算器</a></p>
<h4 id="有无子网通信有何差异"><a href="#有无子网通信有何差异" class="headerlink" title="有无子网通信有何差异"></a>有无子网通信有何差异</h4><p>在无子网这个概念之前，假如主机A访问主机B，主机A会判断主机B和自己是不是在同一个网段，即拥有同样的网络号，如果网络号相同则A会通过ARP获得B的MAC地址然后进行通信；如果网络不相同，则将请求发送给默认网关然后再由网关进行路由。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">IF ip_net_number(dg.ip_dest) = ip_net_number(my_ip_addr)</span><br><span class="line">    THEN</span><br><span class="line">        send_dg_locally(dg, dg.ip_dest)</span><br><span class="line">    ELSE</span><br><span class="line">        send_dg_locally(dg, gateway_to(ip_net_number(dg.ip_dest)))</span><br></pre></td></tr></table></figure>
<p>实现子网划分后，主机A判断和主机B是否在同一个子网，如果在同一个子网A会通过ARP获得B的MAC地址然后进行通信；如果不在同一个子网，则将请求发送给默认网关然后再由网关进行路由。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">IF bitwise_and(dg.ip_dest, my_ip_mask) = bitwise_and(my_ip_addr,my_ip_mask)</span><br><span class="line">    THEN</span><br><span class="line">        send_dg_locally(dg, dg.ip_dest)</span><br><span class="line">    ELSE</span><br><span class="line">        send_dg_locally(dg, gateway_to(bitwise_and(dg.ip_dest, my_ip_mask)))</span><br></pre></td></tr></table></figure></p>
<h4 id="子网掩码是如何发现的"><a href="#子网掩码是如何发现的" class="headerlink" title="子网掩码是如何发现的"></a>子网掩码是如何发现的</h4><p>当网络启动的时候主机如何确定自己的子网掩码呢？</p>
<p>首先主机会从磁盘文件中获取子网掩码信息，如果存在则直接使用；如果磁盘上没有记录子网掩码信息，主机将会发出广播信息以此请求子网掩码。</p>
<p>例子:来自rfc950</p>
<ul>
<li>假如在A类网络<code>36.0.0.0</code>有主机<code>IP</code>为<code>36.40.0.123</code>,网关为<code>32.40.0.62</code>,使用<code>8-bit</code>作为<code>subnet id</code>则其子掩码为<code>255.255.0.0</code>。</li>
<li>如果主机不知道自己的<code>IP</code>地址则会通过<code>RARP</code>协议获取自己的<code>IP</code>地址。然后发送<code>ICMP</code>请求到广播地址<code>255.255.255.255</code>:</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>key</th>
<th>val</th>
</tr>
</thead>
<tbody>
<tr>
<td>Source address:</td>
<td>36.40.0.123</td>
</tr>
<tr>
<td>Destination address:</td>
<td>255.255.255.255</td>
</tr>
<tr>
<td>Protocol:</td>
<td>ICMP = 1</td>
</tr>
<tr>
<td>Type:</td>
<td>Address Mask Request = AM1</td>
</tr>
<tr>
<td>Code:</td>
<td>0</td>
</tr>
<tr>
<td>Mask:</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>然后网关可以直接回复网络包给主机<code>36.40.0.123</code>,主机便获取到了自己的子网掩码</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>key</th>
<th>val</th>
</tr>
</thead>
<tbody>
<tr>
<td>Source address:</td>
<td>36.40.0.62</td>
</tr>
<tr>
<td>Destination address:</td>
<td>36.40.0.123</td>
</tr>
<tr>
<td>Protocol:</td>
<td>ICMP = 1</td>
</tr>
<tr>
<td>Type:</td>
<td>Address Mask Request = AM2</td>
</tr>
<tr>
<td>Code:</td>
<td>0</td>
</tr>
<tr>
<td>Mask:</td>
<td>255.255.0.0</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>假如主机根本不知道自己的主机号则会发出如下内容的包。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>key</th>
<th>val</th>
</tr>
</thead>
<tbody>
<tr>
<td>Source address:</td>
<td>0.0.0.0</td>
</tr>
<tr>
<td>Destination address:</td>
<td>255.255.255.255</td>
</tr>
<tr>
<td>Protocol:</td>
<td>ICMP = 1</td>
</tr>
<tr>
<td>Type:</td>
<td>Address Mask Request = AM1</td>
</tr>
<tr>
<td>Code:</td>
<td>0</td>
</tr>
<tr>
<td>Mask:</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>网关将会收到数据包，然后回复如下内容的数据包：<br>|key|val|<br>|—-|—-|<br>|Source address:|36.40.0.62|<br>|Destination address:|255.255.255.255|<br>|Protocol:|ICMP = 1|<br>|Type:|Address Mask Request = AM2|<br>|Code:|0|<br>|Mask:|255.255.0.0|</p>
<ul>
<li>如果主机不允许进行广播消息并且假设主机知道网关的地址，主机刚会直接发数据包给网关请求子网掩码。</li>
</ul>
<h4 id="无法获取子网掩码的情况"><a href="#无法获取子网掩码的情况" class="headerlink" title="无法获取子网掩码的情况"></a>无法获取子网掩码的情况</h4><p>在如下三种情况下，经过多次尝试后仍可能无法获取子网掩码：<br>1.网络与其它所有网络隔离<br>2.未使用子网而且没有其它主机可以提供子网掩码<br>3.此网络上的所有网关都未能启动。</p>
<p>在第一种和第二种情况，子网掩码等于网络号。在第三种情况下，无法确定主机的子网掩码因此最安全的做法就是将子网掩码设置为网络号，虽然可能是错误的。当网关正常工作后，网关会广播<code>Address Mask Reply</code>类型的数据包，主机收到数据包后，会更正自己的子网掩码。</p>
<hr>
<p>REF：<br>1.<a href="https://tools.ietf.org/pdf/rfc950.pdf" target="_blank" rel="noopener">RFC950</a><br>2.<a href="http://www.tcpipguide.com/free/index.htm" target="_blank" rel="noopener">tcpipguide.com</a></p>
]]></content>
      <tags>
        <tag>－网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>使用cargo管理外部依赖</title>
    <url>/2020/03/22/%E4%BD%BF%E7%94%A8cargo%E7%AE%A1%E7%90%86%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<p>1.使用<code>cargo</code>创建项目,会在当前目录下生成<code>hello_cargo</code>文件夹<br><code>cargo new hello_cargo --bin</code></p>
<p>2.使用<code>Goland</code>打开项目<code>hello_cargo</code>,目录如下。其中<code>Cargo.toml</code>中<code>[package]</code>定义的是关于项目的一些信息,<code>[dependencies]</code>中定义的是外部依赖<br><img src="http://img.hysyeah.top/2020/3/22/hello-cargo.png" alt="image"></p>
<p>3.引入外部包<code>rand</code>,<a href="https://docs.rs/rand/0.3.14/rand/" target="_blank" rel="noopener">rand</a><br>在<code>Cargo.toml</code>文件<code>[dependencies]</code>下加入<code>rand = &quot;0.3.14&quot;</code></p>
<p>4.<code>cargo build</code>将会从远端下载<code>rand</code>包,包括<code>rand</code>的依赖包<br><img src="http://img.hysyeah.top/2020/3/22/rand.png" alt="image"></p>
<p>5.使用外部包<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern crate rand; //表明rand是外部依赖</span><br><span class="line"></span><br><span class="line">use std::io;</span><br><span class="line">use rand::Rng;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Guess the number!&quot;);</span><br><span class="line"></span><br><span class="line">    let secret_number = rand::thread_rng().gen_range(1, 101);</span><br><span class="line">    println!(&quot;The secret number is:&#123;&#125;&quot;, secret_number);</span><br><span class="line">    println!(&quot;Please input your guess.&quot;);</span><br><span class="line"></span><br><span class="line">    let mut guess = String::new();</span><br><span class="line">    io::stdin().read_line(&amp;mut guess)</span><br><span class="line">        .expect(&quot;Failed to read line&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;You guessed:&#123;&#125;&quot;, guess);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.编译执行<br><img src="http://img.hysyeah.top/2020/3/22/run-rand.png" alt="image"></p>
<hr>
<h5 id="cargo相关命令"><a href="#cargo相关命令" class="headerlink" title="cargo相关命令"></a>cargo相关命令</h5><div class="table-container">
<table>
<thead>
<tr>
<th>command</th>
<th>desc</th>
</tr>
</thead>
<tbody>
<tr>
<td>rustup doc</td>
<td>打开本地文档</td>
</tr>
<tr>
<td>rustc main.rs</td>
<td>编译</td>
</tr>
<tr>
<td>rustup update</td>
<td>更新Rust工具链和rustup</td>
</tr>
<tr>
<td>cargo new <app_name> —bin</app_name></td>
<td>新建一个可执行应用</td>
</tr>
<tr>
<td>cargo build</td>
<td>生成可执行文件</td>
</tr>
<tr>
<td>cargo update</td>
<td>更新外部依赖,并更新Cargo.lock文件</td>
</tr>
<tr>
<td>cargo build —release</td>
<td>生成可发布的执行文件,Rust有做一些优化</td>
</tr>
<tr>
<td>cargo run</td>
<td>如果存在目标文件,且Rust认为代码没有改变,则直接执行可执行文件;如果源码改变或可执行文件不存在,则编译后再执行</td>
</tr>
<tr>
<td>cargo check</td>
<td>检查代码是否能正确编译,速度当然比cargo build,因为不产生可执行文件,编码中用于快速检查代码是否有问题</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>使用过程中遇到的问题：<br>Caused by:<br>  error authenticating: failed connecting agent; class=Ssh (23)<br><img src="http://img.hysyeah.top/2020/3/22/cargo-error.png" alt="image"><br>解决方法：将~/.gitconfig中的两行内容注释,<code>Windows</code>下路径为<code>C:\Users\Administrator\</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[url &quot;git@github.com:&quot;]</span><br><span class="line"># 	insteadOf = https://github.com/</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Ref：<br>1.<a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a><br>2.<a href="https://github.com/rust-lang/cargo/issues/3381" target="_blank" rel="noopener">https://github.com/rust-lang/cargo/issues/3381</a></p>
]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker搭建hadoop,spark集群</title>
    <url>/2018/02/12/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAhadoop,spark%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h5 id="环境：ubuntu-16-04-64位"><a href="#环境：ubuntu-16-04-64位" class="headerlink" title="环境：ubuntu 16.04 64位"></a>环境：ubuntu 16.04 64位</h5><h5 id="安装所需文件：-Java-SDK-1-8-scala-2-11-11-hadoop-2-7-4-spark-2-2-0-bin-hadoop2-7"><a href="#安装所需文件：-Java-SDK-1-8-scala-2-11-11-hadoop-2-7-4-spark-2-2-0-bin-hadoop2-7" class="headerlink" title="安装所需文件： Java SDK 1.8, scala-2.11.11,hadoop-2.7.4,spark-2.2.0-bin-hadoop2.7"></a>安装所需文件： Java SDK 1.8, scala-2.11.11,hadoop-2.7.4,spark-2.2.0-bin-hadoop2.7</h5><hr>
<p>1.docker pull ubuntu<br>2.启动镜像，docker run -idt [image_id] /bin/bash<br>3.进入容器，安装必要的工具</p>
<pre><code>  apt-get install iputils-ping  #ping命令
  apt-get install net-tools     #ifconfig
</code></pre><p>4.将安装包复制到容器内部，<a href="http://img.hysyeah.top/2018/02/07/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A42/" title="查看容器主机之间文件复制" target="_blank" rel="noopener">查看容器主机之间文件复制</a><br>5.解压各个安装包，设置环境变量 ~/.bashrc <img src="http://img.hysyeah.top/wp-content/uploads/2018/02/hadoopenv.png" alt="image"> docker commit -m “xx” -a “xx” spark_base #生成一个新的镜像 </p>
<p>6.新建项目，修改各种<a href="https://github.com/hys20151008/hadoop-cluster-config" title="配置文件" target="_blank" rel="noopener">配置文件</a><br>7.项目目录</p>
<pre><code># ssh文件夹下面是通过ssh-keygen -t rsa 命令生成的~/.ssh目录下的所有文件（这样不用每次重新启动新的容器后，都要重新配置ssh)

├── master
│   ├── hadoop
│   ├── spark
│   └── ssh
├── slave1
│   ├── hadoop
│   ├── spark
│   └── ssh
└── slave2
|    └── ssh
|__ docker-compose.yml
</code></pre><p>8.<a href="http://hysyeah.top/2018/02/01/%E5%90%AF%E5%8A%A8docker%20hadoop%E9%9B%86%E7%BE%A4%E5%A4%B1%E8%B4%A5" target="_blank" rel="noopener">创建网络</a> docker-compose up -d #启动容器，一个namenode,二个datanode<br>9.进入master容器，/opt/hadoop-2.7.4/sbin/start-all.sh #启动集群 10. 进入master容器，输入jps，有如下进程</p>
<pre><code>3191 NameNode
3817 Jps
3433 ResourceManager
</code></pre><p>进入slave1容器，输入jps，有如下进程</p>
<pre><code>962 NodeManager
1235 Jps
854 DataNode
</code></pre><p>11.输入hdfs dfsadmin -report可查看节点信息 <img src="http://img.hysyeah.top/wp-content/uploads/2018/02/hdfsreport.png" alt="image"> 12.测试集群是否正常工作。</p>
<pre><code>vim a.txt                              #创建本地文件
hdfs dfs -put a.txt /                  #上传到hdfs文件系统
cd /opt/hadoop-2.7.4/share/hadoop/mapreduce
hadoop jar hadoop-mapreduce-examples-2.7.4.jar wordcount /a.txt /out  #执行count计算
hdfs dfs -text /out/part-r-00000                                      #查看执行结果
若以上都没有出错，说明集群正常
</code></pre><hr>
<p>Ref：<br>1.<a href="http://blog.csdn.net/xu470438000/article/details/50512442" target="_blank" rel="noopener">http://blog.csdn.net/xu470438000/article/details/50512442</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>修改.zshrc文件报badassiment错误</title>
    <url>/2017/09/04/%E4%BF%AE%E6%94%B9.zshrc%E6%96%87%E4%BB%B6%E6%8A%A5badassiment%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>修改~/.zshrc文件添加下如下</p>
<pre><code>export PATH=&quot;/usr/local/bin:$PATH&quot;
</code></pre><p>source ~/.zshrc报badassiment错误 原因：=号之间不能有空格</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>决策树-ID3算法</title>
    <url>/2018/06/23/%E5%86%B3%E7%AD%96%E6%A0%91-ID3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>分类决策树模型是一 种描述对实例进行分类的树形结构。决策树由结点和有向边组成。结点有两种类型：内部结点和叶结点。内部结点表示一个特征或属性，叶结点表示一个类。<br>用决策树分类，从根结点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子结点；这时，每一个结点对应着该特征的一个取值。如此递归地对实例进行测试并分配，直至达到叶结点。最后将实例分到叶结点的类中。<img src="http://img.hysyeah.top/wp-content/uploads/2018/06/decision_tree.png" alt> 决策树学习常用的算法有ID3,C4.5,CART。</p>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>特征选择在于选取对训练数据具有分类能力的特征。这样可以提高决策树学习的效率。</p>
<h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>在信息论与概率统计中，熵(entropy)表示随机变量不确定性的度量。设X是一个取有限个值的离散随机变量，其概率分布为：<br>$ P(X=x<em>{i}) = p</em>{i}, i=1,2, \cdot \cdot \cdot, n $ 则随机变量X的熵定义为<br>$ H(X)=-\sum<em>{i=1}^{n}p</em>{i} \log p_{i} $ ,通常式中的对数以2为底或以e为底。<br>熵越大，随机变量的不确定性就越大。 (信息增益：定义) 特征A对训练数据集D的信息增益g(D,A),定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差，即<br>$ g(D,A)= H(D)-H(D|A) $<br>熵H(Y)与条件熵H(Y|X)之差称为互信息。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/sample.png" alt> <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/hd.png" alt><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/id3.png" alt></p>
<pre><code> from scipy.stats import entropy
 from collections import Counter
 # 计算熵
 def calcEnt(dataSet):
    num = len(dataSet)
    labelCount = {}
    for featVec in dataSet:
        label = featVec[-1]
        if label not in labelCount:
            labelCount[label] = 0
        labelCount[label] += 1
    Ent = 0.0
    for k in labelCount:
        prob = float(labelCount[k])/num
        Ent -= prob * log(prob, 2)
    return Ent


def calcEnt2(dataSet):
    dataSet = np.array(dataSet)
    num = len(dataSet)
    labelCount = Counter(dataSet[:,-1]) #使用Counter简化代码

    prod = [float(labelCount[k])/num for k in labelCount]
    Ent = entropy(prod, base=2)        # scipy中提供计算熵的函数

    return Ent


# 对数据集进行切割
def splitData(dataSet, axis, value):
    retDataSet = []
    for featVec in dataSet:
        if featVec[axis] == value:
            reducedFeatVec = featVec[:axis]
            reducedFeatVec.extend(featVec[axis+1:])
            retDataSet.append(reducedFeatVec)
    return retDataSet


# 选择信息增益最大的特征
def chooseBestFeature(dataSet):
    numFeatures = len(dataSet[0]) - 1  # 特征的数量
    hd = calcEnt2(dataSet)
    bestInfoGain, bestFeature = 0.0, -1

    for i in range(numFeatures):
        featList = [elt[i] for elt in dataSet] #获取特征列表
        uniqueVals = set(featList)     #对特征值进行去重
        newEntropy = 0.0
        for v in uniqueVals:
            # 切割数据计算熵
            subDataSet = splitData(dataSet, i, v)
            prob = len(subDataSet)/float(len(dataSet))
            newEntropy += prob * calcEnt2(subDataSet)
        infoGain = hd - newEntropy   # 计算信息增益
        print(infoGain)
        if infoGain &gt; bestInfoGain:
            bestInfoGain = infoGain
            bestFeature = i
    return bestFeature


# 返回出现次数最多的那项
def majorityCnt(classList):
    classCount = {}
    for vote in classList:
        if vote not in classCount:
            classCount[vote] = 0
        classCount[vote] += 1
    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)
    return sortedClassCount[0][0]


# 使用字典构造决策树
def createTree(dataSet, labels):
    classList = [elt[-1] for elt in dataSet] #获取分类
    # 如果只有一分类，则只有一个根节点
    if classList.count(classList[0]) == len(classList):
        return classList[0]
    # 当数据为一维时，返回出现次数最多的项
    if len(dataSet[0]) == 1:
        print(&#39;dataSet&#39;, dataSet)
        return majorityCnt(classList)
    bestFeat = chooseBestFeature(dataSet)
    bestFeatLabel = labels[bestFeat]
    myTree = {bestFeatLabel: {}}
    del(labels[bestFeat])
    featValues = [elt[bestFeat] for elt in dataSet]
    uniqueVals = set(featValues)
    print(&#39;labels=&#39;, labels)

    for v in uniqueVals:
        subLabels = labels[:]
        print(&#39;subLabels&#39;,subLabels)
        # 使用递归法构建决策树
        myTree[bestFeatLabel][v] = createTree(splitData(dataSet, bestFeat, v), subLabels)
    return myTree


# 使用构建的决策树进行分类
def classify(inputTree, featLabels, testVec):
    firstStr = list(inputTree.keys())[0]
    secondDict = inputTree[firstStr]
    featIndex = featLabels.index(firstStr)
    print(&#39;featIndex&#39;, featIndex)
    print(&#39;secondDict&#39;, secondDict)
    for k in secondDict:
        if testVec[featIndex] == k:
            if isinstance(secondDict[k], dict):
                classLabel = classify(secondDict[k], featLabels, testVec)
            else:
                classLabel = secondDict[k]
    return classLabel
</code></pre><hr>
<p>Ref：<br>1.机器学习实战<br>2.统计学习方法—李航</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>凸函数</title>
    <url>/2018/07/12/%E5%87%B8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><img src="http://img.hysyeah.top/wp-content/uploads/2018/07/domf.png" alt="image"> 定义：函数<script type="math/tex">f: \mathcal R^{n} \to \mathcal R</script>是凸的，如果<script type="math/tex">dom f</script>是凸集，且对于任意<script type="math/tex">x, y \in dom f</script>和任意<script type="math/tex">0 \le \theta \le 1</script>，有  </p>
<script type="math/tex; mode=display">f(\theta x + (1-\theta)y) \le \theta f(x) + (1-\theta)f(y)</script><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/convex_plot.png" alt><br><a href="https://github.com/hys20151008/7788/blob/master/convex_func_ex.py" target="_blank" rel="noopener">图象代码</a>   </p>
<p>当<script type="math/tex">\theta = 0</script>时，f(y) = f(y)成立，<br>当<script type="math/tex">\theta = 1</script>时，f(x) = f(x)成立, 当<script type="math/tex">\theta = \frac{1}{2}</script>时，<script type="math/tex">f(\frac{x+y}{2}) \le \frac{f(x)+f(y)}{2}</script></p>
<hr>
<p>从几何意义上看，上述不等式意味着点(x, f(x))和(y, f(y))之间的线段，即从x到y的弦，在函数f的图像上方(如上图)。</p>
<hr>
<p>Ref：<br>1.Convex Optimization (Stephen Boyd)<br>2.支持向量机：理论，算法与拓展(田英杰)</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>初识Dgraph</title>
    <url>/2019/05/19/%E5%88%9D%E8%AF%86Dgraph/</url>
    <content><![CDATA[<p>1.Dgraph介绍 　关键字：快速，支持事务，分布式图数据库 <img src="http://img.hysyeah.top/wp-content/uploads/2019/05/Screenshot-from-2019-05-19-15-17-10.png" alt> ２.安装，启动Dgraph</p>
<pre><code>docker pull dgraph/dgraph:v0.7.7

mkdir -p ~/dgraph
docker run -it -p 127.0.0.1:8080:8080 -p 127.0.0.1:9080:9080 -v ~/dgraph:/dgraph --name dgraph dgraph/dgraph dgraph --bindall=true
</code></pre><p>3.访问<code>http://127.0.0.1:8080/</code> 4.在输入框中，分别输入如下数据，点击run</p>
<pre><code>mutation {
  set {
   _:luke &lt;name&gt; &quot;Luke Skywalker&quot; .
   _:leia &lt;name&gt; &quot;Princess Leia&quot; .
   _:han &lt;name&gt; &quot;Han Solo&quot; .
   _:lucas &lt;name&gt; &quot;George Lucas&quot; .
   _:irvin &lt;name&gt; &quot;Irvin Kernshner&quot; .
   _:richard &lt;name&gt; &quot;Richard Marquand&quot; .

   _:sw1 &lt;name&gt; &quot;Star Wars: Episode IV - A New Hope&quot; .
   _:sw1 &lt;release_date&gt; &quot;1977-05-25&quot; .
   _:sw1 &lt;revenue&gt; &quot;775000000&quot; .
   _:sw1 &lt;running_time&gt; &quot;121&quot; .
   _:sw1 &lt;starring&gt; _:luke .
   _:sw1 &lt;starring&gt; _:leia .
   _:sw1 &lt;starring&gt; _:han .
   _:sw1 &lt;director&gt; _:lucas .

   _:sw2 &lt;name&gt; &quot;Star Wars: Episode V - The Empire Strikes Back&quot; .
   _:sw2 &lt;release_date&gt; &quot;1980-05-21&quot; .
   _:sw2 &lt;revenue&gt; &quot;534000000&quot; .
   _:sw2 &lt;running_time&gt; &quot;124&quot; .
   _:sw2 &lt;starring&gt; _:luke .
   _:sw2 &lt;starring&gt; _:leia .
   _:sw2 &lt;starring&gt; _:han .
   _:sw2 &lt;director&gt; _:irvin .

   _:sw3 &lt;name&gt; &quot;Star Wars: Episode VI - Return of the Jedi&quot; .
   _:sw3 &lt;release_date&gt; &quot;1983-05-25&quot; .
   _:sw3 &lt;revenue&gt; &quot;572000000&quot; .
   _:sw3 &lt;running_time&gt; &quot;131&quot; .
   _:sw3 &lt;starring&gt; _:luke .
   _:sw3 &lt;starring&gt; _:leia .
   _:sw3 &lt;starring&gt; _:han .
   _:sw3 &lt;director&gt; _:richard .

   _:st1 &lt;name&gt; &quot;Star Trek: The Motion Picture&quot; .
   _:st1 &lt;release_date&gt; &quot;1979-12-07&quot; .
   _:st1 &lt;revenue&gt; &quot;139000000&quot; .
   _:st1 &lt;running_time&gt; &quot;132&quot; .
  }
}


mutation {
  schema {
    name: string @index .
    release_date: date @index .
    revenue: float .
    running_time: int .
  }
}
</code></pre><p>5.查询数据,</p>
<pre><code>{
  me(func:allofterms(name, &quot;Star Wars&quot;)) @filter(ge(release_date, &quot;1980&quot;)) {
    name
    release_date
    revenue
    running_time
    director {
     name
    }
    starring {
     name
    }
  }
}
点击RUN
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2019/05/dgraph_pic.png" alt></p>
<hr>
<p>总结：刚开始是安装的<code>dgraph/dgraph:v1.0.12</code>,但是启动后访问浏览器显示<code>disconneted</code>，为了快速看到浏览器中节点和关系的效果所以安装了<code>dgraph/dgraph:v0.7.7</code>。后续继续了解。</p>
<hr>
<p>Ref：<br>1.<a href="https://yq.aliyun.com/articles/237205" target="_blank" rel="noopener">https://yq.aliyun.com/articles/237205</a> 2.<a href="https://yq.aliyun.com/articles/237205" target="_blank" rel="noopener">https://docs.dgraph.io/get-started/#dataset</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>初识k8sgpt</title>
    <url>/2023/06/01/%E5%88%9D%E8%AF%86k8sgpt/</url>
    <content><![CDATA[<p><code>k8sgpt</code>是一个扫描<code>k8s</code>集群和诊断集群问题的强有力工具。<code>k8sgpt</code>的分析都是基于<code>SRE</code>经验，使用<code>k8sgpt</code>能快速对集群进行<br>问题扫描且快速提取相关信息并且可以使用<code>AI</code>增加自身的能力。</p>
<p>K8SGPT的作用是帮助用户扫描和诊断Kubernetes集群中的问题。它可以执行以下任务：</p>
<ul>
<li><p>故障排除：K8SGPT使用自然语言处理技术分析Kubernetes集群的状态和配置，帮助用户快速识别和解决故障。</p>
</li>
<li><p>安全性分析：K8SGPT能够检测和分析Kubernetes集群的安全性问题，例如暴露的敏感信息、权限配置错误等，并提供相应的建议和修复措施。</p>
</li>
<li><p>性能优化：K8SGPT可以评估Kubernetes集群的性能，并提供性能优化建议，帮助用户提升集群的吞吐量、响应时间等关键指标。</p>
</li>
<li><p>最佳实践验证：K8SGPT基于SRE经验，可以检查Kubernetes集群是否符合最佳实践和行业标准，并提供改进建议。</p>
</li>
</ul>
<h6 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h6><p><a href="https://docs.k8sgpt.ai/getting-started/installation/" target="_blank" rel="noopener">安装教程</a></p>
<h6 id="简明教程"><a href="#简明教程" class="headerlink" title="简明教程"></a>简明教程</h6><p>你可以在官方网站上<a href="https://docs.k8sgpt.ai/tutorials/playground/" target="_blank" rel="noopener">直接体验</a>不用安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 分析k8s集群状态，默认会检查这些资源</span><br><span class="line"><span class="meta">#</span> Deployment, ReplicaSet, PersistentVolumeClaim, Service, Ingress, StatefulSet, Pod, CronJob, Node</span><br><span class="line">k8sgpt analyze</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> --explain选项将会将错误信息发送给AI后端(默认是OpenAI)以获得一些帮助(会提示你怎么解决问题)</span><br><span class="line">k8sgpt analyze --explain</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用FakeAI provider</span><br><span class="line">k8sgpt analyze -b noopai --explain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 数据安全性，为了提高安全性k8sgpt提供了匿名化功能，在把数据发送给AI后端之前会对一些敏感数据进行处理。当AI后端返回数据之后，k8sgpt再把数据替换成真实的数据返回给客户端</span><br><span class="line"><span class="meta">#</span> 匿名化不支持Event</span><br><span class="line"></span><br><span class="line">k8sgpt analyze -b noopai --explain --anonymize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 对指定的命名空间进行扫描</span><br><span class="line">k8sgpt analyze --namespace kubee-system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 只想扫描指定的资源</span><br><span class="line"><span class="meta">#</span> 只扫描Ingress, Service</span><br><span class="line">k8sgpt analyze --filter Ingress,Service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> filters列表，分为Active 和Unused</span><br><span class="line">➜  k8sgpt filters list</span><br><span class="line">Active: </span><br><span class="line"><span class="meta">&gt;</span> Pod</span><br><span class="line"><span class="meta">&gt;</span> Deployment</span><br><span class="line"><span class="meta">&gt;</span> ReplicaSet</span><br><span class="line"><span class="meta">&gt;</span> PersistentVolumeClaim</span><br><span class="line"><span class="meta">&gt;</span> Service</span><br><span class="line"><span class="meta">&gt;</span> Ingress</span><br><span class="line"><span class="meta">&gt;</span> StatefulSet</span><br><span class="line"><span class="meta">&gt;</span> CronJob</span><br><span class="line"><span class="meta">&gt;</span> Node</span><br><span class="line">Unused: </span><br><span class="line"><span class="meta">&gt;</span> HorizontalPodAutoScaler</span><br><span class="line"><span class="meta">&gt;</span> PodDisruptionBudget</span><br><span class="line"><span class="meta">&gt;</span> NetworkPolicy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加新的filters</span><br><span class="line">k8sgpt filters add PodDisruptionBudget</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从Active中的filters移除</span><br><span class="line">k8sgpt filters remove PodDisruptionBudget</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 与其它工具集成</span><br><span class="line"><span class="meta">#</span># 支持的工具列表</span><br><span class="line">➜ k8sgpt integrations list</span><br><span class="line">Active:</span><br><span class="line">Unused: </span><br><span class="line"><span class="meta">&gt;</span> trivy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 激活trivy</span><br><span class="line">k8sgpt integration activate trivy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> try</span><br><span class="line">k8sgpt analyze -b noopai --filter VulnerabilityReport</span><br></pre></td></tr></table></figure>
<hr>
<p>REF:<br>1.<a href="https://docs.k8sgpt.ai/" target="_blank" rel="noopener">https://docs.k8sgpt.ai/</a><br>2.<a href="https://docs.k8sgpt.ai/tutorials/playground/" target="_blank" rel="noopener">https://docs.k8sgpt.ai/tutorials/playground/</a><br>3.<a href="https://github.com/k8sgpt-ai/k8sgpt/blob/main/CONTRIBUTING.md" target="_blank" rel="noopener">https://github.com/k8sgpt-ai/k8sgpt/blob/main/CONTRIBUTING.md</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>k8sgpt</tag>
      </tags>
  </entry>
  <entry>
    <title>协程</title>
    <url>/2019/10/13/%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="普通函数与协程函数"><a href="#普通函数与协程函数" class="headerlink" title="普通函数与协程函数"></a>普通函数与协程函数</h4><p>有栈协程<br>无栈协程</p>
<p>共享栈<br>私有栈</p>
<p>对称协程<br>非对称协程</p>
<p><img src="http://img.hysyeah.top/2019/10/22/fun_and_coroutine.png" alt="image"></p>
<hr>
<p>Ref:<br>1.<a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Coroutine</a></p>
]]></content>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2018/07/31/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<pre><code>class Node:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

link = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8, Node(9)))))))))


def rev(link):
    p = link
    q = link.next
    p.next = None
    while q:
        r = q.next
        q.next = p
        p = q
        q = r
    return p

root = rev(link)
while root:
    print(root.data)
    root = root.next
</code></pre><hr>
<p><img src="http://img.hysyeah.top/wp-content/uploads/2018/07/reverse_list.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式(Singleton)-创建型</title>
    <url>/2018/08/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(Singleton)-%E5%88%9B%E5%BB%BA%E5%9E%8B/</url>
    <content><![CDATA[<p>单例模式保证类有且只有一个实例，并提供一个访问他的全局访问点。 1.</p>
<pre><code>class Singleton(object):
    def __new__(cls):
        if not hasattr(cls, &#39;instance&#39;):
            cls.instance = super(Singleton, cls).__new__(cls)
        return cls.instance

s = Singleton()
print(&quot;Object created&quot;, s)

s1 = Singleton()
print(&quot;Object created&quot;, s1)
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/single.png" alt> 2.</p>
<pre><code>class Singleton:
    __instance = None
    def __init__(self):
        if not Singleton.__instance:
            print(&quot; __init__ method called..&quot;)
        else:
            print(&quot;Instance already created:&quot;, self.getInstance())
    @classmethod
    def getInstance(cls):
        if not cls.__instance:
            cls.__instance = Singleton()
        return cls.__instance
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/single1.png" alt> 3. <img src="http://img.hysyeah.top/wp-content/uploads/2018/08/single3.png" alt> 4.有时候我们并不关心生成的实例是否具有同一id，而只关心其状态和行为方式。我们可以允许许多个实例被创建，但所有的实例都共享状态和行为方式：</p>
<pre><code>class Borg:
    __shared_state = {&quot;1&quot;:&quot;2&quot;}
    def __init__(self):
        self.x = 1
        self.__dict__ = self.__shared_state
        pass
b = Borg()
b1 = Borg()
b.x = 4
print(&quot;Borg Object &#39;b&#39;: &quot;, b)
print(&quot;Borg Object &#39;b1&#39;: &quot;, b1)
print(&quot;Object State &#39;b&#39;:&quot;, b.__dict__)
print(&quot;Object State &#39;b1&#39;:&quot;, b1.__dict__)
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/08/single4.png" alt> 或者使用<strong>new</strong>方法：</p>
<pre><code>In [16]: class Borg(object):
             _shared_state = {}
             def __new__(cls, *args, **kwargs):
                 obj = super(Borg, cls).__new__(cls, *args, **kwargs)
                 obj.__dict__ = cls._shared_state
                 return obj
</code></pre><hr>
<p>4.元类实现</p>
<pre><code># 当我们调用Logger()初始化Logger时，将会调用类MetaSingleton中的__call__方法
In [1]: class MetaSingleton(type):
            _instances = {}
            def __call__(cls, *args, **kwargs):
                if cls not in cls._instances:
                    cls._instances[cls] = super(MetaSingleton, cls).__call__(*args, **kwargs)
                return cls._instances[cls]
       class Logger(metaclass=MetaSingleton):
           pass


In [2]: l1 = Logger()

In [3]: l2 = Logger()

In [4]: id(l1)
Out[4]: 140568820684616

In [5]: id(l2)
Out[5]: 140568820684616
</code></pre><hr>
<p>线程安全的写法：</p>
<pre><code>In [9]: def synchronized(func):
   ...:     func.__lock__ = threading.Lock()
   ...:
   ...:     def synced_func(*args, **kws):
   ...:         with func.__lock__:
   ...:             return func(*args, **kws)
   ...:
   ...:     return synced_func
   ...:
   ...:

In [10]: def Singleton(cls):
    ...:     instances = {}
    ...:
    ...:     @synchronized
    ...:     def get_instance(*args, **kw):
    ...:         if cls not in instances:
    ...:             instances[cls] = cls(*args, **kw)
    ...:         return instances[cls]
    ...:
    ...:     return get_instance
    ...:
    ...:

In [11]: @Singleton
    ...: class test():
    ...:     a = 1
    ...:

In [12]: s = test()

In [13]: s1 = test()

In [14]: id(s)
Out[14]: 140308601028336

In [15]: id(s1)
Out[15]: 140308601028336
</code></pre><p>实用场景： 1.数据库连接 2.应用健康检测 3.许多需要创建一个对象的场景，如线程池，缓存，对话框，等等。</p>
<hr>
<p>优点： 通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。 缺点： 全局变量可能会在某一处被修改，一个同一对象存在多个引用，所有依赖于全局变量的类都会紧密耦合，因为一个类对全局数据的更改可能会无意中影响另一个类 Ref： 1.<a href="https://www.amazon.com/Learning-Python-Design-Patterns-Second/dp/178588803X/ref=sr_1_1_sspa?ie=UTF8&amp;qid=1533132340&amp;sr=8-1-spons&amp;keywords=Learning+Python+Design+Patterns&amp;psc=1" target="_blank" rel="noopener">Learning Python Design Patterns</a> 2.<a href="https://www.cnblogs.com/baiyb/p/8506438.html" target="_blank" rel="noopener">https://www.cnblogs.com/baiyb/p/8506438.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>启动docker hadoop集群失败</title>
    <url>/2018/02/01/%E5%90%AF%E5%8A%A8docker%20hadoop%E9%9B%86%E7%BE%A4%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<pre><code>启动hadoop发生失败，查看日志文件
docker hadoop Does not contain a valid host:port authority 

从google得知，网络信息不能带下划线
</code></pre><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><h5 id="1-docker-network-ls"><a href="#1-docker-network-ls" class="headerlink" title="1.docker network ls"></a>1.docker network ls</h5><pre><code>发现docker网络中NAME:dockerpro_sparknet中含有下划线
NETWORK ID          NAME                 DRIVER              SCOPE
321147ce790d        bridge               bridge              local
0fd542a85347        dockerpro_hsnet      bridge              local
fa6a55dd5ed3        dockerpro_sparknet   bridge              local
</code></pre><h5 id="2-docker-network-create-d-bridge-—subnet-192-168-2-0-24-sparknet"><a href="#2-docker-network-create-d-bridge-—subnet-192-168-2-0-24-sparknet" class="headerlink" title="2.docker network create -d bridge —subnet 192.168.2.0/24 sparknet"></a>2.docker network create -d bridge —subnet 192.168.2.0/24 sparknet</h5><h5 id="3-在docker-compose-yml中引用已创建的网络"><a href="#3-在docker-compose-yml中引用已创建的网络" class="headerlink" title="3.在docker-compose.yml中引用已创建的网络"></a>3.在docker-compose.yml中引用已创建的网络</h5><pre><code>networks:
  default:
    external:
      name: sparknet


version: &#39;2&#39;
services:
  master:
    image: hyspark
    networks:
      default:
        ipv4_address: 192.168.2.10
</code></pre><h5 id="4-重新启动hadoop集群"><a href="#4-重新启动hadoop集群" class="headerlink" title="4.重新启动hadoop集群"></a>4.重新启动hadoop集群</h5><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/02/hdfsreport.png" alt="image"></p>
<hr>
<p>这问题够坑的。。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>在客户机添加路由访问docker集群服务</title>
    <url>/2018/05/17/%E5%9C%A8%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E8%AE%BF%E9%97%AEdocker%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>在局域网(网段为10.68.2.0/24)中通过docker搭建了spark服务，docker容器的网段为192.168.2.0/24。 在相同网段的客户机中要访问docker容器中的服务，可以在客户机添加路由</p>
<pre><code># linux环境下 10.68.2.xx:为网关，也就是搭建服务电脑的ip
sudo route add -net 192.168.2.0 netmask 255.255.255.0 gw 10.68.2.xx

# windows环境下
route add 192.168.0.0 mask 255.255.0.0 10.68.2.xxx
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>寻找数组中字符串最长公共前缀</title>
    <url>/2018/09/12/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<pre><code># 外层循环为列表中第一个元素的长度，内层循环为列表元素的个数
# 即列表的长度
def LongestCommonPrefix(lst):
    if not lst:
        return &quot;&quot;
    else:
        index = 0
        for i in range(len(lst[0])):
            for j in range(1, len(lst)):
                if i &gt;= len(lst[j]) or lst[0][i] != lst[j][i]:
                    return lst[0][:index]
            index += 1
        return lst[0][:index]



In [2]: lst = [&quot;abcdefg&quot;, &quot;abcdefghijk&quot;, &quot;abcdfghijk&quot;, &quot;abcef&quot;]

In [3]: print(LongestCommonPrefix(lst))
abc
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>定义一个可以通过属性访问的字典</title>
    <url>/2017/09/15/%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<pre><code>In [6]: class attrdict(dict):
...:        def __getattr__(self, attr):
...:            try:
...:                return self[attr]
...:            except KeyError:
...:                raise AttributeError(attr)
...:

In [7]: op = attrdict(AND=&#39;and&#39;,OR=&#39;or&#39;)

In [8]: op
Out[8]: {&#39;AND&#39;: &#39;and&#39;, &#39;OR&#39;: &#39;or&#39;}

In [9]: op.AND
Out[9]: &#39;and&#39;

In [10]: op.OR
Out[10]: &#39;or&#39;
</code></pre><hr>
<p>Ref:<br>1.<a href="https://github.com/coleifer/peewee" target="_blank" rel="noopener">来自peewee源码</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>将sympy.plotting转换为matplotlib.pyplot</title>
    <url>/2018/06/27/%E5%B0%86sympy.plotting%E8%BD%AC%E6%8D%A2%E4%B8%BAmatplotlib.pyplot/</url>
    <content><![CDATA[<pre><code># -*- coding: utf-8 -*-


from sympy import symbols
from sympy.plotting import plot, plot_implicit
import matplotlib.pyplot as plt

def move_sympyplot_to_axes(p, ax):
    backend = p.backend(p)
    backend.ax = ax
    backend.process_series()
    backend.ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)
    backend.ax.spines[&#39;bottom&#39;].set_position(&#39;zero&#39;)
    backend.ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)
    plt.close(backend.fig)

x = symbols(&#39;x&#39;)
p1 = plot((x**2,(x,-2,2)),(x,(x,-4,4)),legend=True, show=False)
p1[1].line_color = &#39;r&#39;
p2 = plot((1/x,(x,-4,4)),ylim=(-2,2),legend=True, show=False)


fig,(ax,ax2) = plt.subplots(ncols=2)
move_sympyplot_to_axes(p1,ax)
move_sympyplot_to_axes(p2, ax2)
plt.show()
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/some_graf.png" alt></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>将图像转换为excel表格</title>
    <url>/2018/06/15/%E5%B0%86%E5%9B%BE%E5%83%8F%E8%BD%AC%E6%8D%A2%E4%B8%BAexcel%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<p>原理：将图像中的每一个点映射到excel中的每一个单元格 安装：PIL, openpyxl 步骤： 1.使用PIL读取图像 2.使用openpyxl将一个个像素点写入到excel文件 中</p>
<pre><code># -*- coding: utf-8 -*-
# 将图像转换为excel文件，一个像素点对应一个单元格
import re
import openpyxl
from PIL import Image
from openpyxl.styles import PatternFill

# 因为通过PIL获取到的像素点是元组，所以将元组转换为FFEEFFDD格式的字符串
def tuple2str(t):
    lst = [&#39;{0:#0{1}x}&#39;.format(elt, 4) for elt in t]
    s = &#39;&#39;.join(lst)
    return re.sub(&#39;0x&#39;, &#39;&#39;, s).upper()

# 设置填充的颜色
def fill_color(s):
    color = PatternFill(fgColor=s, bgColor=&#39;00000000&#39;,fill_type=&#39;solid&#39;)
    return color

wb = openpyxl.Workbook()
ws = wb.active

im = Image.open(&#39;t.jpg&#39;)
# 循环将像素点写入excel
for i in range(0,im.size[-1]):
    for j in range(0,im.size[0]):
        pixel = im.getpixel((j,i))
        pixel_str = tuple2str(pixel)
        print(i,j,pixel_str)
        color = fill_color(pixel_str)
        d = ws.cell(row=i+1, column=j+1)
        d.fill = color

for col in ws.columns:
    column = col[0].column
    ws.column_dimensions[column].width=1

for row in ws.rows:
    row = row[0].row
    ws.row_dimensions[row].height=1
wb.save(&#39;out.xlsx&#39;)
</code></pre><p><a href="https://github.com/hys20151008/7788/blob/master/image2excel.py" target="_blank" rel="noopener">完整代码</a></p>
<hr>
<p>输入图像为： <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/img2excel.jpg" alt> 输出excel: <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/excelimg.png" alt></p>
<hr>
<p>Ref： 一则新闻</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式(Factory Pattern)-创建型</title>
    <url>/2018/09/25/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F(Factory%20Pattern)-%E5%88%9B%E5%BB%BA%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="简单工厂设计模式：这允许接口创建对象而不暴露对象创建逻辑"><a href="#简单工厂设计模式：这允许接口创建对象而不暴露对象创建逻辑" class="headerlink" title="简单工厂设计模式：这允许接口创建对象而不暴露对象创建逻辑"></a>简单工厂设计模式：这允许接口创建对象而不暴露对象创建逻辑</h4><p>当客户端调用create_type()方法时，工厂会根据type参数的不同，返回Product1或者Product2。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/08/simple-factory-pattern.png" alt></p>
<pre><code>from abc import ABCMeta, abstractmethod
class Animal(metaclass = ABCMeta):
    @abstractmethod
    def do_say(self):
        pass

class Dog(Animal):
    def do_say(self):
        print(&quot;Bhow Bhow!!&quot;)

class Cat(Animal):
    def do_say(self):
        print(&quot;Meow Meow!!&quot;)

class ForestFactory:
    def make_sound(self, obj_type):
        return eval(obj_type)().do_say() #根据类型直接调用不同的方法

if __name__ == &#39;__main__&#39;:
    ff = ForestFactory()
    ff.make_sound(&#39;Cat&#39;)

[out]:Meow Meos!!                   # 根据不同的参数返回不同的对象，打印不同的信息
</code></pre><hr>
<h4 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h4><p>提供接口创建对象，但是推迟对子类决定使用哪个类产生对象。定义了一个创建对象的接口，但不是工厂负责创建对象，而是将责任推迟到决定要实例化的类的子类。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/08/factory-method-pattern.png" alt></p>
<pre><code>from abc import ABCMeta, abstractmethod
class Section(metaclass=ABCMeta):
    @abstractmethod
    def describe(self):
        pass


class PersonalSection(Section):
    def describe(self):
        print(&quot;Personal Section&quot;)


class AlbumSection(Section):
    def describe(self):
        print(&quot;Album Section&quot;)


class PatentSection(Section):
    def describe(self):
        print(&quot;Patent Section&quot;)


class PublicationSection(Section):
    def describe(self):
        print(&quot;Publication Section&quot;)


class Profile(metaclass=ABCMeta):
    def __init__(self):
        self.sections = []
        self.createProfile()
    @abstractmethod
    def createProfile(self):
        pass
    def getSections(self):
        return self.sections
    def addSections(self, section):
        self.sections.append(section)


class linkedin(Profile):
    def createProfile(self):
        self.addSections(PersonalSection())
        self.addSections(PatentSection())
        self.addSections(PublicationSection())


class facebook(Profile):
    def createProfile(self):
        self.addSections(PersonalSection())
        self.addSections(AlbumSection())


if __name__ == &#39;__main__&#39;:
    profile_type = &#39;linkedin&#39;
    profile = eval(profile_type)()
    print(&quot;Creating profile..&quot;, type(profile).__name__)
    print(&quot;Profile has sections --&quot;, profile.getSections())
</code></pre><hr>
<h4 id="抽象工厂设计模式"><a href="#抽象工厂设计模式" class="headerlink" title="抽象工厂设计模式"></a>抽象工厂设计模式</h4><p>抽象工厂是创建相关对象而不指定/公开其类的接口。该模式提供另一个工厂的对象，该工厂在内部创建其他对象。抽象工厂模式的主要目标是提供一个接口来创建相关对象的族，而无需指定具体类。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/08/abstract-factory-pattern.png" alt></p>
<pre><code>from abc import ABCMeta, abstractmethod

class PizzaFactory(metaclass=ABCMeta):
    @abstractmethod
    def createVegPizza(self):
        pass

    @abstractmethod
    def createNonVegPizza(self):
        pass


class IndianPizzaFactory(PizzaFactory):
    def createVegPizza(self):
        return DeluxVeggiePizza()
    def createNonVegPizza(self):
        return ChickenPizza()


class USPizzaFactory(PizzaFactory):
    def createVegPizza(self):
        return MexicanVegPizza()
    def createNonVegPizza(self):
        return HamPizza()


class VegPizza(metaclass=ABCMeta):
    @abstractmethod
    def prepare(self, VegPizza):
        pass

class NonVegPizza(metaclass=ABCMeta):
    @abstractmethod
    def serve(self, NonVegPizza):
        pass


class DeluxVeggiePizza(VegPizza):
    def prepare(self):
        print(&quot;Prepare &quot;, type(self).__name__)


class ChickenPizza(NonVegPizza):
    def serve(self, VegPizza):
        print(type(self).__name__, &quot; is served with Chicken on &quot;, type(VegPizza).__name__)


class MexicanVegPizza(VegPizza):
    def prepare(self):
        print(&quot;Prepare &quot;, type(self).__name__)


class HamPizza(NonVegPizza):
    def serve(self, VegPizza):
        print(type(self).__name__, &quot; is served with Ham on &quot;, type(VegPizza).__name__)



class PizzaStore:
    def __init__(self):
        pass
    def makePizzas(self):
        for factory in [IndianPizzaFactory(), USPizzaFactory()]:
            self.factory = factory
            self.NonVegPizza = self.factory.createNonVegPizza()
            self.VegPizza = self.factory.createVegPizza()
            self.VegPizza.prepare()
            self.NonVegPizza.serve(self.VegPizza)



pizza = PizzaStore()
pizza.makePizzas()
</code></pre><hr>
<p>工厂方法和抽象工厂方法的区别 在面象对象编程中，工厂意味着负责创建其它类型对象的类 工厂方法模式：这允许接口创建对象，但是推迟对子类决定使用哪个类产生对象 抽象工厂模式：抽象工厂是创建相关对象而不指定/公开其类的接口。该模式提供另一个工厂的对象，该工厂在内部创建其他对象 工厂模式的优点： 1.松散耦合，其中对象创建可以独立于类实现 2.客户端不必知道具体实现，只需要知道接口，方法和传递参数就可以了 3.可以轻松地将另一个类添加到工厂以创建另一种类型的对象,客户端不用修改代码 4.可以重用已存在的对象</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>感知机-简介</title>
    <url>/2018/06/08/%E6%84%9F%E7%9F%A5%E6%9C%BA-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>定义(感知机) 假设输入空间(特征空间)是$ \chi \in \mathbf {R}^{n} $,输出空间是$ \mathcal{Y} ={+1,-1} $.输入$ x \in \chi $表示实例的特征向量，对应于输入空间的点，输出$ y \in \mathcal{Y} $表示实例的类别.由输入空间到输出空间的如下函数 $ f(x) = sign(w\cdot x + b)  $ 称为感知机.其中，w和b为感知机模型参数，$ w \in \mathbf {R}^{n} $叫作权值或权值向量，$ b \in \mathbf{R} $叫作偏置，$ w \cdot x $表示w和x的内积。sign是符号函数，即 <script type="math/tex">sign(x)= \begin{cases} +1,& {x \geq 0}\ \\ -1,& {x \le 0} \end{cases}</script> </p>
<p>感知机是一种线性分类模型，属于判别模型。感知机模型的假设空间是定义在特征空间中的所有线性分类模型或线性分类器，即函数集合$ {f|f(x)=w \cdot x + b} $</p>
<hr>
<p>感知机学习策略 定义(数据集的线性可分性) 给定一个数据集 $ T = {(x<em>{1},y</em>{1}),(x<em>{2},y</em>{2}),\cdot \cdot \cdot,(x<em>{N},y</em>{N})} $,其中，$ x<em>{i} \in \chi=\mathcal R^{n} $,$ y</em>{i} \in \chi ={+1,-1} i=1,2,\cdot \cdot \cdot,N $,如果存在某个超平面S $ w \cdot x +b = 0 $ 能够将数据集的正实例点和负实例点完全正确的划分到超平面的 两侧，即对所有$ y<em>{i}=+1 $的实例i,有$ w \cdot x</em>{i} &gt; 0 $,对所有$ y<em>{i}=-1 $的实例i，有$ w \cdot x</em>{i} \lt 0 $,则称数据集T为线性可分数据集；否则，称数据集T线性不可分。</p>
<hr>
<p>假设训练数据集是线性可分的，感知机学习的目标是求得一个能够将训练集正实例点和负实例点完全正确分开的分离超平面。感知机采用误分类点到超平面S的总距离作为损失函数。 输入空间中任一点到超平面S的距离： <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/plans_dist.png" alt> ||w||是w的L2范数。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/perception_loss_fun.png" alt></p>
<hr>
<p>Ref：<br>1.统计学习方法-李航</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>感知机算法的原始形式</title>
    <url>/2018/06/08/%E6%84%9F%E7%9F%A5%E6%9C%BA%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E5%A7%8B%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/perception_original.png" alt> 使用例2.1的数据点作为输入。</p>
<pre><code>class Perception:
    def __init__(self, learningrate):
        self.lr = learningrate         # 学习率
        self.wh = np.array([0.0, 0.0]) #初始化wh = [0.0, 0.0]
        self.b = 0

    def train(self,inputs, target):
        inputs = np.asarray(inputs)
        if self.check(inputs,target):        # 如果被误分类，则更新wh,b
            self.wh += self.lr * np.dot(inputs, target)
            self.b += target * self.lr
            print(self.wh, self.b)

    #判断是否被正确分类
    def check(self, inputs, target):
        flag = False
        res = 0.0
        res += (np.dot(inputs, self.wh)+self.b)*target
        if res &lt;=0:
            flag = True

        return flag
</code></pre><p>例2.1的迭代过程为 <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/perception_original2.png" alt> 程序输出迭代过程为： <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/perception_original3.png" alt></p>
<hr>
<p><a href="https://github.com/hys20151008/ml_python/blob/master/perception.py" target="_blank" rel="noopener">完整代码</a></p>
<hr>
<h5 id="scikit-learn实现"><a href="#scikit-learn实现" class="headerlink" title="scikit-learn实现"></a>scikit-learn实现</h5><pre><code>from sklearn.linear_model import Perceptron

# max_iter为最大迭代次数，eta0为学习率
perceptron = Perceptron(max_iter=1000, eta0=1)

# coef_init设置w初始向量，intercept_init设置初始参数b
p_fit = perceptron.fit(x, y, coef_init=np.array([[0.0, 0.0]]).reshape(-1,1),intercept_init=np.array([0]),sample_weight=np.array([1,1,1]))
# 对未知数据进行预测
p_fit.predict(np.array([4,4]).reshape(1,-1))
</code></pre><p>Ref：<br>1.统计学习方法-李航<br>2.<a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Perceptron.html#sklearn.linear_model.Perceptron.fit" target="_blank" rel="noopener">scikit-learn官方文档</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>感知机算法的对偶形式</title>
    <url>/2018/06/08/%E6%84%9F%E7%9F%A5%E6%9C%BA%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/perceptron_dual1.png" alt="image"> <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/perceptron_dual2.png" alt="image"> <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/perceptron_dual3.png" alt="image"> <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/perceptron_dual4.png" alt="image"></p>
<hr>
<pre><code> class PerceptionPair:
        #初始化一些参数学习率，gram矩阵等等
  7     def __init__(self, dataSet, target, learningrate=1):
  8         self.lr = learningrate
  9         self.a = np.zeros(len(dataSet), np.float)
 10         self.b = 0.0
 11         self.gram = np.matmul(np.array(dataSet), np.array(dataSet).T)
 12         self.target = target

 13     #计算判断是否误分类的值
 14     def calc(self,i):
 15         res = np.dot(self.a*self.target, self.gram[i])
 16         res = (res+self.b)*target[i]
 17         return res
 18
 19     def train(self, inputs, target):
 20         flag = False
 21         m = len(inputs)
 22         res = 0.0
 23         for i in range(m):
                # 进行权值更新
 24             if self.calc(i) &lt;= 0:
 25                 self.a[i] += self.lr
 26                 self.b += target[i]
 27                 print(self.a, self.b)
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/perceptron_dual5.png" alt="image"> <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/perceptron_pair.png" alt="image"></p>
<hr>
<p><a href="https://github.com/hys20151008/ml_python/blob/master/perceptron_pair.py" target="_blank" rel="noopener">完整代码</a> </p>
<p>Ref：<br>1.统计学习方法-李航</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>找出距离自己最近的指定元素</title>
    <url>/2018/09/05/%E6%89%BE%E5%87%BA%E8%B7%9D%E7%A6%BB%E8%87%AA%E5%B7%B1%E6%9C%80%E8%BF%91%E7%9A%84%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<pre><code># 找出距离H最近的G
# input lst = [&#39;H&#39;, &#39;H&#39;, &#39;G&#39;, &#39;H&#39;, &#39;G&#39;, &#39;H&#39;, &#39;H&#39;, &#39;G&#39;, &#39;H&#39;]
# output [2, 1, 0, 1, 0, 1, 1, 0, 1]  # 第一个&quot;H&quot;最近的&quot;G&quot;相差距离为2


lst = [&#39;H&#39;, &#39;H&#39;, &#39;G&#39;, &#39;H&#39;, &#39;G&#39;, &#39;H&#39;, &#39;H&#39;, &#39;G&#39;, &#39;H&#39;]


def find_min_distance(lst):
    lst = &#39;&#39;.join(lst)
    ret = []
    n = len(lst)
    for i in range(n):
        if lst[i] == &#39;G&#39;:
            ret.append(0)
            continue
        else:
            index1 = lst.find(&#39;G&#39;, i)
            index2 = lst[::-1].find(&#39;G&#39;, n-i)

            if index1 and index2:
                if abs(index1 - i) &lt; abs(index2-n+i+1):
                    ret.append(abs(index1-i))
                else:
                    ret.append(abs(index2-n+i+1))
            elif index1:
                ret.append(abs(index1-i))
            elif index2:
                ret.append(abs(index2-n+i))
    return ret

print(find_min_distance(lst))
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>执行go get出现 go: GOPATH entry is relative错误</title>
    <url>/2018/04/01/%E6%89%A7%E8%A1%8Cgo%20get%E5%87%BA%E7%8E%B0%20go%20GOPATH%20entry%20is%20relative%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<pre><code>将~/.zshrc文件中 
export GOPATH=&quot;/home/hys/mycode/go:/home/hys/mycode/go/gopl:$GOPATH&quot;

改为
export GOPATH=&quot;/home/hys/mycode/go:/home/hys/mycode/go/gopl&quot;
</code></pre>]]></content>
      <categories>
        <category>GO</category>
      </categories>
  </entry>
  <entry>
    <title>搭建安全Docker Registry</title>
    <url>/2018/01/23/%E6%90%AD%E5%BB%BA%E5%AE%89%E5%85%A8Docker%20Registry/</url>
    <content><![CDATA[<pre><code>1.安装registry
docker pull registry

2.制作证书
openssl req -newkey rsa:2048 -nodes -sha256 -keyout certs/domain.key -x509 -days 365 -out certs/domain.crt
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/01/ca.png" alt="image"></p>
<pre><code>3.docker run -d -p 5000:5000 --restart=always --name registry \
  -v /data/registry:/var/lib/registry \
  -v /certs:/certs \
  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \
  -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \

.4.在客户端安装证书
sudo mkdir -p /etc/docker/certs.d/d.img.hysyeah.top:5000
sudo cp domain.crt /etc/docker/certs.d/d.img.hysyeah.top:5000/ca.crt
sudo service docker restart

5.docker pull busybox

6.docker tag busybox d.img.hysyeah.top:5000/busybox 

7.docker push d.img.hysyeah.top:5000/busybox
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>一个操作系统的实现笔记：引导扇区实现</title>
    <url>/2020/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>实验环境：<br>   · ubuntu18.04<br>   · qemu<br>   · nasm</p>
<p>1.安装需软件</p>
<ul>
<li><p>qemu安装，请<a href="https://123xzy.github.io/2019/03/08/MIT-6-828-Lab-Guide/" target="_blank" rel="noopener">参考</a></p>
</li>
<li><p>nasm安装 <code>sudo apt-get install nasm</code></p>
</li>
</ul>
<p>2.编写引导扇区代码<code>a.asm</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	org	07c00h			; 告诉编译器程序加载到7c00处</span><br><span class="line">	mov	ax, cs</span><br><span class="line">	mov	ds, ax</span><br><span class="line">	mov	es, ax</span><br><span class="line">	call	DispStr			; 调用显示字符串例程</span><br><span class="line">	jmp	$			; 无限循环</span><br><span class="line">DispStr:</span><br><span class="line">	mov	ax, BootMessage ;将字符串首地址传递给寄存器ax</span><br><span class="line">	mov	bp, ax			; ES:BP = 串地址,指向BootMessage</span><br><span class="line">	mov	cx, 16			; CX = 串长度</span><br><span class="line">	mov	ax, 01301h		; AH = 13,  AL = 01h</span><br><span class="line">	mov	bx, 000ch		; 页号为0(BH = 0) 黑底红字(BL = 0Ch,高亮)</span><br><span class="line">	mov	dl, 0</span><br><span class="line">	int	10h			; 10h 号中断</span><br><span class="line">	ret</span><br><span class="line">BootMessage:		db	&quot;Hello, OS world!&quot;</span><br><span class="line">times 	510-($-$$)	db	0	; 填充剩下的空间，使生成的二进制代码恰好为512字节;表示将这个字节重复510-($-$$)遍。</span><br><span class="line">dw 	0xaa55				; 结束标志</span><br></pre></td></tr></table></figure></p>
<p>代码分析<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$表示当前行被汇编后的地址</span><br><span class="line">$$表示一个节(section)的开始处被汇编后的地址。在这里,我们的程序只有1个节,所以$$实际上就表示程序被编译后的开始地址。</span><br><span class="line"></span><br><span class="line">从第10行开始为调用10hk号中断做准备(10h号中断是由BIOS对显示提供的服务),设置寄存器的值</span><br><span class="line">AH:往屏幕中写入字符串</span><br><span class="line">AL:写模式,bit 0(0位置零):写入字符串后更新光标; bit 1(1位置1):字符串中包括字符和属性;bit 2-7为保留位</span><br><span class="line">BH: 页码</span><br><span class="line">BL:如果字符串只包括characters,BL为字符串的属性</span><br><span class="line">CX:字符串长度</span><br><span class="line">DH,DL: 写字符串的起始列与行</span><br></pre></td></tr></table></figure></p>
<p>3.生成启动镜像<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nasm a.asm -o a.bin</span><br><span class="line">dd if=a.bin of=a.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure></p>
<p>4.使用<code>QEMU</code>引导软盘映像文件<code>a.img</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./qemu-system-i386 -hda /home/hys/code/6828/src/orange/ch1/a.img  # 根据自己情况适当修改文件路径</span><br></pre></td></tr></table></figure></p>
<p>启动后效果如下：<br><img src="http://img.hysyeah.top/2020/1/10/qemu-boot-hello-os-world.png" alt="image"></p>
<p>至此一个简单的”操作系统”已经完成。</p>
<hr>
<p>5.调试我们写的引导扇区代码</p>
<ul>
<li><p>启动qemu,等待gdb连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -hda /home/hys/code/6828/src/orange/ch1/a.img -gdb tcp::26000 -S</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动gdb<code>gdb -n -x .gdbinit</code>,设置断点,观察寄存器的值<br><code>p/x $cs</code>显示寄存器<code>cs</code>的值</p>
</li>
</ul>
<p><code>.gdbinit</code>文件内容：设置<code>gdb</code>连接到时<code>QEMU</code>并调试早期启动的16位代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set $lastcs = -1</span><br><span class="line"></span><br><span class="line">define hook-stop</span><br><span class="line">  # There doesn&apos;t seem to be a good way to detect if we&apos;re in 16- or</span><br><span class="line">  # 32-bit mode, but we always run with CS == 8 in 32-bit mode.</span><br><span class="line">  if $cs == 8 || $cs == 27</span><br><span class="line">    if $lastcs != 8 &amp;&amp; $lastcs != 27</span><br><span class="line">      set architecture i386</span><br><span class="line">    end</span><br><span class="line">    x/i $pc</span><br><span class="line">  else</span><br><span class="line">    if $lastcs == -1 || $lastcs == 8 || $lastcs == 27</span><br><span class="line">      set architecture i8086</span><br><span class="line">    end</span><br><span class="line">    # Translate the segment:offset into a physical address</span><br><span class="line">    printf &quot;[%4x:%4x] &quot;, $cs, $eip</span><br><span class="line">    x/i $cs*16+$eip</span><br><span class="line">  end</span><br><span class="line">  set $lastcs = $cs</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">echo + target remote localhost:26000\n</span><br><span class="line">target remote localhost:26000</span><br><span class="line"># If this fails, it&apos;s probably because your GDB doesn&apos;t support ELF.</span><br><span class="line"># Look at the tools page at</span><br><span class="line">#  http://pdos.csail.mit.edu/6.828/2009/tools.html</span><br><span class="line"># for instructions on building GDB with ELF support.</span><br><span class="line">echo + symbol-file obj/kern/kernel\n</span><br><span class="line">symbol-file obj/kern/kernel</span><br></pre></td></tr></table></figure></p>
<p>gdb相关命令请查看<a href="http://visualgdb.com/gdbreference/commands/" target="_blank" rel="noopener">http://visualgdb.com/gdbreference/commands/</a></p>
<p>Ref：<br>1.<a href="https://123xzy.github.io/2019/03/08/MIT-6-828-Lab-Guide/" target="_blank" rel="noopener">https://123xzy.github.io/2019/03/08/MIT-6-828-Lab-Guide/</a><br>2.<a href="https://book.douban.com/subject/3735649/" target="_blank" rel="noopener">Orange’S：一个操作系统的实现</a><br>3.<a href="https://jlk.fjfi.cvut.cz/arch/manpages/man/qemu.1" target="_blank" rel="noopener">qemu</a><br>4.<a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener">gdb</a><br>5.<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm" target="_blank" rel="noopener">Intel 80386 Reference Programmer’s Manual</a><br>7.<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/" target="_blank" rel="noopener">lab1</a><br>8.<a href="http://www.ctyme.com/intr/rb-0210.htm" target="_blank" rel="noopener">Interrupts</a><br>9.<a href="https://en.wikipedia.org/wiki/INT_10H" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/INT_10H</a><br>10.<a href="http://visualgdb.com/gdbreference/commands/x" target="_blank" rel="noopener">http://visualgdb.com/gdbreference/commands/x</a></p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机--线性可分支持向量机</title>
    <url>/2018/06/23/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA--%E7%BA%BF%E6%80%A7%E5%8F%AF%E5%88%86%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<p>支持向量机(support vector machines, SVM)是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机包括核技巧，这使它成为实质上的非线性分类器。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题，支持向量机的学习算法是求解凸二次规划的最优化算法。</p>
<hr>
<p>支持向量机学习方法包含由构建由简至繁的模型：线性可分支持向量机，线性支持向量机及非线性支持向量机。 给定线性可分线性训练数据集，通过间隔最大化或等价的求解相应的凸二次规划问题学习得到的分离超平面为 <script type="math/tex">w^{*} \cdot x + b^{*} = 0</script> 以及相应的分类决策函数<script type="math/tex">f(x) = sign(w^{*} \cdot x + b^{*})</script>称为线性可分支持向量机。</p>
<hr>
<p>(函数间隔) 对于给定的训练数据集T和超平面(w,b),定义超平面(w,b)关于样本点$ (x<em>{i},y</em>{i}) $的函数间隔为 $ \hat{\gamma}<em>{i} = y</em>{i}(w \cdot x<em>{i} + b) $ 定义超平面(w, b)关于训练数据集T的函数间隔为超平面(w,b)关于T中所有样本点$ (x</em>{i},y<em>{i}) $的函数间隔之最小值，即 $ \hat{\gamma} = \min</em>{i=1,\cdot \cdot \cdot,N} \hat{\gamma}_{i} $</p>
<hr>
<p>(几何间隔) 对于给定的训练数据集T和超平面(w,b),定义超平面(w,b)关于样本点$ (x<em>{i},y</em>{i}) $的几何间隔为 $ \gamma<em>{i} = y</em>{i}\bigg(\frac{w}{||w||} \cdot x<em>{i} + \frac{b}{||w||}\bigg) $ 定义超平面(w, b)关于训练数据集T的函数间隔为超平面(w,b)关于T中所有样本点$ (x</em>{i},y<em>{i}) $的几何间隔之最小值，即 $ \gamma = \min</em>{i=1,\cdot \cdot \cdot,N} \gamma_{i} $</p>
<hr>
<p>函数间隔和几何间隔有如下关系： $ \gamma<em>{i} = \frac{\hat{\gamma}</em>{i}}{||w||} $<br>$ \gamma = \frac{\hat{\gamma}}{||w||} $</p>
<hr>
<p>间隔最大化 支持向量机的基本思想是求解能够正确划分训练数据集并且几何间隔最在的分离超平面. 对线性可分的训练数据集而言，线性可分分离超平面有无穷多个(等价于感知机),但是几何 间隔最大化的分离超平面是唯一的。这里的间隔最大化又称为硬间隔最大化(与训练数据集近似线性可分时的软间隔最大化相对应)</p>
<hr>
<p>凸优化问题是指约束最优化问题： $ \min<em>{w} f(w) $ s.t. $ g</em>{i}(w) \le 0, i=1,2,\cdot \cdot \cdot,k $<br>$ h<em>{i}(w) = 0, i=1,2,\cdot \cdot \cdot,l $ 其中，目标函数f(w)和约束函数$ g</em>{i}(w) $都是$ R^{n} $上的连续可微的凸函数，约束函数$ h<em>{i}(w) $是$ R^{n} $上的仿射函数。<br>当目标函数f(w)是二次函数且约束函数$ g</em>{i}(w) $是仿射函数时，上述凸最优化问题成为凸二次规划问题。</p>
<hr>
<h4 id="线性可分支持向量机学习算法—-最大间隔法"><a href="#线性可分支持向量机学习算法—-最大间隔法" class="headerlink" title="线性可分支持向量机学习算法—-最大间隔法"></a>线性可分支持向量机学习算法—-最大间隔法</h4><p>输入：线性可分训练数据集$ T = {(x<em>{1},y</em>{1}),(x<em>{2},y</em>{2}),\cdot \cdot \cdot, (x<em>{N},y</em>{N})} $,其中，$ x<em>{i} \in \mathcal=R^{n},y</em>{i}={-1,+1}, i=1,2,\cdot \cdot \cdot,N $;<br>输出：最大间隔分离超平面和分类决策函数<br>(1)构造并求解约束最优化问题：<br>$ \min<em>{w,b}^{} \frac{||w||^2}{2} $<br>s.t.<br>$ y</em>{i}(w \cdot x_{i}+b)-1 \ge 0, i=1,2,\cdot \cdot \cdot,N $ 求得最优解<script type="math/tex">w^{*},b^{*}</script>  </p>
<p>(2)由此得到的分离超平面：  </p>
<script type="math/tex; mode=display">w^* \cdot x + b^* = 0</script><p>分类决策函数：  </p>
<script type="math/tex; mode=display">f(x) = sign(w^* \cdot x + b^*)</script><hr>
<p>(定理) (最大间隔分离超平面的存在唯一性)若训练数据集T线性可分，则可将训练数据集中的样本点完全正确分开的最大间隔分离超平面存在且唯一。</p>
<hr>
<p>例：已知一个如下图所示的训练数据集，其正例点是$ x<em>{1}=(3,3)^T,x</em>{2}=(4,3)^T $,负实例点是$ x<em>{3}=(1, 1)^T $,试求最大间隔分离超平面。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/7.1figure.png" alt="image"> <a href="https://github.com/hys20151008/7788/blob/master/7.1.py" target="_blank" rel="noopener">图片代码</a> 按照最大间隔法，根据训练数据集构造约束最优化问题：<br>$ \min</em>{w,b} \frac{1}{2}(w<em>{1}^2+w</em>{2}^2) $<br>s.t.<br>$ 3w<em>{1} + 3w</em>{2}+b \ge 1 $<br>$ 4w<em>{1} + 3w</em>{2}+b \ge 1 $<br>$ -w<em>{1} - w</em>{2}-b \ge 1 $</p>
<hr>
<pre><code>import cvxpy as cvx

w1 = cvx.Variable()
w2 = cvx.Variable()
b  = cvx.Variable()

#约束条件
constraints = [3*w1+3*w2+b&gt;=1,4*w1+3*w2+b&gt;=1,-w1-w2-b&gt;=1]
#目标函数
obj = cvx.Minimize((w1**2+w2**2)/2)


prob = cvx.Problem(obj, constraints)
prob.solve()


print(&quot;w1=&quot;,w1.value)
print(&quot;w2=&quot;,w2.value)
print(&quot;b=&quot;,b.value)
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/dualprograming.png" alt> 求解得最优化解为$ w<em>{1}=w</em>{2}=\frac{1}{2}, b=-2 $,最大间隔分离超平面为$ \frac{1}{2}x^{(1)} +\frac{1}{2}x^{(1)}-1=0 $，其中 $ x<em>{1}=(3,3)^T,x</em>{3}=(1,1)^T $为支持向量。</p>
<hr>
<h3 id="学习的对偶算法"><a href="#学习的对偶算法" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><p>未完待续</p>
<hr>
<p>Ref：<br>1.统计学习方法<br>2.cvxpy</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>最大似然估计</title>
    <url>/2018/06/26/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<p>若总体X属于离散型，其分布律$ P{X=x} = p(x;\theta),\theta \in \Theta $的形式为已知，$ \theta $为待估参数，$ \Theta $为$ \theta $可能取值的范围。设$ X<em>{1},X</em>{2},\cdot \cdot \cdot, X<em>{n} $是来自X的样本，则$ X</em>{1},X<em>{2},\cdot \cdot \cdot, X</em>{n} $的联合分布律为<br>$ \prod<em>{i=1}^n p(x</em>{i};\theta) $ 又设$ x<em>{1},x</em>{2},\cdot \cdot \cdot, x<em>{n} $是相应于样本$ X</em>{1},X<em>{2},\cdot \cdot \cdot, X</em>{n} $的一个样本值。易知样本$ X<em>{1},X</em>{2},\cdot \cdot \cdot, X<em>{n} $取到观察值$ x</em>{1},x<em>{2},\cdot \cdot \cdot, x</em>{n} $的概率，亦即事件$ { X<em>{1} = x</em>{1}, X<em>{2}=x</em>{2},\cdot \cdot \cdot, X<em>{n}=x</em>{n}} $发生的概率为<br>$ L(\theta)=L(x<em>{1},x</em>{2},\cdot \cdot \cdot,x<em>{n};\theta) = \prod</em>{i=1}^np(x<em>{i};\theta), \theta \in \Theta $<br>这一概率随$ \theta $的取值而变化，它是$ \theta $的函数，$ L(\theta) $称为样本的似然函数。<br>最大似然估计法就是固定样本观察值$ x</em>{1},x<em>{2},\cdot \cdot \cdot, x</em>{n} $,在$ \theta $的取值范围$ \Theta $内挑选使似然函数$ L(x<em>{1},x</em>{2},\cdot \cdot \cdot,x<em>{n};\hat \theta)=\max</em>{\theta \in \Theta}L(x<em>{1},x</em>{2},\cdot \cdot \cdot,x<em>{n};\theta) $ 这样得到的$ \hat \theta $与样本值$ x</em>{1},x<em>{2},\cdot \cdot \cdot, x</em>{n} $有关，常记为$ \hat \theta (x<em>{1},x</em>{2},\cdot \cdot \cdot, x<em>{n}) $,称为参数$ \theta $的最大似然估计值，而相应的统计量$ \hat \theta (X</em>{1},X<em>{2},\cdot \cdot \cdot, X</em>{n}) $称为参数$ \theta $的最大似然估计量。</p>
<hr>
<p>若总体X属于连续型，其概率密度$ f(x;\theta),\theta \in \Theta $的形式为已知，$ \theta $为待估参数，$ \Theta $为$ \theta $可能取值的范围。设$ X<em>{1},X</em>{2},\cdot \cdot \cdot, X<em>{n} $是来自X的样本，则$ X</em>{1},X<em>{2},\cdot \cdot \cdot, X</em>{n} $的联合密度为<br>$ \prod<em>{i=1}^n f(x</em>{i};\theta) $ 又设$ x<em>{1},x</em>{2},\cdot \cdot \cdot, x<em>{n} $是相应于样本$ X</em>{1},X<em>{2},\cdot \cdot \cdot, X</em>{n} $的一个样本值，则随机点($ X<em>{1},X</em>{2},\cdot \cdot \cdot, X<em>{n} $)落在点$ x</em>{1},x<em>{2},\cdot \cdot \cdot, x</em>{n} $的邻域(边长分别为$ dx<em>{1},dx</em>{2},\cdot \cdot \cdot, dx<em>{n} $的n维立方体)内的概率近似的为<br>$ \prod</em>{i=1}^n f(x<em>{i};\theta)dx</em>{i} $<br>其值随$ \theta $的取值而变化，与离散型的情况一样，我们取$  \theta $估计值$ \hat \theta $使概率取到最大值，但因子$ \prod<em>{i=1}^{n}dx</em>{i} $不随$ \theta $而变，故只需考虑函数<br>$ L(\theta)=L(x<em>{1},x</em>{2},\cdot \cdot \cdot,x<em>{n};\theta) = \prod</em>{i=1}^nf(x<em>{i};\theta) $的最大值。<br>若$ L(x</em>{1},x<em>{2},\cdot \cdot \cdot,x</em>{n};\hat \theta)=\max<em>{\theta \in \Theta}L(x</em>{1},x<em>{2},\cdot \cdot \cdot,x</em>{n};\theta) $，则称$ \hat \theta (x<em>{1},x</em>{2},\cdot \cdot \cdot, x<em>{n}) $为$ \theta $的最大似然估计值，称$ \hat \theta (X</em>{1},X<em>{2},\cdot \cdot \cdot, X</em>{n}) $称为参数$ \theta $的最大似然估计量</p>
<hr>
<p>例：设$ X \sim b(1,p). X<em>{1},X</em>{2},\cdot \cdot \cdot,X_{n} $是来自X的一个样本，试求参数p的最大似然估计值。<br><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/max_likehood_example.jpg" alt></p>
<hr>
<p>最大似然估计就是通过已知的样本点来求得求似然函数取值最大的参数$ \theta $,通常采用牛顿法和梯度下降法求解。 </p>
<p>Ref： 1.概率论与数理统计</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>朴素贝叶斯法</title>
    <url>/2018/06/23/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/</url>
    <content><![CDATA[<p>1.条件概率(定义): 设A，B两 个事件，且P(A)&gt;0,称 $ P(B|A) = \frac{P(AB)}{P(A)} $为事件A发生的条件下事件B发生的概率。 </p>
<p>2.全概率公式： 设试验E的样本空间为S， A为E的事件，$ B<em>{1},B</em>{2}, \cdot \cdot \cdot,B<em>{n} $为S的一个划分，且$ P(B</em>{i})&gt;0 (i=1,2,\cdot \cdot \cdot,n) $,则 $ P(A) = P(A|B<em>{1})P(B</em>{1})+P(A|B<em>{2})P(B</em>{2})+\cdot \cdot \cdot + P(A|B<em>{n})P(B</em>{n}) $，称为全概率公式。</p>
<p> 3.贝叶斯公式：设试验E的样本空间为S。A为E的事件，$ B<em>{1},B</em>{2}, \cdot \cdot \cdot,B<em>{n} $为S的一个划分,且$ P(A)&gt;0,P(B</em>{i})&gt;0 (i=1,2,\cdot \cdot \cdot,n) $,则 $ P(B<em>{i}|A) = \frac{P(A|B</em>{i})P(B<em>{i})}{\sum</em>{j=1}^nP(A|B<em>{j})P(B</em>{j})},i=1,2, \cdot \cdot \cdot, n. $称为贝叶斯公式。</p>
<hr>
<p>朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的联合概率分布；然后基于此模型，对给定的输入x,利用贝叶斯定理求出后验概率大的输出y。朴素贝叶斯法实现简单，学习与预测的效率都很高，是种常用的方法。</p>
<hr>
<h3 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h3><p>输入：训练数据$ T = {(x<em>{1},y</em>{1}),(x<em>{2},y</em>{2}),\cdot \cdot \cdot,(x<em>{N},y</em>{N})} $,其中$ x<em>{i} = (x</em>{i}^{(1)},x<em>{i}^{(2)},\cdot \cdot \cdot, x</em>{i}^{(n)})^T $,$ x<em>{i}^{(j)} $是第i个样本的第j个特征，$ x</em>{i}^{(j)} \in {a<em>{j1},a</em>{j2},\cdot \cdot \cdot,a<em>{js_j}} $,$ a\</em>{jl} $是第j个特征可能取的第l个值，$ j = 1,2,\cdot \cdot \cdot,n, l= 1, 2,\cdot \cdot \cdot, S<em>j, y</em>{i} \in {c<em>{1},c</em>{2}, \cdot \cdot \cdot ,c<em>{k}} $;实例x;<br>输出：实例x的分类。<br>（1）计算先验概率及条件概率<br>$ P(Y=c</em>{k})=\frac{\sum<em>{i=1}^{N}I(y</em>{i}=c<em>{k})}{N}, k=1,2,\cdot \cdot \cdot,K $ $ P(X^{(j)}=a</em>{jl}|Y=c<em>{k})=\frac{\sum</em>{i=1}^{n}I(x<em>{i}^{(j)}=a</em>{jl},y<em>{i}=c</em>{k})}{\sum<em>{i=1}^{N}I(y</em>{i}=c<em>{k})} $ $ j=1,2,\cdot \cdot,\cdot,n;l=1,2,\cdot \cdot \cdot,S</em>{j};k=1,2,\cdot \cdot \cdot, K $ (2)对于给定的实例$ x=(x^{(1)},x^{(2)},\cdot \cdot \cdot,x^{(n)})^T $,计算<br>$ P(Y=c<em>{k})\prod</em>{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c<em>{k}),k=1,2,\cdot \cdot \cdot, K $ (3)确定实例x的类<br>$ y = arg \max</em>{c<em>{k}}P(Y=c</em>{k})\prod<em>{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c</em>{k}) $</p>
<hr>
<p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/bayes_al.png" alt> <a href="https://github.com/hys20151008/ml_python/blob/master/naivebayes.py" target="_blank" rel="noopener">实现代码</a></p>
<pre><code># 对数据集进行去重
def createVecabList(dataSet):
    vocabSet = set([])
    for doc in dataSet:
        vocabSet = vocabSet | set(doc)
    return list(vocabSet)


# 将数据集中出现的word，映射到去重后的数据集中，如果出现则为1，否则为0
def setOfWords2Vec(vocabList, inputSet):
    retVec = [0] * len(vocabList)
    for word in inputSet:
        if word in vocabList:
            retVec[vocabList.index(word)] = 1
        else:
            print(&quot;the word: %s is not in my vocabulary!&quot; % word)
    return retVec


# 计算p(wi|c0)，p(wi|c1)，pAbusive
def trainNB0(trainMatrix, trainCategory):
    numTrainDocs = len(trainMatrix)
    print(numTrainDocs)
    numWords = len(trainMatrix[0])
    pAbusive = sum(trainCategory)/float(numTrainDocs)
    p0Num = np.zeros(numWords)
    p1Num = np.zeros(numWords)
    p0Denom, p1Denom = 0.0, 0.0

    for i in range(numTrainDocs):
        if trainCategory[i] == 1:
            p1Num += trainMatrix[i]
            print(trainMatrix[i])
            p1Denom += sum(trainMatrix[i])
        else:
            p0Num += trainMatrix[i]
            p0Denom += sum(trainMatrix[i])

    print(p1Denom)
    p1Vect = p1Num/p1Denom
    p0Vect = p0Num/p0Denom
    return p0Vect, p1Vect, pAbusive


def classifyNB(vec2Classify, p0Vec, p1Vec, pClass1):
    p1 = sum(vec2Classify * p1Vec) + log(pClass1)
    p0 = sum(vec2Classify * p0Vec) + log(1.0 - pClass1)
    if p1 &gt; p0:
        return 1
    else:
        return 0

def testingNB():
    listPosts, listClasses = loadDataSet()
    myVocabList = createVecabList(listPosts)
    trainMat = []
    for p in listPosts:
        trainMat.append(setOfWords2Vec(myVocabList, p))

    p0V, p1V, pAb = trainNB0(np.array(trainMat), np.array(listClasses))
    testEntry = [&#39;love&#39;, &#39;my&#39;, &#39;dalmation&#39;]
    thisDoc = np.array(setOfWords2Vec(myVocabList, testEntry))
    print(testEntry,&#39;classified as: &#39;,classifyNB(thisDoc,p0V,p1V,pAb))
    testEntry = [&#39;stupid&#39;, &#39;garbage&#39;]
    thisDoc = np.array(setOfWords2Vec(myVocabList, testEntry))
    print(testEntry,&#39;classified as: &#39;,classifyNB(thisDoc,p0V,p1V,pAb))
</code></pre><p><a href="https://github.com/hys20151008/ml_python/blob/master/bayes.py" target="_blank" rel="noopener">完整代码</a> </p>
<hr>
<p>Ref：<br>1.机器学习实战<br>2.统计学习方法</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>牛顿法</title>
    <url>/2018/06/28/%E7%89%9B%E9%A1%BF%E6%B3%95/</url>
    <content><![CDATA[<p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/newton.jpg" alt> <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/newton_grah.gif" alt> <a href="https://www.cnblogs.com/shixiangwan/p/7532830.html" target="_blank" rel="noopener">图片来源</a></p>
<hr>
<p>曲线函数为$ f(x)=(x-1)**2-2 $,起始点为x=4,进行4次迭代后x值为2.4142137800471977，接近真实值$ 1+ \sqrt{2} $</p>
<p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/newton_ani.gif" alt><br><a href="https://github.com/hys20151008/7788/blob/master/newton_plot.py" target="_blank" rel="noopener">实现代码</a> </p>
<hr>
<p>Ref：<br>1.普林斯顿微积分读本<br>2.<a href="https://www.cnblogs.com/shixiangwan/p/7532830.html" target="_blank" rel="noopener">https://www.cnblogs.com/shixiangwan/p/7532830.html</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>流式处理图</title>
    <url>/2019/07/16/%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="http://img.hysyeah.top/2019/07/17/IMG_0001.JPG" alt="image"></p>
<p><img src="http://img.hysyeah.top/2019/07/17/IMG_0002.JPG" alt="image"></p>
<p><img src="http://img.hysyeah.top/2019/07/17/IMG_0003.JPG" alt="image"></p>
]]></content>
  </entry>
  <entry>
    <title>皮尔逊相关系数</title>
    <url>/2018/05/20/%E7%9A%AE%E5%B0%94%E9%80%8A%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/</url>
    <content><![CDATA[<p>皮尔逊相关系数 两个变量之间的皮尔逊相关系数定义为两个变量之间的协方差和标准差的商<br>上式定义了总体相关系数，常用希腊小写字母 作为代表符号。估算样本的协方差和标准差，可得到皮尔逊相关系数，常用英文小写字母 代表 $ \rho<em>{X,Y}=\frac{cov(X,Y)}{\sigma</em>{X}\sigma<em>{Y}}=\frac{E[(X-\mu</em>{x})(Y - \mu<em>{Y})]}{\sigma</em>{X}\sigma<em>{Y}} $ $ r = \frac{\sum</em>{i=1}^n(X<em>{i}-\overline X)(Y</em>{i}-\overline Y)}{\sqrt{\sum<em>{i=1}^n(X</em>{i}-\overline X)^2}\sqrt{\sum<em>{i=1}^n(Y</em>{i}-\overline Y)^2}} $</p>
<hr>
<pre><code>from scipy import stats
import numpy  as np
a = np.array([0, 0, 0, 1, 1, 1, 1])
b = np.arange(7)
stats.pearsonr(a,b)
(0.8660254037844386, 0.011724811003954654)
</code></pre>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵相关概念</title>
    <url>/2018/06/20/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h3><p>在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的1，这种矩阵被称为单位矩阵。它是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1。除此以外全都为0。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/identity_matrix.jpg" alt></p>
<hr>
<h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><p>一个n阶 <strong>方阵</strong> A称为可逆的，或非奇异的，如果存在一个n阶方阵B，使得 AB = BA = E 并称B是A的一个逆矩阵。E为单位矩阵。A的逆矩阵记作$ A^{-1} $ 。当|A|=0时，A称为奇异矩阵，否则称为非奇异矩阵。 可逆矩阵又称满秩矩阵，不可逆矩阵(奇异矩阵)又称降秩矩阵。</p>
<pre><code>np.linalg.inv(A)  #求A的逆矩阵，若矩阵A可逆，则|A|!=0
</code></pre><hr>
<h3 id="正定矩阵"><a href="#正定矩阵" class="headerlink" title="正定矩阵"></a>正定矩阵</h3><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/positive-definite-matrix.png" alt="image"> 对称阵A为正定矩阵充分必要条件是，A的特征值全部&gt;0。 对称阵A为半正定矩阵充分必要条件是，A的特征值全部&gt;=0。</p>
<hr>
<h3 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h3><p>把矩阵A的行换成同序数的列得到一个新矩阵，叫做A的转置矩阵，记住$ A^T $ 。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/matrix_T.png" alt> 矩阵的转置也是一种运算。 $ (A^{T})^{T} = A $<br>$ (A+B)^{T} = A^{T} + B^{T} $<br>$ (\lambda A)^{T} = \lambda A^{T} $<br>$ (AB)^{T} = B^T A^T $ </p>
<hr>
<h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>设A为n阶方阵，如果满足$ A^T = A $ ,那么A称为对称矩阵，简称对称阵。</p>
<hr>
<h3 id="共轭矩阵"><a href="#共轭矩阵" class="headerlink" title="共轭矩阵"></a>共轭矩阵</h3><p>当$ A = (a<em>{ij}) $ 为复矩阵时，用$ \bar {a</em>{ij}} $ 表示$ a<em>{ij} $ 的共轭复数，记<br>$ \bar A = (\bar {a</em>{ij}}) $ ,<br>$ \bar A $ 称为$ A $ 的共轭矩阵。 共轭矩阵满足下述运算规律(设A，B为复矩阵，$ \lambda $ 为复数，且运算都是可行的)；<br>$ \bar {A+B} = \bar A + \bar B $<br>$ \bar {\lambda A} = \bar \lambda \bar A $<br>$ \bar {AB} = \bar A \bar B $  <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/gonge_H.png" alt> a.H为矩阵a的共轭转置(先求矩阵a的共轭矩阵，然后再进行转置)</p>
<hr>
<h3 id="方阵行列式"><a href="#方阵行列式" class="headerlink" title="方阵行列式"></a>方阵行列式</h3><p>由n阶方阵A的元素所构成的行列式(各元素的位置不变),称为方阵A的行列式，记作|A|或det A。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/det.png" alt></p>
<hr>
<h3 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h3><p>如果n阶矩阵A满足$ A^T A = E $ 即$ A^{-1} = A^T $ ,那么称A为正交矩阵，简称正交阵.</p>
<h2 id><a href="#" class="headerlink" title></a><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/%E6%AD%A3%E4%BA%A4.png" alt></h2><h3 id="特征向量"><a href="#特征向量" class="headerlink" title="特征向量"></a>特征向量</h3><p>设A是n阶矩阵，如果数$ \lambda $ 和n维非零列向量x使关系式$ Ax=\lambda x $ 成立，那么，这样的数$ \lambda $ 称为矩阵A的特征值，非零向量x称为A的对应于特征值$ \lambda $ 的特征向量。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/eig.png" alt="image"> 4和2是特征值，后面是特征值所对应的特征向量。</p>
<hr>
<h3 id="矩阵的迹"><a href="#矩阵的迹" class="headerlink" title="矩阵的迹"></a>矩阵的迹</h3><p>矩阵的迹为矩阵对角线各元素之和。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/matrix_trace.png" alt></p>
<hr>
<h3 id="克拉默法则"><a href="#克拉默法则" class="headerlink" title="克拉默法则"></a>克拉默法则</h3><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/kelamo.png" alt></p>
<hr>
<h4 id="两个矩阵行数和列数相同，则称为同型矩阵。"><a href="#两个矩阵行数和列数相同，则称为同型矩阵。" class="headerlink" title="两个矩阵行数和列数相同，则称为同型矩阵。"></a>两个矩阵行数和列数相同，则称为同型矩阵。</h4><h4 id="元素都为零的矩阵称为零矩阵"><a href="#元素都为零的矩阵称为零矩阵" class="headerlink" title="元素都为零的矩阵称为零矩阵"></a>元素都为零的矩阵称为零矩阵</h4><hr>
<p>若一n行n列的复数矩阵$ U $ 满足：<br>$ U^H U= UU^H = E<em>{n} $<br>其中，$ U^H $ 为$ U $ 的共轭转置，$ E</em>{n} $ 为n阶单位矩阵，则$ U $ 称为酉矩阵(幺正矩阵)。 一个简单的充分必要判断准则是：<br>$ U^{-1} = U^H $ ,即酉矩阵的共轭转置和它的逆矩阵相等。</p>
<hr>
<h3 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h3><p>假设M是一个$ m $ x$ n $ ,如果存在一个分解使得<br>$ M=U \sum V^<em> $<br>其中U是$ m $ x$ m $ 阶酉矩阵；$ \sum $ 是半正定$ m $ x$ n $ 阶对角矩阵；而$ V^</em> $ 为共轭转置，是$ n $ x$ n $ 阶酉矩阵。这样的分解就称作M的奇异值分解。$ \sum $ 的对角线上的元素为M的奇异值。 <img src="http://img.hysyeah.top/wp-content/uploads/2018/06/svd.png" alt></p>
<hr>
<h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p>对角矩阵(diagonal matrix)是一个主对角线之外的元素皆为0的矩阵，常写为diag（a1，a2,…,an)</p>
<hr>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>第1章 统计学习方法概论</title>
    <url>/2018/05/06/%E7%AC%AC1%E7%AB%A0%20%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<p>统计学习(statistical learning)是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。<br>统计学习的主要特点：<br> 1.统计学习以计算机及网络为平台，是建立大计算机及网络之上的<br> 2.统计学习以数据为研究对象，是数据驱动的学科<br> 3.统计学习的目的是对数据进行预测与分析<br> 4.统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析<br> 5.统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科、并且在发展中逐步形成独自的理论体系与方法论。 </p>
<p> 统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。 统计学习的方法是基于数据构建统计模型从而对数据进行预测与分析。统计学习由监督学习(supervised learning)、非监督学习(unsupervised learning)、半监督学习(semi-supervised learning)和强化学习(reinforcement learning)等组成。 统计学习方法的步骤如下： 1.得到一个有限的训练数据集合 2.确定包含所有可能的模型的假设空间，即学习模型的集合 3.确定模型选择的准则，即学习的策略 4.实现求解最优模型的算法，即学习的算法 5.通过学习方法选择最优模型 6.利用学习的最优模型对新数据进行预测或分析</p>
<hr>
<p>模型就是使用什么方法对数据进行预测与分析，就是所要学习的条件概率分布或决策函数，比如是线性回归，还是用多项式回归 策略就是你你通过什么方法判断哪个模型是最优的， 算法就是求解策略的最优解的算法，如梯度下降，最小二乘法</p>
<hr>
<p>根据输入、输出变量的不同类型，对预测任务给予不同的名称：输入变量与输出变量均为连续变量的预测问题称为回归问题；输出变量为有限个离散变量的预测问题称为分类问题；输入变量与输出变量均为变量序列的预测问题称为标注问题。 在监督学习过程中，模型就是所要学习的条件概率分布或决策函数。 假设空间用$ \mathcal{F} $表示。假设空间可以定义为决策函数的集合 $ \mathcal{F}= { {\mathcal{f}|Y = f(X)}} $ 其中，X和Y是定义在输入空间$ \chi $和输出空间$ \mathcal{Y} $上的变量。这时$ \mathcal{F} $通常是由一个参数向量决定的函数族：<br>$ \mathcal{F} = { {f|Y=f_{\theta}}(X),\theta\in R^{n}} $ 参数向量$ \theta $取值于n维欧式空间$ R^{n} $,称为参数空间。 假设空间也可以定义为条件概率的集合$ \mathcal{F}={ {P|P(Y|X)}} $ 策略： 统计学习的目标在于从假设空间中选取最优模型。<br>损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。 统计学习常用损失函数：<br>(1) 0-1损失函数<br>$ L(Y,f(X))= \begin{cases} 0,&amp; {Y\neq f(X)}\ 1,&amp; {Y\neq f(X)} \end{cases}  $<br>(2) 平方损失函数<br>$ L(Y, f(X)) = (Y - f(X))^2 $ (3) 绝对损失函数<br>$ L(Y, f(X)) = |(Y - f(X))| $ (4) 对数损失函数<br>$ L(Y, P(Y|X)) = -log P(Y|X) $</p>
<hr>
<p>如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高。这种现象称为过拟合。过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但对未知的数据预测得很差的现象。 模型选择的典型方法是正则化。正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项或罚项。正则化项一般是模型复杂度的单调函数，模型越复杂，正则化的值就越大。正则化项一般具有如下形式： $ min<em>{f\in\mathcal{F}} \frac{1}{N}\sum</em>{i=1}^NL(y<em>{(i)}, f(x</em>{i})) + \lambda J(f)  $ 其中，第一项是经验风险，第二项是正则化项，$ \lambda \geq 0 $为调整两者之间关系的系数。</p>
<h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><p>1.简单交叉验证 简单交叉验证方法是：首先随机地将已给数据分为两部分，一部分作为训练，另一部分作为测试集。 2.S折交叉验证 首先随机地将已给数据切分为S个互不相交的大小相同的子集；然后利用S-1个子集的数据训练模型，利用余下的子集测试模型；将这一过程可能的S种选择重复进行；最后选出S次评测中平均测试误差最小的模型。 3.留一交叉验证 S折交叉验证的特殊情形是S=N，称为留一交叉验证，往往在数据缺乏的情况下使用，N是给定的数据集容量。</p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>TP-将正类预测为正类数 FN-将正类预测为负类数 FP-将负类数预测为正类数 TN-将负数预测为负类数 准确率 $ A = \frac{TP+TN}{TP+FN+FP+TN} $ 精确率 $ P = \frac{TP}{TP+FP} $ 召回率 $ R = \frac{TP}{TP+FN} $ $ F<em>{1} $值 $ \frac{2}{F</em>{1}}= \frac{1}{P}+\frac{1}{R} $ $ F_{1} = \frac{2TP}{2TP+FP+FN} $</p>
<h4 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h4><p>泛化能力是指由该方法学习到的模型对未知数据的预测能力，是学习方法本质上重要的性质。<br>如果学到的模型是$ \hat f $,那么利用这个模型 对未知数据预测的误差就是泛化误差<br>$ R<em>{exp}(\hat f) = E[L(Y, \hat f(X))] = \int</em>{\chi \times \mathcal{Y}}L(y,\hat f(x))P(x,y)dxdy $ 泛化误差上界：对二类分类问题，当假设空间是有限个函数集合$ \mathcal{F}={f<em>{1},f</em>{2},\cdot \cdot \cdot, f_{d}} $时，对于任意一个函数$ f \in \mathcal{F} $,至少以概率$ 1-\delta $,以下不等式成立<br>$ R(f) \leq \hat R(f) + \varepsilon(d, N, \delta) $,其中$ \varepsilon(d, N, \delta) = \sqrt{\frac{1}{2N}\bigg(\log d + \log \frac{1}{\delta}\bigg)}  $<br>左端R(f)就泛化误差，右端即为泛化误差上界。第二项$ \varepsilon(d, N, \delta) $是N的单调递减函数，当N趋于无穷时趋于0 监督学习方法又可以分为生成方法和判别方法。<br>生成方法由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型<br>判别方法由数据直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型<br>典型的生成模型包括：朴素贝叶斯法和隐马尔可夫模型。典型的判别模型包括：K近邻法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机、提升方法和条件随机场等。</p>
<hr>
<p><img src="http://img.hysyeah.top/wp-content/uploads/2018/05/向量范数.png" alt="image"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>记wordpress一次坑爹的问题</title>
    <url>/2019/06/13/%E8%AE%B0wordpress%E4%B8%80%E6%AC%A1%E5%9D%91%E7%88%B9%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天晚上发再更新文章时总是提醒<code>/wp-admin/post.php</code>,但 查看服务器发现文件存在，最近也没有安装插件。 多方尝试最后将下图红框中的数据删除，点击保存，问题解决。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/15604410141.png" alt></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>认识ucontext函数簇</title>
    <url>/2019/10/27/%E8%AE%A4%E8%AF%86ucontext/</url>
    <content><![CDATA[<p>ucontext函数簇提供了4个函数用于控制用户态的上下文。利用这几个函数可以实现一个协程。</p>
<p>ucontext_t结构体<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ucontext_t</span> *uc_link;    <span class="comment">//当前上下文结束后要恢复到时的上下文,</span></span><br><span class="line">    <span class="keyword">sigset_t</span>    uc_sigmask; <span class="comment">//上下文要阻塞的信号集合</span></span><br><span class="line">    <span class="keyword">stack_t</span>     uc_stack;   <span class="comment">//上下文所使用的栈</span></span><br><span class="line">    <span class="keyword">mcontext_t</span>  uc_mcontext; <span class="comment">//机器特定的保护上下文的表示，包括协程的机器寄存器</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">ucontext_t</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前用户上下文,并初始化指针ucp指向的结构体。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="comment">// 设置当前的上下文为ucp指向的内容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setcontext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个上下文,修改通过getcontext初始化的ucp,当切换到ucp指向的上下文时，将会执行func函数。</span></span><br><span class="line"><span class="comment">// 执行makecontext前必须为ucp分配栈和指定ucp-&gt;uc_link</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makecontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp, <span class="keyword">void</span> (*func)(),</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">int</span> argc, ...)</span></span>;</span><br><span class="line"><span class="comment">// 将当前上下文保存到指针oucp指向的结构,并切换到ucp指向的上下文</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swapcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *<span class="keyword">restrict</span> oucp,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">const</span> <span class="keyword">ucontext_t</span> *<span class="keyword">restrict</span> ucp)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ucontext_t</span> context;</span><br><span class="line"></span><br><span class="line">    getcontext(&amp;context);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    setcontext(&amp;context);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每隔一秒打印一行<code>Hello world</code>。</p>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"foo\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ucontext_t</span> context;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">stack</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    getcontext(&amp;context);  <span class="comment">// 初始化context</span></span><br><span class="line">    context.uc_stack.ss_sp = <span class="built_in">stack</span>; <span class="comment">// 设置栈顶指针</span></span><br><span class="line">    context.uc_stack.ss_size = <span class="keyword">sizeof</span>(<span class="built_in">stack</span>); <span class="comment">// 设置栈的大小</span></span><br><span class="line">    context.uc_link = <span class="literal">NULL</span>;    <span class="comment">//下一个要恢复的上下文为NULL, 将结束运行          </span></span><br><span class="line">    makecontext(&amp;context, foo, <span class="number">0</span>); <span class="comment">//构建上下文，执行context上下文时，将执行foo函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    setcontext(&amp;context);  <span class="comment">//设置上下文为context,在这里会切换到执行foo函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先打印<code>Hello world</code>,然后打印<code>foo</code>。</p>
<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ucontext_t</span> ctx[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">f1(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start f1\n"</span>);</span><br><span class="line">    <span class="comment">// 将当前 context 保存到 ctx[1]，切换到 ctx[2]</span></span><br><span class="line">    swapcontext(&amp;ctx[<span class="number">1</span>], &amp;ctx[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"finish f1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">f2(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start f2\n"</span>);</span><br><span class="line">    <span class="comment">// 将当前 context 保存到 ctx[2]，切换到 ctx[1]</span></span><br><span class="line">    swapcontext(&amp;ctx[<span class="number">2</span>], &amp;ctx[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"finish f2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> stack1[<span class="number">8192</span>];</span><br><span class="line">    <span class="keyword">char</span> stack2[<span class="number">8192</span>];</span><br><span class="line">    </span><br><span class="line">    getcontext(&amp;ctx[<span class="number">1</span>]);</span><br><span class="line">    ctx[<span class="number">1</span>].uc_stack.ss_sp = stack1;</span><br><span class="line">    ctx[<span class="number">1</span>].uc_stack.ss_size = <span class="keyword">sizeof</span>(stack1);</span><br><span class="line">    ctx[<span class="number">1</span>].uc_link = &amp;ctx[<span class="number">0</span>]; <span class="comment">// 将执行 return 0</span></span><br><span class="line">    makecontext(&amp;ctx[<span class="number">1</span>], f1, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    getcontext(&amp;ctx[<span class="number">2</span>]);</span><br><span class="line">    ctx[<span class="number">2</span>].uc_stack.ss_sp = stack2;</span><br><span class="line">    ctx[<span class="number">2</span>].uc_stack.ss_size = <span class="keyword">sizeof</span>(stack2);</span><br><span class="line">    ctx[<span class="number">2</span>].uc_link = &amp;ctx[<span class="number">1</span>];</span><br><span class="line">    makecontext(&amp;ctx[<span class="number">2</span>], f2, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前 context 保存到 ctx[0]，切换到 ctx[2]</span></span><br><span class="line">    swapcontext(&amp;ctx[<span class="number">0</span>], &amp;ctx[<span class="number">2</span>]);  <span class="comment">// 为什么么ctx[0]不用初始化栈？原因是swapcontext会将当前的上下文设置到ctx中,此时ctx[0]为main函数的上下文</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swapcontext(&amp;ctx[0], &amp;ctx[2])</code>切换到ctx[2]上下文，此时将执行<code>f2</code>。打印start f2,然后切换上下文到ctx[1];执行f1函数，打印start f1;切换到<code>f2</code>，打印finish f2;<code>f2</code>执行完成后，因为<code>ctx[2].uc_link=&amp;ctx[1]</code>,再次进入ctx[1],打印出finish f1。</p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start f2</span><br><span class="line">start f1</span><br><span class="line">finish f2</span><br><span class="line">finish f1</span><br></pre></td></tr></table></figure></p>
<hr>
<p>Ref：<br>1.<a href="http://walkerdu.com/2017/01/09/ucontext-theory/" target="_blank" rel="noopener">http://walkerdu.com/2017/01/09/ucontext-theory/</a><br>2.<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#System-V-contexts" target="_blank" rel="noopener">Complete Context Control</a><br>3.<a href="https://zhengyinyong.com/post/ucontext-usage-and-coroutine/" target="_blank" rel="noopener">https://zhengyinyong.com/post/ucontext-usage-and-coroutine/</a></p>
]]></content>
  </entry>
  <entry>
    <title>记录Rust Hello Word</title>
    <url>/2020/03/21/%E8%AE%B0%E5%BD%95Rust-Hello-Word/</url>
    <content><![CDATA[<p>1.安装<code>Rust</code><br>官网<a href="https://www.rust-lang.org/zh-CN/tools/install" target="_blank" rel="noopener">下载</a>直接点击安装即可</p>
<p>2.在<code>Goland</code>上安装<code>Rust</code>插件<br>在<a href="https://plugins.jetbrains.com/plugin/8182-rust/versions" target="_blank" rel="noopener">rust plugins</a>上下载对应<code>Goland</code>版本的<code>Rust</code>插件。笔者的<code>Goland</code>是<code>2019.1</code>。<br><img src="http://img.hysyeah.top/2020/3/21/goland-rust-plugin.png" alt="image"></p>
<p>根据如下步骤安装即可,<code>Install Plugin from Disk</code>指定上一步下载的压缩文件。安装好后重启<code>Goland</code><br><img src="http://img.hysyeah.top/2020/3/21/plugin-install-1.png" alt="image"><br><img src="http://img.hysyeah.top/2020/3/21/plugin-install-2.png" alt="image"><br>3.将环境变量<code>%USERPROFILE%\.cargo\bin</code>添加到<code>Path</code><br>4.使用<code>Goland</code>新建一个<code>Rust</code>项目<br><img src="http://img.hysyeah.top/2020/3/21/rust.png" alt="image"></p>
<p>5.编译执行<code>Rust</code>代码<br><img src="http://img.hysyeah.top/2020/3/21/rust2.png" alt="image"></p>
<hr>
<p>过程中遇到的问题：<br>缺少一些库:advapi32.lib,userenv.lib<br>解决方法：直接安装一个<code>visual studio community 2019</code>,问题解决<br><img src="http://img.hysyeah.top/2020/3/21/link-error.png" alt="image"></p>
<p>Ref：<br>1.<a href="https://github.com/rust-lang/rust/issues/43039" target="_blank" rel="noopener">https://github.com/rust-lang/rust/issues/43039</a></p>
]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>连接docker创建的mysql容器时出错</title>
    <url>/2018/05/29/%E8%BF%9E%E6%8E%A5docker%E5%88%9B%E5%BB%BA%E7%9A%84mysql%E5%AE%B9%E5%99%A8%E6%97%B6%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>连接mysql容器时报错如下 ERROR 2059 (HY000): Authentication plugin ‘caching_sha2_password’ cannot be loaded: /usr/lib/mysql/plugin/caching_sha2_password.so: cannot open shared object file: No such file or directory 原因是docker pull下来的是最新的mysql镜像，移除镜像，重新拉取5.7版的镜像即可</p>
<pre><code>docker pull mysql:5.7
</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>记一次粗心的错误</title>
    <url>/2018/11/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%B2%97%E5%BF%83%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>最近在学习使用alembic,有一个地方是要填写数据库的url如下：</p>
<pre><code>sqlalchemy.url = &#39;mysql://root:123456@10.10.20.11/test&#39;
</code></pre><p>不小心将<code>mysql</code>写成了<code>msyql</code>,结果报错提示msyql模块未安装。然后自己以为是mysql驱动没安装好，然后就是各种安装，结果还是一样。 一小时后，重新将url写一遍却正确了，于是查看日志才发现是<code>mysql</code>写错了。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>通过keepalived实现neo4j主备切换</title>
    <url>/2019/07/11/%E9%80%9A%E8%BF%87keepalived%E5%AE%9E%E7%8E%B0neo4j%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<p>1.背景：我们使用的是社区版Neo4j不支持集群功能,因此通过对Neo4j进行双写，再通过keepalived实现主备切换</p>
<p>2.环境：Neo4j服务器A(10.23.4.123),Neo4j服务器B(10.23.4.124),VIP(10.23.4.126),服务器均为CentOs</p>
<p>3.安装keepalived<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install keepalived</span><br></pre></td></tr></table></figure></p>
<p>4.修改主机10.23.4.123 keepalived的配置文件/etc/keepalived/keepalived.conf<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">    router_id neo4j_master</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_neo4j &#123;</span><br><span class="line">    script &quot;netstat -lntp | grep 7687&quot;</span><br><span class="line">    interval 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance neo4j &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens160</span><br><span class="line">    lvs_sync_daemon_interface ens160</span><br><span class="line">    virtual_router_id 210</span><br><span class="line">    priority 150</span><br><span class="line">    nopreempt</span><br><span class="line">    advert_int 1</span><br><span class="line"></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.23.4.126</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_neo4j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.修改主机10.23.4.124 keepalived的配置文件/etc/keepalived/keepalived.conf<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">    router_id neo4j_slave</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_neo4j &#123;</span><br><span class="line">    script &quot;netstat -lntp | grep 7687&quot;</span><br><span class="line">    interval 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance neo4j &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens160</span><br><span class="line">    lvs_sync_daemon_interface ens160</span><br><span class="line">    virtual_router_id 210</span><br><span class="line">    priority 150</span><br><span class="line">    nopreempt</span><br><span class="line">    advert_int 1</span><br><span class="line"></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.23.4.126</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_neo4j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.启动keepalived<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable  keepalived.service</span><br><span class="line">systemctl start  keepalived.service</span><br></pre></td></tr></table></figure></p>
<p>7.验证</p>
<ul>
<li>停止Neo4j-A,在Neo4j-B通过命令ip a查看VIP是否飘到Neo4j-B上</li>
<li>停止Neo4j-B,在Neo4j-A通过命令ip a查看VIP是否飘到Neo4j-A上</li>
</ul>
<h2 id="未完"><a href="#未完" class="headerlink" title="未完"></a>未完</h2>]]></content>
  </entry>
  <entry>
    <title>设计模式开篇</title>
    <url>/2018/08/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<h4 id="oop特性"><a href="#oop特性" class="headerlink" title="oop特性"></a>oop特性</h4><p>1.封装，对外部隐藏内部的实现,对数据进行隐藏 2.多态性，根据类型的不一致，调用不同的方法 3.继承，可以继承其它类的功能 4.抽象-提供简易接口给客户端，客户端可以调用接口中的方法 5.混合，可以构建复杂的数据结构</p>
<pre><code># A类在B类下
class A(object):
    def a1(self):
        print(&quot;a1&quot;)
class B(object):
    def b(self):
        print(&quot;b&quot;)
        A().a1()
objectB = B()
objectB.b()
</code></pre><hr>
<p>1.打开/关闭原则：对扩展开放(在不改变原有代码的情况下添加功能)，对修改关闭 2.控制原理的反转：控制原理的反转表明高级模块不应该依赖于低级模块;它们都应该依赖于抽象。细节应该取决于抽象，而不是相反。这个原则表明，任何两个模块都不应该以一种紧密的方式相互依赖。 4.接口隔离原则：客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口 5.单一责任原则：一个类只负责一个功能 6.替代原则 —在扩展子类的时候，不需要重写父类的功能</p>
<hr>
<p>设计模式分为三大类：1.创建型-它们的工作原理是如何创建对象-他们隔离了对象创建的细节-代码与要创建的对象类型无关 2.结构型-它们设计对象和类的结构以便获得更大的结果-它们关注简化结构和发现类和对象之间的关系-它们关注类的继承与混合 3.行为型-他们关注对象之间的交互和对象的责任-对象应该能够交互并且仍然可以松散耦合</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>通过nginx-controller将redis服务暴露到集群外</title>
    <url>/2020/10/13/%E9%80%9A%E8%BF%87nginx-controller%E5%B0%86redis%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%88%B0%E9%9B%86%E7%BE%A4%E5%A4%96/</url>
    <content><![CDATA[<p>在微服务迁移过程中，在进行流量切换的过程中，旧的服务和微服务会共存一段时间。当用户从前端访问时，流量分别会被转发到旧服务和新服务上。<br>为了使用户可以同时访问旧服务和新服务，需要共用一个redis。因为以前使用的都是各自集群内部的redis(新旧服务在不同的k8s集群上)，因此为了让集群外的服务也能访问另一集群的redis服务，所以需要将redis暴露到集群外。</p>
<p>我们ingress使用的是<code>nginx controller</code>.</p>
<p>1.找到<code>nginx controller</code>对应的service<code>ingress-nginx</code>,一般在<code>kube-system</code>命名空间下,并编辑。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kubectl get svc -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑ingress-nginx并新增6379端口</span></span><br><span class="line">kubectl edit svc ingress-nginx -n kube-system</span><br><span class="line"></span><br><span class="line">－ name: tcp-redis</span><br><span class="line">   port: <span class="number">6379</span></span><br><span class="line">   protocol: TCP</span><br><span class="line">   targetPort: <span class="number">6379</span></span><br></pre></td></tr></table></figure></p>
<p>2.修改<code>ingress-nginx</code>对应<code>TCP</code>协议的configmap。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kubectl edit cm tcp-services -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在data字段下添加如下内容</span></span><br><span class="line">data:</span><br><span class="line">  &lt;namespace/service name&gt;:&lt;service port&gt;:[PROXY]:[PROXY]</span><br><span class="line">  <span class="number">6379</span>: &lt;namespace&gt;/redis:<span class="number">6379</span></span><br></pre></td></tr></table></figure></p>
<p>3.然后就可以通过<code>redis-cli</code>在集群外访问<code>redis</code>服务了。</p>
<hr>
<p>参考：<br>1.<a href="https://kubernetes.github.io/ingress-nginx/user-guide/exposing-tcp-udp-services/" target="_blank" rel="noopener">https://kubernetes.github.io/ingress-nginx/user-guide/exposing-tcp-udp-services/</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>通过tcpdump分析tcp中的三次握手和四次挥手</title>
    <url>/2019/06/07/%E9%80%9A%E8%BF%87tcpdump%E5%88%86%E6%9E%90tcp%E4%B8%AD%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<p>最近在看《unix网络编程》刚好总结下tcp中的三次握手和四次挥手。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/tcp-ip-handshake.png" alt="image"> 一、tcp中的三次握手和四次挥手的过程 TCP三次握手： 1.连接请求由客户端发起，发送一个SYN分节，Seqence number为0(也就是图中的J) 2.服务端接收到客户的SYN之后，确认(ACK)客户的SYN,同时也发送一个SYN分节。此时Acknowledgment number=1(J+1) 3.客户端确认服务端的SYN。 下图为tcp分节的模式（图来源于网络) <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/tcp_header-1.png" alt> TCP四次挥手：<strong>上图为客户端执行主动关闭的情况，客户，服务端都可以执行主动关闭</strong> 1.客户端调用<code>close</code>，该端称为<strong>主动关闭</strong>,发送FIN分节. 2.接收到这个FIN分节的一端称为<strong>被动关闭</strong>。这个FIN由TCP确认。它的接收也作为一个文件结束符传递给接收端应用进程（放在已排队等候该应用进程接收的任何其它数据之后），因为FIN的接收意味着接收端应用进程在相应连接上现无额外数据可接收。 3.一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的socket。同时也会发一个FIN分节。 4.主动关闭那一端，发送ACK确认FIN。</p>
<h5 id="步骤2和步骤3都由被动关闭一端发出，有可能会被合并成一个分节。"><a href="#步骤2和步骤3都由被动关闭一端发出，有可能会被合并成一个分节。" class="headerlink" title="步骤2和步骤3都由被动关闭一端发出，有可能会被合并成一个分节。"></a>步骤2和步骤3都由被动关闭一端发出，有可能会被合并成一个分节。</h5><p>二、通过tcpdump抓包进行分析 1.使用<code>socket</code>编写tcp客户端和服务程序。</p>
<pre><code># server.py
import socket

bind_ip =&quot;0.0.0.0&quot;
bind_port = 8080

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((bind_ip, bind_port)) #将指定的ip和port绑定到该套接字

server.listen(3)  #调用listen函数把该套接字转换成一个监听套接字，参数3指定系统内核允许在这个监听描述符上排队的最大客户连接数

while True:
    client, addr = server.accept() #等待客户端连接，完成三路握手后返回一个已连接描述符，accept函数为每个连接到本服务器的客户端返回一个新的新描述符
    rcv = client.recv(1024)
    print(rcv)
    client.close()


# client.py
import socket

host = &quot;127.0.0.1&quot;
port = 8080

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((host, port))
client.close()
</code></pre><p>2.在linux终端中执行命令<code>tcpdump -i lo port 8080 -w tcphandshake.pcap</code> 3.在两个窗口分别执行<code>python server.py</code>,<code>python client.py</code> 4.将抓包的在wireshake中打开。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/wireshake-tpc-handshake.png" alt></p>
<h5 id="可以看到和上面描述的过程是一致的，四次挥手步骤2和步骤3合并成了一个分节。"><a href="#可以看到和上面描述的过程是一致的，四次挥手步骤2和步骤3合并成了一个分节。" class="headerlink" title="可以看到和上面描述的过程是一致的，四次挥手步骤2和步骤3合并成了一个分节。"></a>可以看到和上面描述的过程是一致的，四次挥手步骤2和步骤3合并成了一个分节。</h5><p>5.查看分节中的详细信息。 - tcp三次握手中客户端发送的SYN分节。 <img src="http://img.hysyeah.top/wp-content/uploads/2019/06/handshake1.png" alt><img src="http://img.hysyeah.top/wp-content/uploads/2019/06/handshake1-1.png" alt> 客户端会告诉对端它的最大分节大小(maximum segment size—MSS),就是在这个连接中每个TCP分节可以接受的最大数据量。 告诉对端它的窗口大小是多少。 - tcp四次挥手，步骤2和步骤3发送的分节（合并成了一个分节），图如下。<img src="http://img.hysyeah.top/wp-content/uploads/2019/06/huishou1.png" alt></p>
<p>三,https协议握手过程<br>https握手在tcp的三次握手的基础上加上了TLS/SSL安全基础层，用于在HTTP协议上安全地传输数据。<br><img src="http://img.hysyeah.top/2021/7/20210711165811-https.png" alt="image"></p>
<p>1.客户端首次请求服务端，告诉服务端自己支持的协议版本,支持的加密算法及压缩算法，并生成一个客户端随机数(Client Random)并告知服务端<br><img src="http://img.hysyeah.top/2021/7/20210711170531-https1.png" alt="image"></p>
<p>2.服务端确认双方使用的加密算法，并返回组客户端证书及一个服务端生成的服务端随机数(Server Random)</p>
<p><img src="http://img.hysyeah.top/2021/7/20210711171157-https2.png" alt="image"></p>
<p>3.客户端收到证书后，首先验证证书的有效性,然后生成一个新的随机数(Premaster Secret),使用数字证书中的公钥来加密这个随机数，并发送给服务端。</p>
<p><img src="http://img.hysyeah.top/2021/7/20210711171907-https3.png" alt="image"></p>
<p>4.服务端接收到已加密的随机数后，使用私钥进行解密,获取这个随机数(Premaster Secret)</p>
<p><img src="http://img.hysyeah.top/2021/7/20210711172141-https4.png" alt="image"></p>
<p>最后服务端和客户端根据约定的加密算法，使用前面的3个随机数(Client Random,Server Random, Premaster Secret),生成对话密钥，用来加密接下来的事个会话过程。</p>
<p><img src="http://img.hysyeah.top/2021/7/20210711172442-https5.png" alt="image"></p>
<hr>
<p>总结： 看十遍，不如实际动手操作一遍！！！</p>
<hr>
<p>Ref： 1.《unix网络编程-套接字》<br>2.<a href="https://www.freesoft.org/CIE/Course/Section4/8.htm" target="_blank" rel="noopener">https://www.freesoft.org/CIE/Course/Section4/8.htm</a><br>3.<a href="https://cs.fit.edu/~mmahoney/cse4232/tcpip.html" target="_blank" rel="noopener">https://cs.fit.edu/~mmahoney/cse4232/tcpip.html</a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>通过梯度下降法求最小值</title>
    <url>/2018/04/24/%E9%80%9A%E8%BF%87%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<p>1.梯度下降是迭代法的一种,可以用于求解最小二乘问题(线性和非线性都可以)。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。—来源于百度百科 2.给定初始值和步长，通过当前值与上一值的比较，不断进行迭代，直到符合设定的条件后停止。 3.下面是对f(x) = x * x，通过梯度下降法求最小值</p>
<pre><code>import matplotlib.pyplot as plt

f = lambda x: x*x

fig, ax = plt.subplots()
def gradient_x(step,init_val):
    f_change, f_current = f(init_val), f(init_val)
    count = 0
    x = init_val
    while f_change &gt; 0.0001:
        x = x - 2 * step * x
        f_change = f_current - f(x)
        f_current = f(x)
        count += 1
        plt.plot(x,f(x), &quot;*-&quot;)
    print(&quot;after%diteration func found min value %d,x value is %d&quot;,count,f(x),x) 
    plt.show() 
if __name__ == &#39;__main__&#39;:
    gradient_x(0.1, 2)
</code></pre><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/04/gradient.png" alt="image"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/2018/06/28/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h3 id="logistic分布"><a href="#logistic分布" class="headerlink" title="logistic分布"></a>logistic分布</h3><p>设X是连续随机变量，X服从logistic分布是指X具有下列分布函数和密度函数：<br>$ F(x)=P(X \le x) = \frac{1}{1+e^{-(x - \mu)/\gamma}} $<br>$ f(x) = F’(x) = \frac{e^{-(x-\mu)/\gamma} }{\gamma(1+e^{-(x-\mu)/\gamma})^2} $ 式中，$ \mu $ 为位置参数，$ \gamma \gt 0 $ 为形状参数。<br><img src="http://img.hysyeah.top/wp-content/uploads/2018/04/logistic_plot.png" alt><br>当$ \mu $不等于0时，相当于图像向左或向右移动$ \mu $个单位，$ \gamma $越大，图像越<br>平坦。 <a href="https://github.com/hys20151008/7788/blob/master/logistic_plot.py" target="_blank" rel="noopener">图像代码</a></p>
<hr>
<h3 id="logistic回归模型"><a href="#logistic回归模型" class="headerlink" title="logistic回归模型"></a>logistic回归模型</h3><p>二项logistic回归模型是如下的条件概率分布:<br>$ P(Y=1|x) = \frac{\exp(w \cdot x + b)} {1+\exp(w \cdot x + b)} $<br>$ P(Y=0|x) = \frac{1} {1+\exp(w \cdot x + b)} $<br>这里，$ x \in \mathcal R^n $是输入，$ Y \in {0,1} $是输出，$ w\in \mathcal R^n $和$ b\in \mathcal R $是参数，w称为权值向量，b称为偏置，$ w \cdot x $为w和x的内积。 逻辑回归其<br>实就是<strong>回归</strong>加上<strong>阶梯函数</strong>，将输出值映射到一定的范围内。</p>
<h3 id="模型参数估计"><a href="#模型参数估计" class="headerlink" title="模型参数估计"></a>模型参数估计</h3><p><img src="http://img.hysyeah.top/wp-content/uploads/2018/06/logistic_maxl.png" alt></p>
<hr>
<pre><code># 构建数据集
def loadDataSet2():
    dataMat = []; labelMat = []
    fr = open(&#39;./dataset/testSet5.txt&#39;)
    for line in fr.readlines():
        lineArr = line.strip().split()
        dataMat.append([1.0, float(lineArr[0]), float(lineArr[1])])
        labelMat.append(int(lineArr[2]))
    return dataMat,labelMat


# 梯度下降(每次都要对所有训练数据进行计算，不适合数据量大的场景)
def gradAscent(dataMatIn, classLabels):
    dataMatrix = np.mat(dataMatIn)
    labelMat = np.mat(classLabels).transpose()
    m, n = dataMatrix.shape

    alpha = 0.001
    max_iter = 500
    weights = np.ones((n, 1))
    for k in range(max_iter):
        h = sigmoid(dataMatrix*weights)
        error = (labelMat -h)
        weights = weights + alpha * dataMatrix.transpose() * error
    return weights


# 随机梯度下降每次迭代只使用一条训练数据进行计算，减少计了计算量
def stocGradAscent0(dataMatrix, classLabels):
    m,n = np.shape(dataMatrix)
    alpha = 0.01
    weights = np.ones(n)
    for i in range(m):
        h = sigmoid(sum(dataMatrix[i]*weights))
        error = classLabels[i] - h
        weights = weights + alpha * error * dataMatrix[i]
    return weights


# 改良版随机梯度下降，
def stocGradAscent1(dataMatrix, classLabels, numIter=150):
    m, n = dataMatrix.shape
    weights = np.ones(n)
    dataIndex = range(m)
    for j in range(numIter):
        for i in range(m):
            alpha = 4/(1.0+j+i)+0.01
            randIndex = int(np.random.uniform(0, len(dataIndex)))
            h = sigmoid(sum(dataMatrix[randIndex]*weights))
            error = classLabels[randIndex] - h
            weights = weights + alpha*error*dataMatrix[randIndex]
    return weights


# 分类
def classifyVec(inX, weights):
    prob = sigmoid(sum(inX*weights))
    if prob &gt; 0.5:
        return 1
    return 0

# 训练，测试
def colicTest():
    frTrain = open(&#39;dataset/horseColicTraining.txt&#39;)
    frTest = open(&#39;dataset/horseColicTest.txt&#39;)
    trainingSet, trainingLabels = [], []
    for line in frTrain.readlines():
        currLine = line.strip().split(&#39;\t&#39;)
        lineArr = []
        for i in range(21):
            lineArr.append(float(currLine[i]))
        trainingSet.append(lineArr)
        trainingLabels.append(float(currLine[21]))
    trainWeights = stocGradAscent1(np.array(trainingSet), trainingLabels, 500)
    errorCount, numTestVec = 0, 0
    for line in frTest.readlines():
        numTestVec += 1
        currLine = line.strip().split(&#39;\t&#39;)
        lineArr = []
        for i in range(21):
            lineArr.append(float(currLine[i]))
        if int(classifyVec(np.array(lineArr), trainWeights))!=int(currLine[21]):
            errorCount += 1
    errorRate = (float(errorCount)/numTestVec)
    print(&quot;the error rate of this test is: %f&quot; % errorRate)
</code></pre><p><a href="https://github.com/hys20151008/ml_python/blob/master/logRegres.py" target="_blank" rel="noopener">完整代码</a></p>
<hr>
<p>Ref：<br>1.统计学习方法<br>2.机器学习实战</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
</search>
